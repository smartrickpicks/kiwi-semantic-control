# Orchestrate OS — Semantic Control Board

## Overview
Orchestrate OS is a governance-only semantic control plane designed for defining, validating, and previewing semantic rules offline. It serves as a single source of semantic truth to streamline patch requests, improve operator ergonomics, and provide an analyst-first reference for explicit, deterministic, and auditable decisions. The system aims to improve semantic rule management, reduce errors, and enhance decision-making efficiency by capturing semantic decisions as reviewable configuration artifacts and operating offline-first with deterministic outputs.

## User Preferences
Preferred communication style: Simple, everyday language.

## System Architecture
The system employs a Config Pack Model with strict version matching and supports a 12-status lifecycle for patch requests, including comment systems and role-based access control. The UI/UX features a dashboard with a queue-centric sidebar, right-side drawers, role-based navigation, and a Patch Studio for drafting and preflight checks with live previews and revision tracking. Data handling supports CSV/XLSX import, inline editing, a lock-on-commit mechanism with a change map engine, and workbook session caching.

Semantic rules, defined by a WHEN/THEN pattern, generate deterministic cell-level signals using metadata for validation, populating Analyst Triage queues and driving grid coloring. Access control is email-based with Google sign-in. Key features include a "Contract Line Item Wizard," XLSX export capabilities, and an Audit Timeline system. A Schema Tree Editor manages the canonical rules bundle, and a Batch Merge feature allows combining source batches. The `SystemPass` module provides a deterministic, rerunnable engine for system changes, and `UndoManager` offers session-scoped undo for draft edits. `RollbackEngine` creates governed rollback artifacts, and a Triage Analytics module aggregates metrics. A Role Registry manages user permissions. The system includes contract-first navigation, a combined interstitial Data Quality Check, and an `ADDRESS_INCOMPLETE_CANDIDATE` Matching System. The architecture is modular, with components extracted into distinct namespaces.

The system is being upgraded to include Postgres-backed multi-user persistence, featuring resource-based routes, ULID primaries, optimistic concurrency, and server-enforced no-self-approval. Authentication uses Google OAuth for human users and scoped API keys for service ingestion, with strict workspace isolation.

An Evidence Viewer (v2.51) is implemented with document-level text anchoring, corrections workflow, and RFI custody tracking. It provides an interactive panel with three collapsible sections: Anchors Panel for creating and managing anchors, Corrections Panel for viewing and approving/rejecting corrections, and RFI Custody Panel for managing RFIs. This feature is gated by the `EVIDENCE_INSPECTOR_V251` feature flag.

The "Grid" mode has been renamed to "Evidence Viewer" mode with unified click behavior that prioritizes opening the Evidence Viewer panel on the first click and subsequent clicks for cell validation. A context menu allows opening records in "Review Mode." The Evidence Viewer mode uses a two-column layout with a document viewer (Reader/PDF toggle) and an Evidence Details panel on the left, and the grid table on the right. The Reader mode includes text extraction, formatting for readability (detecting headings, lists, paragraphs), Mojibake inline detection with visual classifications (suspect/unreadable), and an OCR escalation CTA. A selection action menu allows creating Evidence Marks, RFIs, and Corrections directly from selected text. RFI and Encoding Correction modals facilitate dedicated workflows, with policy-driven status assignments (auto_applied/pending_verifier).

RFI lifecycle propagation (v2.52) ensures that RFIs created in the Evidence Viewer are injected into both analyst and verifier queues, with deep-linking capabilities back to the Evidence Viewer. The system displays RFI thread replies in the triage queue table and uses a notification badge system to indicate unseen RFIs. Role-based visibility for RFIs is applied across the Evidence Details panel and triage queues. Shared constants are used for resolving contract, account, and display names. The system accepts various http/https URLs for documents, including Google Drive links, but rejects known non-PDF formats.

Grid Record Labels (v2.53): The first data column in the grid uses a standardized naming convention — `Contract: Account` for account sheets, or `Contract: Account: Opportunity` for opportunity sheets. The contract name is derived from the file name, and the account/opportunity names from their respective data fields. This first column is frozen (sticky) so it remains visible during horizontal scrolling. The `_gridBuildRecordLabel()` function resolves the composite label, applied in both standard and batch grid render paths.

Sandbox Session Management (v2.52): Sandbox-created artifacts (RFIs, patches, corrections, queue items) persist indefinitely until explicit admin reset — no TTL expiration. Two reset options are available in admin-only UI sections: (1) "Reset Sandbox" clears all sandbox-created artifacts while preserving uploaded data, and (2) "Reset All Data" performs a full reset including uploaded datasets, returning to the loader screen. The `_evRfiLocalCache` stores sandbox RFIs without time-based expiry; `resetPlayground()` clears the cache along with verifier queue, patch storage, and badge state. `resetDemoState()` gates sandbox clearing to playground environment only, preventing accidental production data loss.

Suggested Fields + Alias Builder (v2.51): A heuristic suggestion engine analyzes source document column headers and proposes mappings to canonical glossary terms. The engine supports three matching strategies: exact (score 1.0), fuzzy (Levenshtein ratio >= 0.6), and keyword (category-based term matching). Results are presented in a "Suggestions" tab in the grid float controls (renamed from "Sync" per SUGGEST-24), grouped by match type (exact/fuzzy/keyword/unmatched). Users can Accept or Decline suggestions (renamed from "Reject" per SUGGEST-24); accepting auto-creates a glossary alias linking the source field to the canonical term. Duplicate aliases return 409 with details of the existing mapping. The feature uses 4 new DB tables: glossary_terms, glossary_aliases, suggestion_runs, suggestions (migration 008). Migration 009 adds version + updated_at to glossary_aliases for edit support. ULID prefixes: glt_, gla_, sgr_, sug_. Backend routes: server/routes/suggestions.py, server/routes/glossary.py (includes PATCH /glossary/aliases/{id} with OCC). Engine: server/suggestion_engine.py. Frontend fetch calls include X-Workspace-Id header via _syncHeaders() helper. OpenAPI: docs/api/openapi.yaml includes full Suggested Fields tag with glossary/terms, glossary/aliases, suggestions/run, suggestions endpoints. Design doc: docs/handoff/V251_SUGGESTED_FIELDS_DESIGN.md. Audit: docs/handoff/V251_SUGGESTED_FIELDS_AUDIT.md.

Multi-Workspace Glossary Routing: All glossary endpoints (GET /glossary/terms, POST /glossary/terms, POST /glossary/aliases, PATCH /glossary/aliases/{id}) require explicit workspace selection via `X-Workspace-Id` header, `workspace_id` body field, or JWT `workspace_id` claim. Missing workspace returns 422 MISSING_WORKSPACE. Membership is verified against `user_workspace_roles`; non-members get 403 FORBIDDEN. No implicit "first workspace" fallback exists. The `_require_workspace_id()` helper in `server/routes/glossary.py` enforces this contract. Verification: CHECK 6 in `scripts/verify_suggested_fields.py` covers multi-workspace reads, writes, missing selector, and non-member access (71 total checks).

## Migration Notes
Migration 003 (auth_google_oauth) is self-contained: it creates the production workspace (`ws_SEED0100000000000000000000`) via `INSERT ... ON CONFLICT DO NOTHING` before inserting user workspace roles, so it does not depend on seed data from migration 002. This ensures the migration succeeds in production where `SEED_DATA` is not enabled.

Section Metadata Integration (v2.53): The `orderFieldsForInspector()` function in the record inspector reads `enrichments.section_metadata` from `field_meta.json`. When section_headers and field_section_map are present for a sheet, fields are grouped by section (using `section_key`) and ordered by `question_order`. Section titles and descriptions from `section_headers` are displayed as group headers. If section_metadata is absent for a sheet, the legacy hinge-based grouping (Primary/Secondary/Other) is used as fallback. The `_getSectionMetadata()` helper retrieves metadata, and `_orderFieldsBySectionMetadata()` builds the grouped ordering.

Section Focus Guidance (v2.53): The `renderSectionGuidanceCard()` function first checks `section_focus` from `enrichments.section_metadata` for the current sheet. If available, it uses that text as the "what to look for" guidance. If section_focus is unavailable, it falls back to `config/section_guidance.json`. The `_getSectionFocusFromMeta()` helper resolves section_focus from the metadata. The guidance card UI shell (section label, what_to_look_for, common_failure_modes) is preserved.

Module Registry (v2.53): `Engines.SuggestionsState` and `Components.SuggestionsPanel` registered in AppModules Phase D16. SuggestionsState provides accessors for sync state, document/workspace IDs, and headers. SuggestionsPanel provides toggle, run, accept, decline, and refresh operations. Total registered modules: ~50+ across D1-D16 phases.

## External Dependencies
- **FastAPI server**: Used as a local PDF proxy for CORS-safe PDF fetching and text extraction using PyMuPDF.
- **SheetJS (XLSX)**: Integrated for Excel import/export functionality.
- **Google Drive**: Integrated as a data source for contract workbook import/export.