# Orchestrate OS — Semantic Control Board

## Overview
Orchestrate OS is a governance-only semantic control plane. Its primary purpose is to define, validate, and preview semantic rules offline, serving as a single source of semantic truth. It enables rule authoring and review as configuration, providing an analyst-first reference with clear interfaces and checklists for explicit, deterministic, and auditable decisions. The project aims to improve operator ergonomics and streamline the patch request and review pipeline.

## User Preferences
Preferred communication style: Simple, everyday language.

## System Architecture

### Core Design Decisions
Orchestrate OS functions as a governance-only control plane, capturing semantic decisions as reviewable configuration artifacts without runtime execution, APIs, credentials, or prompts. It emphasizes offline-first determinism, ensuring identical outputs for the same inputs through local previews using only the Python standard library. The system employs a canonical join strategy (`contract_key` → `file_url` → `file_name`) and a Config Pack Model (`config_pack.base.json` for baseline, `config_pack.patch.json` for changes) with strict version matching.

### UI/UX and Workflow
The user interface features a dashboard shell with a queue-centric sidebar, right-side drawers for data sources and record details, and role-based navigation. Admin configurations are presented in a workflow-ordered view with Plain-English, Payload, and Master tabs, supported by extensive tooltips and Plain English explanations. The system implements an 11-status lifecycle for patch requests, including comment systems, role-based access control (Analyst, Verifier, Admin), and a Patch Studio for drafting, preflight checks, and evidence packing with live previews and revision tracking. UI/UX decisions include enforcing hard page separation, RBAC route guards, and explicit page labels. Grid cells display color-coded highlighting based on change type (corrections, RFIs, system changes, blacklist) with a color legend for the modified dataset. The All Data Grid features Excel-style column headers (A, B, C...), drag-and-drop column reordering, and preferred column ordering (File_Name_c and Account_Name_c first); File_Name fields are clickable hyperlinks to file_url with hidden URL column. The PDF viewer is configured for single-column continuous scroll with hidden thumbnail sidebar. Record Inspection (SRR) includes Previous/Next navigation buttons in the top bar following the current grid's filtered/sorted order, with a position indicator (e.g., '3 of 145'); when all fields in a record reach a completed state (verified, rfi, submitted, blocked, or modified), the system auto-advances to the next record with a toast notification.

### Data Handling and Integration
Data loading in demo mode defaults to `ostereo_demo_v1.json` (the modified export with meta sheets) on cold start; production mode loads with no sample data and shows "No dataset loaded" until a data source is connected. An "Upload Excel" button in the sticky header provides a failsafe import method for .xlsx/.xls files (not CSV). The system supports CSV/XLSX import with delimiter inference and utilities for resetting demo state. A PDF proxy (FastAPI server on port 5000) handles CORS-safe PDF fetching and field resolution using `<object>` elements for display. A Field Inspector provides search-filtered fields, inline editing, and a lock-on-commit mechanism, highlighting fields with signals and displaying patch details. Glossary hover tooltips (v1.6.36) appear on the ⓘ icon next to each field label, showing metadata from field_meta.json (field label, type, required/optional status, definition, options) and hinge group from hinge_groups.json; fields without metadata display "No glossary data available." A change map engine parses meta sheets (`_change_log` and `RFIs & Analyst Notes`) to build cell-level change tracking for the modified dataset. Meta sheet propagation ensures `RFIs & Analyst Notes` entries are seeded into canonical stores: RFIs (Note_Type = "RFI") go to PATCH_REQUEST_STORE for cross-role visibility, Manual Review items (Note_Type = "Manual Review") go to META_TRIAGE_STORE for Analyst triage, and *_change_log sheets populate the System Changes queue with address standardizations and rule corrections. Datasets missing meta sheets are handled gracefully with warning logs. The Verifier Triage uses a 4-queue system, and a localStorage-backed mock filesystem manages artifacts with a deterministic artifact ID system. A Canonical Record Store persists records to localStorage, enabling Single Row Review (SRR) rehydration. Picklist/options fields are supported, rendering as dropdowns in the Field Inspector with validation for invalid values. Review Checklist gating enforces that Verifier approvals require a 6-item checklist (intent clarity, schema correctness, preview validity, conflict assessment, evidence pack, smoke verification) and Admin approvals require a 4-item checklist (verifier approval validity, downstream risk, versioning, smoke strict); the "confirm all" checkbox is disabled until all items are checked, and checklist confirmation persists per patch in localStorage (`orchestrate_checklist_confirmations` with `role:patchId` keys). Patch queue approve paths offer inline confirmation prompts as a fallback when the dedicated review page checklist hasn't been completed. Workbook session caching (v1.6.41) persists uploaded Excel data to localStorage, automatically restoring the user's session on page reload; a "Clear Cache" button in the Data Source panel allows starting fresh. Multi-session storage (v1.6.51) lets users save up to 10 named workbook sessions to localStorage via the "Save Session" button in the Data Sources drawer; saved sessions display as cards showing name, timestamp, sheet/row counts, and role badge, with click-to-load and delete actions; session names are XSS-safe via escapeHtml and event delegation.

### Semantic Rules and Signals
The system generates deterministic cell-level signals on dataset load using `field_meta.json` and `qa_flags.json` for validation (e.g., `MISSING_REQUIRED`, `PICKLIST_INVALID`, `MOJIBAKE_DETECTED`, `QA_FLAG`). These signals populate Analyst Triage queues and drive grid coloring and row badges. Field Inspector ordering is derived from `field_meta.json`, `hinge_groups.json`, and `sheet_order.json` from the `/rules/rules_bundle/`. Rules follow a WHEN/THEN pattern with `rule_id`, conditions, and actions.

### Identity and Authentication
Record identity is defined by `tenant_id`, `division_id`, `dataset_id`, `record_id`, with `record_id` generated based on a canonicalized row fingerprint. A production-style landing page with Google sign-in handles user authentication, supporting `?role=admin|verifier` URL parameters for testing. Admin-only Playground mode allows role switching, while Analyst/Verifier users are locked to their roles. As of v1.6.45, all "Reviewer" terminology has been unified to "Verifier" across UI, statuses, and documentation; legacy `Reviewer_*` status values are normalized via `normalizeLegacyStatus()` and `normalizeLegacyRole()` for backward compatibility. User creation and management are available in the Admin Panel for Demo/Playground mode, with changes persisting to localStorage. Production Google OAuth login checks a configured user list for role assignment. Session persistence (v1.6.49): Landing and demo pages auto-redirect to `/ui/viewer/` when a valid session (`demoUser` + `currentRole`) exists in localStorage, allowing page reloads without re-authentication. Navigation state (`saveNavStateToCache`) is saved on every `navigateTo()` call, and `masterlineAutoload()` restores the user's last page (not just grid). Sign Out clears session keys and redirects to the appropriate login page. "Start Fresh (Clear Cache)" also clears session keys and redirects to login to prevent auto-redirect loops.

### Catalog Items Grouping + Safe Batch Add (v1.6.48)
The Catalog Items feature allows analysts to group records under a "Catalog Items Group" and batch-add missing items with safe deduplication. The feature uses a per-record toggle (off by default) — analysts click "Set as Catalog Items Group" in Record Inspection to mark a record as a Group Anchor, then "Add Missing Items" appears.

**Group Anchor Model:** Any record can be marked as a Group Anchor via the per-record toggle. Child rows inherit `group_id` from the anchor and copy baseline fields. The data model adds `_group` (containing `group_id`, `group_label`, `is_anchor`) and `_batch_added` (containing `timestamp`, `actor`, `anchor_record_id`, `source`) to row objects.

**Safe Deduplication:** When pasting items, the system normalizes text (trim, lowercase, collapse punctuation) and compares against existing sheet rows using bigram similarity scoring. Items are categorized as: Existing (exact match — attached to group, no new record), Possible Duplicate (≥70% similarity — new row created and flagged), or New (no match — new row created). Nothing is auto-deleted.

**Wizard Flow:** A 3-step modal (Paste List → Preview → Confirm) collects one-per-line items, lets the user pick the target field, then shows a categorized preview with Existing (green), Possible Duplicate (amber), and New (blue) sections with counts. Maximum 500 items per batch. Each created row emits a `MANUAL_ROW_ADD` audit event with `attached_existing_count`, `created_new_count`, and `possible_duplicate_count`.

### Document Type + Capabilities Model
Each record carries a `_document_type` (default: "Unknown") and `_capabilities` object (default: {}). Document types are loaded from `config/document_types.json` at startup alongside rule bundles. The Record Inspection header shows an editable "Doc Type" dropdown populated from this config. When a record is set as a Catalog Items group, `capabilities.catalog_items = true` is set (treating Catalog Items as a capability, not a document type). Export includes `document_type`, `capabilities` (JSON), and `group_id` as flat columns. Existing records without `_document_type` are backfilled to "Unknown" during signal generation.

**Grid Nesting:** Anchor rows display an expand/collapse caret (▼) in the row-index cell. Child rows are visually indented. Collapsed state persists in localStorage (`orchestrate_group_collapsed`). Export remains flat — all rows are included without grouping hierarchy.

### Export / Save Functionality
The Export/Save button generates an XLSX file using SheetJS with all data sheets, changelog, RFI notes, and signals summary. The export includes:
- All data sheets with original structure preserved
- `_change_log` sheet with corrections, status changes, and audit trail
- `RFIs & Analyst Notes` sheet with all analyst questions and responses
- `_signals_summary` sheet with validation flags and semantic signals
- `_orchestrate_meta` sheet with dataset metadata, version info, and nomenclature

Exported files are named `orchestrate_{dataset_id}_{timestamp}.xlsx` and downloaded directly to the user's device.

## External Dependencies
None by design. This repository exclusively uses the Python standard library, with no external Python packages, database connections, API integrations, runtime services, or credentials/secrets. A FastAPI server is used as a local PDF proxy for CORS-safe PDF fetching and text extraction (PyMuPDF). The `/api/pdf/text` endpoint extracts per-page text for anchor-driven search; the viewer's match navigation bar lets users jump to pages containing a field's value with Previous/Next controls. SheetJS (XLSX) is loaded via CDN for Excel import/export functionality.