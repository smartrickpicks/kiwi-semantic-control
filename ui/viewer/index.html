<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orchestrate OS — Semantic Control Board</title>
  <!-- SheetJS library for XLSX parsing (v1.4.12) -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; color: #333; margin: 0; padding: 0; }
    h1 { margin-bottom: 10px; color: #1a1a2e; }

    /* Staged Loader Overlay */
    .staged-loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 46, 0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    .staged-loader-content {
      text-align: center;
      color: white;
    }
    /* v1.6.37: Excel upload loading overlay */
    .upload-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 20000;
      flex-direction: column;
      gap: 16px;
    }
    .upload-loading-overlay.visible { display: flex; }
    .upload-loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: #1a73e8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .upload-loading-text {
      color: white;
      font-size: 1.1em;
      font-weight: 500;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .staged-loader-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: #64b5f6;
      border-radius: 50%;
      margin: 0 auto 20px;
      animation: staged-spin 1s linear infinite;
    }
    @keyframes staged-spin {
      to { transform: rotate(360deg); }
    }
    .staged-loader-title {
      font-size: 1.3em;
      font-weight: 600;
      margin-bottom: 24px;
      color: #fff;
    }
    .staged-loader-stages {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
      padding: 0 20px;
    }
    .staged-loader-stage {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95em;
      color: rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
    }
    .staged-loader-stage.active {
      color: #64b5f6;
    }
    .staged-loader-stage.active .stage-icon {
      color: #64b5f6;
      animation: pulse-icon 1s ease-in-out infinite;
    }
    .staged-loader-stage.completed {
      color: #81c784;
    }
    .staged-loader-stage.completed .stage-icon {
      color: #81c784;
    }
    .stage-icon {
      font-size: 1.1em;
      width: 18px;
      text-align: center;
    }
    @keyframes pulse-icon {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .app-layout { display: flex; min-height: 100vh; }
    .nav-sidebar { width: 280px; background: #1a1a2e; color: white; flex-shrink: 0; display: flex; flex-direction: column; overflow-y: auto; }
    .nav-header { padding: 16px 20px; border-bottom: 1px solid #2d2d4a; }
    .nav-header h1 { font-size: 1em; color: white; margin: 0; }
    .nav-header .version { font-size: 0.7em; color: #888; margin-top: 4px; }
    .nav-menu { flex: 1 1 auto; padding: 10px 0; overflow-y: auto; min-height: 0; }
    .nav-footer { flex-shrink: 0; background: #1a1a2e; border-top: 1px solid #333; }
    .nav-section { margin-bottom: 8px; }
    .nav-section-header { padding: 8px 20px 6px; font-size: 0.65em; color: #666; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
    .nav-item { display: flex; align-items: center; padding: 10px 20px; color: #aaa; text-decoration: none; cursor: pointer; transition: all 0.2s; border-left: 3px solid transparent; }
    .nav-item:hover { background: #2d2d4a; color: white; }
    .nav-item.active { background: #0f3460; color: white; border-left-color: #1565c0; }
    .nav-parent { position: relative; }
    .nav-expand-arrow { margin-left: auto; font-size: 0.7em; transition: transform 0.2s; color: #888; }
    .nav-parent.expanded .nav-expand-arrow { transform: rotate(90deg); color: #ccc; }
    .nav-subitems { display: none; overflow: hidden; }
    .nav-subitems.expanded { display: block; }
    .nav-subitem { padding-left: 40px !important; font-size: 0.95em; }
    .nav-subitem .nav-icon { font-size: 0.85em; }
    .nav-subparent { position: relative; }
    .nav-subparent.expanded .nav-expand-arrow { transform: rotate(90deg); color: #ccc; }
    .nav-level3 { display: none; }
    .nav-level3.expanded { display: block; }
    .nav-level3 .nav-section-link { display: block; padding: 6px 16px 6px 56px; color: #bbb; font-size: 0.88em; cursor: pointer; transition: all 0.15s; text-decoration: none; border-left: 3px solid transparent; }
    .nav-level3 .nav-section-link:hover { color: #fff; background: #2d2d4a; }
    .nav-level3 .nav-section-link.active { color: #fff; background: #0f3460; border-left-color: #42a5f5; }
    .nav-item.queue-item { padding: 8px 20px; }
    .nav-icon { width: 18px; margin-right: 10px; text-align: center; font-size: 0.9em; }
    .nav-label { font-size: 0.85em; flex-grow: 1; }
    .nav-count { background: #3d3d5c; color: #aaa; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; margin-left: 8px; }
    .nav-count.has-items { background: #1565c0; color: white; }
    .nav-count.blocking { background: #c62828; color: white; }
    .nav-severity-chips { display: flex; gap: 3px; margin-left: 8px; }
    .nav-severity-chip { width: 6px; height: 6px; border-radius: 50%; }
    .nav-severity-chip.blocking { background: #c62828; }
    .nav-severity-chip.warning { background: #f57c00; }
    .nav-severity-chip.info { background: #1565c0; }
    .nav-divider { height: 1px; background: #2d2d4a; margin: 8px 20px; }
    .nav-mode-section { padding: 12px 20px; border-top: 1px solid #2d2d4a; }
    .nav-mode-label { font-size: 0.65em; color: #666; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.5px; }
    .mode-toggle { display: flex; gap: 4px; flex-wrap: wrap; }
    .mode-btn { padding: 6px 12px; font-size: 0.75em; border: 1px solid #555; background: transparent; color: #aaa; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    .mode-btn:hover { border-color: #888; color: white; }
    .mode-btn.active { background: #1565c0; border-color: #1565c0; color: white; }
    .mode-btn.mode-analyst { }
    .mode-btn.mode-verifier { }
    .mode-btn.mode-admin { }

    .main-content { flex-grow: 1; padding: 20px; overflow-y: auto; max-height: 100vh; }
    .page { display: none; }
    .page.active { display: block; }
    .page-header { margin-bottom: 20px; }
    .page-header h2 { color: #1a1a2e; font-size: 1.4em; margin-bottom: 5px; }
    .page-header .page-desc { color: #666; font-size: 0.9em; }

    .mode-hidden { display: none !important; }

.triage-icon-btn { padding: 5px 6px; border: none; border-radius: 6px; font-size: 0.72em; cursor: pointer; display: inline-flex; align-items: center; gap: 0; white-space: nowrap; overflow: hidden; max-width: 30px; transition: max-width 0.25s ease, padding 0.2s ease, gap 0.2s ease, box-shadow 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }
.triage-icon-btn:hover { max-width: 160px; padding: 5px 10px; gap: 5px; box-shadow: 0 2px 8px rgba(0,0,0,0.18); }
.triage-icon-btn .btn-label { opacity: 0; transition: opacity 0.15s ease 0.05s; font-weight: 500; }
.triage-icon-btn:hover .btn-label { opacity: 1; }
.triage-icon-btn svg { flex-shrink: 0; }

    .mode-dimmed { opacity: 0.5; pointer-events: none; }
    h2 { margin: 20px 0 10px; color: #16213e; border-bottom: 2px solid #0f3460; padding-bottom: 5px; }
    .subtitle { color: #666; margin-bottom: 20px; font-size: 0.9em; }
    .summary { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
    .summary-card { background: white; padding: 15px 25px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; min-width: 100px; }
    .summary-card .count { font-size: 2em; font-weight: bold; }
    .summary-card .label { font-size: 0.85em; color: #666; text-transform: uppercase; }
    .summary-card.clickable { cursor: pointer; transition: transform 0.15s, box-shadow 0.15s; }
    .summary-card.clickable:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .ready .count { color: #2e7d32; }
    .needs-review .count { color: #f57c00; }
    .blocked .count { color: #c62828; }
    .contracts .count { color: #1565c0; }
    table { width: 100%; border-collapse: collapse; background: white; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #eee; font-size: 0.9em; }
    th { background: #1a1a2e; color: white; font-weight: 600; }
    tr:hover { background: #e8f4fd; cursor: pointer; }
    tr:last-child td { border-bottom: none; }
    .severity-blocking { background: #ffebee; color: #c62828; font-weight: bold; }
    .severity-warning { background: #fff3e0; color: #e65100; }
    .severity-info { background: #e3f2fd; color: #1565c0; }
    .status-ready { color: #2e7d32; font-weight: bold; }
    .status-needs_review { color: #f57c00; font-weight: bold; }
    .status-blocked { color: #c62828; font-weight: bold; }
    .diff-pane { background: #263238; color: #eceff1; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.85em; white-space: pre-wrap; margin-bottom: 20px; }
    .diff-pane code { display: block; background: #37474f; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .error { background: #ffebee; color: #c62828; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .info { background: #e3f2fd; color: #1565c0; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .source-info { font-size: 0.8em; color: #666; margin-bottom: 20px; }
    .null-value { color: #999; font-style: italic; }
    .table-container { overflow-x: auto; }
    .hidden-row { display: none; }

    .toolbar { background: #1a1a2e; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .toolbar-btn { background: #0f3460; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9em; transition: background 0.2s; }
    .toolbar-btn:hover { background: #1565c0; }
    .toolbar-confirm { display: flex; align-items: center; gap: 8px; color: #ffeb3b; font-size: 0.85em; margin-left: auto; }
    .toolbar-confirm input { width: 18px; height: 18px; cursor: pointer; }
    .toolbar-confirm label { cursor: pointer; }

    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center;  }
    .modal-overlay.active { display: flex; }
    .modal { background: white; border-radius: 8px; max-width: 700px; width: 90%; max-height: 80vh; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
    
    /* Drawer (right-side slide-over panel) */
    .drawer-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4); display: none;  }
    .drawer-overlay.active { display: block; }
    .drawer { position: fixed; top: 0; right: -420px; width: 400px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); transition: right 0.25s ease-out; z-index: 1001; display: flex; flex-direction: column; }
    .drawer-overlay.active .drawer { right: 0; }
    .drawer-header { background: #1a1a2e; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
    .drawer-header h3 { margin: 0; font-size: 1.1em; font-weight: 600; }
    .drawer-close { background: none; border: none; color: white; font-size: 1.4em; cursor: pointer; line-height: 1; padding: 0; opacity: 0.8; }
    .drawer-close:hover { opacity: 1; }
    .drawer-body { flex: 1; overflow-y: auto; padding: 20px; }
    .drawer-footer { padding: 15px 20px; border-top: 1px solid #e0e0e0; background: #f8f9fa; flex-shrink: 0; }
    
    /* First-Run Banner */
    .first-run-banner { display: flex; align-items: center; gap: 12px; padding: 10px 20px; background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border-bottom: 1px solid #bbdefb; font-size: 0.9em; }
    .first-run-banner .banner-icon { font-size: 1.2em; }
    .first-run-banner .banner-text { flex: 1; color: #1565c0; }
    .first-run-banner .banner-dismiss { background: none; border: none; font-size: 1.2em; color: #666; cursor: pointer; padding: 4px 8px; line-height: 1; }
    .first-run-banner .banner-dismiss:hover { color: #333; }
    
    /* Configure Button Style */
    .top-toolbar-btn.configure-btn { background: linear-gradient(135deg, #7c4dff 0%, #536dfe 100%); color: white; border: none; }
    .top-toolbar-btn.configure-btn:hover { background: linear-gradient(135deg, #651fff 0%, #304ffe 100%); }
    
    /* Wizard Progress Dots */
    .wizard-step-dot { width: 12px; height: 12px; border-radius: 50%; background: #e0e0e0; transition: background 0.2s; }
    .wizard-step-dot.active { background: #7c4dff; }
    .wizard-step-dot.completed { background: #4caf50; }
    
    /* Config Flows Rail */
    .rail-item { display: flex; align-items: center; gap: 10px; padding: 10px 15px; cursor: pointer; color: #555; text-decoration: none; transition: background 0.15s; }
    .rail-item:hover { background: #e8e8e8; }
    .rail-item.active { background: #e3f2fd; color: #1565c0; border-left: 3px solid #1565c0; }
    .rail-number { width: 22px; height: 22px; border-radius: 50%; background: #ddd; color: #666; display: flex; align-items: center; justify-content: center; font-size: 0.75em; font-weight: 600; flex-shrink: 0; }
    .rail-item.active .rail-number { background: #1565c0; color: white; }
    .rail-label { font-size: 0.85em; }
    
    /* Config Flows Tabs */
    .stage-tab { padding: 8px 16px; border: none; background: none; cursor: pointer; font-size: 0.85em; color: #666; border-bottom: 2px solid transparent; }
    .stage-tab:hover { color: #333; }
    .stage-tab.active { color: #1565c0; border-bottom-color: #1565c0; }
    
    /* Wizard Form Elements */
    .wizard-form-group { margin-bottom: 18px; }
    .wizard-form-group label { display: block; font-weight: 500; margin-bottom: 6px; color: #333; }
    .wizard-form-group .hint { font-size: 0.8em; color: #888; margin-top: 4px; }
    .wizard-toggle { display: flex; align-items: center; gap: 10px; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer; }
    .wizard-toggle input { width: 18px; height: 18px; }
    .wizard-toggle-label { flex: 1; }
    .wizard-toggle-label strong { display: block; margin-bottom: 2px; }
    .wizard-toggle-label small { color: #666; }
    .wizard-multi-select { display: flex; flex-wrap: wrap; gap: 8px; }
    .wizard-multi-select label { display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f5; border-radius: 6px; cursor: pointer; font-size: 0.9em; }
    .wizard-multi-select label:has(input:checked) { background: #e8eaf6; border: 1px solid #7c4dff; }
    .wizard-multi-select input { width: 16px; height: 16px; }
    .modal-header { background: #1a1a2e; color: white; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h3 { margin: 0; }
    .modal-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .modal-body { padding: 20px; overflow-y: auto; max-height: calc(80vh - 60px); }
    .modal-command { background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.9em; word-break: break-all; margin-bottom: 15px; }
    .modal-actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .modal-btn { padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer; font-size: 0.9em; }
    .modal-btn-primary { background: #1565c0; color: white; }
    .modal-btn-primary:hover { background: #1976d2; }
    .modal-btn-secondary { background: #e0e0e0; color: #333; }
    .modal-btn-secondary:hover { background: #bdbdbd; }
    .modal-btn-danger { background: #c62828; color: white; }
    .modal-btn-danger:hover { background: #d32f2f; }
    .modal-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .modal-status { margin-top: 15px; padding: 10px; border-radius: 4px; font-size: 0.85em; }
    .modal-status.success { background: #e8f5e9; color: #2e7d32; }
    .modal-status.error { background: #ffebee; color: #c62828; }
    .modal-status.info { background: #e3f2fd; color: #1565c0; }

    /* Welcome Hero (no data loaded) */
    .welcome-hero { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60vh; text-align: center; padding: 40px; }
    .welcome-hero.hidden { display: none; }
    .welcome-hero h2 { font-size: 1.8em; color: #1a1a2e; margin-bottom: 10px; }
    .welcome-hero p { color: #666; margin-bottom: 30px; max-width: 500px; }
    .welcome-cta { background: #1565c0; color: white; border: none; padding: 16px 32px; border-radius: 8px; font-size: 1.1em; cursor: pointer; transition: background 0.2s; }
    .welcome-cta:hover { background: #1976d2; }
    .welcome-hint { margin-top: 20px; font-size: 0.85em; color: #888; }

    /* Top Toolbar (fixed) */
    .top-toolbar { background: white; border-bottom: 1px solid #ddd; padding: 10px 20px; display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .top-toolbar-left { display: flex; align-items: center; gap: 10px; }
    .top-toolbar-right { margin-left: auto; display: flex; align-items: center; gap: 10px; }
    .top-toolbar-btn { background: #e8f4fd; color: #1565c0; border: 1px solid #bbdefb; padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 0.85em; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
    .top-toolbar-btn:hover { background: #1565c0; color: white; border-color: #1565c0; }
    .top-toolbar-btn.primary { background: #1565c0; color: white; border-color: #1565c0; }
    .top-toolbar-btn.primary:hover { background: #0d47a1; }
    .data-indicator { display: flex; align-items: center; gap: 8px; font-size: 0.85em; color: #666; }
    .data-indicator .dot { width: 10px; height: 10px; border-radius: 50%; background: #4caf50; }
    .data-indicator .dot.no-data { background: #ff9800; }
    .data-indicator-path { font-family: monospace; background: #f5f5f5; padding: 4px 8px; border-radius: 4px; max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* Wizard Modal */
    .wizard-modal { max-width: 600px; }
    .wizard-field { margin-bottom: 20px; }
    .wizard-field label { display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em; }
    .wizard-field input, .wizard-field select { width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; }
    .wizard-field input:focus, .wizard-field select:focus { border-color: #1565c0; outline: none; }
    .wizard-field .hint { font-size: 0.8em; color: #888; margin-top: 4px; }
    .wizard-section { background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .wizard-section h4 { margin: 0 0 10px; font-size: 0.95em; color: #1a1a2e; }
    .wizard-divider { border-top: 1px solid #eee; margin: 20px 0; }
    .wizard-row { display: flex; gap: 15px; }
    .wizard-row .wizard-field { flex: 1; }
    .wizard-preset { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .wizard-preset-btn { padding: 6px 12px; background: #e0e0e0; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer; transition: background 0.2s; }
    .wizard-preset-btn:hover { background: #bdbdbd; }
    .wizard-preset-btn.active { background: #1565c0; color: white; }

    /* Nav item mode visibility */
    .nav-item.analyst-only { display: flex; }
    .nav-item.verifier-only { display: none; }
    .nav-item.admin-only { display: none; }
    .mode-analyst .nav-item.analyst-only { display: flex; }
    .mode-analyst .nav-item.verifier-only { display: none; }
    .mode-analyst .nav-item.admin-only { display: none; }
    .mode-verifier .nav-item.analyst-only { display: none; }
    .mode-verifier .nav-item.verifier-only { display: flex; }
    .mode-verifier .nav-item.admin-only { display: none; }
    .mode-admin .nav-item.analyst-only { display: none; }
    .mode-admin .nav-item.verifier-only { display: flex; }
    .mode-admin .nav-item.admin-only { display: flex; }

    /* Sidebar Action Buttons */
    .nav-action-btn { width: 100%; padding: 10px 14px; background: #1565c0; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; display: flex; align-items: center; gap: 8px; transition: background 0.2s; }
    .nav-action-btn:hover { background: #1976d2; }
    .nav-action-btn.export-btn { background: #2e7d32; }
    .nav-action-btn.export-btn:hover { background: #388e3c; }
    .nav-action-icon { font-size: 1.1em; }

    /* Progress Block */
    .progress-block { display: block; background: #2d2d4a; border-radius: 8px; padding: 12px; text-decoration: none; color: inherit; cursor: pointer; transition: background 0.2s; }
    .progress-block:hover { background: #3d3d5a; }
    .progress-header { font-size: 0.7em; text-transform: uppercase; letter-spacing: 0.5px; color: #888; margin-bottom: 8px; font-weight: 600; }
    .progress-stats { display: flex; justify-content: space-between; margin-bottom: 10px; }
    .progress-stat { text-align: center; flex: 1; }
    .progress-stat-count { display: block; font-size: 1.4em; font-weight: 600; color: white; }
    .progress-stat-label { font-size: 0.65em; color: #888; text-transform: uppercase; }
    .progress-bar-container { background: #1a1a2e; border-radius: 4px; height: 6px; overflow: hidden; }
    .progress-bar-fill { background: linear-gradient(90deg, #1565c0, #2196f3); height: 100%; transition: width 0.3s; }

    /* Active Data Source Bar */
    .active-data-source-bar { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: #252542; border-bottom: 1px solid #333; }
    .active-data-source-info { flex: 1; min-width: 0; }
    .active-data-source-label { font-size: 0.65em; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; }
    .active-data-source-name { font-size: 0.85em; color: #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .active-data-source-change { background: transparent; border: 1px solid #555; color: #aaa; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; cursor: pointer; transition: all 0.2s; flex-shrink: 0; margin-left: 12px; }
    .active-data-source-change:hover { background: #333; border-color: #777; color: white; }

    /* Sheet Selector */
    .sheet-selector { width: 100%; padding: 8px 10px; background: #2d2d4a; border: 1px solid #444; border-radius: 6px; color: #ddd; font-size: 0.85em; cursor: pointer; }
    .sheet-selector:focus { outline: none; border-color: #1565c0; }

    /* Cache Section */
    .cache-clear-btn { width: 100%; padding: 6px 10px; background: transparent; border: 1px solid #555; border-radius: 4px; color: #aaa; font-size: 0.75em; cursor: pointer; transition: all 0.2s; }
    .cache-clear-btn:hover { background: #333; border-color: #777; color: white; }
    
    /* Role-based visibility for any element */
    .admin-only-content { display: none !important; }
    .verifier-only-content { display: none !important; }
    .mode-admin .admin-only-content { display: block !important; }
    .mode-admin .admin-only-content.flex { display: flex !important; }
    .mode-verifier .verifier-only-content { display: block !important; }
    .mode-admin .verifier-only-content { display: block !important; }
    
    /* Loader Modal */
    .loader-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; z-index: 1001; justify-content: center; align-items: center; }
    .loader-modal-overlay.active { display: flex; }
    .loader-modal { background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.25); z-index: 1002; display: flex; flex-direction: column; max-width: 520px; width: 90%; max-height: 85vh; animation: modalFadeIn 0.2s ease-out; }
    @keyframes modalFadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    .loader-modal-header { background: #1565c0; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-radius: 12px 12px 0 0; }
    .loader-modal-header h3 { margin: 0; font-size: 1.1em; font-weight: 600; }
    .loader-modal-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; padding: 4px 10px; border-radius: 4px; line-height: 1; }
    .loader-modal-close:hover { background: rgba(255,255,255,0.2); }
    .loader-modal-body { flex: 1; overflow-y: auto; padding: 24px; }

    /* Session Status Chip */
    .session-chip { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; text-transform: uppercase; }
    .session-chip.not-loaded { background: #fff3e0; color: #e65100; }
    .session-chip.loaded { background: #e8f5e9; color: #2e7d32; }
    .session-chip.fallback { background: #e3f2fd; color: #1565c0; }
    .session-chip .chip-dot { width: 6px; height: 6px; border-radius: 50%; }
    .session-chip.not-loaded .chip-dot { background: #e65100; }
    .session-chip.loaded .chip-dot { background: #2e7d32; }
    .session-chip.fallback .chip-dot { background: #1565c0; }
    .session-meta { font-size: 0.75em; color: #888; margin-left: 10px; }

    /* Drop Zone */
    .drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 20px; text-align: center; background: #fafafa; transition: all 0.2s; cursor: pointer; margin-bottom: 10px; }
    .drop-zone:hover { border-color: #1565c0; background: #e8f4fd; }
    .drop-zone.drag-over { border-color: #1565c0; background: #bbdefb; }
    .drop-zone.has-file { border-color: #2e7d32; background: #e8f5e9; }
    .drop-zone-icon { font-size: 1.5em; margin-bottom: 8px; }
    .drop-zone-text { font-size: 0.85em; color: #666; }
    .drop-zone-file { font-size: 0.85em; color: #2e7d32; font-weight: 600; margin-top: 5px; }

    /* Paste Area */
    .paste-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.8em; resize: vertical; margin-bottom: 10px; }
    .paste-area:focus { border-color: #1565c0; outline: none; }
    .paste-area.valid { border-color: #2e7d32; background: #f1f8e9; }
    .paste-area.invalid { border-color: #c62828; background: #ffebee; }

    /* Path Hint */
    .path-hint-container { display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px; margin-bottom: 10px; }
    .path-hint-input { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85em; background: white; }
    .path-hint-label { font-size: 0.75em; color: #888; background: #eee; padding: 2px 6px; border-radius: 3px; }
    .path-hint-warning { font-size: 0.75em; color: #f57c00; margin-top: 5px; display: flex; align-items: center; gap: 5px; }

    /* Loader Tabs */
    .loader-tabs { display: flex; gap: 5px; margin-bottom: 15px; }
    .loader-tab { padding: 8px 16px; border: none; background: #e0e0e0; color: #666; border-radius: 6px 6px 0 0; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
    .loader-tab:hover { background: #ccc; }
    .loader-tab.active { background: #1565c0; color: white; }
    .loader-panel { display: none; }
    .loader-panel.active { display: block; }

    .saved-sessions-section { margin-top: 20px; }
    .saved-sessions-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .saved-sessions-title { font-size: 0.85em; font-weight: 600; color: #333; text-transform: uppercase; letter-spacing: 0.5px; }
    .saved-sessions-count { font-size: 0.75em; color: #999; }
    .saved-session-card { display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: #fff; border: 1px solid #e8e8e8; border-radius: 8px; margin-bottom: 8px; transition: all 0.15s; cursor: pointer; }
    .saved-session-card:hover { border-color: #1565c0; background: #f8fbff; box-shadow: 0 2px 8px rgba(21,101,192,0.08); }
    .saved-session-info { flex: 1; min-width: 0; }
    .saved-session-name { font-size: 0.88em; font-weight: 600; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 3px; }
    .saved-session-meta { display: flex; align-items: center; gap: 4px; font-size: 0.75em; color: #888; flex-wrap: wrap; }
    .saved-session-dot { color: #ccc; }
    .saved-session-role { background: #e3f2fd; color: #1565c0; padding: 1px 6px; border-radius: 4px; font-weight: 500; font-size: 0.9em; }
    .saved-session-delete { width: 24px; height: 24px; border-radius: 50%; border: none; background: transparent; color: #bbb; font-size: 1.1em; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; flex-shrink: 0; }
    .saved-session-delete:hover { background: #fce4ec; color: #c62828; }
    .save-session-btn { padding: 7px 14px; background: #fff; color: #1565c0; border: 1.5px solid #1565c0; border-radius: 7px; font-size: 0.82em; cursor: pointer; display: inline-flex; align-items: center; gap: 5px; font-weight: 500; transition: all 0.15s; }
    .save-session-btn:hover { background: #e3f2fd; }
    .save-session-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    /* Loader Section */
    .loader-section { background: #f9f9f9; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
    .loader-section h4 { margin: 0 0 10px; font-size: 0.95em; color: #1a1a2e; display: flex; align-items: center; gap: 8px; }
    .loader-section h4 .required { color: #c62828; font-size: 0.8em; }
    .loader-section h4 .optional { color: #888; font-size: 0.8em; font-weight: normal; }
    .loader-section-status { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; margin-left: auto; }
    .loader-section-status.empty { background: #eee; color: #888; }
    .loader-section-status.loaded { background: #e8f5e9; color: #2e7d32; }

    /* Remember Toggle */
    .remember-toggle { display: flex; align-items: center; gap: 8px; margin-top: 15px; padding: 10px; background: #fff8e1; border-radius: 6px; }
    .remember-toggle input { width: 18px; height: 18px; cursor: pointer; }
    .remember-toggle label { font-size: 0.85em; color: #666; cursor: pointer; }

    /* Reset Button */
    .reset-session-btn { background: #fff3e0; color: #e65100; border: 1px solid #ffcc80; }

    /* Empty Queue Message */
    .empty-queue-message { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 50vh; text-align: center; padding: 40px; background: #fafafa; border-radius: 12px; margin: 20px 0; }
    .empty-queue-message.hidden { display: none; }
    .empty-queue-icon { font-size: 3em; margin-bottom: 15px; }
    .empty-queue-message h3 { font-size: 1.3em; color: #333; margin-bottom: 10px; }
    .empty-queue-message p { color: #666; margin-bottom: 20px; max-width: 400px; line-height: 1.5; }
    .empty-queue-cta { background: #1565c0; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 1em; cursor: pointer; transition: background 0.2s; }
    .empty-queue-cta:hover { background: #1976d2; }

    /* Data Sources Drawer (right-side slide-over) */
    .data-drawer { position: fixed; top: 0; right: -420px; width: 420px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 950; transition: right 0.3s ease; display: flex; flex-direction: column; }
    .data-drawer.active { right: 0; }
    .data-drawer-header { background: #1a1a2e; color: white; padding: 16px 20px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    .data-drawer-header h3 { margin: 0; font-size: 1.1em; }
    .data-drawer-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .data-drawer-body { padding: 20px; overflow-y: auto; flex-grow: 1; }
    .data-drawer-section { background: #f9f9f9; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
    .data-drawer-section h4 { margin: 0 0 8px; font-size: 0.95em; color: #333; display: flex; align-items: center; gap: 8px; }
    .data-drawer-section h4 .required { color: #c62828; font-size: 0.75em; font-weight: 600; }
    .data-drawer-section h4 .optional { color: #888; font-size: 0.75em; font-weight: normal; }
    .data-drawer-section p { font-size: 0.8em; color: #666; margin: 0 0 12px; line-height: 1.4; }
    .data-drawer-section .info-tooltip { display: inline-block; width: 14px; height: 14px; background: #1565c0; color: white; border-radius: 50%; font-size: 0.65em; text-align: center; line-height: 14px; cursor: help; margin-left: 4px; }
    .data-drawer-actions { padding: 16px 20px; border-top: 1px solid #eee; flex-shrink: 0; }
    .data-drawer-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); display: none; z-index: 940; }
    .data-drawer-overlay.active { display: block; }

    .filters { background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .filters-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
    .filter-group { display: flex; flex-direction: column; gap: 5px; }
    .filter-group label { font-size: 0.75em; color: #666; text-transform: uppercase; font-weight: 600; }
    .filter-search { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; width: 250px; }
    .filter-chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .filter-chip { padding: 6px 12px; border-radius: 20px; font-size: 0.8em; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; }
    .filter-chip.severity-blocking { background: #ffcdd2; border-color: #c62828; }
    .filter-chip.severity-warning { background: #ffe0b2; border-color: #e65100; }
    .filter-chip.severity-info { background: #bbdefb; border-color: #1565c0; }
    .filter-chip.status-ready { background: #c8e6c9; border-color: #2e7d32; }
    .filter-chip.status-needs_review { background: #ffe0b2; border-color: #f57c00; }
    .filter-chip.status-blocked { background: #ffcdd2; border-color: #c62828; }
    .filter-chip.inactive { opacity: 0.4; }
    .filter-chip:hover { opacity: 1; }
    .filter-chip.active { background: #1976d2; color: white; border-color: #1565c0; }

    /* Record Inspection - Three Panel Layout */
    .srr-layout { display: flex; height: calc(100vh - 200px); gap: 0; }
    /* v1.6.7: Footer with file name */
    .srr-footer { background: #f5f5f5; border-top: 1px solid #e0e0e0; padding: 8px 16px; text-align: center; }
    .srr-footer-filename { font-size: 0.85em; color: #666; font-weight: 500; }
    .srr-panel { background: white; border: 1px solid #e0e0e0; overflow-y: auto; }
    .srr-panel-left { flex: 0 0 380px; flex-shrink: 0; border-right: none; order: 3; transition: flex-basis 0.3s ease, opacity 0.3s ease; position: relative; overflow: hidden; }
    .srr-panel-left.collapsed { flex-basis: 0px; min-width: 0; overflow: hidden; opacity: 0; padding: 0; border: none; }
    .srr-panel-center { flex: 1; min-width: 300px; order: 2; }
    .srr-panel-right { flex: 0 0 0px; flex-shrink: 0; border-left: none; order: 1; display: none; }
    .srr-panel-right.collapsed { flex-basis: 0px; min-width: 0; overflow: hidden; opacity: 0; padding: 0; border: none; }
    .srr-patch-expand-strip { display: none; writing-mode: vertical-rl; text-orientation: mixed; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px 0 0 4px; padding: 12px 6px; cursor: pointer; font-size: 0.75em; font-weight: 600; color: #1976d2; position: relative; order: 0; flex-shrink: 0; letter-spacing: 1px; }
    .srr-patch-expand-strip:hover { background: #bbdefb; }
    .srr-left-tabs { display: flex; flex-direction: column; gap: 2px; background: #f0f0f0; flex-shrink: 0; padding: 6px 3px; width: 36px; min-width: 36px; border-left: 1px solid #e0e0e0; }
    .srr-left-tab { padding: 7px 0; font-size: 0.6em; font-weight: 700; color: #888; cursor: pointer; border: none; background: none; border-radius: 4px; transition: color 0.15s, background 0.15s; white-space: nowrap; text-align: center; line-height: 1.2; letter-spacing: 0.02em; }
    .srr-left-tab:hover { color: #555; background: #e4e4e4; }
    .srr-left-tab.active { color: #1565c0; background: #e3f2fd; }
    .srr-left-tab-body { display: none; flex: 1; overflow-y: auto; flex-direction: column; min-width: 0; }
    .srr-left-tab-body.active { display: flex; }
    .srr-glossary-list { padding: 0; }
    .srr-glossary-entry { padding: 12px 16px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: background 0.1s; }
    .srr-glossary-entry:hover { background: #f5f8ff; }
    .srr-glossary-entry.expanded { background: #f5f8ff; }
    .srr-glossary-field-label { font-weight: 600; font-size: 0.9em; color: #333; margin-bottom: 2px; }
    .srr-glossary-field-key { font-size: 0.75em; color: #999; font-family: monospace; }
    .srr-glossary-detail { padding: 8px 0 4px 0; font-size: 0.85em; color: #555; line-height: 1.5; }
    .srr-glossary-meta { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
    .srr-glossary-tag { font-size: 0.72em; padding: 2px 8px; border-radius: 10px; background: #e3f2fd; color: #1565c0; font-weight: 500; }
    .srr-glossary-tag.format { background: #f3e5f5; color: #7b1fa2; }
    .srr-glossary-tag.required { background: #fce4ec; color: #c62828; }
    .srr-glossary-tag.optional { background: #e8f5e9; color: #2e7d32; }
    .srr-glossary-search { width: 100%; padding: 8px 12px; border: 1px solid #e0e0e0; border-radius: 4px; font-size: 0.85em; box-sizing: border-box; margin-bottom: 0; }
    .srr-glossary-empty { padding: 24px 16px; text-align: center; color: #999; font-size: 0.85em; }
    .srr-ctx-btn { padding: 2px 10px; border: 1px solid #ccc; background: #f5f5f5; color: #666; border-radius: 12px; cursor: pointer; font-size: 0.8em; font-weight: 500; }
    .srr-ctx-btn.active { background: #e3f2fd; border-color: #1565c0; color: #1565c0; }
    .srr-panel-header { background: #f5f5f5; padding: 12px 16px; border-bottom: 1px solid #e0e0e0; font-weight: 600; font-size: 0.9em; color: #333; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 5; }
    .srr-panel-tabs { display: flex; gap: 4px; }
    .srr-panel-tab { padding: 4px 10px; font-size: 0.75em; border: 1px solid #ccc; background: #fff; border-radius: 4px; cursor: pointer; color: #666; }
    .srr-panel-tab:hover { background: #f0f0f0; }
    .srr-panel-tab.active { background: #1565c0; color: white; border-color: #1565c0; }
    .srr-panel-body { padding: 12px; }
    .srr-top-bar { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding: 8px 12px; background: #1a1a2e; border-radius: 8px; color: white; flex-wrap: wrap; }
    .srr-identity { font-family: 'Courier New', monospace; font-size: 0.85em; background: #0f3460; padding: 6px 12px; border-radius: 4px; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; }
    .srr-state-badge { padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; text-transform: uppercase; }
    .srr-state-badge.ready { background: #c8e6c9; color: #2e7d32; }
    .srr-state-badge.needs_review { background: #ffe0b2; color: #e65100; }
    .srr-state-badge.blocked { background: #ffcdd2; color: #c62828; }
    .srr-state-badge.finalized { background: #bbdefb; color: #1565c0; }
    .srr-back-btn { background: #0f3460; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
    .srr-back-btn:hover { background: #1565c0; }
    .srr-nav-group { display: flex; align-items: center; gap: 4px; margin-left: 8px; }
    .srr-nav-btn { background: #e8eaf6; color: #1a237e; border: 1px solid #c5cae9; padding: 6px 10px; border-radius: 5px; cursor: pointer; font-size: 0.82em; font-weight: 600; display: flex; align-items: center; gap: 4px; transition: background 0.15s, opacity 0.15s; }
    .srr-nav-btn:hover:not(:disabled) { background: #c5cae9; }
    .srr-nav-btn:disabled { opacity: 0.35; cursor: not-allowed; }
    .srr-nav-pos { font-size: 0.75em; color: #888; white-space: nowrap; margin: 0 4px; }
    .srr-page-title-filename { font-size: 0.85em; font-weight: 400; color: #94a3b8; margin-left: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 500px; display: inline-block; vertical-align: middle; }
    .srr-file-action-bar { display: flex; align-items: center; gap: 8px; padding: 6px 12px; background: #f8fafc; border-bottom: 1px solid #e2e8f0; font-size: 0.82em; min-height: 36px; }
    .srr-file-action-bar .file-action-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: #334155; font-weight: 500; }
    .srr-file-action-bar .file-action-btn { padding: 4px 10px; border: 1px solid #cbd5e1; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.9em; color: #475569; display: flex; align-items: center; gap: 4px; transition: background 0.15s; }
    .srr-file-action-bar .file-action-btn:hover:not(:disabled) { background: #e2e8f0; }
    .srr-file-action-bar .file-action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .srr-file-action-bar .file-action-btn.primary { background: #3b82f6; color: #fff; border-color: #3b82f6; }
    .srr-file-action-bar .file-action-btn.primary:hover { background: #2563eb; }
    .srr-file-action-bar .file-action-btn.cancel { color: #ef4444; border-color: #fca5a5; }
    .srr-file-action-bar .file-action-edit-input { flex: 1; padding: 4px 8px; border: 1px solid #3b82f6; border-radius: 4px; font-size: 0.9em; outline: none; min-width: 0; }
    
    /* Field Inspector */
    .srr-field-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: background 0.15s; }
    .srr-field-item:hover { background: #f8f9fa; }
    .srr-field-item.active { background: #e3f2fd; border-left: 3px solid #1565c0; }
    .srr-field-name { flex: 1; font-size: 0.85em; font-weight: 500; word-break: break-word; }
    .srr-field-value { font-size: 0.8em; color: #666; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .srr-field-indicators { display: flex; gap: 4px; }
    .srr-indicator { width: 18px; height: 18px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.65em; }
    .srr-indicator.system { background: #e0e0e0; color: #666; }
    .srr-indicator.delta { background: #fff3e0; color: #e65100; }
    .srr-indicator.flag { background: #ffcdd2; color: #c62828; }
    .srr-indicator.evidence { background: #e3f2fd; color: #1565c0; }
    
    /* Document Viewer */
    .srr-doc-viewer { height: 100%; display: flex; flex-direction: column; }
    .srr-doc-controls { display: flex; gap: 8px; padding: 8px 12px; background: #263238; border-bottom: 1px solid #37474f; align-items: center; }
    .srr-doc-btn { background: #37474f; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em; }
    .srr-doc-btn:hover { background: #455a64; }
    .srr-doc-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .srr-page-indicator { color: #b0bec5; font-size: 0.8em; min-width: 80px; text-align: center; }
    .srr-zoom-indicator { color: #b0bec5; font-size: 0.8em; min-width: 50px; text-align: center; }
    .srr-doc-spacer { flex: 1; }
    .srr-doc-frame { flex: 1; background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #666; font-size: 0.9em; position: relative; min-height: 400px; overflow: hidden; }
    .srr-doc-empty-state { text-align: center; padding: 40px; }
    .srr-doc-container { width: 100%; height: 100%; overflow: auto; }
    .srr-pdf-iframe { width: 100%; height: 100%; border: none; transform-origin: top left; }
    .srr-pdf-object { width: 100%; height: 100%; border: none; transform-origin: top left; display: block; }
    .srr-pdf-fallback { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #f0f0f0; }
    .srr-anchor-overlay { position: absolute; border: 2px solid #1565c0; background: rgba(21, 101, 192, 0.1); pointer-events: auto; cursor: pointer; }
    .srr-anchor-overlay:hover { background: rgba(21, 101, 192, 0.25); }
    

    /* ═══ P1E: PDF Reliability — Cache Diagnostics Panel ═══ */
    
    /* ── P1F Batch PDF Scan ── */
    .p1f-scan-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10001;
      background: #1a237e;
      color: #fff;
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 14px;
      font-family: 'Inter', sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    .p1f-scan-banner.visible {
      transform: translateY(0);
    }
    .p1f-scan-progress {
      flex: 1;
      height: 6px;
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
      overflow: hidden;
    }
    .p1f-scan-progress-bar {
      height: 100%;
      background: #4fc3f7;
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .p1f-scan-stats {
      display: flex;
      gap: 12px;
      font-size: 12px;
      opacity: 0.9;
    }
    .p1f-scan-stat-bad { color: #ff8a80; font-weight: 600; }
    .p1f-scan-stat-ok { color: #b9f6ca; }
    .p1f-scan-stat-skip { color: #fff9c4; }
    .p1f-scan-done {
      background: #1b5e20;
    }
    .p1f-scan-done.has-issues {
      background: #b71c1c;
    }

    .p1e-diag-panel { position: fixed; bottom: 10px; right: 10px; width: 380px; max-height: 320px; background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); z-index: 99999; font-size: 0.82em; display: none; overflow: auto; }
    .p1e-diag-panel.visible { display: block; }
    .p1e-diag-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #e3f2fd; border-bottom: 1px solid #bbdefb; border-radius: 8px 8px 0 0; font-weight: 600; color: #1565c0; }
    .p1e-diag-close { cursor: pointer; font-size: 1.2em; color: #999; }
    .p1e-diag-close:hover { color: #333; }
    .p1e-diag-body { padding: 10px 12px; }
    .p1e-diag-row { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #f0f0f0; }
    .p1e-diag-label { color: #666; font-weight: 500; min-width: 110px; }
    .p1e-diag-value { color: #333; text-align: right; word-break: break-all; max-width: 240px; }
    .p1e-diag-value.ok { color: #2e7d32; }
    .p1e-diag-value.warn { color: #e65100; }
    .p1e-diag-value.fail { color: #c62828; }
    .p1e-mojibake-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.78em; font-weight: 600; background: #fff3e0; color: #e65100; }

    /* PDF anchor match navigation bar */
    .srr-pdf-match-bar {
      position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
      background: #fff; color: #333; padding: 6px 14px;
      border-radius: 8px; font-size: 0.82em; font-weight: 500;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15); z-index: 100;
      display: none; align-items: center; gap: 8px;
      border: 1px solid #e0e0e0; pointer-events: auto;
    }
    .srr-pdf-match-bar.visible { display: flex; }
    .srr-pdf-match-bar .match-label { color: #555; white-space: nowrap; }
    .srr-pdf-match-bar .match-field { color: #1565c0; font-weight: 600; max-width: 140px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .srr-pdf-match-bar .match-count { color: #888; font-size: 0.9em; }
    .srr-pdf-match-bar .match-nav-btn {
      background: #e8eaf6; border: none; color: #1565c0; width: 26px; height: 26px;
      border-radius: 50%; cursor: pointer; font-size: 0.9em; font-weight: 700;
      display: flex; align-items: center; justify-content: center;
    }
    .srr-pdf-match-bar .match-nav-btn:hover { background: #c5cae9; }
    .srr-pdf-match-bar .match-nav-btn:disabled { opacity: 0.4; cursor: default; }
    .srr-pdf-match-bar .match-close { cursor: pointer; color: #999; font-size: 1.1em; margin-left: 2px; }
    .srr-pdf-match-bar .match-close:hover { color: #333; }
    .srr-pdf-match-bar .match-not-found { color: #e65100; font-style: italic; }
    .srr-pdf-match-bar .match-loading { color: #888; font-style: italic; }
    @keyframes matchPulse { 0%, 100% { box-shadow: 0 2px 10px rgba(0,0,0,0.15); } 50% { box-shadow: 0 2px 16px rgba(21, 101, 192, 0.4); } }
    .srr-pdf-match-bar.has-match { animation: matchPulse 1.5s ease-in-out 2; border-color: #1565c0; }
    @keyframes framePulse { 0% { box-shadow: inset 0 0 0 3px rgba(21, 101, 192, 0.5); } 100% { box-shadow: inset 0 0 0 0 rgba(21, 101, 192, 0); } }
    .srr-doc-frame.match-active { animation: framePulse 1s ease-out; }
    .srr-anchor-list { padding: 12px; border-top: 1px solid #e0e0e0; max-height: 150px; overflow-y: auto; }
    .srr-anchor-item { padding: 8px 10px; background: #f8f9fa; border-radius: 4px; margin-bottom: 6px; font-size: 0.8em; cursor: pointer; border-left: 3px solid #1565c0; }
    .srr-anchor-item:hover { background: #e3f2fd; }
    
    /* v1.4.18: Field Inspector Search + Filters */
    .srr-search-bar { padding: 8px 12px; border-bottom: 1px solid #e0e0e0; }
    .srr-search-input { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; }
    .srr-search-input:focus { border-color: #1565c0; outline: none; }
    .srr-filter-bar { display: flex; gap: 8px; padding: 8px 12px; border-bottom: 1px solid #e0e0e0; align-items: center; flex-wrap: wrap; }
    .srr-filter-chips { display: flex; gap: 4px; }
    .srr-filter-chip { padding: 4px 10px; font-size: 0.75em; border-radius: 12px; cursor: pointer; background: #f0f0f0; color: #666; }
    .srr-filter-chip:hover { background: #e0e0e0; }
    .srr-filter-chip.active { background: #1565c0; color: white; }
    
    /* v1.5.7: Field group headers for hinge-based grouping */
    .srr-field-group-header { font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px; padding: 12px 12px 6px; margin-top: 8px; border-bottom: 2px solid #e0e0e0; background: #f8f9fa; }
    .srr-field-group-header:first-child { margin-top: 0; }
    /* v1.6.7: Color-coded group headers */
    .srr-field-group-header.group-primary { background: #e8f5e9; border-bottom-color: #4caf50; color: #2e7d32; }
    .srr-field-group-header.group-secondary { background: #e3f2fd; border-bottom-color: #1976d2; color: #1565c0; }
    .srr-field-group-header.group-other { background: #fafafa; border-bottom-color: #9e9e9e; color: #616161; }
    .srr-group-count { font-weight: 400; color: #999; }
    
    /* v1.4.18: Field Card enhancements - locked, changed */
    .srr-field-card.locked { background: #f8f8f8; opacity: 0.9; }
    .srr-field-card.locked .srr-field-value-display { pointer-events: none; cursor: not-allowed; }
    .srr-field-card.changed { border-left: 3px solid #4caf50; }
    .srr-field-card.changed .srr-field-card-header { background: #e8f5e9; }
    .srr-chip-changed { background: #4caf50; color: white; }
    .srr-chip-locked { background: #9e9e9e; color: white; }
    
    /* v1.4.20: Field state styling */
    /* Field state styles */
    .srr-field-card.state-verified { border-left: 3px solid #4caf50; }
    .srr-field-card.state-verified .srr-field-card-header { background: #e8f5e9; }
    .srr-field-card.state-modified { border-left: 3px solid #1976d2; }
    .srr-field-card.state-modified .srr-field-card-header { background: #e3f2fd; }
    .srr-field-card.state-submitted { border-left: 3px solid #1565c0; }
    .srr-field-card.state-submitted .srr-field-card-header { background: #bbdefb; }
    .srr-field-card.state-rfi { border-left: 3px solid #ff9800; }
    .srr-field-card.state-rfi .srr-field-card-header { background: #fff3e0; }
    .srr-field-card.state-blocked { border-left: 3px solid #d32f2f; }
    .srr-field-card.state-blocked .srr-field-card-header { background: #ffebee; }
    /* Field state badges */
    .srr-chip-verified { background: #4caf50; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    .srr-chip-modified { background: #1976d2; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    .srr-chip-submitted { background: #1565c0; color: white; font-size: 0.65em; padding: 2px 5px; border-radius: 10px; white-space: nowrap; }
    .srr-chip-rfi { background: #ff9800; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    .srr-chip-blocked { background: #d32f2f; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    
    /* v1.4.20: Field action buttons */
    /* v1.4.20: Field action icons - Heroicons outline SVGs */
    .srr-field-actions { display: flex; gap: 2px; margin-left: auto; }
    .srr-field-action { border: none; background: transparent; cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: color 0.15s, background 0.15s; }
    .srr-field-action svg { width: 16px; height: 16px; }
    .srr-field-action { color: #9e9e9e; }
    .srr-field-action.blacklist:hover { color: #e53935; background: #ffebee; }
    .srr-field-action.rfi:hover { color: #7b1fa2; background: #f3e5f5; }
    .srr-field-action.verify:hover { color: #2e7d32; background: #e8f5e9; }
    .srr-field-action.blacklist.active { color: #e53935; }
    .srr-field-action.rfi.active { color: #7b1fa2; }
    .srr-field-action.verify.active { color: #2e7d32; background: #e8f5e9; }
    .srr-field-action.reset:hover { color: #616161; background: #f5f5f5; }
    
    /* v1.4.20: Filter chip with count */
    .srr-filter-chip .chip-count { font-size: 0.85em; margin-left: 4px; opacity: 0.8; }
    .srr-lock-icon { font-size: 0.9em; margin-left: 4px; }
    
    /* v1.5.2: Patch Type chip selected field indicator */
    .srr-patch-type-selected-field { font-size: 0.75em; color: #666; margin-top: 6px; padding: 4px 8px; background: #f5f5f5; border-radius: 4px; text-align: center; }
    .srr-patch-type-chips.no-selection .srr-patch-type-chip { opacity: 0.6; }
    .srr-patch-type-chips.no-selection .srr-patch-type-chip:hover { opacity: 1; }

    /* v1.4.18: Patch Editor Block */
    .srr-patch-editor { background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    .srr-patch-editor-title { font-weight: 600; font-size: 0.9em; color: #333; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; }
    .srr-patch-editor-empty { color: #999; font-size: 0.85em; font-style: italic; text-align: center; padding: 20px; }
    .srr-patch-editor-field { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #e0e0e0; }
    .srr-patch-editor-field:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .srr-patch-editor-label { font-size: 0.8em; font-weight: 600; color: #333; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
    .srr-patch-editor-row { display: flex; gap: 8px; align-items: flex-start; margin-bottom: 4px; }
    .srr-patch-editor-row label { font-size: 0.75em; color: #666; min-width: 60px; }
    .srr-patch-editor-old { flex: 1; background: #f5f5f5; padding: 6px 8px; border-radius: 4px; font-size: 0.8em; color: #999; font-family: monospace; border: 1px dashed #ccc; }
    .srr-patch-editor-new { flex: 1; }
    .srr-patch-editor-new input { width: 100%; padding: 8px 10px; border: 2px solid #4caf50; border-radius: 4px; font-size: 0.85em; font-family: monospace; background: #e8f5e9; font-weight: 500; }
    .srr-patch-editor-new input:focus { outline: none; border-color: #2e7d32; box-shadow: 0 0 0 2px rgba(76,175,80,0.2); }
    .srr-patch-type-selector { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #e0e0e0; }
    .srr-patch-type-label { font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px; }
    .srr-patch-type-chips { display: flex; gap: 6px; overflow-x: auto; white-space: nowrap; }
    .srr-patch-type-chip { padding: 5px 10px; border-radius: 14px; font-size: 0.75em; font-weight: 500; cursor: pointer; border: 2px solid transparent; transition: all 0.15s; flex-shrink: 0; }
    .srr-patch-type-chip.correction { background: #e3f2fd; color: #1565c0; border-color: #bbdefb; }
    .srr-patch-type-chip.correction.active { background: #1565c0; color: white; border-color: #1565c0; }
    .srr-patch-type-chip.blacklist { background: #ffebee; color: #c62828; border-color: #ffcdd2; }
    .srr-patch-type-chip.blacklist.active { background: #c62828; color: white; border-color: #c62828; }
    .srr-patch-type-chip.rfi { background: #f3e5f5; color: #7b1fa2; border-color: #e1bee7; }
    .srr-patch-type-chip.rfi.active { background: #7b1fa2; color: white; border-color: #7b1fa2; }
    .srr-override-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #fff3e0; border-radius: 6px; margin-top: 12px; }
    .srr-override-toggle { width: 40px; height: 22px; background: #ccc; border-radius: 11px; position: relative; cursor: pointer; transition: background 0.2s; }
    .srr-override-toggle.active { background: #ff9800; }
    .srr-override-toggle::after { content: ''; position: absolute; width: 18px; height: 18px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: left 0.2s; }
    .srr-override-toggle.active::after { left: 20px; }
    .srr-override-label { font-size: 0.8em; color: #e65100; font-weight: 500; }
    .srr-override-badge { display: inline-block; padding: 2px 8px; background: #ff9800; color: white; font-size: 0.7em; font-weight: 600; border-radius: 4px; text-transform: uppercase; }
    .srr-blacklist-subject { background: #ffebee; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; color: #c62828; margin-top: 8px; }
    .srr-blacklist-subject-label { font-weight: 600; margin-bottom: 4px; }
    .srr-rfi-target { margin-top: 12px; }
    .srr-rfi-target input { width: 100%; padding: 8px 10px; border: 1px solid #e1bee7; border-radius: 6px; font-size: 0.85em; }
    .srr-section-hidden { display: none !important; }
    .srr-patch-remove-btn { background: none; border: none; color: #c62828; cursor: pointer; font-size: 0.9em; padding: 4px; }
    .srr-patch-remove-btn:hover { background: #ffebee; border-radius: 4px; }
    
    /* Evidence Pack + Patch Request */
    .srr-evidence-block { margin-bottom: 16px; }
    .srr-evidence-label { font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
    .srr-evidence-alias { font-weight: 400; color: #999; }
    .srr-evidence-select { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; }
    .srr-evidence-select:focus { border-color: #1565c0; outline: none; }
    .srr-evidence-textarea { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; font-family: inherit; resize: vertical; }
    .srr-evidence-textarea:focus { border-color: #1565c0; outline: none; }
    .srr-evidence-textarea::placeholder { color: #999; }
    .srr-evidence-file-input { margin-top: 8px; display: flex; align-items: center; gap: 8px; }
    .srr-repro-required { font-size: 0.7em; color: #f57c00; font-weight: 500; margin-left: 6px; }
    .srr-patch-section { margin-top: 20px; padding-top: 16px; border-top: 1px solid #e0e0e0; }
    .srr-patch-list { background: #f9f9f9; border-radius: 6px; max-height: 150px; overflow-y: auto; margin-bottom: 12px; }
    .srr-patch-header { padding: 8px 10px; font-weight: 600; font-size: 0.85em; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; }
    .srr-patch-status { font-size: 0.75em; padding: 2px 8px; border-radius: 10px; font-weight: 500; }
    .srr-patch-status.draft { background: #fff3e0; color: #e65100; }
    .srr-patch-status.submitted { background: #e3f2fd; color: #1565c0; }
    .srr-patch-item { padding: 8px 10px; border-bottom: 1px solid #eee; font-size: 0.8em; }
    .srr-patch-item:last-child { border-bottom: none; }
    .srr-patch-path { font-family: 'Courier New', monospace; color: #7b1fa2; }
    .srr-patch-change { display: flex; gap: 8px; margin-top: 4px; }
    .srr-patch-before { color: #c62828; text-decoration: line-through; }
    .srr-patch-after { color: #2e7d32; }
    .srr-actions { display: flex; gap: 8px; margin-top: 16px; }

    .review-checklist-panel { background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 14px; margin-bottom: 16px; }
    .review-checklist-panel h4 { margin: 0 0 10px; font-size: 0.9em; color: #333; display: flex; align-items: center; gap: 6px; }
    .review-checklist-item { display: flex; align-items: flex-start; gap: 8px; padding: 6px 0; font-size: 0.85em; color: #444; }
    .review-checklist-item input[type="checkbox"] { margin-top: 2px; accent-color: #1976d2; }
    .review-checklist-item label { cursor: pointer; line-height: 1.4; }
    .review-checklist-confirm { display: flex; align-items: center; gap: 8px; margin-top: 12px; padding-top: 10px; border-top: 1px solid #e0e0e0; font-weight: 600; font-size: 0.85em; }
    .review-checklist-confirm input[type="checkbox"] { accent-color: #2e7d32; width: 16px; height: 16px; }
    .srr-btn { flex: 1; padding: 10px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; }
    .srr-btn-secondary { background: #455a64; color: white; }
    .srr-btn-secondary:hover { background: #546e7a; }
    .srr-btn-primary { background: #1565c0; color: white; }
    .srr-btn-primary:hover { background: #1976d2; }
    .srr-empty-state { color: #999; font-style: italic; text-align: center; padding: 20px; }

    /* SRR Field Cards + Groups/Filters (v1.4.1) */
    .srr-filter-bar { display: flex; gap: 8px; padding: 8px 12px; border-bottom: 1px solid #e0e0e0; flex-wrap: wrap; background: #fafafa; }
    .srr-group-select { padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.8em; background: white; cursor: pointer; }
    .srr-filter-chips { display: flex; gap: 6px; flex-wrap: wrap; }
    .srr-filter-chip { padding: 3px 10px; border-radius: 12px; font-size: 0.75em; cursor: pointer; border: 1px solid #ddd; background: white; transition: all 0.15s; }
    .srr-filter-chip.active { background: #1565c0; color: white; border-color: #1565c0; }
    .srr-filter-chip:hover { background: #e3f2fd; }
    .srr-filter-chip.active:hover { background: #1976d2; }
    .srr-field-card { border: 1px solid #e0e0e0; border-radius: 8px; margin: 8px; padding: 0; background: white; transition: all 0.25s ease-out; overflow: hidden; }
    .srr-field-card:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    .srr-field-card.active { border-color: #1565c0; box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2); }
    .srr-field-card.removing { opacity: 0; transform: translateX(-20px); margin: 0; padding: 0; height: 0; overflow: hidden; }
    .srr-field-card.edited { border-color: #ff9800; background: #fff8e1; }
    .srr-field-card-header { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; background: #f5f5f5; border-bottom: 1px solid #eee; cursor: pointer; }
    .srr-field-card.edited .srr-field-card-header { background: #fff3e0; }
    .srr-field-card-label { font-weight: 600; font-size: 0.85em; color: #333; display: flex; align-items: center; gap: 4px; }
    
    /* v1.6.36+: Glossary tooltip styles (portal-based, light theme) */
    .glossary-tooltip-wrapper { position: relative; display: inline-flex; align-items: center; }
    .glossary-icon { 
      font-size: 0.75em; 
      color: #9e9e9e; 
      cursor: help; 
      transition: color 0.2s;
      line-height: 1;
    }
    .glossary-icon:hover { color: #1976d2; }
    #glossary-portal-tooltip {
      display: none;
      position: fixed;
      z-index: 99999;
      background: #ffffff;
      color: #222;
      padding: 14px 16px;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      font-size: 0.82em;
      font-weight: normal;
      width: 320px;
      max-width: 360px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      line-height: 1.5;
      pointer-events: none;
    }
    #glossary-portal-tooltip.visible { display: block; }
    #glossary-portal-tooltip .gtt-row { margin-bottom: 6px; display: flex; gap: 6px; }
    #glossary-portal-tooltip .gtt-label { color: #777; font-size: 0.85em; white-space: nowrap; min-width: 55px; }
    #glossary-portal-tooltip .gtt-value { color: #222; font-weight: 500; }
    #glossary-portal-tooltip .gtt-divider { border: none; border-top: 1px solid #eee; margin: 8px 0; }
    #glossary-portal-tooltip .gtt-definition { color: #444; font-style: italic; line-height: 1.5; }
    #glossary-portal-tooltip .gtt-options { 
      background: #f5f5f5; 
      padding: 6px 8px; 
      border-radius: 4px; 
      margin-top: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      max-height: 80px;
      overflow-y: auto;
      color: #555;
    }
    #glossary-portal-tooltip .gtt-no-data { color: #999; font-style: italic; }
    .srr-field-card-api { font-size: 0.7em; color: #888; font-family: 'Courier New', monospace; }
    .srr-field-card-chips { display: flex; gap: 4px; }
    .srr-chip { padding: 2px 6px; border-radius: 8px; font-size: 0.65em; font-weight: 600; text-transform: uppercase; }
    .srr-chip-edited { background: #ff9800; color: white; }
    .srr-chip-needs-patch { background: #e91e63; color: white; }
    .srr-chip-required { background: #9c27b0; color: white; }
    /* v1.6.15: Asterisk markers for required/invalid fields (replaces pills) */
    .srr-required-marker { color: #42a5f5; font-size: 0.75em; margin-left: 3px; opacity: 0.8; }
    .srr-invalid-marker { color: #e65100; font-size: 0.8em; font-weight: 700; margin-left: 2px; }
    .srr-field-card.signal-error { border-left: 3px solid #d32f2f; }
    .srr-field-card.signal-error .srr-field-card-header { background: #ffebee; }
    .srr-field-card.signal-warning { border-left: 3px solid #e65100; }
    .srr-field-card.signal-warning .srr-field-card-header { background: #fff3e0; }
    .srr-field-card.signal-info { border-left: 3px solid #1976d2; }
    .srr-field-card.signal-info .srr-field-card-header { background: #e3f2fd; }
    .srr-signal-chip { display: none; }
    .srr-field-legend { display: flex; flex-wrap: wrap; gap: 10px; padding: 6px 12px; background: #fafafa; border-bottom: 1px solid #e0e0e0; font-size: 0.72em; align-items: center; }
    .srr-legend-item { display: inline-flex; align-items: center; gap: 4px; color: #666; }
    .srr-legend-swatch { width: 12px; height: 12px; border-radius: 3px; display: inline-block; }
    /* Legend for asterisk markers */

    /* v1.6.10: Dropdown field styling */

    .srr-field-card.has-invalid-value { border-left: 3px solid #ff5722; }
    .srr-field-value-select { 
      width: 100%; 
      padding: 6px 8px; 
      border: 1px solid #0288d1; 
      border-radius: 4px; 
      font-size: 0.9em; 
      background: white;
      outline: none;
    }
    .srr-field-value-select:focus { border-color: #01579b; box-shadow: 0 0 0 2px rgba(2, 136, 209, 0.2); }
    .srr-inline-select {
      width: 100%; padding: 6px 8px; border: 1px solid #e0e0e0; border-radius: 4px;
      font-size: 0.85em; background: #fafafa; outline: none; color: #333;
      cursor: pointer; font-family: inherit; appearance: auto;
    }
    .srr-inline-select:hover { border-color: #90caf9; background: #f5f9ff; }
    .srr-inline-select:focus { border-color: #1565c0; box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.15); background: white; }
    .srr-inline-select.invalid { border-color: #ff5722; background: #fff8f6; }
    .srr-inline-select:disabled { opacity: 0.6; cursor: not-allowed; }
    .srr-inline-select option.invalid-opt { color: #c62828; }
    .srr-field-card-body { padding: 10px; }
    .srr-field-value-display { font-size: 0.85em; color: #333; word-break: break-word; padding: 6px 8px; background: #fafafa; border-radius: 4px; min-height: 24px; cursor: text; }
    .srr-field-value-display:hover { background: #f0f0f0; }
    .srr-field-card.edited .srr-field-value-display { background: #fff8e1; }
    .srr-field-value-input { width: 100%; padding: 6px 8px; border: 1px solid #1565c0; border-radius: 4px; font-size: 0.85em; font-family: inherit; box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2); }
    .srr-mini-patch { margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 6px; border: 1px solid #bbdefb; }
    .srr-mini-patch-label { font-size: 0.75em; font-weight: 600; color: #1565c0; margin-bottom: 6px; }
    .srr-mini-patch-input { width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.8em; margin-bottom: 6px; }
    .srr-mini-patch-actions { display: flex; gap: 6px; }
    .srr-mini-patch-btn { flex: 1; padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.75em; font-weight: 500; }
    .srr-mini-patch-btn.save { background: #1565c0; color: white; }
    .srr-mini-patch-btn.save:hover { background: #1976d2; }
    .srr-mini-patch-btn.undo { background: #f44336; color: white; }
    .srr-mini-patch-btn.undo:hover { background: #e53935; }
    .srr-patch-type { padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.75em; background: white; cursor: pointer; }
    .srr-proposed-change { padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; margin-bottom: 8px; background: #fafafa; }
    .srr-proposed-change-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .srr-proposed-change-field { font-weight: 600; font-size: 0.85em; color: #333; }
    .srr-proposed-change-values { font-size: 0.8em; display: flex; gap: 8px; flex-wrap: wrap; }
    .srr-proposed-change-from { color: #c62828; text-decoration: line-through; }
    .srr-proposed-change-to { color: #2e7d32; font-weight: 500; }

    /* Unsaved Changes Modal */
    .srr-guard-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .srr-guard-modal.active, .srr-guard-modal.visible { display: flex; }
    .srr-guard-dialog { background: white; border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .srr-guard-title { font-size: 1.1em; font-weight: 600; color: #333; margin-bottom: 12px; }
    .srr-guard-message { font-size: 0.9em; color: #666; line-height: 1.5; margin-bottom: 20px; }
    .srr-guard-actions { display: flex; gap: 8px; justify-content: flex-end; }
    .srr-guard-btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; }
    .srr-guard-btn.cancel { background: #e0e0e0; color: #333; }
    .srr-guard-btn.discard { background: #f44336; color: white; }
    .srr-guard-btn.save { background: #1565c0; color: white; }

    /* Verifier Review Styles (v1.4.5) */
    .vr-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 20px; }
    .vr-section { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; }
    .vr-section-header { font-weight: 600; font-size: 0.95em; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    .vr-section-header .icon { font-size: 1.1em; }
    .vr-intent-block { background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 8px; }
    .vr-intent-label { font-size: 0.75em; color: #666; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .vr-intent-value { font-size: 0.9em; color: #333; }
    .vr-evidence-block { background: #fafafa; padding: 10px 12px; border-left: 3px solid #1565c0; margin-bottom: 8px; }
    .vr-evidence-label { font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600; }
    .vr-evidence-text { font-size: 0.85em; color: #333; margin-top: 4px; white-space: pre-wrap; }
    .vr-preflight-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .vr-preflight-badge.pass { background: #e8f5e9; color: #2e7d32; }
    .vr-preflight-badge.warn { background: #fff3e0; color: #e65100; }
    .vr-preflight-badge.fail { background: #ffebee; color: #c62828; }
    .vr-revision-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; font-size: 0.85em; }
    .vr-revision-item:last-child { border-bottom: none; }
    .vr-author-info { display: flex; flex-direction: column; gap: 4px; font-size: 0.85em; }
    .vr-author-label { color: #666; }
    .vr-author-value { font-weight: 500; color: #333; }
    .vr-notes-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; resize: vertical; }
    .vr-actions-panel { background: #f5f5f5; padding: 16px; border-radius: 8px; margin-top: 16px; }
    .vr-actions-header { font-weight: 600; font-size: 0.9em; margin-bottom: 12px; color: #333; }
    .vr-actions-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
    .vr-action-btn { padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: all 0.15s; }
    .vr-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .vr-action-btn.begin { background: #1565c0; color: white; }
    .vr-action-btn.begin:hover:not(:disabled) { background: #1976d2; }
    .vr-action-btn.clarify { background: #ff9800; color: white; }
    .vr-action-btn.clarify:hover:not(:disabled) { background: #ffa726; }
    .vr-action-btn.approve { background: #2e7d32; color: white; }
    .vr-action-btn.approve:hover:not(:disabled) { background: #388e3c; }
    .vr-action-btn.reject { background: #c62828; color: white; }
    .vr-action-btn.reject:hover:not(:disabled) { background: #d32f2f; }
    .vr-state-badge { display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .vr-state-badge.submitted { background: #e3f2fd; color: #1565c0; }
    .vr-state-badge.under-review { background: #fff3e0; color: #e65100; }
    .vr-state-badge.needs-clarification { background: #fce4ec; color: #c2185b; }
    .vr-state-badge.approved { background: #e8f5e9; color: #2e7d32; }
    .vr-state-badge.rejected { background: #ffebee; color: #c62828; }
    .vr-decision-summary { background: #e8f5e9; border: 1px solid #c8e6c9; padding: 12px; border-radius: 6px; margin-top: 12px; }
    .vr-decision-summary.rejected { background: #ffebee; border-color: #ffcdd2; }
    .vr-empty-state { color: #666; font-style: italic; padding: 20px; text-align: center; background: #f9f9f9; border-radius: 6px; }
    .vr-full-width { grid-column: span 2; }
    .vr-clarify-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .vr-clarify-modal.active { display: flex; }
    .vr-clarify-modal-content { background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; }
    .vr-clarify-modal h4 { margin: 0 0 12px 0; }
    .vr-clarify-modal textarea { width: 100%; min-height: 100px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 12px; }
    .vr-clarify-modal-actions { display: flex; gap: 10px; justify-content: flex-end; }

    /* Admin Approval Styles (v1.4.5) */
    .aa-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 20px; }
    .aa-section { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; }
    .aa-section-header { font-weight: 600; font-size: 0.95em; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    .aa-section-header .icon { font-size: 1.1em; }
    .aa-intent-block { background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 8px; }
    .aa-intent-label { font-size: 0.75em; color: #666; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .aa-intent-value { font-size: 0.9em; color: #333; }
    .aa-evidence-block { background: #fafafa; padding: 10px 12px; border-left: 3px solid #7b1fa2; margin-bottom: 8px; }
    .aa-evidence-label { font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600; }
    .aa-evidence-text { font-size: 0.85em; color: #333; margin-top: 4px; white-space: pre-wrap; }
    .aa-preflight-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .aa-preflight-badge.pass { background: #e8f5e9; color: #2e7d32; }
    .aa-preflight-badge.warn { background: #fff3e0; color: #e65100; }
    .aa-preflight-badge.fail { background: #ffebee; color: #c62828; }
    .aa-verifier-decision { background: #e8f5e9; border: 1px solid #c8e6c9; padding: 12px; border-radius: 6px; }
    .aa-verifier-decision-header { font-weight: 600; color: #2e7d32; margin-bottom: 8px; }
    .aa-smoke-status { display: flex; align-items: center; gap: 8px; padding: 12px; border-radius: 6px; }
    .aa-smoke-status.pass { background: #e8f5e9; border: 1px solid #c8e6c9; }
    .aa-smoke-status.fail { background: #ffebee; border: 1px solid #ffcdd2; }
    .aa-smoke-icon { font-size: 1.5em; }
    .aa-smoke-label { font-weight: 600; }
    /* Patch Replay Styles (v1.4.17) */
    .aa-replay-status { display: flex; align-items: center; gap: 8px; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
    .aa-replay-status.not-run { background: #f5f5f5; border: 1px solid #e0e0e0; color: #666; }
    .aa-replay-status.pass { background: #e8f5e9; border: 1px solid #c8e6c9; color: #2e7d32; }
    .aa-replay-status.fail { background: #ffebee; border: 1px solid #ffcdd2; color: #c62828; }
    .aa-replay-badge { font-weight: 600; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; text-transform: uppercase; }
    .aa-replay-badge.not-run { background: #e0e0e0; color: #666; }
    .aa-replay-badge.pass { background: #4caf50; color: white; }
    .aa-replay-badge.fail { background: #f44336; color: white; }
    .aa-replay-packet { margin-top: 12px; }
    .aa-replay-check { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #fafafa; border-left: 3px solid #e0e0e0; margin-bottom: 4px; font-size: 0.85em; }
    .aa-replay-check.pass { border-left-color: #4caf50; }
    .aa-replay-check.fail { border-left-color: #f44336; }
    .aa-replay-check-icon { font-size: 1.1em; }
    .aa-replay-check-label { flex: 1; }
    .aa-replay-failure-reason { background: #fff8e1; border: 1px solid #ffcc80; padding: 12px; border-radius: 6px; margin-top: 12px; font-size: 0.85em; }
    .aa-replay-failure-reason-header { font-weight: 600; color: #e65100; margin-bottom: 6px; }
    .aa-replay-btn { background: #1976d2; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.85em; font-weight: 500; }
    .aa-replay-btn:hover { background: #1565c0; }
    .aa-replay-btn:disabled { background: #90caf9; cursor: not-allowed; }
    .aa-changelog-preview { background: #263238; color: #eceff1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; }
    .aa-actions-panel { background: #f3e5f5; padding: 16px; border-radius: 8px; margin-top: 16px; border: 1px solid #ce93d8; }
    .aa-actions-header { font-weight: 600; font-size: 0.9em; margin-bottom: 12px; color: #6a1b9a; }
    .aa-actions-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
    .aa-action-btn { padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: all 0.15s; }
    .aa-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .aa-action-btn.approve { background: #6a1b9a; color: white; }
    .aa-action-btn.approve:hover:not(:disabled) { background: #7b1fa2; }
    .aa-action-btn.hold { background: #ff9800; color: white; }
    .aa-action-btn.hold:hover:not(:disabled) { background: #ffa726; }
    .aa-action-btn.release { background: #1565c0; color: white; }
    .aa-action-btn.release:hover:not(:disabled) { background: #1976d2; }
    .aa-action-btn.promote { background: #2e7d32; color: white; grid-column: span 2; }
    .aa-action-btn.promote:hover:not(:disabled) { background: #388e3c; }
    .aa-state-badge { display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .aa-state-badge.verifier-approved { background: #e8f5e9; color: #2e7d32; }
    .aa-state-badge.admin-hold { background: #fff3e0; color: #e65100; }
    .aa-state-badge.admin-approved { background: #f3e5f5; color: #6a1b9a; }
    .aa-state-badge.promoted { background: #e3f2fd; color: #1565c0; }
    .aa-decision-summary { background: #f3e5f5; border: 1px solid #ce93d8; padding: 12px; border-radius: 6px; margin-top: 12px; }
    .aa-full-width { grid-column: span 2; }
    .aa-notes-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; resize: vertical; }
    .aa-hold-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .aa-hold-modal.active { display: flex; }
    .aa-hold-modal-content { background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; }
    .aa-hold-modal h4 { margin: 0 0 12px 0; }
    .aa-hold-modal textarea { width: 100%; min-height: 100px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 12px; }
    .aa-hold-modal-actions { display: flex; gap: 10px; justify-content: flex-end; }

    /* Folder Selection Modal (v1.4.23) */
    .folder-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .folder-modal-overlay.active { display: flex; }
    .folder-modal { background: white; border-radius: 12px; width: 90%; max-width: 450px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); animation: folderModalSlide 0.2s ease; }
    @keyframes folderModalSlide { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    .folder-modal-header { padding: 20px 24px; border-bottom: 1px solid #e0e0e0; }
    .folder-modal-header h3 { margin: 0 0 6px 0; font-size: 1.1em; color: #1a1a2e; }
    .folder-modal-header p { margin: 0; font-size: 0.85em; color: #666; }
    .folder-modal-body { padding: 24px; }
    .folder-select-wrapper { margin-bottom: 16px; }
    .folder-select-label { font-size: 0.8em; color: #666; margin-bottom: 6px; font-weight: 500; }
    .folder-select { width: 100%; padding: 12px 14px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.95em; cursor: pointer; background: white; }
    .folder-select:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 0 3px rgba(25,118,210,0.1); }
    .folder-modal-footer { padding: 16px 24px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 10px; }
    .folder-modal-btn { padding: 10px 20px; border-radius: 6px; font-size: 0.9em; font-weight: 500; cursor: pointer; transition: all 0.15s; }
    .folder-modal-btn.primary { background: #1976d2; color: white; border: none; }
    .folder-modal-btn.primary:hover { background: #1565c0; }
    .folder-modal-btn.primary:disabled { background: #90caf9; cursor: not-allowed; }
    .folder-connected-card { background: #e8f5e9; border: 1px solid #81c784; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
    .folder-connected-icon { font-size: 1.5em; margin-bottom: 8px; }
    .folder-connected-label { font-size: 0.75em; color: #2e7d32; text-transform: uppercase; font-weight: 600; margin-bottom: 4px; }
    .folder-connected-name { font-size: 1em; color: #1b5e20; font-weight: 600; }
    .folder-sync-time { font-size: 0.8em; color: #558b2f; margin-top: 6px; }

    /* Grid Table Styles */
    .grid-table { min-width: 800px; }
    .grid-table th, .grid-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #e0e0e0; white-space: nowrap; }
    .grid-table th { font-weight: 600; color: #333; background: #f5f5f5; border-bottom: 2px solid #ddd; }
    .grid-table tr:hover { background: #f8f9fa; }
    .grid-table tr.clickable { cursor: pointer; }
    .grid-table td.status-ready { color: #2e7d32; }
    .grid-table td.status-needs_review { color: #f57c00; }
    .grid-table td.status-blocked { color: #c62828; }
    .grid-table td.status-finalized { color: #1565c0; }
    .grid-table td.status-flagged { color: #7b1fa2; }
    .grid-table td.truncated { max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    .grid-table .row-index { color: #999; font-size: 0.8em; }
    /* v1.6.2: Row badges for signal counts */
    .row-badges { display: inline-flex; gap: 3px; margin-left: 6px; }
    .row-badge { 
      display: inline-flex; align-items: center; justify-content: center;
      min-width: 16px; height: 16px; padding: 0 4px;
      border-radius: 8px; font-size: 0.7em; font-weight: 600;
    }
    .badge-patch { background: #e3f2fd; color: #1565c0; }
    .badge-sflogic { background: #fff3e0; color: #e65100; }
    .badge-manual { background: #fffde7; color: #f57f17; }
    .badge-system { background: #f5f5f5; color: #616161; }
    .badge-blacklist { background: #ffebee; color: #c62828; }
    /* v1.6.6: Patch tooltip styles */
    .row-badge { position: relative; cursor: pointer; }
    .patch-tooltip { 
      display: none; position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
      background: #1a1a2e; color: white; padding: 10px 12px; border-radius: 6px;
      font-size: 0.8em; white-space: nowrap;  min-width: 180px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); margin-top: 6px;
    }
    .patch-tooltip::before {
      content: ''; position: absolute; top: -6px; left: 50%; transform: translateX(-50%);
      border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 6px solid #1a1a2e;
    }
    .row-badge:hover .patch-tooltip { display: block; }
    .patch-tooltip-title { font-weight: 600; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #333; }
    .patch-tooltip-item { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
    .patch-tooltip-field { flex: 1; font-family: 'Courier New', monospace; font-size: 0.9em; }
    .patch-chip { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; font-weight: 500; }
    .patch-chip-correction { background: #1565c0; color: white; }
    .patch-chip-rfi { background: #e65100; color: white; }
    .patch-chip-blacklist { background: #c62828; color: white; }
    .patch-chip-system { background: #616161; color: white; }
    .patch-chip-legacy { background: #78909c; color: white; }
    /* v1.6.6: Field Inspector patch highlight */
    .srr-field-card.has-patch { border-left: 3px solid #1565c0; background: #f8fbff; }
    .srr-field-card.has-patch.patch-rfi { border-left-color: #e65100; background: #fff8f5; }
    .srr-field-card.has-patch.patch-blacklist { border-left-color: #c62828; background: #fff5f5; }
    .srr-field-card.has-patch.patch-system { border-left-color: #616161; background: #fafafa; }
    .field-patch-indicator { display: inline-flex; gap: 4px; margin-left: 8px; }
    .field-patch-chip { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; font-weight: 500; }
    .field-patch-chip.correction { background: #e3f2fd; color: #1565c0; }
    .field-patch-chip.rfi { background: #fff3e0; color: #e65100; }
    .field-patch-chip.blacklist { background: #ffebee; color: #c62828; }
    .field-patch-chip.system_change { background: #f5f5f5; color: #616161; }
    .field-patch-chip.legacy { background: #eceff1; color: #546e7a; font-style: italic; }
    .filter-select { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; min-width: 150px; }

    .drawer-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); display: none; z-index: 900; }
    .drawer-overlay.active { display: block; }
    .drawer { position: fixed; top: 0; right: -550px; width: 550px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 901; transition: right 0.3s ease; display: flex; flex-direction: column; }
    .drawer.active { right: 0; }
    .drawer-header { background: #1a1a2e; color: white; padding: 15px 20px; flex-shrink: 0; }
    .drawer-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .drawer-header h3 { margin: 0; font-size: 1em; }
    .drawer-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .drawer-identity { display: flex; align-items: center; gap: 10px; }
    .identity-pill { background: #0f3460; padding: 6px 12px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.75em; word-break: break-all; flex-grow: 1; }
    .identity-copy { background: #1565c0; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75em; white-space: nowrap; }
    .identity-copy:hover { background: #1976d2; }
    .drawer-tabs { display: flex; background: #263238; flex-shrink: 0; }
    .drawer-tab { flex: 1; padding: 12px 8px; text-align: center; color: #90a4ae; background: none; border: none; cursor: pointer; font-size: 0.85em; border-bottom: 3px solid transparent; transition: all 0.2s; }
    .drawer-tab:hover { color: white; background: #37474f; }
    .drawer-tab.active { color: white; border-bottom-color: #1565c0; background: #37474f; }
    .drawer-tab-count { display: inline-block; background: #455a64; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.75em; margin-left: 4px; }
    .drawer-body { padding: 15px; overflow-y: auto; flex-grow: 1; }
    .drawer-json { background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; word-break: break-all; max-height: 100%; overflow-y: auto; }
    .drawer-table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    .drawer-table th, .drawer-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    .drawer-table th { background: #f5f5f5; font-weight: 600; color: #333; }
    .drawer-table tr:hover { background: #f9f9f9; }
    .drawer-empty { color: #666; font-style: italic; padding: 20px; text-align: center; background: #f9f9f9; border-radius: 6px; }
    .drawer-actions { padding: 15px 20px; border-top: 1px solid #eee; flex-shrink: 0; }
    .drawer-btn { padding: 10px 14px; background: #1565c0; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; }
    .drawer-btn:hover { background: #1976d2; }
    .drawer-actions-grid { display: flex; flex-wrap: wrap; gap: 8px; }
    .drawer-btn-secondary { background: #455a64; }
    .drawer-btn-secondary:hover { background: #546e7a; }
    .drawer-warning { background: #fff3e0; color: #e65100; padding: 10px 15px; font-size: 0.85em; border-bottom: 1px solid #ffe0b2; }
    .identity-primary { color: #4caf50; font-weight: bold; }
    .identity-fallback { color: #90a4ae; }

    .selection-controls { display: flex; gap: 8px; margin-bottom: 10px; align-items: center; }
    .selection-btn { padding: 4px 10px; font-size: 0.75em; border: 1px solid #ddd; background: #f5f5f5; border-radius: 4px; cursor: pointer; }
    .selection-btn:hover { background: #e0e0e0; }
    .selection-count { font-size: 0.8em; color: #666; margin-left: auto; }
    .drawer-table input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
    .drawer-table th:first-child, .drawer-table td:first-child { width: 30px; text-align: center; }

    .patch-studio { position: fixed; top: 0; right: -450px; width: 450px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 902; transition: right 0.3s ease; display: flex; flex-direction: column; }
    .patch-studio.active { right: 0; }
    .patch-studio-header { background: #2e7d32; color: white; padding: 15px 20px; flex-shrink: 0; }
    .patch-studio-header h3 { margin: 0 0 5px 0; font-size: 1em; }
    .patch-studio-header-row { display: flex; justify-content: space-between; align-items: center; }
    .patch-studio-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .patch-studio-body { padding: 15px; overflow-y: auto; flex-grow: 1; }
    .patch-field { margin-bottom: 15px; }
    .patch-field label { display: block; font-size: 0.8em; color: #666; margin-bottom: 4px; font-weight: 600; text-transform: uppercase; }
    .patch-field input, .patch-field textarea { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; font-family: inherit; }
    .patch-field textarea { min-height: 60px; resize: vertical; }
    .patch-changes-header { display: flex; justify-content: space-between; align-items: center; margin: 15px 0 10px; }
    .patch-changes-header h4 { margin: 0; font-size: 0.9em; color: #333; }
    .patch-changes-list { background: #f9f9f9; border-radius: 6px; max-height: 250px; overflow-y: auto; }
    .patch-change-item { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid #eee; font-size: 0.85em; }
    .patch-change-item:last-child { border-bottom: none; }
    .patch-change-info { flex-grow: 1; }
    .patch-change-remove { background: none; border: none; color: #c62828; cursor: pointer; font-size: 1.1em; padding: 4px 8px; }
    .patch-change-remove:hover { background: #ffebee; border-radius: 4px; }
    .patch-studio-actions { padding: 15px 20px; border-top: 1px solid #eee; flex-shrink: 0; display: flex; flex-direction: column; gap: 8px; }
    .patch-studio-btn { padding: 10px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; }
    .patch-studio-btn-primary { background: #2e7d32; color: white; }
    .patch-studio-btn-primary:hover { background: #388e3c; }
    .patch-studio-btn-secondary { background: #455a64; color: white; }
    .patch-studio-btn-secondary:hover { background: #546e7a; }
    .patch-empty { color: #666; font-style: italic; padding: 20px; text-align: center; }
    .evidence-section { margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee; }
    .evidence-section h4 { margin: 0 0 10px 0; font-size: 0.85em; color: #666; text-transform: uppercase; }
    .evidence-btns { display: flex; flex-wrap: wrap; gap: 6px; }
    .evidence-btn { padding: 6px 10px; font-size: 0.75em; background: #e0e0e0; border: none; border-radius: 4px; cursor: pointer; }
    .evidence-btn:hover { background: #bdbdbd; }

    .patch-studio-tabs { display: flex; background: #1b5e20; flex-shrink: 0; }
    .patch-studio-tab { flex: 1; padding: 10px 8px; text-align: center; color: rgba(255,255,255,0.7); background: none; border: none; cursor: pointer; font-size: 0.85em; border-bottom: 3px solid transparent; transition: all 0.2s; }
    .patch-studio-tab:hover { color: white; background: rgba(255,255,255,0.1); }
    .patch-studio-tab.active { color: white; border-bottom-color: #81c784; background: rgba(255,255,255,0.1); }
    .patch-studio-panel { display: none; }
    .patch-studio-panel.active { display: block; }

    .p1a-sheet-tab { transition: all 0.15s ease; }
    .p1a-sheet-tab:hover { border-color: #1565c0 !important; color: #1565c0 !important; }
    .preflight-checklist { margin-bottom: 15px; }
    .preflight-step { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; margin-bottom: 8px; }
    .preflight-step-num { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.75em; font-weight: bold; flex-shrink: 0; }
    .preflight-step-num.pending { background: #e0e0e0; color: #666; }
    .preflight-step-num.pass { background: #c8e6c9; color: #2e7d32; }
    .preflight-step-num.warn { background: #fff3e0; color: #e65100; }
    .preflight-step-num.fail { background: #ffcdd2; color: #c62828; }
    .preflight-step-info { flex-grow: 1; }
    .preflight-step-title { font-weight: 600; font-size: 0.9em; }
    .preflight-step-status { font-size: 0.75em; color: #666; }
    .preflight-step-chip { padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; text-transform: uppercase; }
    .preflight-step-chip.pending { background: #e0e0e0; color: #666; }
    .preflight-step-chip.pass { background: #c8e6c9; color: #2e7d32; }
    .preflight-step-chip.warn { background: #fff3e0; color: #e65100; }
    .preflight-step-chip.fail { background: #ffcdd2; color: #c62828; }

    .preflight-input-group { margin-bottom: 15px; }
    .preflight-input-group label { display: block; font-size: 0.8em; color: #666; margin-bottom: 4px; font-weight: 600; }
    .preflight-input-group textarea { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; font-family: 'Courier New', monospace; min-height: 80px; resize: vertical; }
    .preflight-input-group input { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; }
    .preflight-input-actions { display: flex; gap: 6px; margin-top: 6px; }
    .preflight-parse-btn { padding: 4px 10px; font-size: 0.75em; background: #1565c0; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .preflight-parse-btn:hover { background: #1976d2; }
    .preflight-clear-btn { padding: 4px 10px; font-size: 0.75em; background: #e0e0e0; border: none; border-radius: 4px; cursor: pointer; }
    .preflight-clear-btn:hover { background: #bdbdbd; }

    .preflight-result { background: #f5f5f5; border-radius: 6px; padding: 10px 12px; margin-top: 8px; font-size: 0.85em; }
    .preflight-result.pass { background: #e8f5e9; border-left: 3px solid #2e7d32; }
    .preflight-result.warn { background: #fff8e1; border-left: 3px solid #f57c00; }
    .preflight-result.fail { background: #ffebee; border-left: 3px solid #c62828; }
    .preflight-result-row { display: flex; justify-content: space-between; padding: 3px 0; }
    .preflight-result-key { color: #666; }
    .preflight-result-val { font-weight: 500; font-family: 'Courier New', monospace; }

    .preflight-conflicts-table { width: 100%; border-collapse: collapse; font-size: 0.8em; margin-top: 10px; }
    .preflight-conflicts-table th, .preflight-conflicts-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #eee; }
    .preflight-conflicts-table th { background: #f5f5f5; font-weight: 600; }

    .preflight-section-title { font-size: 0.85em; font-weight: 600; color: #333; margin: 15px 0 8px; padding-bottom: 4px; border-bottom: 1px solid #eee; }
    .preflight-reset-row { display: flex; gap: 8px; margin-top: 15px; }
    .preflight-reset-btn { padding: 8px 14px; font-size: 0.85em; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .preflight-reset-btn:hover { background: #d32f2f; }

    .session-loader { background: #e8eaf6; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .session-loader-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .session-loader-header h3 { margin: 0; font-size: 0.95em; color: #3f51b5; }
    .session-loader-toggle { padding: 6px 12px; font-size: 0.8em; background: #3f51b5; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .session-loader-toggle:hover { background: #5c6bc0; }
    .session-loader-body { display: none; }
    .session-loader-body.active { display: block; }
    .session-loader-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
    .session-loader-field { flex: 1; min-width: 200px; }
    .session-loader-field label { display: block; font-size: 0.75em; color: #666; margin-bottom: 4px; font-weight: 600; text-transform: uppercase; }
    .session-loader-field input { width: 100%; padding: 8px 10px; border: 1px solid #c5cae9; border-radius: 4px; font-size: 0.85em; font-family: 'Courier New', monospace; }
    .session-loader-actions { display: flex; gap: 8px; }
    .session-loader-btn { padding: 8px 14px; font-size: 0.85em; border: none; border-radius: 4px; cursor: pointer; }
    .session-loader-btn-primary { background: #3f51b5; color: white; }
    .session-loader-btn-primary:hover { background: #5c6bc0; }
    .session-loader-btn-secondary { background: #e0e0e0; color: #333; }
    .session-loader-btn-secondary:hover { background: #bdbdbd; }
    .session-loader-status { margin-top: 10px; font-size: 0.85em; padding: 8px 12px; border-radius: 4px; }
    .session-loader-status.success { background: #e8f5e9; color: #2e7d32; }
    .session-loader-status.error { background: #ffebee; color: #c62828; }
    .session-loader-status.info { background: #e3f2fd; color: #1565c0; }

    .delta-summary { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
    .delta-card { background: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; min-width: 90px; border-left: 4px solid #9e9e9e; }
    .delta-card.positive { border-left-color: #4caf50; }
    .delta-card.negative { border-left-color: #f44336; }
    .delta-card.neutral { border-left-color: #9e9e9e; }
    .delta-card .delta-value { font-size: 1.5em; font-weight: bold; }
    .delta-card .delta-value.positive { color: #4caf50; }
    .delta-card .delta-value.negative { color: #f44336; }
    .delta-card .delta-value.neutral { color: #9e9e9e; }
    .delta-card .delta-label { font-size: 0.75em; color: #666; text-transform: uppercase; }
    .delta-card .delta-detail { font-size: 0.7em; color: #999; margin-top: 2px; }

    .row-added { background: #e8f5e9 !important; }
    .row-added td:first-child::before { content: '+'; color: #4caf50; font-weight: bold; margin-right: 4px; }
    .row-removed { background: #ffebee !important; text-decoration: line-through; opacity: 0.7; }
    .row-removed td:first-child::before { content: '-'; color: #f44336; font-weight: bold; margin-right: 4px; }
    .row-changed { background: #fff3e0 !important; }
    .row-changed td:first-child::before { content: '~'; color: #ff9800; font-weight: bold; margin-right: 4px; }

    .compare-legend { display: flex; gap: 15px; margin-bottom: 10px; font-size: 0.8em; }
    .compare-legend-item { display: flex; align-items: center; gap: 4px; }
    .compare-legend-dot { width: 12px; height: 12px; border-radius: 2px; }
    .compare-legend-dot.added { background: #4caf50; }
    .compare-legend-dot.changed { background: #ff9800; }
    .compare-legend-dot.removed { background: #f44336; }

    .compare-actions { display: flex; gap: 10px; margin-bottom: 15px; }
    .compare-btn { padding: 8px 14px; font-size: 0.85em; background: #7c4dff; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .compare-btn:hover { background: #651fff; }

    .config-inspector { background: #fce4ec; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .config-inspector-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .config-inspector-header h3 { margin: 0; font-size: 0.95em; color: #880e4f; }
    .config-inspector-toggle { padding: 6px 12px; font-size: 0.8em; background: #880e4f; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .config-inspector-toggle:hover { background: #ad1457; }
    .config-inspector-body { display: none; }
    .config-inspector-body.active { display: block; }
    .config-inspector-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
    .config-inspector-field { flex: 1; min-width: 200px; }
    .config-inspector-field label { display: block; font-size: 0.75em; color: #666; margin-bottom: 4px; font-weight: 600; text-transform: uppercase; }
    .config-inspector-field input { width: 100%; padding: 8px 10px; border: 1px solid #f8bbd9; border-radius: 4px; font-size: 0.85em; font-family: 'Courier New', monospace; }
    .config-inspector-actions { display: flex; gap: 8px; }
    .config-inspector-btn { padding: 8px 14px; font-size: 0.85em; border: none; border-radius: 4px; cursor: pointer; }
    .config-inspector-btn-primary { background: #880e4f; color: white; }
    .config-inspector-btn-primary:hover { background: #ad1457; }
    .config-inspector-btn-secondary { background: #e0e0e0; color: #333; }
    .config-inspector-btn-secondary:hover { background: #bdbdbd; }
    .config-inspector-status { margin-top: 10px; font-size: 0.85em; padding: 8px 12px; border-radius: 4px; }
    .config-inspector-status.success { background: #e8f5e9; color: #2e7d32; }
    .config-inspector-status.error { background: #ffebee; color: #c62828; }
    .config-inspector-status.info { background: #e3f2fd; color: #1565c0; }

    .patch-summary { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .patch-summary-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .patch-summary-header h4 { margin: 0; font-size: 0.95em; color: #333; }
    .patch-summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }
    .patch-summary-item { }
    .patch-summary-item label { display: block; font-size: 0.7em; color: #666; text-transform: uppercase; margin-bottom: 2px; }
    .patch-summary-item .value { font-family: 'Courier New', monospace; font-size: 0.9em; }
    .version-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
    .version-chip.match { background: #c8e6c9; color: #2e7d32; }
    .version-chip.mismatch { background: #ffcdd2; color: #c62828; }

    .ruleset-delta { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .ruleset-delta h4 { margin: 0 0 10px 0; font-size: 0.95em; color: #333; }
    .ruleset-delta-counts { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 10px; }
    .ruleset-count-card { background: #f5f5f5; padding: 8px 12px; border-radius: 6px; text-align: center; min-width: 80px; }
    .ruleset-count-card .count { font-size: 1.3em; font-weight: bold; }
    .ruleset-count-card .count.added { color: #4caf50; }
    .ruleset-count-card .count.deprecated { color: #f44336; }
    .ruleset-count-card .label { font-size: 0.7em; color: #666; text-transform: uppercase; }

    .changes-table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    .changes-table th, .changes-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    .changes-table th { background: #880e4f; color: white; font-weight: 600; }
    .changes-table tr:hover { background: #fce4ec; }
    .action-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
    .action-chip.add_rule { background: #c8e6c9; color: #2e7d32; }
    .action-chip.deprecate_rule { background: #ffcdd2; color: #c62828; }

    .config-inspector-copy-actions { display: flex; gap: 10px; margin-top: 15px; }
    .config-copy-btn { padding: 8px 14px; font-size: 0.85em; background: #880e4f; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .config-copy-btn:hover { background: #ad1457; }

    .stream-panel { background: #e0f2f1; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .stream-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .stream-panel-header h3 { margin: 0; font-size: 0.95em; color: #00695c; }
    .stream-panel-toggle { padding: 6px 12px; font-size: 0.8em; background: #00695c; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .stream-panel-toggle:hover { background: #00897b; }
    .stream-panel-body { display: none; }
    .stream-panel-body.active { display: block; }

    .stream-concept { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .stream-concept h4 { margin: 0 0 10px 0; font-size: 0.95em; color: #00695c; }
    .stream-concept p { font-size: 0.85em; color: #555; line-height: 1.5; margin-bottom: 10px; }

    .session-timeline { display: flex; gap: 15px; overflow-x: auto; padding: 10px 0; }
    .session-card { background: white; border-radius: 8px; padding: 12px; min-width: 180px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-left: 4px solid #00695c; }
    .session-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .session-card-title { font-weight: 600; font-size: 0.9em; color: #333; }
    .session-card-idx { font-size: 0.75em; color: #666; background: #e0e0e0; padding: 2px 6px; border-radius: 10px; }
    .session-card-stats { font-size: 0.8em; color: #666; }
    .session-card-stats div { display: flex; justify-content: space-between; padding: 2px 0; }

    .state-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; text-transform: uppercase; }
    .state-chip.consolidated { background: #c8e6c9; color: #2e7d32; }
    .state-chip.partial { background: #fff3e0; color: #e65100; }
    .state-chip.waiting { background: #e3f2fd; color: #1565c0; }
    .state-chip.blocked { background: #ffcdd2; color: #c62828; }
    
    /* Queue Tab Styles */
    .queue-tab { padding: 8px 14px; border: 1px solid #ddd; border-radius: 20px; background: #f5f5f5; cursor: pointer; font-size: 0.85em; transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px; }
    .queue-tab:hover { background: #e0e0e0; }
    .queue-tab.active { background: #1976d2; color: white; border-color: #1976d2; }
    .queue-tab .queue-count { background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 10px; font-size: 0.85em; min-width: 20px; text-align: center; }
    .queue-tab.active .queue-count { background: rgba(255,255,255,0.2); }
    
    /* Patch Console Table Styles */
    #patch-console-table tr:hover { background: #f5f5f5; }
    #patch-console-table td { padding: 8px; border-bottom: 1px solid #eee; }
    .patch-status-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
    .patch-status-chip.draft { background: #e3f2fd; color: #1565c0; }
    .patch-status-chip.submitted { background: #fff3e0; color: #e65100; }
    .patch-status-chip.approved { background: #e8f5e9; color: #2e7d32; }
    .patch-status-chip.sent { background: #ede7f6; color: #5e35b1; }
    .patch-status-chip.returned { background: #fce4ec; color: #c2185b; }
    .patch-status-chip.applied { background: #c8e6c9; color: #1b5e20; }
    .patch-status-chip.rejected { background: #ffcdd2; color: #b71c1c; }
    
    /* Masterline / Artifact Registry Styles */
    .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 22px; transition: 0.3s; }
    .toggle-slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.3s; }
    .toggle-switch input:checked + .toggle-slider { background-color: #4caf50; }
    .toggle-switch input:checked + .toggle-slider:before { transform: translateX(18px); }
    
    .masterline-status { font-size: 0.75em; font-weight: 600; padding: 2px 8px; border-radius: 10px; }
    .masterline-status.on { background: #c8e6c9; color: #2e7d32; }
    .masterline-status.off { background: #e0e0e0; color: #666; }
    
    .artifact-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    .artifact-table th { text-align: left; padding: 10px 12px; background: #f5f5f5; border-bottom: 2px solid #ddd; font-weight: 600; color: #333; }
    .artifact-table td { padding: 10px 12px; border-bottom: 1px solid #eee; vertical-align: middle; }
    .artifact-table tr:hover { background: #fafafa; }
    
    .artifact-status { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 0.8em; font-weight: 600; }
    .artifact-status.status-loaded { background: #c8e6c9; color: #2e7d32; }
    .artifact-status.status-missing { background: #ffcdd2; color: #c62828; }
    .artifact-status.status-unknown { background: #e0e0e0; color: #666; }
    
    .rebound-badge { font-size: 0.7em; background: #e3f2fd; color: #1565c0; padding: 2px 6px; border-radius: 8px; margin-left: 6px; }
    
    .artifact-path { font-family: monospace; font-size: 0.85em; color: #666; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    
    .rebind-btn { padding: 4px 10px; font-size: 0.8em; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
    .rebind-btn:hover { background: #e3f2fd; border-color: #90caf9; }
    
    .info-icon { display: inline-block; width: 16px; height: 16px; line-height: 16px; text-align: center; font-size: 12px; color: #90a4ae; cursor: help; margin-left: 4px; vertical-align: middle; }
    .info-icon:hover { color: #1976d2; }
    
    .json-header { font-size: 0.75em; color: #78909c; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; font-weight: 600; }
    
    /* Workflow Map Styles */
    .workflow-map { display: flex; flex-direction: column; gap: 0; }
    .workflow-node { display: flex; align-items: flex-start; gap: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; margin-bottom: 0; background: #fafafa; cursor: pointer; transition: all 0.2s ease; position: relative; }
    .workflow-node:hover { background: #e3f2fd; border-color: #90caf9; }
    .workflow-node:not(:last-child)::after { content: ''; position: absolute; left: 28px; bottom: -12px; width: 2px; height: 12px; background: #90caf9; z-index: 1; }
    .workflow-node-icon { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; background: #e3f2fd; border-radius: 50%; font-size: 1em; flex-shrink: 0; }
    .workflow-node-content { flex: 1; min-width: 0; }
    .workflow-node-title { font-weight: 600; color: #333; margin-bottom: 4px; font-size: 0.95em; }
    .workflow-node-desc { font-size: 0.8em; color: #666; margin-bottom: 8px; }
    .workflow-node-artifacts { display: flex; flex-wrap: wrap; gap: 6px; }
    .workflow-artifact { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 12px; font-size: 0.75em; background: #e8f5e9; color: #2e7d32; }
    .workflow-artifact.missing { background: #ffebee; color: #c62828; }
    .workflow-artifact.unknown { background: #f5f5f5; color: #666; }
    .workflow-connector { height: 12px; margin-left: 27px; border-left: 2px solid #90caf9; }

    .state-legend { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; }
    .state-legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.8em; }

    .flow-diagram { background: #fafafa; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
    .flow-diagram-title { font-weight: 600; font-size: 0.9em; color: #333; margin-bottom: 10px; }
    .flow-stages { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .flow-stage { background: white; padding: 10px 15px; border-radius: 6px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 100px; }
    .flow-stage-name { font-size: 0.8em; font-weight: 600; color: #333; }
    .flow-stage-desc { font-size: 0.7em; color: #666; margin-top: 4px; }
    .flow-arrow { color: #00695c; font-size: 1.2em; }
    .flow-stage.source { border-left: 3px solid #1565c0; }
    .flow-stage.process { border-left: 3px solid #00695c; }
    .flow-stage.output { border-left: 3px solid #2e7d32; }
    .flow-stage.hold { border-left: 3px solid #ff9800; }

    .reconsolidation-table { width: 100%; border-collapse: collapse; font-size: 0.85em; margin-bottom: 15px; }
    .reconsolidation-table th, .reconsolidation-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    .reconsolidation-table th { background: #00695c; color: white; font-weight: 600; }
    .reconsolidation-table tr:hover { background: #e0f2f1; }

    .stream-actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .stream-btn { padding: 8px 14px; font-size: 0.85em; background: #00695c; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .stream-btn:hover { background: #00897b; }

    .record-state-summary { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; }
    .record-state-card { background: white; padding: 10px 15px; border-radius: 6px; text-align: center; min-width: 100px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .record-state-card .count { font-size: 1.3em; font-weight: bold; }
    .record-state-card .label { font-size: 0.7em; color: #666; text-transform: uppercase; }
    .record-state-card.consolidated .count { color: #2e7d32; }
    .record-state-card.partial .count { color: #e65100; }
    .record-state-card.waiting .count { color: #1565c0; }
    .record-state-card.blocked .count { color: #c62828; }

    /* ========== BATCH ADD MODAL (v1.6.48) ========== */
    .batch-add-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 10000; display: flex; align-items: center; justify-content: center; }
    .batch-add-content { background: white; border-radius: 12px; max-width: 560px; width: 95%; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 8px 32px rgba(0,0,0,0.3); animation: modalFadeIn 0.2s ease-out; }
    .batch-add-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid #e0e0e0; }
    .batch-add-header h3 { margin: 0; font-size: 1.1em; font-weight: 600; color: #1a1a2e; }
    .batch-add-close { background: none; border: none; font-size: 1.6em; cursor: pointer; color: #999; line-height: 1; padding: 0 4px; }
    .batch-add-close:hover { color: #333; }
    .batch-add-steps { display: flex; justify-content: center; gap: 32px; padding: 16px 20px; border-bottom: 1px solid #f0f0f0; }
    .batch-add-step { display: flex; align-items: center; gap: 8px; color: #bbb; font-size: 0.85em; }
    .batch-add-step .step-num { width: 26px; height: 26px; border-radius: 50%; background: #e0e0e0; color: #999; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.85em; }
    .batch-add-step.active { color: #1565c0; }
    .batch-add-step.active .step-num { background: #1565c0; color: white; }
    .batch-add-step.done { color: #2e7d32; }
    .batch-add-step.done .step-num { background: #2e7d32; color: white; }
    .batch-add-body { flex: 1; overflow-y: auto; padding: 20px; }
    .batch-add-textarea { width: 100%; min-height: 160px; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-family: inherit; font-size: 0.9em; resize: vertical; }
    .batch-add-textarea:focus { border-color: #1565c0; outline: none; }
    .batch-add-select { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; }
    .batch-add-preview { max-height: 350px; overflow-y: auto; }
    .batch-add-preview-list { border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; }
    .batch-add-preview-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; font-size: 0.85em; border-bottom: 1px solid #f0f0f0; }
    .batch-add-preview-row:last-child { border-bottom: none; }
    .batch-add-preview-num { color: #999; font-size: 0.8em; min-width: 28px; text-align: right; }
    .batch-add-preview-text { flex: 1; word-break: break-word; }
    .batch-add-footer { display: flex; justify-content: flex-end; gap: 10px; padding: 16px 20px; border-top: 1px solid #e0e0e0; }
    .batch-add-btn-cancel { padding: 8px 18px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; font-size: 0.9em; color: #666; }
    .batch-add-btn-cancel:hover { background: #f5f5f5; }
    .batch-add-btn-back { padding: 8px 18px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; font-size: 0.9em; color: #333; }
    .batch-add-btn-back:hover { background: #f5f5f5; }
    .batch-add-btn-next { padding: 8px 18px; border: none; background: #1565c0; color: white; border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 500; }
    .batch-add-btn-next:hover { background: #1976d2; }
    .batch-add-btn-confirm { padding: 8px 18px; border: none; background: #2e7d32; color: white; border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 500; }
    .batch-add-btn-confirm:hover { background: #388e3c; }
    .group-anchor-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 10px; background: #e3f2fd; color: #1565c0; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .grid-group-caret { display: inline-block; cursor: pointer; font-size: 0.7em; margin-right: 4px; transition: transform 0.15s; color: #1565c0; user-select: none; }
    .grid-group-caret.collapsed { transform: rotate(-90deg); }
    .grid-child-indent { display: inline-block; width: 18px; border-left: 2px solid #bbdefb; margin-right: 4px; height: 1em; vertical-align: middle; }
    .grid-child-row { background: #f8fbff !important; }
    .grid-child-row:hover { background: #e8f4fd !important; }
    .batch-add-toggle { position: relative; display: inline-block; width: 40px; height: 22px; }
    .batch-add-toggle input { opacity: 0; width: 0; height: 0; }
    .batch-add-toggle .slider { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; border-radius: 22px; cursor: pointer; transition: background 0.2s; }
    .batch-add-toggle .slider:before { content: ''; position: absolute; width: 16px; height: 16px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: transform 0.2s; }
    .batch-add-toggle input:checked + .slider { background: #2e7d32; }
    .batch-add-toggle input:checked + .slider:before { transform: translateX(18px); }
    .batch-add-btn { background: #e8f5e9; color: #2e7d32; border: 1px solid #a5d6a7; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 0.8em; font-weight: 600; display: inline-flex; align-items: center; gap: 4px; transition: all 0.2s; }
    .batch-add-btn:hover { background: #2e7d32; color: white; border-color: #2e7d32; }
    .batch-add-cat-header { padding: 10px 14px; font-size: 0.85em; font-weight: 600; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; }
    .batch-add-cat-header.exact { background: #e8f5e9; color: #2e7d32; }
    .batch-add-cat-header.near { background: #fff8e1; color: #f57f17; }
    .batch-add-cat-header.new-cat { background: #e3f2fd; color: #1565c0; }
    .catalog-toggle-btn { padding: 5px 12px; border-radius: 5px; font-size: 0.8em; font-weight: 600; cursor: pointer; border: 1px solid #1565c0; background: white; color: #1565c0; transition: all 0.15s; }
    .catalog-toggle-btn:hover { background: #e3f2fd; }
    .catalog-toggle-btn.active { background: #1565c0; color: white; border-color: #1565c0; }
    .inspector-action-trigger { width: 22px; height: 22px; border-radius: 5px; border: 1.5px dashed #bbb; background: #fff; color: #999; font-size: 1.1em; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; transition: all 0.15s; position: relative; }
    .inspector-action-trigger:hover { border-color: #1565c0; color: #1565c0; background: #e3f2fd; }
    .inspector-action-trigger.has-active { border-style: solid; border-color: #1565c0; color: #1565c0; background: #e3f2fd; }
    .inspector-actions-menu { position: absolute; top: 100%; left: 0; margin-top: 0; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.12); min-width: 220px; z-index: 50; overflow: hidden; }
    .inspector-actions-menu-item { display: flex; align-items: center; gap: 10px; padding: 10px 14px; font-size: 0.82em; color: #333; cursor: pointer; transition: background 0.12s; border-bottom: 1px solid #f0f0f0; }
    .inspector-actions-menu-item:last-child { border-bottom: none; }
    .inspector-actions-menu-item:hover { background: #f5f7fa; }
    .inspector-actions-menu-item .action-icon { width: 24px; height: 24px; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 0.9em; flex-shrink: 0; }
    .inspector-actions-menu-item .action-label { flex: 1; }
    .inspector-actions-menu-item .action-label .action-title { font-weight: 600; display: block; }
    .inspector-actions-menu-item .action-label .action-desc { font-size: 0.88em; color: #888; display: block; margin-top: 1px; }
    .inspector-actions-menu-item .action-status { font-size: 0.75em; padding: 2px 8px; border-radius: 10px; font-weight: 600; white-space: nowrap; }
    .inspector-actions-menu-item .action-status.active-status { background: #e3f2fd; color: #1565c0; }
    .inspector-actions-menu-item .action-status.off-status { background: #f5f5f5; color: #aaa; }
    .inspector-actions-menu-item.disabled { opacity: 0.45; pointer-events: none; }
    .inspector-action-chips { display: flex; gap: 4px; flex-wrap: wrap; flex: 1; }
    .inspector-action-chip { display: inline-flex; align-items: center; gap: 4px; padding: 3px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; background: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; cursor: pointer; transition: all 0.12s; }
    .inspector-action-chip:hover { background: #bbdefb; }
    .inspector-action-chip .chip-x { font-size: 0.9em; margin-left: 2px; opacity: 0.6; }
    .inspector-action-chip .chip-x:hover { opacity: 1; }
  
    /* P1B QA Runner */
    .p1b-run-btn:hover { opacity: 0.85; }
    .p1b-run-btn:active { transform: scale(0.97); }
    </style>
</head>
<body>
  <!-- v1.6.37: Excel upload loading overlay -->
  <div id="upload-loading-overlay" class="upload-loading-overlay">
    <div class="upload-loading-spinner"></div>
    <div class="upload-loading-text">Loading Excel file...</div>
  </div>
  
  <!-- Debug HUD (v1.2.8) -->
  <div id="debug-hud" class="admin-only-content" style="position: fixed; top: 5px; right: 5px; background: rgba(0,0,0,0.7); color: #0f0; font-family: monospace; font-size: 11px; padding: 4px 8px; border-radius: 4px; z-index: 99999;">Route: - | Data: - | Mode: -</div>
  
  <div class="app-layout">
    <nav class="nav-sidebar">
      <div class="nav-header" style="display: flex; align-items: center; gap: 12px; height: 56px; padding: 10px 16px;">
        <div style="width: 44px; height: 44px; flex-shrink: 0; filter: drop-shadow(0 0 8px rgba(100, 200, 255, 0.6)) drop-shadow(0 0 16px rgba(100, 200, 255, 0.3));">
          <img src="../../assets/brand/orchestrate-os-logo.svg" alt="Orchestrate OS" title="Orchestrate OS" style="width: 100%; height: 100%; display: block; object-fit: contain;">
        </div>
        <div>
          <h1 style="font-size: 0.95em; margin: 0;">Orchestrate OS</h1>
          <div class="version">Semantic Control Board</div>
        </div>
      </div>
      <div class="nav-menu">
        <!-- Progress Block (routes to Triage) -->
        <div class="nav-section" style="padding: 16px 16px 8px;">
          <a class="progress-block" href="#/triage" data-page="triage">
            <div class="progress-header">Progress</div>
            <div class="progress-stats">
              <div class="progress-stat">
                <span class="progress-stat-count" id="progress-todo">0</span>
                <span class="progress-stat-label">To Do</span>
              </div>
              <div class="progress-stat">
                <span class="progress-stat-count" id="progress-review">0</span>
                <span class="progress-stat-label">Review</span>
              </div>
              <div class="progress-stat">
                <span class="progress-stat-count" id="progress-done">0</span>
                <span class="progress-stat-label">Done</span>
              </div>
            </div>
            <div class="progress-bar-container">
              <div class="progress-bar-fill" id="progress-bar-fill" style="width: 0%;"></div>
            </div>
          </a>
        </div>

        <!-- Active Data Source Bar -->
        <div class="active-data-source-bar" id="active-data-source-bar">
          <div class="active-data-source-info">
            <div class="active-data-source-label">Active Data Source</div>
            <div class="active-data-source-name" id="active-data-source-name">No dataset loaded</div>
          </div>
          <button class="active-data-source-change" id="active-data-source-action" onclick="openDataSourcePanel()">Change</button>
        </div>

        <!-- Locked Role Display (for Analyst/Verifier - appears above nav) -->
        <div id="locked-role-display-top" style="display: none; margin: 12px 16px; padding: 8px 12px; font-size: 0.8em; background: rgba(21, 101, 192, 0.15); color: #64b5f6; border-radius: 6px; text-align: center; border: 1px solid rgba(21, 101, 192, 0.3);"></div>

        <div class="nav-divider"></div>

        <!-- Navigation Section -->
        <div class="nav-section">
          <div class="nav-section-header">Navigation</div>

          <!-- View Mode: Triage (top-level) with nested sub-items -->
          <a class="nav-item nav-parent" data-page="triage" href="#/triage" onclick="_toggleTriageSubnav();">
            <span class="nav-icon">📋</span>
            <span class="nav-label">Triage</span>
            <span class="nav-expand-arrow" id="triage-expand-arrow">&#9656;</span>
          </a>
          <div class="nav-subitems" id="triage-subnav">
            <a class="nav-item nav-subitem nav-subparent" data-page="grid" href="#/grid" onclick="gridState.sheet = null;">
              <span class="nav-icon">📊</span>
              <span class="nav-label">All Data Grid</span>
              <span class="nav-expand-arrow" id="grid-expand-arrow">&#9656;</span>
            </a>
            <div class="nav-subitems nav-level3" id="grid-sections-nav">
              <a class="nav-section-link" data-section="accounts" href="#" onclick="_selectGridSection('Accounts'); return false;">Accounts</a>
              <a class="nav-section-link" data-section="catalog" href="#" onclick="_selectGridSection('Catalog'); return false;">Catalog</a>
              <a class="nav-section-link" data-section="contacts" href="#" onclick="_selectGridSection('Contacts'); return false;">Contacts</a>
              <a class="nav-section-link" data-section="financials" href="#" onclick="_selectGridSection('Financials'); return false;">Financials</a>
              <a class="nav-section-link" data-section="opportunities" href="#" onclick="_selectGridSection('Opportunities'); return false;">Opportunities</a>
              <a class="nav-section-link" data-section="schedule" href="#" onclick="_selectGridSection('Schedule'); return false;">Schedule</a>
              <a class="nav-section-link" data-section="schedule_catalog" href="#" onclick="_selectGridSection('Schedule Catalog'); return false;">Schedule Catalog</a>
              <a class="nav-section-link" data-section="v2_add_ons" href="#" onclick="_selectGridSection('V2 Add Ons'); return false;">V2 Add Ons</a>
            </div>
            <a class="nav-item nav-subitem" id="nav-record-inspection" href="#" onclick="openRecordInspectionFromNav(); return false;">
              <span class="nav-icon">🔎</span>
              <span class="nav-label">Record Inspection</span>
            </a>
          </div>
          <a class="nav-item verifier-only" data-page="verifier-review" href="#/verifier-review">
            <span class="nav-icon">✓</span>
            <span class="nav-label">Verifier Review</span>
          </a>
        </div>

        <div class="nav-divider"></div>

        <!-- Tools Section -->
        <div class="nav-section">
          <div class="nav-section-header">Tools</div>
          <a class="nav-item analyst-only" data-page="patch" href="#/patch">
            <span class="nav-icon">✎</span>
            <span class="nav-label">Patch Studio</span>
          </a>
          <a class="nav-item verifier-only" data-page="review" href="#/review">
            <span class="nav-icon">🔍</span>
            <span class="nav-label">Config Inspector</span>
          </a>
          <a class="nav-item admin-only" data-page="admin-approval" href="#/admin-approval">
            <span class="nav-icon">✓✓</span>
            <span class="nav-label">Admin Approval</span>
          </a>
          <a class="nav-item admin-only" data-page="admin" href="#/admin">
            <span class="nav-icon">⚙</span>
            <span class="nav-label">Admin Panel</span>
          </a>
          <a class="nav-item admin-only" id="nav-config-flows" href="#" onclick="openConfigFlows(); return false;">
            <span class="nav-icon">🔧</span>
            <span class="nav-label">Config Flows</span>
          </a>
        </div>

      </div>
      <!-- Sidebar Footer (anchored to bottom) -->
      <div class="nav-footer">
        <div class="nav-divider"></div>
        <!-- Cache Section (v1.4.13) -->
        <div class="nav-section">
          <div class="nav-section-header">PDF Cache</div>
          <div class="cache-info" style="padding: 4px 20px; font-size: 0.8em; color: #888;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Cached PDFs</span>
              <span id="cache-pdf-count">0</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Storage used</span>
              <span id="cache-storage-used">0 B</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9em; color: #aaa;">
              <span>Max capacity</span>
              <span>250 MB</span>
            </div>
            <button class="cache-clear-btn" onclick="clearCachedPDFs()">Clear All Cached PDFs</button>
          </div>
        </div>
        <!-- Export / Save -->
        <div class="nav-section" style="padding: 12px 16px;">
          <button class="nav-action-btn export-btn" onclick="handleExportSave()">
            <span class="nav-action-icon">💾</span>
            <span>Export / Save</span>
          </button>
        </div>
      </div>
      <div class="nav-mode-section">
        <div class="nav-mode-label">Role</div>
        <div class="mode-toggle" id="mode-toggle-container">
          <button class="mode-btn mode-analyst active" data-mode="analyst">Analyst</button>
          <button class="mode-btn mode-verifier" data-mode="verifier">Verifier</button>
          <button class="mode-btn mode-admin" data-mode="admin">Admin</button>
        </div>
        <div id="locked-role-display" style="display: none; padding: 6px 12px; font-size: 0.75em; background: rgba(21, 101, 192, 0.15); color: #64b5f6; border-radius: 4px; text-align: center;"></div>
      </div>
      
      <!-- User Profile -->
      <div id="sidebar-user-profile" style="padding: 10px 16px; border-top: 1px solid #2d2d4a; display: flex; align-items: center; gap: 10px;">
        <div id="sidebar-user-avatar" style="width: 32px; height: 32px; border-radius: 50%; background: #1565c0; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.85em; flex-shrink: 0;"></div>
        <div style="flex: 1; min-width: 0;">
          <div id="sidebar-user-name" style="font-size: 0.82em; font-weight: 600; color: #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
          <div id="sidebar-user-role" style="font-size: 0.7em; color: #888; text-transform: capitalize;"></div>
        </div>
        <a href="#" id="sign-out-link" onclick="handleSignOut(event)" title="Sign Out" style="color: #666; font-size: 1em; text-decoration: none; flex-shrink: 0; transition: color 0.2s;">
          <span>←</span>
        </a>
      </div>
      
    </nav>

    <main class="main-content">
      
      <!-- Empty Queue Message (visible when no data loaded) -->
      <div class="empty-queue-message" id="empty-queue-message">
        <div class="empty-queue-icon">📋</div>
        <h3>No records loaded yet</h3>
        <p>Import a dataset to start working.</p>
        <button class="empty-queue-cta" id="empty-queue-load" onclick="openDataSourcePanel()">Add Data Source</button>
      </div>
      
      <!-- Loader Page (DEPRECATED - v1.2.9 uses drawer instead) -->
      <div class="page-content" id="page-loader" style="display: none !important;">
        <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">

          <!-- PRIMARY ACTION PANEL: Continue to Triage (shown when dataset active) -->
          <div id="loader-continue-panel" style="display: none; background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%); border-radius: 12px; padding: 30px; margin-bottom: 30px; color: white; text-align: center;">
            <div style="font-size: 2em; margin-bottom: 10px;">✅</div>
            <h2 style="margin: 0 0 8px 0; font-size: 1.4em; color: white;">Dataset Ready</h2>
            <div id="loader-active-dataset-info" style="font-size: 0.9em; opacity: 0.9; margin-bottom: 20px;"></div>
            <button id="btn-continue-triage" class="empty-queue-cta" style="background: white; color: #1976d2; font-size: 1.1em; padding: 14px 28px; border-radius: 8px;">Continue to Triage</button>
            <div style="margin-top: 15px;">
              <button id="btn-copy-bundle-primary" class="top-toolbar-btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);" onclick="copyBundleJSON()">Copy Bundle JSON</button>
            </div>
          </div>
          <!-- PRIMARY ACTION PANEL: Import CSV (shown when no dataset) -->
          <div id="loader-import-panel" style="display: none; background: linear-gradient(135deg, #455a64 0%, #37474f 100%); border-radius: 12px; padding: 30px; margin-bottom: 20px; color: white; text-align: center;">
            <div style="font-size: 2em; margin-bottom: 10px;">📄</div>
            <h2 style="margin: 0 0 8px 0; font-size: 1.4em; color: white;">Load a File</h2>
            <p style="font-size: 0.95em; opacity: 0.9; margin: 0 0 20px 0;">Import a CSV file to start working with your data.</p>
            <input type="file" id="file-import-csv-primary" accept=".csv" style="display: none;">
            <button id="btn-import-csv-primary" class="empty-queue-cta" style="background: white; color: #37474f; font-size: 1.1em; padding: 14px 28px; border-radius: 8px;">Import CSV</button>
          </div>
          <!-- SECONDARY ACTION: Load Sample Dataset (hidden v1.4.23 - folder-based workflow) -->
          <div id="loader-sample-panel" style="display: none !important;"></div>
          <!-- COLLAPSIBLE: Other Actions -->
          <div id="loader-other-actions" style="background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden;">
            <button id="loader-toggle-actions" style="width: 100%; padding: 14px 20px; background: none; border: none; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.95em; color: #333;">
              <span style="font-weight: 600;">Other Actions</span>
              <span id="loader-toggle-icon" style="font-size: 0.8em;">&#9660;</span>
            </button>
            <div id="loader-actions-content" style="display: none; padding: 0 20px 20px 20px;">
              <div style="display: grid; gap: 12px;">
                <!-- Sample dataset hidden (v1.4.23 - folder-based workflow) -->
                
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 1px solid #e0e0e0; border-radius: 6px;">
                  <span>📄</span>
                  <div style="flex: 1;">
                    <div style="font-weight: 600; font-size: 0.9em;">Import CSV</div>
                    <div style="font-size: 0.8em; color: #666;">Create dataset from CSV file</div>
                  </div>
                  <input type="file" id="file-import-csv" accept=".csv" style="display: none;">
                  <button id="btn-import-csv" class="top-toolbar-btn" style="padding: 8px 16px;">Choose...</button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 1px solid #e0e0e0; border-radius: 6px;">
                  <span>📎</span>
                  <div style="flex: 1;">
                    <div style="font-weight: 600; font-size: 0.9em;">Attach PDF</div>
                    <div style="font-size: 0.8em; color: #666;">Add artifact reference</div>
                  </div>
                  <input type="file" id="file-attach-pdf" accept=".pdf" style="display: none;">
                  <button id="btn-attach-pdf" class="top-toolbar-btn" style="padding: 8px 16px;">Attach...</button>
                </div>
                <div id="pdf-attachments-list" style="font-size: 0.85em; color: #666; padding-left: 30px;"></div>
              </div>
              
              <div class="admin-only-content" style="border-top: 1px solid #e0e0e0; margin-top: 15px; padding-top: 15px;">
                <div style="font-weight: 600; font-size: 0.85em; color: #666; margin-bottom: 10px;">Test Utilities</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                  <button class="top-toolbar-btn" id="btn-reset-demo-state" style="font-size: 0.85em;">Reset Demo State</button>
                  <button class="top-toolbar-btn" id="btn-rebuild-field-index" style="font-size: 0.85em;">Rebuild Field Index</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>


      <!-- V2.2 P0: Full Audit Panel -->
      <div id="audit-full-panel" class="page" style="display: none;">
        <div style="padding: 20px 30px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="margin: 0;">Audit Log</h2>
            <div style="display: flex; gap: 8px;">
              <button onclick="exportAuditLogOnly()" style="padding: 6px 16px; font-size: 0.85em; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">Export Audit Log</button>
              <button onclick="closeFullAuditPanel()" style="padding: 6px 16px; font-size: 0.85em; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">Close</button>
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-bottom: 16px; flex-wrap: wrap; align-items: center;">
            <select id="audit-full-filter-scope" onchange="refreshFullAuditPanel()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em;">
              <option value="">All Scopes</option>
              <option value="batch">Batch</option>
              <option value="contract">Contract</option>
              <option value="document">Document</option>
              <option value="row">Row</option>
            </select>
            <select id="audit-full-filter-type" onchange="refreshFullAuditPanel()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em;">
              <option value="">All Types</option>
              <option value="patch">Patch</option>
              <option value="schema_change">Schema Change</option>
              <option value="system_change">System Change</option>
              <option value="rollback">Undo / Rollback</option>
              <option value="session">Session</option>
            </select>
            <select id="audit-full-filter-role" onchange="refreshFullAuditPanel()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em;">
              <option value="">All Roles</option>
              <option value="analyst">Analyst</option>
              <option value="verifier">Verifier</option>
              <option value="admin">Admin</option>
            </select>
            <input id="audit-full-search" placeholder="Search events..." oninput="refreshFullAuditPanel()" style="padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em; width: 180px;">
            <button onclick="saveCurrentAuditFilter()" style="padding: 5px 10px; font-size: 0.8em; background: #e8eaf6; border: 1px solid #c5cae9; border-radius: 4px; cursor: pointer;" title="Save current filter as preset">Save Filter</button>
            <span id="audit-full-count" style="font-size: 0.8em; color: #888;"></span>
          </div>
          <div style="display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; align-items:center;">
            <span style="font-size:0.78em; color:#888;">Quick:</span>
            <button onclick="applyAuditQuickChip('system_change')" class="audit-chip-btn" style="padding:2px 10px; font-size:0.78em; background:#fff3e0; border:1px solid #ffe082; border-radius:12px; cursor:pointer;">System Changes</button>
            <button onclick="applyAuditQuickChip('rollback')" class="audit-chip-btn" style="padding:2px 10px; font-size:0.78em; background:#fce4ec; border:1px solid #f8bbd0; border-radius:12px; cursor:pointer;">Undo / Rollback</button>
            <button onclick="applyAuditQuickChip('schema_change')" class="audit-chip-btn" style="padding:2px 10px; font-size:0.78em; background:#e8f5e9; border:1px solid #c8e6c9; border-radius:12px; cursor:pointer;">Schema Changes</button>
            <button onclick="applyAuditQuickChip('session')" class="audit-chip-btn" style="padding:2px 10px; font-size:0.78em; background:#e3f2fd; border:1px solid #bbdefb; border-radius:12px; cursor:pointer;">Session</button>
            <button onclick="applyAuditQuickChip('')" class="audit-chip-btn" style="padding:2px 10px; font-size:0.78em; background:#f5f5f5; border:1px solid #e0e0e0; border-radius:12px; cursor:pointer;">All</button>
          </div>
          <div id="audit-filter-presets" style="margin-bottom:10px;"></div>
          <div id="audit-full-body" style="border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.82em;">
              <thead style="background: #f5f5f5;">
                <tr>
                  <th style="padding: 8px 10px; text-align: left; border-bottom: 1px solid #e0e0e0;">Timestamp</th>
                  <th style="padding: 8px 10px; text-align: left; border-bottom: 1px solid #e0e0e0;">Event</th>
                  <th style="padding: 8px 10px; text-align: left; border-bottom: 1px solid #e0e0e0;">Scope</th>
                  <th style="padding: 8px 10px; text-align: left; border-bottom: 1px solid #e0e0e0;">Actor</th>
                  <th style="padding: 8px 10px; text-align: left; border-bottom: 1px solid #e0e0e0;">Details</th>
                </tr>
              </thead>
              <tbody id="audit-full-table-body">
                <tr><td colspan="5" style="padding: 20px; text-align: center; color: #999;">Loading...</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- ACCESS RESTRICTED PAGE (v1.4.22) -->
      <div class="page" id="page-restricted" style="display: none;">
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 60vh; text-align: center;">
          <div style="font-size: 64px; margin-bottom: 20px;">🔒</div>
          <h2 style="margin: 0 0 10px; color: #333;">Access Restricted</h2>
          <p style="color: #666; margin-bottom: 24px; max-width: 400px;" id="restricted-message">You don't have permission to view this page with your current role.</p>
          <div style="display: flex; gap: 12px;">
            <button onclick="navigateToRoleDefault()" class="toolbar-btn" style="padding: 10px 24px;">Go to My Dashboard</button>
            <button onclick="window.location.href='/ui/landing/'" class="toolbar-btn" style="padding: 10px 24px; background: #f5f5f5; color: #333;">Switch Role</button>
          </div>
        </div>
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: LOADER | BUILD v1.6.49</div>
      </div>

      <!-- TRIAGE PAGE (default after data loaded) -->
      <div class="page" id="page-triage">
        <div id="analyst-triage-content">
          <div class="page-header" style="position: relative;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
              <h2 id="triage-page-title">Triage</h2>
              </div>
            <p class="page-desc">All items requiring analyst review and action.</p>

            <!-- Sticky Search Bar (top right) - repositioned to avoid audit overlap (P0.1) -->
            <div id="triage-search-bar" style="position: fixed; top: 56px; right: 24px; z-index: 100; display: flex; align-items: center; gap: 6px; background: rgba(255, 255, 255, 0.92); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 12px rgba(0,0,0,0.08); transition: opacity 0.2s ease, transform 0.2s ease;">
              <!-- v1.6.33: Upload Excel button (failsafe for data import) -->
              <button id="btn-rerun-preflight" onclick="rerunPreFlight()" class="triage-icon-btn"
                      style="background: linear-gradient(135deg, #e65100 0%, #bf360c 100%); color: white;"
                      title="Rerun Pre-Flight">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="23 4 23 10 17 10"/>
                  <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                </svg>
                <span class="btn-label">Rerun</span>
              </button>
              <button id="upload-excel-btn" onclick="document.getElementById('excel-file-import').click()" class="triage-icon-btn"
                      style="background: linear-gradient(135deg, #1a73e8 0%, #0d47a1 100%); color: white;"
                      title="Upload Excel">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                <span class="btn-label">Upload</span>
              </button>
              <div id="audit-header-dropdown-container" style="position: relative; display: inline-flex;">
                <button onclick="toggleAuditHeaderDropdown()" id="btn-audit-header" class="triage-icon-btn" title="Audit Log"
                        style="background: #f5f5f5; border: 1px solid #e0e0e0; color: #555; max-width: 52px;"
                        onmouseover="this.style.maxWidth='140px'" onmouseout="this.style.maxWidth='52px'">
                  <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
                  <span id="audit-header-badge" style="background: #e3f2fd; color: #1565c0; padding: 1px 5px; border-radius: 10px; font-size: 0.85em; min-width: 14px; text-align: center; flex-shrink: 0;">0</span>
                  <span class="btn-label">Audit</span>
                </button>
                <div id="audit-header-dropdown" style="display: none; position: absolute; right: 0; top: 32px; width: 380px; max-height: 420px; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.12); z-index: 1000; overflow: hidden;">
                  <div style="padding: 12px 16px; background: #fafafa; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-weight: 600; font-size: 0.9em;">Recent Audit Events</span>
                    <button onclick="openFullAuditPanel()" style="padding: 2px 10px; font-size: 0.8em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">See All</button>
                  </div>
                  <div id="audit-header-list" style="max-height: 340px; overflow-y: auto; padding: 4px 0;"></div>
                </div>
              </div>
              <input type="file" id="excel-file-import" accept=".xlsx,.xls" style="display: none;" onchange="handleExcelUpload(this)">
              <input type="text" id="global-search-input" placeholder="Search records…" 
                     style="padding: 5px 8px; border: none; background: transparent; border-radius: 4px; font-size: 0.8em; width: 160px; color: #444; outline: none;" 
                     onkeydown="handleGlobalSearchKeydown(event)">
              <span style="font-size: 0.6em; color: #999; padding: 2px 5px; background: rgba(0,0,0,0.06); border-radius: 3px;">⌘K</span>
            </div>
          </div>

          <div id="triage-merged-batch-indicator" style="display: none; margin-bottom: 16px; padding: 10px 14px; background: #e3f2fd; border-radius: 8px; border-left: 3px solid #1976d2; font-size: 0.85em;">
            <strong>Viewing merged batch:</strong> <span id="triage-merged-batch-label"></span>
            <span style="color: #888; margin-left: 8px;" id="triage-merged-batch-stats"></span>
            <button onclick="handleMergedBatchFilterChange('')" style="margin-left: 12px; padding: 2px 8px; background: white; border: 1px solid #bbdefb; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Clear</button>
          </div>
          <!-- V2.3: Triage Analytics Header -->
          <!-- P0.6: Truth Pack Calibration Panel (Architect-only) -->
          <div id="truth-pack-calibration-panel" style="display: none; margin-bottom: 16px;"></div>

          <div id="triage-analytics-header" style="margin-bottom: 24px; display: none;">
            <!-- P1: Processing Status Banner -->
            <div id="ta-processing-banner" style="display: none; padding: 8px 16px; background: #e8f5e9; border: 1px solid #c8e6c9; border-radius: 8px; margin-bottom: 12px; font-size: 0.82em;">
              <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                <span id="ta-proc-icon" style="font-size: 1.1em;">&#9679;</span>
                <span id="ta-proc-text" style="font-weight: 600; color: #333;">Up to date</span>
                <span id="ta-proc-detail" style="color: #666;"></span>
                <span id="ta-proc-stage" style="color: #888; font-size: 0.9em;"></span>
                <span id="ta-proc-time" style="color: #999; font-size: 0.85em; margin-left: auto;"></span>
                <span id="ta-proc-throughput" style="display: none; color: #1565c0; font-size: 0.85em; font-weight: 600;"></span>
                <span id="ta-proc-stale" style="display: none; padding: 2px 8px; border-radius: 6px; background: #fff3e0; color: #e65100; font-size: 0.8em; font-weight: 600;">&#9888; Stale</span>
              </div>
            </div>
            <!-- 1) Batch Summary -->
            <div id="ta-batch-summary" style="display: flex; gap: 20px; align-items: center; padding: 12px 16px; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 10px; margin-bottom: 16px; flex-wrap: wrap;">
              <div style="text-align: center; min-width: 60px;">
                <div style="font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600;">Contracts</div>
                <div id="ta-bs-contracts" style="font-size: 1.3em; font-weight: 700; color: #1565c0;">0</div>
              </div>
              <div style="width: 1px; height: 28px; background: #ddd;"></div>
              <div style="text-align: center; min-width: 60px;">
                <div style="font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600;">Records</div>
                <div id="ta-bs-records" style="font-size: 1.3em; font-weight: 700; color: #333;">0</div>
              </div>
              <div style="width: 1px; height: 28px; background: #ddd;"></div>
              <div style="text-align: center; min-width: 60px;">
                <div style="font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600;">Completed</div>
                <div id="ta-bs-completed" style="font-size: 1.3em; font-weight: 700; color: #2e7d32;">0</div>
              </div>
              <div style="text-align: center; min-width: 60px;">
                <div style="font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600;">Needs Review</div>
                <div id="ta-bs-review" style="font-size: 1.3em; font-weight: 700; color: #e65100;">0</div>
              </div>
              <div style="text-align: center; min-width: 60px;">
                <div style="font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600;">Pending</div>
                <div id="ta-bs-pending" style="font-size: 1.3em; font-weight: 700; color: #555;">0</div>
              </div>
              <div style="width: 1px; height: 28px; background: #ddd;"></div>
              <div style="text-align: center; min-width: 80px;">
                <div style="font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600;">Updated</div>
                <div id="ta-bs-updated" style="font-size: 0.8em; color: #999;">--</div>
              </div>
              <div id="ta-bs-unassigned" style="display: none;">
                <span style="padding: 2px 10px; border-radius: 8px; background: #fff3e0; color: #e65100; font-size: 0.75em; cursor: help;" title="Rows without a contract assignment. Excluded from lifecycle tracking by policy.">&#9888; <span id="ta-bs-unassigned-count">0</span> Unassigned rows</span>
              </div>
              <div id="ta-reconcile-warn" style="display: none;">
                <span style="padding: 2px 10px; border-radius: 8px; background: #ffebee; color: #c62828; font-size: 0.75em; cursor: help;" title="Contract count mismatch detected. See console for details.">&#9888; Count mismatch</span>
              </div>
            </div>
            <!-- 2) Contract Summary -->
            <!-- C) Contract Summary Table (collapsible) -->
            <div id="ta-contract-section" style="margin-bottom: 20px; background: #fff; border: 1px solid #e0e0e0; border-radius: 10px; overflow: hidden;">
              <div onclick="TriageAnalytics.toggleContractTable()" style="display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid #eee; cursor: pointer; user-select: none;" title="Click to expand/collapse">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span id="ta-contract-toggle" style="font-size: 0.7em; color: #999; transition: transform 0.2s;">&#9654;</span>
                  <h4 style="margin: 0; font-size: 0.9em; color: #333;">Contract Summary</h4>
                  <span id="ta-contract-filter-badge" style="display: none; font-size: 0.7em; padding: 1px 8px; border-radius: 10px; background: #e3f2fd; color: #1565c0; font-weight: 600;"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span id="ta-contract-count" style="font-size: 0.8em; color: #666;">0 contracts</span>
                  <span id="ta-contract-summary-chips" style="display: flex; gap: 6px; font-size: 0.72em;"></span>
                  <button id="ta-contract-view-grid" onclick="event.stopPropagation(); TriageAnalytics.viewFilteredInGrid();" style="display: none; font-size: 0.7em; padding: 2px 10px; border-radius: 10px; border: 1px solid #1976d2; background: #e3f2fd; color: #1565c0; cursor: pointer; font-weight: 600;">View in Grid</button>
                </div>
              </div>
              <div id="ta-health-filter-bar" style="display: none; padding: 6px 16px; background: #fafafa; border-bottom: 1px solid #eee; gap: 8px; flex-wrap: wrap; align-items: center;">
                <span style="font-size: 0.75em; color: #888; font-weight: 600;">Health:</span>
                <span class="health-filter-chip" data-health-band="critical" onclick="ContractHealthScore.filterByBand('critical')" style="padding: 2px 10px; border-radius: 10px; font-size: 0.72em; font-weight: 600; cursor: pointer; background: #ffebee; color: #c62828; border: 1px solid transparent;">Critical <span id="health-chip-critical-count">0</span></span>
                <span class="health-filter-chip" data-health-band="at_risk" onclick="ContractHealthScore.filterByBand('at_risk')" style="padding: 2px 10px; border-radius: 10px; font-size: 0.72em; font-weight: 600; cursor: pointer; background: #fff3e0; color: #e65100; border: 1px solid transparent;">At Risk <span id="health-chip-at-risk-count">0</span></span>
                <span class="health-filter-chip" data-health-band="watch" onclick="ContractHealthScore.filterByBand('watch')" style="padding: 2px 10px; border-radius: 10px; font-size: 0.72em; font-weight: 600; cursor: pointer; background: #fffde7; color: #f9a825; border: 1px solid transparent;">Watch <span id="health-chip-watch-count">0</span></span>
                <span class="health-filter-chip" data-health-band="healthy" onclick="ContractHealthScore.filterByBand('healthy')" style="padding: 2px 10px; border-radius: 10px; font-size: 0.72em; font-weight: 600; cursor: pointer; background: #e8f5e9; color: #2e7d32; border: 1px solid transparent;">Healthy <span id="health-chip-healthy-count">0</span></span>
                <span class="health-filter-chip" data-health-band="all" onclick="ContractHealthScore.filterByBand('all')" style="padding: 2px 10px; border-radius: 10px; font-size: 0.72em; font-weight: 600; cursor: pointer; background: #e3f2fd; color: #1565c0; border: 2px solid #1565c0;">All</span>
              </div>
              <div id="ta-contract-body" style="max-height: 280px; overflow-y: auto; display: none;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.82em;">
                  <thead style="background: #fafafa; position: sticky; top: 0;">
                    <tr>
                      <th style="padding: 8px 12px; text-align: left; font-weight: 600; color: #555;">Contract</th>
                      <th style="padding: 8px 12px; text-align: left; font-weight: 600; color: #555;">Doc Role</th>
                      <th style="padding: 8px 12px; text-align: center; font-weight: 600; color: #555;">Stage</th>
                      <th style="padding: 8px 12px; text-align: center; font-weight: 600; color: #f44336;">Pre-Flight</th>
                      <th style="padding: 8px 12px; text-align: center; font-weight: 600; color: #ff9800;">Semantic</th>
                      <th style="padding: 8px 12px; text-align: center; font-weight: 600; color: #1976d2;">Patches</th>
                      <th style="padding: 8px 12px; text-align: right; font-weight: 600; color: #555;">Rows</th>
                      <th style="padding: 8px 12px; text-align: center; font-weight: 600; color: #555;">Health</th>
                    </tr>
                  </thead>
                  <tbody id="ta-contract-tbody">
                    <tr><td colspan="8" style="padding: 20px; text-align: center; color: #999;">No contracts indexed</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- 3) Lane Health -->
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 20px;">
              <div class="ta-lane-card" onclick="TriageAnalytics.handleLaneClick('preflight')" style="background: #fff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 14px 16px; cursor: pointer; transition: box-shadow 0.2s; border-top: 3px solid #f44336;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <h4 style="margin: 0; font-size: 0.85em; font-weight: 600; color: #333; letter-spacing: 0.01em;">Pre-Flight</h4>
                  <span id="ta-preflight-total" style="background: #ffebee; color: #c62828; padding: 2px 10px; border-radius: 12px; font-size: 0.8em; font-weight: 600;">0</span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px 16px; font-size: 0.78em; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #f0f0f0;">
                  <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="color: #888; font-size: 0.92em;">Affected Contracts</span><span id="ta-pf-affected" style="font-weight: 700; color: #c62828; font-size: 1.05em;">0</span></div>
                  <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="color: #888; font-size: 0.92em;">Records Impacted</span><span id="ta-pf-impacted" style="font-weight: 700; color: #c62828; font-size: 1.05em;">0</span></div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px 16px; font-size: 0.78em;">
                  <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="color: #999;">Unknown Columns</span><span id="ta-pf-unknown" style="font-weight: 600; color: #555;">0</span></div>
                  <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="color: #999;">OCR / Mojibake</span><span id="ta-pf-ocr" style="font-weight: 600; color: #555;">0</span></div>
                  <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="color: #999;">Low Confidence</span><span id="ta-pf-lowconf" style="font-weight: 600; color: #555;">0</span></div>
                  <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="color: #999;">Doc Type</span><span id="ta-pf-doctype" style="font-weight: 600; color: #555;">0</span></div>
                </div>
              </div>
              <div class="ta-lane-card" onclick="TriageAnalytics.handleLaneClick('semantic')" style="background: #fff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 16px; cursor: pointer; transition: box-shadow 0.2s; border-top: 3px solid #ff9800;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                  <h4 style="margin: 0; font-size: 0.9em; color: #333;">Semantic</h4>
                  <span id="ta-semantic-total" style="background: #fff3e0; color: #e65100; padding: 2px 10px; border-radius: 12px; font-size: 0.85em; font-weight: 600;">0</span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 0.8em;">
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Proposals</span><span id="ta-sem-proposals" style="font-weight: 600;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Accepted</span><span id="ta-sem-accepted" style="font-weight: 600; color: #2e7d32;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Rejected</span><span id="ta-sem-rejected" style="font-weight: 600; color: #c62828;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Pending</span><span id="ta-sem-pending" style="font-weight: 600; color: #e65100;">0</span></div>
                </div>
              </div>
              <div class="ta-lane-card" onclick="TriageAnalytics.handleLaneClick('patch')" style="background: #fff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 16px; cursor: pointer; transition: box-shadow 0.2s; border-top: 3px solid #1976d2;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                  <h4 style="margin: 0; font-size: 0.9em; color: #333;">Patch Review</h4>
                  <span id="ta-patch-total" style="background: #e3f2fd; color: #1565c0; padding: 2px 10px; border-radius: 12px; font-size: 0.85em; font-weight: 600;">0</span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 0.8em;">
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Draft</span><span id="ta-pr-draft" style="font-weight: 600;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Submitted</span><span id="ta-pr-submitted" style="font-weight: 600;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">At Verifier</span><span id="ta-pr-verifier" style="font-weight: 600;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Admin</span><span id="ta-pr-admin" style="font-weight: 600;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">RFIs</span><span id="ta-pr-rfi" style="font-weight: 600;">0</span></div>
                  <div style="display: flex; justify-content: space-between;"><span style="color: #666;">Promoted</span><span id="ta-pr-promoted" style="font-weight: 600; color: #2e7d32;">0</span></div>
                </div>
              </div>
            </div>
            <!-- 4) Lifecycle Progression -->
            <div style="margin-bottom: 20px; background: #fff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 16px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <h4 style="margin: 0; font-size: 0.9em; color: #333;">Lifecycle Progression</h4>
                <span style="font-size: 0.75em; color: #999;" id="ta-lifecycle-updated"></span>
              </div>
              <div id="ta-lifecycle-stages" style="display: flex; gap: 2px; align-items: stretch; overflow-x: auto;"></div>
            </div>
            <!-- 5) Schema Snapshot -->
            <div style="margin-bottom: 20px; background: #fff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 16px;">
              <h4 style="margin: 0 0 12px; font-size: 0.9em; color: #333;">Schema Snapshot</h4>
              <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                <div onclick="TriageAnalytics.handleSchemaClick('matched')" style="text-align: center; padding: 10px; background: #f5f5f5; border-radius: 8px; cursor: pointer; transition: box-shadow 0.2s;" title="How many uploaded column headers match the canonical glossary. Higher is better." onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.12)'" onmouseout="this.style.boxShadow=''">
                  <div id="ta-schema-matched-pct" style="font-size: 1.4em; font-weight: 700; color: #2e7d32;">--</div>
                  <div style="font-size: 0.75em; color: #666;">Columns Mapped</div>
                  <div id="ta-schema-matched-count" style="font-size: 0.7em; color: #999;">0 / 0</div>
                  <div id="ta-schema-matched-subtext" style="font-size: 0.6em; color: #aaa;"></div>
                  <div id="ta-schema-matched-scope" style="font-size: 0.65em; color: #aaa;"></div>
                  <div id="ta-schema-glossary-secondary" style="font-size: 0.6em; color: #bbb;"></div>
                </div>
                <div onclick="TriageAnalytics.handleSchemaClick('unknown')" style="text-align: center; padding: 10px; background: #fff3e0; border-radius: 8px; cursor: pointer; transition: box-shadow 0.2s;" title="Columns in this upload that do not match glossary fields or aliases. Review and classify each before promotion." onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.12)'" onmouseout="this.style.boxShadow=''">
                  <div id="ta-schema-unknown" style="font-size: 1.4em; font-weight: 700; color: #e65100;">0</div>
                  <div style="font-size: 0.75em; color: #666;">Unknown Columns</div>
                  <div style="font-size: 0.6em; color: #aaa;">Not in glossary</div>
                </div>
                <div onclick="TriageAnalytics.handleSchemaClick('missing')" style="text-align: center; padding: 10px; background: #ffebee; border-radius: 8px; cursor: pointer; transition: box-shadow 0.2s;" title="Required glossary fields that are either missing as headers or have blank/invalid values in the data. These need analyst attention." onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.12)'" onmouseout="this.style.boxShadow=''">
                  <div id="ta-schema-missing" style="font-size: 1.4em; font-weight: 700; color: #c62828;">0</div>
                  <div style="font-size: 0.75em; color: #666;">Missing Required</div>
                  <div id="ta-schema-missing-split" style="font-size: 0.6em; color: #aaa;"></div>
                  <div style="font-size: 0.55em; color: #bbb;">Required fields needing analyst action</div>
                </div>
                <div onclick="TriageAnalytics.handleSchemaClick('drift')" style="text-align: center; padding: 10px; background: #f5f5f5; border-radius: 8px; cursor: pointer; transition: box-shadow 0.2s;" title="Structural schema issues only: columns not in the glossary plus required headers missing entirely. Missing values are tracked separately." onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.12)'" onmouseout="this.style.boxShadow=''">
                  <div id="ta-schema-drift" style="font-size: 1.4em; font-weight: 700; color: #555;">0</div>
                  <div style="font-size: 0.75em; color: #666;">Schema Structure Issues</div>
                  <div id="ta-schema-drift-detail" style="font-size: 0.6em; color: #aaa;"></div>
                  <div style="font-size: 0.55em; color: #bbb;">Unknown columns + missing required headers (values excluded)</div>
                </div>
              </div>
            </div>
          </div>



          <!-- QUEUE 1: Pre-Flight -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; flex-wrap: wrap;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">Pre-Flight <span id="manual-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
              <div id="p1a-preflight-issue-filters" style="display: flex; gap: 6px; align-items: center; margin-left: 4px;"></div>
            </div>
            <div id="p1a-preflight-sheet-tabs" style="display: flex; gap: 4px; margin-bottom: 10px; flex-wrap: wrap; font-size: 0.82em;"></div>
            <div id="p1f1-live-intake-wrapper" style="display:none;">
              <div id="p1f1-summary-bar" class="p1f1-summary-bar"></div>
            </div>
            <div id="p1d-preflight-container" class="p1d-preflight-container">
              <div class="p1d-empty-state">No pre-flight items</div>
            </div>
          </div>

          <!-- QUEUE 2: System Pass -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">System Pass <span id="sflogic-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="sflogic-queue-list" style="background: #fffaf5;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No system pass items</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- System Pass Controls — folded into Semantic lane context (P0.1) -->
          <div id="system-pass-controls" style="margin-bottom: 12px; padding: 10px 14px; background: #fff8e1; border: 1px solid #ffe082; border-radius: 6px; font-size: 0.82em;">
            <div style="display: flex; align-items: center; justify-content: space-between;">
              <span style="color: #f57f17; font-weight: 600;">System Pass</span>
              <button onclick="rerunSystemPass()" id="btn-rerun-system-pass" class="toolbar-btn" style="padding: 4px 10px; font-size: 0.78em; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Re-run</button>
            </div>
            <div id="system-pass-reason-picker" style="display:none; margin-top:6px;">
              <label style="font-size:0.78em; color:#333;">Reason:</label>
              <select id="system-pass-reason" style="margin-left:4px; padding:2px 6px; font-size:0.78em; border:1px solid #ccc; border-radius:4px;">
                <option value="manual_rerun">Manual re-run</option>
                <option value="ocr_readable">OCR became readable</option>
                <option value="hinge_modified">Hinge field modified</option>
                <option value="extraction_regenerated">Extraction regenerated</option>
                <option value="schema_updated">Schema updated</option>
              </select>
              <button onclick="executeSystemPassRerun()" style="margin-left:4px; padding:2px 10px; font-size:0.78em; background:#4caf50; color:white; border:none; border-radius:4px; cursor:pointer;">Go</button>
              <button onclick="cancelSystemPassRerun()" style="margin-left:2px; padding:2px 8px; font-size:0.78em; background:#eee; border:1px solid #ccc; border-radius:4px; cursor:pointer;">Cancel</button>
            </div>
            <div id="system-pass-results" style="display:none; margin-top:8px;"></div>
          </div>

          <!-- QUEUE 3: Patch Queue -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">Patch Queue <span id="patch-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
              <button style="margin-left: auto; padding: 4px 10px; font-size: 0.75em; background: transparent; border: 1px solid #ddd; border-radius: 4px; color: #999; cursor: not-allowed;" disabled title="Filter coming soon">Filter</button>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="patch-queue-list" style="background: #f8fbff;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No patch requests yet</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- QUEUE 4: System Changes -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">System Changes <span id="system-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="system-queue-list" style="background: #fafafa;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No system changes</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div id="verifier-triage-content" style="display: none;">
          <div class="page-header">
            <h2 id="verifier-triage-title">Triage - Verifier</h2>
            <p class="page-desc">Review submitted RFIs, Corrections, and Blacklist requests.</p>
          </div>
          <!-- v1.5.2: Division + Status filter bar -->
          <div class="verifier-filter-bar" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px; padding: 12px 16px; background: #f8f9fa; border-radius: 8px; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 0.85em; color: #666; font-weight: 600;">Division:</label>
              <select id="verifier-filter-division" class="filter-select" style="min-width: 140px;" onchange="onVerifierFilterChange()">
                <option value="">All Divisions</option>
                <option value="__unassigned__">Unassigned</option>
              </select>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 0.85em; color: #666; font-weight: 600;">Status:</label>
              <select id="verifier-filter-status" class="filter-select" style="min-width: 140px;" onchange="onVerifierFilterChange()">
                <option value="">All Statuses</option>
                <option value="pending">Pending Review</option>
                <option value="needs_clarification">Needs Clarification</option>
                <option value="sent_to_admin">Sent to Admin</option>
                <option value="resolved">Resolved</option>
              </select>
            </div>
            <span id="verifier-filter-count" style="font-size: 0.85em; color: #666; margin-left: auto;"></span>
          </div>
          <!-- v1.5.3: Patch Type tabs (Corrections, Blacklist, RFI) -->
          <div class="patch-type-tabs" style="display: flex; gap: 8px; margin-bottom: 16px;">
            <div class="pt-tab active" data-ptype="" onclick="setVerifierPatchType('')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #e3f2fd; color: #1565c0; border: 1px solid #1565c0;">All Types <span id="pt-count-all">(0)</span></div>
            <div class="pt-tab" data-ptype="correction" onclick="setVerifierPatchType('correction')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #f5f5f5; color: #333; border: 1px solid #ddd;">Corrections <span id="pt-count-correction">(0)</span></div>
            <div class="pt-tab" data-ptype="blacklist" onclick="setVerifierPatchType('blacklist')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #f5f5f5; color: #333; border: 1px solid #ddd;">Blacklist <span id="pt-count-blacklist">(0)</span></div>
            <div class="pt-tab" data-ptype="rfi" onclick="setVerifierPatchType('rfi')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #f5f5f5; color: #333; border: 1px solid #ddd;">RFI <span id="pt-count-rfi">(0)</span></div>
          </div>
          <div class="verifier-tabs" style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 1px solid #ddd; padding-bottom: 10px;">
            <div class="v-tab active" data-vqueue="pending" onclick="setVerifierQueue('pending')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600; background: #f5f5f5;">Pending <span id="v-count-pending">(0)</span></div>
            <div class="v-tab" data-vqueue="needs_clarification" onclick="setVerifierQueue('needs_clarification')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600;">Clarification <span id="v-count-clarification">(0)</span></div>
            <div class="v-tab" data-vqueue="sent_to_admin" onclick="setVerifierQueue('sent_to_admin')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600;">To Admin <span id="v-count-admin">(0)</span></div>
            <div class="v-tab" data-vqueue="resolved" onclick="setVerifierQueue('resolved')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600;">Resolved <span id="v-count-resolved">(0)</span></div>
          </div>

          <div class="verifier-table-container" style="background: white; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
              <thead style="background: #f8f9fa; border-bottom: 1px solid #eee;">
                <tr>
                  <th style="padding: 12px;">Type</th>
                  <th style="padding: 12px;">Record</th>
                  <th style="padding: 12px;">Field</th>
                  <th style="padding: 12px;">Change / Value</th>
                  <th style="padding: 12px;">Comment</th>
                  <th style="padding: 12px;">Submitted</th>
                  <th style="padding: 12px;">Actions</th>
                </tr>
              </thead>
              <tbody id="verifier-queue-list">
                <tr><td colspan="7" style="padding: 40px; text-align: center; color: #999;">No payloads in this queue</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: TRIAGE | BUILD v1.6.49</div>
      </div><!-- end page-triage -->

      <!-- ALL-DATA GRID PAGE -->
      <div class="page" id="page-grid">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>All-Data Grid</h2>
          </div>
          <p class="page-desc">Dense spreadsheet view of all records with filtering and search.</p>
        </div>
        
        <!-- v1.5.2: Verifier-only filter bar (mirrors triage filters) -->
        <div id="verifier-grid-filter-bar" class="verifier-filter-bar" style="display: none; gap: 16px; align-items: center; margin-bottom: 16px; padding: 12px 16px; background: #fff3e0; border: 1px solid #ffcc80; border-radius: 8px; flex-wrap: wrap;">
          <span style="font-size: 0.85em; font-weight: 600; color: #e65100;">Read-Only Mode</span>
          <div style="display: flex; align-items: center; gap: 8px; margin-left: 16px;">
            <label style="font-size: 0.85em; color: #666; font-weight: 600;">Division:</label>
            <select id="verifier-grid-filter-division" class="filter-select" style="min-width: 140px;" onchange="onVerifierGridFilterChange()">
              <option value="">All Divisions</option>
            </select>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <label style="font-size: 0.85em; color: #666; font-weight: 600;">Status:</label>
            <select id="verifier-grid-filter-status" class="filter-select" style="min-width: 140px;" onchange="onVerifierGridFilterChange()">
              <option value="">All Statuses</option>
              <option value="pending">Pending Review</option>
              <option value="needs_clarification">Needs Clarification</option>
              <option value="sent_to_admin">Sent to Admin</option>
              <option value="resolved">Resolved</option>
            </select>
          </div>
          <span id="verifier-grid-filter-count" style="font-size: 0.85em; color: #666; margin-left: auto;"></span>
        </div>

        <!-- Grid Controls -->
        <div id="analyst-grid-controls" class="grid-controls" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px; flex-wrap: wrap;">
          <div id="contract-filter-group" style="display: none; align-items: center; gap: 8px;">
            <label style="font-size: 0.85em; color: #666;">Contract:</label>
            <select id="grid-contract-selector" class="filter-select" style="min-width: 180px; max-width: 280px;" onchange="handleContractFilterChange(this.value)">
              <option value="">All Contracts</option>
            </select>
            <button id="btn-view-contract" class="top-toolbar-btn" style="display:none; padding: 4px 10px; font-size: 0.8em;" onclick="openContractDetailDrawer()" title="View contract details">View Contract</button>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <label style="font-size: 0.85em; color: #666;">Contract Section:</label>
            <select id="grid-sheet-selector" class="filter-select" style="min-width: 160px;" onchange="handleGridSheetSelectorChange(this.value)">
              <option value="">All Records</option>
            </select>
          </div>
          <div id="merged-batch-filter-group" style="display: none; align-items: center; gap: 8px;">
            <label style="font-size: 0.85em; color: #666;">Batch:</label>
            <select id="grid-merged-batch-selector" class="filter-select" style="min-width: 180px; max-width: 280px;" onchange="handleMergedBatchFilterChange(this.value)">
              <option value="">Current Batch</option>
            </select>
          </div>
          <div style="flex: 1; min-width: 200px;">
            <input type="text" id="grid-search" class="filter-search" placeholder="Search all fields..." style="width: 100%;">
          </div>
          <div class="filter-chips" id="grid-status-chips" style="display: flex; gap: 6px; flex-wrap: wrap;">
            <span class="filter-chip active" data-filter="all" onclick="setGridFilter('all')">All</span>
            <span class="filter-chip status-ready" data-filter="ready" onclick="setGridFilter('ready')">Ready</span>
            <span class="filter-chip status-needs_review" data-filter="needs_review" onclick="setGridFilter('needs_review')">Needs Review</span>
            <span class="filter-chip status-blocked" data-filter="blocked" onclick="setGridFilter('blocked')">Blocked</span>
          </div>
          <div id="grid-status-legend" style="display: flex; gap: 12px; padding: 4px 0 8px 0; font-size: 0.75em; color: #666;">
            <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#2e7d32;margin-right:4px;vertical-align:middle;"></span>Ready</span>
            <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#f57c00;margin-right:4px;vertical-align:middle;"></span>Needs Review</span>
            <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#c62828;margin-right:4px;vertical-align:middle;"></span>Blocked</span>
            <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#1565c0;margin-right:4px;vertical-align:middle;"></span>Finalized</span>
          </div>
          <button class="top-toolbar-btn" id="grid-column-toggle" onclick="toggleColumnMenu()" title="Toggle columns" style="padding: 4px 8px; font-size: 0.8em; display: inline-flex; align-items: center; gap: 3px;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
              Cols</button>
        </div>

        <!-- Column Toggle Menu (hidden by default) -->
        <div id="grid-column-menu" style="display: none; position: fixed; top: 120px; right: 40px; background: white; border: 1px solid #ddd; border-radius: 8px; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; max-height: 300px; overflow-y: auto;">
          <div style="font-weight: 600; margin-bottom: 8px; color: #333;">Visible Columns</div>
          <div id="grid-column-checkboxes"></div>
        </div>

        <!-- Per-Sheet Mini Stats -->
        <div id="grid-sheet-stats" style="display: flex; gap: 16px; align-items: center; margin-bottom: 12px; padding: 10px 16px; background: #f8f9fa; border-radius: 6px; font-size: 0.85em; color: #555;">
          <span id="grid-stat-rows"><strong>Rows:</strong> <span class="stat-value">0</span></span>
          <span class="stat-divider" style="color: #ccc;">|</span>
          <span id="grid-stat-ready"><strong>Ready:</strong> <span class="stat-value" style="color: #2e7d32;">0</span></span>
          <span id="grid-stat-review"><strong>Needs Review:</strong> <span class="stat-value" style="color: #f57c00;">0</span></span>
          <span id="grid-stat-blocked"><strong>Blocked:</strong> <span class="stat-value" style="color: #c62828;">0</span></span>
          <span class="stat-divider admin-only-content" style="color: #ccc; display: none;">|</span>
          <span id="grid-stat-unknown" class="admin-only-content" style="display: none; cursor: pointer;" onclick="openLoaderDrawer()" title="Click to load data"><strong>Unknown Columns:</strong> <span class="stat-value" style="color: #7b1fa2;">0</span></span>
          <span class="stat-divider" id="contract-stat-divider" style="color: #ccc; display: none;">|</span>
          <span id="grid-stat-contracts" style="display: none;"><strong>Contracts:</strong> <span class="stat-value" style="color: #1565c0;">0</span></span>
        </div>
        
        <!-- v1.6.11: Change Map Legend (shown only for modified dataset) -->
        <div id="grid-change-legend" style="display: none; margin-bottom: 12px; padding: 8px 16px; background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.8em;">
          <span style="font-weight: 600; color: #333; margin-right: 12px;">Cell Colors:</span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #FFD6D6; border: 1px solid #e53935; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">Blacklist</span>
          </span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #FFE7B3; border: 1px solid #ff9800; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">RFI</span>
          </span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #CFE8FF; border: 1px solid #1976d2; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">Correction</span>
          </span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #EFEFEF; border: 1px solid #9e9e9e; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">System</span>
          </span>
          <span class="legend-item">
            <span style="display: inline-block; width: 14px; height: 14px; background: #DDF5DD; border: 1px solid #4caf50; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">Verified</span>
          </span>
        </div>

        <!-- Dense Grid Table -->
        
          <!-- P1C: Composite Grid Controls -->
          <div id="p1c-composite-controls" class="p1c-composite-controls" style="display: none;">
            <span style="font-size: 0.8em; color: #1565c0; font-weight: 600;">Composite View</span>
            <button onclick="_p1cExpandAll()">Expand All</button>
            <button onclick="_p1cCollapseAll()">Collapse All</button>
          </div>

        <div class="grid-table-container" style="overflow-x: auto; border: 1px solid #e0e0e0; border-radius: 8px;">
          <table class="grid-table" id="grid-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
            <thead id="grid-thead" style="position: sticky; top: 0; background: #f5f5f5; z-index: 10;">
              <tr id="grid-header-row"></tr>
            </thead>
            <tbody id="grid-tbody"></tbody>
          </table>
        </div>

        <!-- Grid Footer -->
        <div class="grid-footer" style="margin-top: 12px; display: flex; justify-content: space-between; align-items: center; color: #666; font-size: 0.85em;">
          <span id="grid-row-count">0 records</span>
          <span id="grid-filter-info"></span>
          <span style="font-size: 0.75em; color: #aaa;">PAGE: ALL-DATA-GRID | BUILD v1.6.49</span>
        </div>
      </div><!-- end page-grid -->

      <!-- RECORD INSPECTION PAGE -->
      <div class="page" id="page-row">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2 id="srr-page-title" style="font-size: 1.1em; margin: 0;">Record Inspection<span id="srr-title-record-name" style="font-weight: 400; color: #94a3b8; margin-left: 8px; font-size: 0.85em;"></span></h2>

          </div>
        </div>

        <!-- Top Bar: Identity, State Badge, Back Button -->
        <div class="srr-top-bar">
          <button class="srr-back-btn" onclick="srrBackToGrid()">← Back to Grid</button>
          <div style="display: flex; align-items: center; gap: 6px;">
            <span style="font-size: 0.75em; color: #aaa;">Doc Type:</span>
            <select id="srr-doc-type" onchange="srrSetDocumentType(this.value)" style="padding: 4px 8px; border-radius: 5px; border: 1px solid #c5cae9; font-size: 0.82em; background: #e8eaf6; color: #1a237e; font-weight: 600; cursor: pointer;">
              <option value="Unknown">Unknown</option>
            </select>
          </div>
          <div style="flex: 1;">
            <span style="font-size: 0.75em; color: #aaa; margin-right: 8px;">Record:</span>
            <span class="srr-identity" id="srr-record-id">—</span>
          </div>
          <div>
            <span style="font-size: 0.75em; color: #aaa; margin-right: 8px;">Review State:</span>
            <span class="srr-state-badge" id="srr-state-badge">—</span>
          </div>
          <div class="srr-nav-group">
            <button class="srr-nav-btn" id="srr-nav-prev" onclick="srrNavigatePrev()" disabled title="Previous record">← Prev</button>
            <span class="srr-nav-pos" id="srr-nav-pos">—</span>
            <button class="srr-nav-btn" id="srr-nav-next" onclick="srrNavigateNext()" disabled title="Next record">Next →</button>
          </div>
          <button class="srr-back-btn" onclick="showAuditLogForRecord()" title="View audit log for this record">Audit Log</button>
          <span id="srr-group-badge" style="display:none;"></span>
        </div>

        <!-- Three-Panel Layout -->
        <div class="srr-layout">
          <!-- Left Panel: Field Inspector with Search, Filters, Field Cards -->
          <div class="srr-panel srr-panel-left" style="display: flex; flex-direction: column;">
            <div class="srr-panel-header" style="align-items: center; gap: 6px; padding: 8px 12px;">
              <span id="srr-inspector-title" style="font-size: 0.95em;">Field Inspector</span>
              <div class="inspector-action-chips" id="inspector-action-chips" style="margin-left: auto;"></div>
              <button class="inspector-action-trigger" id="inspector-action-trigger" onclick="openBatchAddModal()" title="Add Catalog Item" style="display:none;">+</button>
            </div>
            <div style="display: flex; flex: 1; overflow: hidden;">
              <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0;">
            <div class="srr-left-tab-body active" id="srr-tab-editor" data-tab="editor">
              <div id="srr-context-bar" style="display:none; width:100%; padding: 4px 0; border-bottom: 1px solid #eee; margin-bottom: 2px;">
                <div style="display:flex; align-items:center; gap:4px; margin-bottom:3px;">
                  <button id="srr-ctx-contract" class="srr-ctx-btn active" onclick="srrSetContextMode('contract')">Contract</button>
                  <button id="srr-ctx-account" class="srr-ctx-btn" onclick="srrSetContextMode('account')">Account</button>
                  <span id="srr-account-count" style="font-size:0.75em; color:#888; margin-left:auto;"></span>
                </div>
                <div id="srr-account-selector-row" style="display:none;">
                  <select id="srr-account-select" onchange="srrSwitchAccount(this.value)" style="width:100%; font-size:0.85em; padding:3px 6px; border:1px solid #ccc; border-radius:4px;"></select>
                </div>
              </div>
              <span id="srr-field-count" style="font-weight: normal; color: #666; font-size: 0.8em;">0 fields</span>
              <div class="inspector-actions-menu" id="inspector-actions-menu" style="display:none;"></div>
            <!-- v1.4.18: Search input -->
            <div class="srr-search-bar">
              <input type="text" class="srr-search-input" id="srr-field-search" placeholder="Search fields..." oninput="srrFilterFields()">
            </div>
            <div class="srr-filter-bar" id="srr-filter-bar">
              <div class="srr-filter-chips" id="srr-filter-chips">
                <span class="srr-filter-chip active" data-filter="all" onclick="srrSetFilter('all')">All <span class="chip-count" id="srr-count-all"></span></span>
                <span class="srr-filter-chip" data-filter="todo" onclick="srrSetFilter('todo')">To Do <span class="chip-count" id="srr-count-todo"></span></span>
                <span class="srr-filter-chip" data-filter="verified" onclick="srrSetFilter('verified')">Verified <span class="chip-count" id="srr-count-verified"></span></span>
                <span class="srr-filter-chip" data-filter="rfi" onclick="srrSetFilter('rfi')">RFI <span class="chip-count" id="srr-count-rfi"></span></span>
                <span class="srr-filter-chip" data-filter="patched" onclick="srrSetFilter('patched')">Patched <span class="chip-count" id="srr-count-patched"></span></span>
              </div>
            </div>
            <!-- v1.6.15: Asterisk legend -->
            <div class="srr-field-legend" id="srr-field-legend">
              <span class="srr-legend-item"><span class="srr-legend-swatch" style="background:#ffebee;border-left:3px solid #d32f2f;"></span> Needs attention</span>
              <span class="srr-legend-item"><span class="srr-legend-swatch" style="background:#fff3e0;border-left:3px solid #e65100;"></span> Review suggested</span>
              <span class="srr-legend-item"><span class="srr-legend-swatch" style="background:#e8f5e9;border-left:3px solid #4caf50;"></span> Verified</span>
            </div>

            <div class="srr-panel-body" id="srr-field-list" style="padding: 0; flex: 1;">
              <div class="srr-empty-state">No fields loaded</div>
            </div>
            </div>
            <div class="srr-left-tab-body" id="srr-tab-patch" data-tab="patch">
              <div id="srr-patch-tab-content" style="padding: 12px; display: flex; flex-direction: column; flex: 1; overflow-y: auto;">
                <div class="srr-empty-state">Select a field and action to begin a patch.</div>
              </div>
            </div>
            <div class="srr-left-tab-body" id="srr-tab-glossary" data-tab="glossary">
              <div style="padding: 8px 12px;">
                <input type="text" class="srr-glossary-search" id="srr-glossary-search" placeholder="Search glossary..." oninput="srrFilterGlossary()">
              </div>
              <div id="srr-glossary-sheet-filter" style="padding: 4px 12px 8px; display: flex; gap: 4px; flex-wrap: wrap; border-bottom: 1px solid #eee;"></div>
              <div class="srr-glossary-list" id="srr-glossary-list" style="flex: 1; overflow-y: auto;">
                <div class="srr-glossary-empty">Loading glossary...</div>
              </div>
            </div>
              </div>
              <div class="srr-left-tabs" id="srr-left-tabs">
                <button class="srr-left-tab active" data-tab="editor" onclick="srrSwitchLeftTab('editor')" title="Editor">Edit</button>
                <button class="srr-left-tab" data-tab="patch" onclick="srrSwitchLeftTab('patch')" title="Patch Studio">Patch</button>
                <button class="srr-left-tab" data-tab="glossary" onclick="srrSwitchLeftTab('glossary')" title="Glossary">Info</button>
              </div>
            </div>
          </div>

          <!-- Center Panel: Document Viewer -->
          <div class="srr-panel srr-panel-center">
            <div class="srr-panel-header">
              <span>Document Viewer</span>
              <span id="srr-doc-page" style="font-weight: normal; color: #666; font-size: 0.85em;">Page 1 of 1</span>
            </div>
            <div class="srr-file-action-bar" id="srr-file-action-bar">
              <span class="file-action-name" id="srr-action-bar-filename" title="">No file loaded</span>
              <button class="file-action-btn" id="srr-edit-link-btn" onclick="srrToggleEditLink()" title="Edit file URL">✎ Edit Link</button>
              <a class="file-action-btn" id="srr-download-btn" href="#" target="_blank" title="Download file" style="text-decoration: none;">⬇ Download</a>
            </div>
            <div class="srr-file-action-bar" id="srr-edit-link-bar" style="display: none;">
              <input class="file-action-edit-input" id="srr-edit-link-input" type="text" placeholder="Enter file URL..." />
              <button class="file-action-btn primary" onclick="srrSaveEditLink()">Save</button>
              <button class="file-action-btn cancel" onclick="srrCancelEditLink()">Cancel</button>
            </div>
            <div class="srr-doc-viewer">
              <div class="srr-doc-controls" style="display: none;">
                <button class="srr-doc-btn" id="srr-prev-btn" onclick="srrPrevPage()" title="Previous page">← Prev</button>
                <span class="srr-page-indicator" id="srr-page-indicator" style="display:none;">Page 1</span>
                <button class="srr-doc-btn" id="srr-next-btn" onclick="srrNextPage()" title="Next page">Next →</button>
                <span class="srr-doc-spacer"></span>
                <button class="srr-doc-btn" id="srr-zoom-out" onclick="srrZoomOut()" title="Zoom out">−</button>
                <span class="srr-zoom-indicator" id="srr-zoom-indicator">125%</span>
                <button class="srr-doc-btn" id="srr-zoom-in" onclick="srrZoomIn()" title="Zoom in">+</button>
              </div>
              <div class="srr-doc-source" id="srr-doc-source" style="font-size: 0.75em; color: #666; padding: 4px 8px; background: #f5f5f5; border-bottom: 1px solid #e0e0e0; display: none;">
                <span id="srr-doc-source-type" style="font-weight: 500;"></span>
                <span id="srr-doc-source-name" style="margin-left: 6px; color: #888;"></span>
              </div>
              <div class="srr-doc-frame" id="srr-doc-frame">
                <!-- PDF anchor match navigation bar -->
                <div id="srr-pdf-match-bar" class="srr-pdf-match-bar">
                  <span class="match-field" id="match-bar-field"></span>
                  <span class="match-count" id="match-bar-count"></span>
                  <button class="match-nav-btn" id="match-bar-prev" onclick="pdfMatchNav(-1)" title="Previous match">◀</button>
                  <button class="match-nav-btn" id="match-bar-next" onclick="pdfMatchNav(1)" title="Next match">▶</button>
                  <span class="match-close" onclick="pdfMatchDismiss()" title="Close (Esc)">✕</span>
                </div>
                
                <div class="srr-doc-empty-state" id="srr-doc-empty">
                  <div style="font-size: 3em; margin-bottom: 10px;">📄</div>
                  <div style="font-weight: 500;">No document attached</div>
                  <div style="font-size: 0.85em; color: #999; margin-top: 8px;">Attach PDFs via Data Source panel to view here</div>
                </div>
                <!-- PDF Error Banner (v1.4.13) -->
                <div id="srr-pdf-error" style="display: none; padding: 16px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 8px; margin: 12px; color: #e65100;">
                  <div style="display: flex; align-items: flex-start; gap: 10px;">
                    <span style="font-size: 1.2em;">⚠️</span>
                    <div style="flex: 1;">
                      <div style="font-weight: 600; margin-bottom: 6px;" id="srr-pdf-error-title">PDF failed to render</div>
                      <div style="font-size: 0.9em; margin-bottom: 10px;" id="srr-pdf-error-msg">The document could not be displayed in the viewer.</div>
                      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <a id="srr-pdf-open-tab" href="#" target="_blank" style="color: #1565c0; text-decoration: underline; font-size: 0.9em;">Open in New Tab</a>
                        <button id="srr-pdf-use-local" onclick="srrSwitchToLocalAttachment()" style="display: none; padding: 4px 10px; font-size: 0.85em; background: #fff; border: 1px solid #ff9800; border-radius: 4px; cursor: pointer;">Use Local Attachment</button>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="srr-doc-container" id="srr-doc-container" style="display: none;">
                  <object id="srr-pdf-object" class="srr-pdf-object" type="application/pdf" data="about:blank">
                    <div class="srr-pdf-fallback" id="srr-pdf-fallback">
                      <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 2em; margin-bottom: 10px;">📄</div>
                        <div style="margin-bottom: 12px;">PDF viewer blocked by browser</div>
                        <a id="srr-pdf-open-tab" href="#" target="_blank" class="btn-primary" style="display: inline-block; padding: 8px 16px; background: #1565c0; color: white; text-decoration: none; border-radius: 4px;">Open in New Tab</a>
                      </div>
                    </div>
                  </object>
                </div>
              </div>
              <div class="srr-anchor-list" id="srr-anchor-list">
                <div style="font-size: 0.8em; font-weight: 600; color: #666; margin-bottom: 8px;">Evidence Anchors</div>
                <div class="srr-empty-state" style="padding: 10px;">No anchors defined</div>
              </div>
            </div>

          </div>

          <!-- Right Panel: Patch Editor + Evidence Pack + Submit -->
          <div id="srr-patch-expand-strip" class="srr-patch-expand-strip" style="display:none;">▶ FIELDS</div>
          <div class="srr-panel srr-panel-right" style="display:none;">
            <div class="srr-panel-header" style="display: flex; align-items: center; gap: 8px;">
              <span id="srr-right-panel-title">Fields</span>
              <button id="srr-patch-toggle-btn" style="display:none;">Collapse</button>
              <!-- v1.5.1: Verifier-only Patch Tester tab -->
              <div id="srr-panel-tabs" class="srr-panel-tabs" style="display: none;"></div>
            </div>
            
            <!-- Fields Content (default, for analysts) -->
            <div class="srr-panel-body" id="srr-tab-fields">
              <!-- Patch Type Chips (horizontal scroll) - v1.5.2: Acts on selected field -->
              <div class="srr-patch-type-selector" style="margin-bottom: 16px;">
                <div class="srr-patch-type-label" style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 6px;">Patch Type</div>
                <div class="srr-patch-type-chips no-selection" id="srr-patch-type-chips" style="display: flex; gap: 6px; overflow-x: auto; white-space: nowrap; padding-bottom: 4px;">
                  <div class="srr-patch-type-chip correction active" data-type="correction" onclick="srrOnPatchTypeChange('correction')">Correction</div>
                  <div class="srr-patch-type-chip blacklist" data-type="blacklist" onclick="srrOnPatchTypeChange('blacklist')">Blacklist</div>
                  <div class="srr-patch-type-chip rfi" data-type="rfi" onclick="srrOnPatchTypeChange('rfi')">RFI</div>
                </div>
                <div class="srr-patch-type-selected-field" id="srr-patch-type-selected-field">Select a field to apply action</div>
              </div>

              <!-- Action Box - title changes based on patch type -->
              <div class="srr-patch-editor" id="srr-patch-editor">
                <div class="srr-patch-editor-title">
                  <span id="srr-action-box-title">Changed Fields</span>
                  <span id="srr-override-badge" class="srr-override-badge srr-section-hidden">OVERRIDE</span>
                  <span id="srr-change-count" style="font-weight: normal; color: #666; font-size: 0.85em; margin-left: auto;">0 changes</span>
                </div>
                <div id="srr-patch-editor-fields">
                  <div class="srr-patch-editor-empty" id="srr-action-box-helper">Click a field value to edit. Changed fields appear here.</div>
                </div>
                
                <!-- v1.4.19: Override toggle (Correction only, when applicable) -->
                <div id="srr-override-section" class="srr-override-row srr-section-hidden">
                  <div class="srr-override-toggle" id="srr-override-toggle" onclick="srrToggleOverride()"></div>
                  <div class="srr-override-label">Enable Override (skip repro requirement)</div>
                </div>
                
                <!-- v1.4.19: Blacklist Subject (Blacklist Flag only) -->
                <div id="srr-blacklist-section" class="srr-blacklist-subject srr-section-hidden">
                  <div class="srr-blacklist-subject-label">Blacklist Subject</div>
                  <div id="srr-blacklist-subject-value">(Derived from selected field/value)</div>
                </div>
                
                <!-- RFI Assignment Stub (RFI only) -->
                <div id="srr-rfi-section" class="srr-rfi-target srr-section-hidden">
                  <div class="srr-rfi-stub" style="display: flex; align-items: center; gap: 8px; padding: 10px; background: #f5f5f5; border-radius: 6px; color: #888;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                    <span style="font-size: 0.85em;">Assign user (coming soon)</span>
                  </div>
                </div>
              </div>

              <!-- Evidence Pack: Conditional sections based on Patch Type -->
              <div style="font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">Evidence Pack</div>
              
              <!-- Observation (Correction only) -->
              <div class="srr-evidence-block" id="srr-observation-block">
                <div class="srr-evidence-label">Observation <span class="srr-evidence-alias">(WHEN)</span></div>
                <select class="srr-evidence-select" id="srr-observation-type" onchange="srrOnObservationChange()">
                  <option value="">-- Select observation type --</option>
                  <option value="incorrect_value">Incorrect Value</option>
                  <option value="missing_value">Missing Value</option>
                  <option value="formatting_issue">Formatting Issue</option>
                  <option value="duplicate_entry">Duplicate Entry</option>
                  <option value="inconsistent_data">Inconsistent Data</option>
                  <option value="override_needed">Override Needed</option>
                </select>
              </div>
              
              <!-- Expected (Correction only) -->
              <div class="srr-evidence-block" id="srr-expected-block">
                <div class="srr-evidence-label">Expected <span class="srr-evidence-alias">(THEN)</span></div>
                <select class="srr-evidence-select" id="srr-expected-type" onchange="srrOnExpectedChange()">
                  <option value="">-- Select expected behavior --</option>
                  <option value="correct_value">Use Correct Value</option>
                  <option value="populate_field">Populate Empty Field</option>
                  <option value="standardize_format">Standardize Format</option>
                  <option value="remove_duplicate">Remove Duplicate</option>
                  <option value="align_with_source">Align with Source Document</option>
                  <option value="allow_override">Allow Override</option>
                </select>
              </div>
              
              <!-- Justification / Comment (all patch types) -->
              <div class="srr-evidence-block" id="srr-justification-block">
                <div class="srr-evidence-label" id="srr-justification-label">Justification <span class="srr-evidence-alias">(BECAUSE)</span></div>
                <textarea class="srr-evidence-textarea" id="srr-justification" placeholder="Explain why this change/flag/question is necessary..." oninput="srrSaveEvidenceDraft()"></textarea>
              </div>
              
              <!-- Repro (Correction only, when required) -->
              <div class="srr-evidence-block" id="srr-repro-block">
                <div class="srr-evidence-label">
                  Repro Method
                  <span id="srr-repro-required-marker" class="srr-repro-required">(required)</span>
                </div>
                <select class="srr-evidence-select" id="srr-repro-type" onchange="srrSaveEvidenceDraft(); srrUpdateReproFileVisibility();">
                  <option value="">-- Select repro method --</option>
                  <option value="breaks_salesforce_rule">System Pass Violation</option>
                  <option value="breaks_qa_gate">Breaks QA Gate</option>
                  <option value="resolver_mismatch">Resolver Mismatch</option>
                  <option value="doc_evidence_mismatch">Doc Evidence Mismatch (attach file)</option>
                </select>
                <div class="srr-evidence-file-input" id="srr-repro-file-section" style="display:none;">
                  <input type="file" id="srr-repro-file" accept=".pdf,.png,.jpg,.jpeg" onchange="srrHandleReproFile(this)">
                  <span id="srr-repro-file-name" style="font-size: 0.8em; color: #666;"></span>
                </div>
              </div>

              <!-- Replay Contract (v1.6.57: Correction/Blacklist required, RFI optional) -->
              <div class="srr-evidence-block" id="srr-replay-contract-block" style="padding-top: 12px; border-top: 1px solid #e0e0e0; display: none;">
                <div style="font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 8px;">Replay Contract</div>
                <div class="srr-evidence-block" id="srr-replay-type-block">
                  <div class="srr-evidence-label">Replay Type <span id="srr-replay-type-required" class="srr-repro-required">(required)</span></div>
                  <select class="srr-evidence-select" id="srr-replay-type" onchange="srrSaveEvidenceDraft()">
                    <option value="">-- Select replay type --</option>
                    <option value="MANUAL">Manual</option>
                    <option value="STUBBED">Stubbed</option>
                    <option value="NA">N/A</option>
                  </select>
                </div>
                <div class="srr-evidence-block" id="srr-replay-steps-block">
                  <div class="srr-evidence-label">Replay Steps <span id="srr-replay-steps-required" class="srr-repro-required">(required)</span></div>
                  <textarea class="srr-evidence-textarea" id="srr-replay-steps" placeholder="Describe the steps to replay this change..." oninput="srrSaveEvidenceDraft()"></textarea>
                </div>
                <div class="srr-evidence-block" id="srr-replay-expected-block">
                  <div class="srr-evidence-label">Replay Expected Result <span id="srr-replay-expected-required" class="srr-repro-required">(required)</span></div>
                  <textarea class="srr-evidence-textarea" id="srr-replay-expected-result" placeholder="What is the expected result of replaying?" oninput="srrSaveEvidenceDraft()"></textarea>
                </div>
              </div>

              <!-- Spacer to push buttons lower -->
              <div style="flex-grow: 1; min-height: 20px;"></div>
              
              <!-- Submit Section (positioned lower) -->
              <div class="srr-patch-section" style="margin-top: auto; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                <div class="srr-actions">
                  <button class="srr-btn srr-btn-secondary" onclick="srrSaveDraft()">Save Draft</button>
                  <button class="srr-btn srr-btn-primary" id="srr-submit-btn" onclick="srrSubmitPatchRequest()">Submit Patch Request</button>
                </div>
              </div>
            </div><!-- end srr-tab-fields -->
            
            <!-- Patch Studio Content -->
            <div class="srr-panel-body" id="srr-tab-studio" style="display: none;">
              <div style="padding: 16px; color: #888; text-align: center;">
                <div style="font-size: 1.1em; font-weight: 600; margin-bottom: 8px;">Patch Studio</div>
                <div style="font-size: 0.85em;">Draft and preview patch requests for this record scope.</div>
                <div id="srr-studio-content" style="margin-top: 16px; text-align: left;"></div>
              </div>
            </div><!-- end srr-tab-studio -->

            <!-- v1.5.1: Patch Tester Content (verifier only) -->
            <div class="srr-panel-body" id="srr-tab-tester" style="display: none;">
              <div style="margin-bottom: 16px;">
                <div style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px;">Patch Summary</div>
                <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                  <div style="margin-bottom: 8px;">
                    <span style="font-size: 0.75em; color: #888;">Field:</span>
                    <span id="srr-tester-field" style="font-weight: 600; margin-left: 6px; font-family: monospace;">—</span>
                  </div>
                  <div style="margin-bottom: 8px;">
                    <span style="font-size: 0.75em; color: #888;">Old Value:</span>
                    <span id="srr-tester-old-value" style="margin-left: 6px; color: #888; text-decoration: line-through;">—</span>
                  </div>
                  <div>
                    <span style="font-size: 0.75em; color: #888;">Proposed:</span>
                    <span id="srr-tester-proposed-value" style="margin-left: 6px; color: #2e7d32; font-weight: 600;">—</span>
                  </div>
                </div>
              </div>
              
              <div style="margin-bottom: 16px;">
                <div style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px;">Adjust New Value</div>
                <input type="text" id="srr-tester-new-value" class="srr-evidence-select" style="width: 100%; padding: 10px; border: 1px solid #4caf50; border-radius: 6px; font-family: monospace;" placeholder="Edit proposed value...">
                <div style="font-size: 0.75em; color: #888; margin-top: 4px;">Modify the proposed value before sending back for analyst confirmation.</div>
              </div>
              
              <div style="margin-bottom: 16px;">
                <div style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px;">Verifier Notes to Analyst</div>
                <textarea id="srr-tester-notes" class="srr-evidence-textarea" placeholder="Explain why you're adjusting this patch or what the analyst should verify..." style="min-height: 100px;"></textarea>
              </div>
              
              <div style="flex-grow: 1; min-height: 20px;"></div>
              
              <div style="margin-top: auto; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                <button class="srr-btn srr-btn-primary" style="width: 100%; background: #ff9800;" onclick="srrSendBackToAnalyst()">
                  ↩ Send Back to Analyst
                </button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; text-align: center;">Item will appear in Analyst's Needs Clarification queue.</div>
              </div>
            </div><!-- end srr-tab-tester -->
          </div>
        </div>
        
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: RECORD-INSPECTION | BUILD v1.6.49</div>
      </div><!-- end page-row -->

      <!-- PATCH STUDIO PAGE -->
      <div class="page" id="page-patch">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>Patch Studio</h2>
          </div>
          <p class="page-desc">Select records, build rule patches, validate with preflight gate, and export.</p>
        </div>

        <div class="preflight-gate" id="preflight-gate">
          <div class="preflight-header">
            <h3>Preflight Gate (PR Checklist)</h3>
            <button class="preflight-toggle" id="preflight-toggle">Show</button>
          </div>
          <div class="preflight-body" id="preflight-body">
            <div class="preflight-checklist">
              <div class="preflight-item" data-step="1">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 1: Validate Config</div>
                  <div class="preflight-evidence" id="evidence-1"></div>
                </div>
              </div>
              <div class="preflight-item" data-step="2">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 2: Preview Baseline</div>
                  <div class="preflight-evidence" id="evidence-2"></div>
                </div>
              </div>
              <div class="preflight-item" data-step="3">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 3: Smoke Baseline</div>
                  <div class="preflight-evidence" id="evidence-3"></div>
                </div>
              </div>
              <div class="preflight-item" data-step="4">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 4: Smoke Edge</div>
                  <div class="preflight-evidence" id="evidence-4"></div>
                </div>
              </div>
            </div>
            <div class="preflight-paste">
              <label>Paste Terminal Output (auto-parses evidence)</label>
              <textarea id="preflight-paste-area" placeholder="Paste terminal output here to auto-extract evidence..."></textarea>
              <button class="preflight-parse-btn" id="preflight-parse">Parse Evidence</button>
            </div>
            <div class="preflight-actions">
              <button class="preflight-btn preflight-btn-secondary" id="preflight-reset">Reset All</button>
              <button class="preflight-btn preflight-btn-primary" id="preflight-copy-evidence">Copy Evidence Summary</button>
            </div>
            <div class="preflight-summary" id="preflight-summary"></div>
          </div>
        </div>

        <div class="patch-studio-inline" id="patch-studio-inline">
          <h3>Patch Draft Builder</h3>
          <p class="page-desc">Open Record Workbench from Triage page to select records and add rules.</p>
          <div id="patch-draft-summary"></div>
          <div class="patch-studio-inline-actions">
            <button class="toolbar-btn" id="copy-patch-json">Copy Patch JSON</button>
            <button class="toolbar-btn" id="copy-pr-summary">Copy PR Summary</button>
          </div>
        </div>
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: PATCH-STUDIO | BUILD v1.6.49</div>
      </div><!-- end page-patch -->

      <!-- REVIEW PAGE -->
      <div class="page" id="page-review">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>Review</h2>
          </div>
          <p class="page-desc">Inspect config deltas, compare artifact versions, and generate evidence summaries.</p>
        </div>

        <div class="config-inspector" id="config-inspector">
          <div class="config-inspector-header">
            <h3>Config + Patch Inspector (Ruleset Delta)</h3>
            <button class="config-inspector-toggle" id="config-inspector-toggle">Show</button>
          </div>
          <div class="config-inspector-body" id="config-inspector-body">
            <div class="config-inspector-row">
              <div class="config-inspector-field">
                <label>Base Config Path</label>
                <input type="text" id="base-config-path" value="config/config_pack.base.json" placeholder="config/config_pack.base.json">
              </div>
              <div class="config-inspector-field">
                <label>Patch Path</label>
                <input type="text" id="patch-path" value="config/config_pack.example.patch.json" placeholder="config/config_pack.example.patch.json">
              </div>
              <div class="config-inspector-actions">
                <button class="config-inspector-btn config-inspector-btn-primary" id="load-config">Load Config</button>
                <button class="config-inspector-btn config-inspector-btn-secondary" id="clear-config">Clear</button>
              </div>
            </div>
            <div class="config-inspector-status" id="config-status" style="display: none;"></div>
            <div id="config-results" style="display: none;">
              <div class="patch-summary" id="patch-summary"></div>
              <div class="ruleset-delta" id="ruleset-delta"></div>
              <div class="table-container">
                <table class="changes-table" id="changes-table"></table>
              </div>
              <div class="config-inspector-copy-actions">
                <button class="config-copy-btn" id="copy-ruleset-delta">Copy Ruleset Delta (Markdown)</button>
              </div>
            </div>
          </div>
        </div>

        <div class="session-loader" id="session-loader">
          <div class="session-loader-header">
            <h3>Session Loader (Comparison Mode)</h3>
            <button class="session-loader-toggle" id="session-loader-toggle">Show</button>
          </div>
          <div class="session-loader-body" id="session-loader-body">
            <div class="session-loader-row">
              <div class="session-loader-field">
                <label>Primary Artifact Path</label>
                <input type="text" id="primary-path" value="out/sf_packet.preview.json" placeholder="out/sf_packet.preview.json">
              </div>
              <div class="session-loader-field">
                <label>Comparison Artifact Path (optional)</label>
                <input type="text" id="compare-path" placeholder="out/sf_packet.preview.prev.json">
              </div>
              <div class="session-loader-actions">
                <button class="session-loader-btn session-loader-btn-primary" id="load-session">Load</button>
                <button class="session-loader-btn session-loader-btn-secondary" id="clear-compare">Clear Compare</button>
              </div>
            </div>
            <div class="session-loader-status" id="session-status" style="display: none;"></div>
          </div>
        </div>

        <div id="review-evidence-summary" class="evidence-summary-panel"></div>
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: CONFIG-INSPECTOR | BUILD v1.6.49</div>
      </div><!-- end page-review -->

      <!-- VERIFIER REVIEW PAGE -->
      <div class="page" id="page-verifier-review">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <button class="srr-back-btn" onclick="navigateBackFromVerifierReview()" style="padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.85em;">← Back</button>
              <h2 style="margin: 0;">Verifier Review</h2>
              <span class="vr-state-badge" id="vr-state-badge">Submitted</span>
            </div>
          </div>
          <p class="page-desc">Review submitted Patch Requests, request clarification, approve or reject.</p>
        </div>

        <div class="vr-container" id="vr-container">
          <!-- Left Column: Type-Specific Content -->
          <div>
            <!-- Payload Type Badge -->
            <div style="margin-bottom: 16px;">
              <span id="vr-type-badge" style="display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; font-weight: 600; background: #1565c0; color: white;">CORRECTION</span>
              <button id="vr-open-srr-btn" onclick="vrOpenSingleRowReview()" style="margin-left: 12px; padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Open Record Inspection</button>
            </div>

            <!-- RFI Content Block -->
            <div id="vr-rfi-content" style="display: none;">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">❓</span> RFI Details</div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Field</div>
                  <div class="vr-intent-value" id="vr-rfi-field">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Current Value</div>
                  <div class="vr-intent-value" id="vr-rfi-value">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Question</div>
                  <div class="vr-intent-value" id="vr-rfi-comment">—</div>
                </div>
              </div>

              <!-- Comment Thread Stub -->
              <div class="vr-section" style="margin-top: 16px;">
                <div class="vr-section-header"><span class="icon">💬</span> Comment Thread</div>
                <div id="vr-comment-thread" style="display: flex; flex-direction: column; gap: 12px;">
                  <div style="display: flex; gap: 10px; align-items: flex-start;">
                    <div style="width: 32px; height: 32px; border-radius: 50%; background: #e3f2fd; display: flex; align-items: center; justify-content: center; font-size: 0.8em; color: #1565c0; flex-shrink: 0;">A</div>
                    <div style="flex: 1;">
                      <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: 600; font-size: 0.85em;">Analyst</span>
                        <span style="font-size: 0.75em; color: #999;">(coming soon)</span>
                      </div>
                      <div style="background: #f5f5f5; padding: 10px 14px; border-radius: 12px; font-size: 0.9em; color: #666;">Thread messages will appear here...</div>
                    </div>
                  </div>
                  <div style="display: flex; gap: 10px; align-items: flex-start;">
                    <div style="width: 32px; height: 32px; border-radius: 50%; background: #fff3e0; display: flex; align-items: center; justify-content: center; font-size: 0.8em; color: #f57c00; flex-shrink: 0;">V</div>
                    <div style="flex: 1;">
                      <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: 600; font-size: 0.85em;">Verifier</span>
                        <span style="font-size: 0.75em; color: #999;">(coming soon)</span>
                      </div>
                      <div style="background: #fff3e0; padding: 10px 14px; border-radius: 12px; font-size: 0.9em; color: #666;">Verifier responses will appear here...</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Correction Content Block -->
            <div id="vr-correction-content" style="display: none;">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">✏️</span> Correction Details</div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Field</div>
                  <div class="vr-intent-value" id="vr-corr-field">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Old Value</div>
                  <div class="vr-intent-value" id="vr-corr-old" style="color: #999; text-decoration: line-through;">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">New Value</div>
                  <div class="vr-intent-value" id="vr-corr-new" style="color: #2e7d32; font-weight: 600;">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Justification</div>
                  <div class="vr-intent-value" id="vr-corr-comment">—</div>
                </div>
              </div>
            </div>

            <!-- Blacklist Content Block -->
            <div id="vr-blacklist-content" style="display: none;">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">🚫</span> Blacklist Details</div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Field</div>
                  <div class="vr-intent-value" id="vr-bl-field">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Value</div>
                  <div class="vr-intent-value" id="vr-bl-value">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Blacklist Subject</div>
                  <div class="vr-intent-value" id="vr-bl-subject" style="color: #d32f2f;">—</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Justification</div>
                  <div class="vr-intent-value" id="vr-bl-comment">—</div>
                </div>
              </div>
            </div>

            <!-- Legacy Evidence Pack (for sample data fallback) -->
            <div id="vr-legacy-content">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">📋</span> Structured Intent</div>
                <div id="vr-intent-blocks">
                  <div class="vr-intent-block">
                    <div class="vr-intent-label">Observation (WHEN)</div>
                    <div class="vr-intent-value" id="vr-intent-when">—</div>
                  </div>
                  <div class="vr-intent-block">
                    <div class="vr-intent-label">Expected (THEN)</div>
                    <div class="vr-intent-value" id="vr-intent-then">—</div>
                  </div>
                  <div class="vr-intent-block">
                    <div class="vr-intent-label">Justification (BECAUSE)</div>
                    <div class="vr-intent-value" id="vr-intent-because">—</div>
                  </div>
                </div>
              </div>

              <div class="vr-section" style="margin-top: 16px;">
                <div class="vr-section-header"><span class="icon">📎</span> Evidence Pack</div>
                <div id="vr-evidence-blocks">
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Observation</div>
                    <div class="vr-evidence-text" id="vr-ev-observation">—</div>
                  </div>
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Expected</div>
                    <div class="vr-evidence-text" id="vr-ev-expected">—</div>
                  </div>
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Justification</div>
                    <div class="vr-evidence-text" id="vr-ev-justification">—</div>
                  </div>
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Repro</div>
                    <div class="vr-evidence-text" id="vr-ev-repro">—</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Column: Preflight + Author + Revisions + Notes + Actions -->
          <div>
            <!-- Preflight Report -->
            <div class="vr-section">
              <div class="vr-section-header"><span class="icon">✅</span> Preflight Report</div>
              <div id="vr-preflight-badges" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <span class="vr-preflight-badge pass">Schema ✓</span>
                <span class="vr-preflight-badge pass">Conflicts ✓</span>
                <span class="vr-preflight-badge pass">Evidence ✓</span>
              </div>
            </div>

            <!-- Author Info -->
            <div class="vr-section" style="margin-top: 16px;">
              <div class="vr-section-header"><span class="icon">👤</span> Author Info</div>
              <div class="vr-author-info">
                <div><span class="vr-author-label">Submitted by:</span> <span class="vr-author-value" id="vr-author-name">analyst@example.com</span></div>
                <div><span class="vr-author-label">Submitted at:</span> <span class="vr-author-value" id="vr-author-time">—</span></div>
                <div><span class="vr-author-label">Patch ID:</span> <span class="vr-author-value" id="vr-patch-id" style="font-family: monospace;">—</span></div>
              </div>
            </div>

            <!-- Revision History -->
            <div class="vr-section" style="margin-top: 16px;">
              <div class="vr-section-header"><span class="icon">📜</span> Revision History</div>
              <div id="vr-revisions">
                <div class="vr-empty-state">No previous revisions</div>
              </div>
            </div>

            <!-- Review Notes -->
            <div class="vr-section" style="margin-top: 16px;">
              <div class="vr-section-header"><span class="icon">📝</span> Review Notes</div>
              <textarea class="vr-notes-area" id="vr-notes" placeholder="Add notes for this review (visible to author if clarification requested)..."></textarea>
            </div>
          </div>

          <!-- Review Checklist -->
          <div class="vr-full-width">
            <div class="review-checklist-panel" id="vr-review-checklist">
              <h4>Review Checklist</h4>
              <div class="review-checklist-item"><input type="checkbox" id="vr-chk-intent" onchange="vrChecklistChanged()"><label for="vr-chk-intent">Intent Clarity — Observation, Expected, and Justification are clear</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="vr-chk-schema" onchange="vrChecklistChanged()"><label for="vr-chk-schema">Schema Correctness — Valid fields, operators, and base version match</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="vr-chk-preview" onchange="vrChecklistChanged()"><label for="vr-chk-preview">Preview Validity — Deterministic results with repository examples only</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="vr-chk-conflict" onchange="vrChecklistChanged()"><label for="vr-chk-conflict">Conflict Assessment — No contradictory actions, severities consistent</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="vr-chk-evidence" onchange="vrChecklistChanged()"><label for="vr-chk-evidence">Evidence Pack — All 4 blocks populated (Observation, Expected, Justification, Repro)</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="vr-chk-smoke" onchange="vrChecklistChanged()"><label for="vr-chk-smoke">Smoke Verification — Strict smoke test passed with evidence attached</label></div>
              <div class="review-checklist-confirm">
                <input type="checkbox" id="vr-chk-confirm" onchange="vrChecklistChanged()" disabled>
                <label for="vr-chk-confirm">I confirm all checklist items have been reviewed</label>
              </div>
            </div>
          </div>

          <!-- Full-Width: Actions Panel -->
          <div class="vr-full-width">
            <div class="vr-actions-panel">
              <div class="vr-actions-header">Verifier Actions</div>
              <div class="vr-actions-grid">
                <button class="vr-action-btn begin" id="vr-btn-begin" onclick="vrBeginReview()">Begin Review</button>
                <button class="vr-action-btn clarify" id="vr-btn-clarify" onclick="vrRequestClarification()" disabled>Request Clarification</button>
                <button class="vr-action-btn approve" id="vr-btn-approve" onclick="vrApprove()" disabled>Approve (Verifier)</button>
                <button class="vr-action-btn reject" id="vr-btn-reject" onclick="vrReject()" disabled>Reject</button>
              </div>
              <div id="vr-decision-summary" style="margin-top: 12px;"></div>
            </div>
          </div>
        </div>
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: VERIFIER-REVIEW | BUILD v1.6.49</div>
      </div><!-- end page-verifier-review -->

      <!-- Verifier Review Clarification Modal -->
      <div class="vr-clarify-modal" id="vr-clarify-modal">
        <div class="vr-clarify-modal-content">
          <h4>Request Clarification</h4>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 12px;">Describe what information or evidence is needed from the author.</p>
          <textarea id="vr-clarify-text" placeholder="What clarification is needed?"></textarea>
          <div class="vr-clarify-modal-actions">
            <button class="vr-action-btn" style="background: #e0e0e0; color: #333;" onclick="vrClarifyCancel()">Cancel</button>
            <button class="vr-action-btn clarify" onclick="vrClarifySubmit()">Send Request</button>
          </div>
        </div>
      </div>

      <!-- ADMIN APPROVAL PAGE -->
      <div class="page" id="page-admin-approval">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <button class="srr-back-btn" onclick="navigateTo('triage')" style="padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.85em;">← Back</button>
              <h2 style="margin: 0;">Admin Approval</h2>
              <span class="aa-state-badge" id="aa-state-badge">Verifier Approved</span>
            </div>
          </div>
          <p class="page-desc">Final approval surface before Promote Patch to Baseline.</p>
        </div>

        <div class="aa-container" id="aa-container">
          <!-- Left Column: Intent + Evidence -->
          <div>
            <!-- Structured Intent -->
            <div class="aa-section">
              <div class="aa-section-header"><span class="icon">📋</span> Structured Intent</div>
              <div id="aa-intent-blocks">
                <div class="aa-intent-block">
                  <div class="aa-intent-label">Observation (WHEN)</div>
                  <div class="aa-intent-value" id="aa-intent-when">—</div>
                </div>
                <div class="aa-intent-block">
                  <div class="aa-intent-label">Expected (THEN)</div>
                  <div class="aa-intent-value" id="aa-intent-then">—</div>
                </div>
                <div class="aa-intent-block">
                  <div class="aa-intent-label">Justification (BECAUSE)</div>
                  <div class="aa-intent-value" id="aa-intent-because">—</div>
                </div>
              </div>
            </div>

            <!-- Evidence Pack -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">📎</span> Evidence Pack</div>
              <div id="aa-evidence-blocks">
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Observation</div>
                  <div class="aa-evidence-text" id="aa-ev-observation">—</div>
                </div>
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Expected</div>
                  <div class="aa-evidence-text" id="aa-ev-expected">—</div>
                </div>
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Justification</div>
                  <div class="aa-evidence-text" id="aa-ev-justification">—</div>
                </div>
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Repro</div>
                  <div class="aa-evidence-text" id="aa-ev-repro">—</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Column: Verifier Decision + Preflight + Smoke + Changelog + Revisions -->
          <div>
            <!-- Verifier Decision -->
            <div class="aa-section">
              <div class="aa-section-header"><span class="icon">✓</span> Verifier Decision</div>
              <div class="aa-verifier-decision" id="aa-verifier-decision">
                <div class="aa-verifier-decision-header">Approved by Verifier</div>
                <div style="font-size: 0.85em; color: #666;">
                  <div><strong>Verifier:</strong> <span id="aa-verifier-name">verifier@example.com</span></div>
                  <div><strong>Approved at:</strong> <span id="aa-verifier-time">—</span></div>
                  <div><strong>Notes:</strong> <span id="aa-verifier-notes">All checklist items confirmed.</span></div>
                </div>
              </div>
            </div>

            <!-- Preflight Report -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">✅</span> Preflight Report</div>
              <div id="aa-preflight-badges" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <span class="aa-preflight-badge pass">Schema ✓</span>
                <span class="aa-preflight-badge pass">Conflicts ✓</span>
                <span class="aa-preflight-badge pass">Evidence ✓</span>
              </div>
            </div>

            <!-- Smoke (Strict) Status -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">🔥</span> Smoke (Strict) Status</div>
              <div class="aa-smoke-status pass" id="aa-smoke-status">
                <span class="aa-smoke-icon">✓</span>
                <div>
                  <div class="aa-smoke-label">Smoke (Strict) Passing</div>
                  <div style="font-size: 0.8em; color: #666;">Last run: <span id="aa-smoke-time">—</span></div>
                </div>
              </div>
            </div>

            <!-- Patch Replay Gate (v1.4.17) -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">🔄</span> Patch Replay</div>
              <div class="aa-replay-status not-run" id="aa-replay-status">
                <span class="aa-replay-badge not-run" id="aa-replay-badge">NOT RUN</span>
                <span id="aa-replay-status-text">Replay evaluation not yet performed</span>
              </div>
              <button class="aa-replay-btn" id="aa-replay-btn" onclick="aaRunReplay()">Run Replay</button>
              
              <!-- Replay Packet (checks list) -->
              <div class="aa-replay-packet" id="aa-replay-packet" style="display: none;">
                <div class="aa-replay-check pass" id="aa-replay-check-schema">
                  <span class="aa-replay-check-icon">✓</span>
                  <span class="aa-replay-check-label">Schema Validation</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-conflicts">
                  <span class="aa-replay-check-icon">✓</span>
                  <span class="aa-replay-check-label">Conflict Detection</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-baseline">
                  <span class="aa-replay-check-icon">✓</span>
                  <span class="aa-replay-check-label">Baseline Compatibility</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-rules">
                  <span class="aa-replay-check-icon">✓</span>
                  <span class="aa-replay-check-label">Rule Evaluation</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-output">
                  <span class="aa-replay-check-icon">✓</span>
                  <span class="aa-replay-check-label">Output Determinism</span>
                </div>
              </div>
              
              <!-- Failure Reason (shown only on FAIL) -->
              <div class="aa-replay-failure-reason" id="aa-replay-failure-reason" style="display: none;">
                <div class="aa-replay-failure-reason-header">Failure Reason</div>
                <div id="aa-replay-failure-text">—</div>
                <div style="margin-top: 8px; font-size: 0.8em;">
                  <a href="#" onclick="aaShowReplayAuditLog(); return false;">View in Audit Log →</a>
                </div>
              </div>
            </div>

            <!-- Changelog Preview -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">📝</span> Changelog Preview</div>
              <div class="aa-changelog-preview" id="aa-changelog-preview">## [1.4.6] - 2026-02-03

### Changed
- SF_R1_LABEL_NOT_ARTIST: Updated label_vendor requirement for LICENSING contracts</div>
            </div>

            <!-- Revision History -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">📜</span> Revision History</div>
              <div id="aa-revisions">
                <div style="font-size: 0.85em; color: #666;">No previous revisions</div>
              </div>
            </div>
          </div>

          <!-- Full-Width: Admin Notes + Actions -->
          <div class="aa-full-width">
            <div class="aa-section">
              <div class="aa-section-header"><span class="icon">📝</span> Admin Notes</div>
              <textarea class="aa-notes-area" id="aa-notes" placeholder="Add admin notes (visible in audit log)..."></textarea>
            </div>

            <div class="review-checklist-panel" id="aa-review-checklist" style="margin-bottom: 16px;">
              <h4>Admin Review Checklist</h4>
              <div class="review-checklist-item"><input type="checkbox" id="aa-chk-verifier" onchange="aaChecklistChanged()"><label for="aa-chk-verifier">Verifier approval is valid and complete</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="aa-chk-downstream" onchange="aaChecklistChanged()"><label for="aa-chk-downstream">Downstream Risk — Operator workflow impact reviewed</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="aa-chk-version" onchange="aaChecklistChanged()"><label for="aa-chk-version">Versioning — Version increment and changelog are correct</label></div>
              <div class="review-checklist-item"><input type="checkbox" id="aa-chk-smoke" onchange="aaChecklistChanged()"><label for="aa-chk-smoke">Smoke (Strict) — Test passed with exit code 0</label></div>
              <div class="review-checklist-confirm">
                <input type="checkbox" id="aa-chk-confirm" onchange="aaChecklistChanged()" disabled>
                <label for="aa-chk-confirm">I confirm all checklist items have been reviewed</label>
              </div>
            </div>

            <div class="aa-actions-panel">
              <div class="aa-actions-header">Admin Actions</div>
              <div class="aa-actions-grid">
                <button class="aa-action-btn approve" id="aa-btn-approve" onclick="aaAdminApprove()">Admin Approve</button>
                <button class="aa-action-btn hold" id="aa-btn-hold" onclick="aaAdminHold()">Admin Hold</button>
                <button class="aa-action-btn release" id="aa-btn-release" onclick="aaReleaseHold()" disabled>Release Hold</button>
                <button class="aa-action-btn promote" id="aa-btn-promote" onclick="aaPromoteToBaseline()" disabled>Promote Patch to Baseline</button>
              </div>
              <div id="aa-decision-summary" style="margin-top: 12px;"></div>
            </div>
          </div>
        </div>
        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: ADMIN-APPROVAL | BUILD v1.6.49</div>
      </div><!-- end page-admin-approval -->

      <!-- Admin Hold Modal -->
      <div class="aa-hold-modal" id="aa-hold-modal">
        <div class="aa-hold-modal-content">
          <h4>Admin Hold</h4>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 12px;">Describe why this patch is being placed on hold.</p>
          <textarea id="aa-hold-text" placeholder="Hold reason..."></textarea>
          <div class="aa-hold-modal-actions">
            <button class="aa-action-btn" style="background: #e0e0e0; color: #333;" onclick="aaHoldCancel()">Cancel</button>
            <button class="aa-action-btn hold" onclick="aaHoldSubmit()">Place on Hold</button>
          </div>
        </div>
      </div>

      <!-- ADMIN PAGE (Console) -->
      <div class="page" id="page-admin">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>Admin Panel</h2>
          </div>
          <p class="page-desc">Centralized admin tools for governance, config, standardization, and patch management.</p>
        </div>

        <!-- Admin Panel Tabs -->
        <div class="admin-console-tabs" style="display: flex; gap: 4px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; padding-bottom: 0;">
          <button class="admin-tab active" data-admin-tab="governance" onclick="switchAdminTab('governance')" style="padding: 10px 20px; background: #1976d2; color: white; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-weight: 600;">Governance</button>
          <button class="admin-tab" data-admin-tab="users" onclick="switchAdminTab('users')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Users</button>
          <button class="admin-tab" data-admin-tab="patch-queue" onclick="switchAdminTab('patch-queue')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Patch Queue <span id="patch-queue-count" style="display:none; background:#e91e63; color:white; padding:1px 6px; border-radius:10px; font-size:0.8em; margin-left:4px;">0</span></button>
          <button class="admin-tab" data-admin-tab="config" onclick="switchAdminTab('config')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Config</button>
          <button class="admin-tab" data-admin-tab="inspector" onclick="switchAdminTab('inspector')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Inspector</button>
          <button class="admin-tab" data-admin-tab="standardizer" onclick="switchAdminTab('standardizer')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Schema</button>
          <button class="admin-tab" data-admin-tab="patch-console" onclick="switchAdminTab('patch-console')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Patch Console</button>
          <button class="admin-tab" data-admin-tab="evidence" onclick="switchAdminTab('evidence')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Evidence</button>
          <button class="admin-tab" data-admin-tab="unknown-cols" onclick="switchAdminTab('unknown-cols')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Unknown Columns</button>
          <button class="admin-tab" data-admin-tab="people" onclick="switchAdminTab('people')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">People</button>
          <button class="admin-tab" data-admin-tab="qa-runner" onclick="switchAdminTab('qa-runner')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">QA Runner</button>
        </div>

        <!-- GOVERNANCE TAB -->
        <div id="admin-tab-governance" class="admin-tab-panel" data-admin-section="true">
        <!-- Masterline / Artifact Registry Section -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 1.1em; color: #333;">Artifact Registry <span class="info-icon" title="Manage the master artifacts that drive the semantic control board. When Dev Masterline is enabled, artifacts are auto-loaded from repository paths.">&#9432;</span></h3>
            <div style="display: flex; align-items: center; gap: 10px;">
              <label class="toggle-label" style="font-size: 0.85em; color: #666;">Dev Masterline</label>
              <label class="toggle-switch">
                <input type="checkbox" id="dev-masterline-toggle" onchange="toggleDevMasterline()">
                <span class="toggle-slider"></span>
              </label>
              <span id="dev-masterline-status" class="masterline-status on">ON</span>
            </div>
          </div>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">When enabled, master artifacts are auto-loaded from repository on startup. Rebind paths if files are in different locations.</p>
          <div id="artifact-registry-table"></div>
          <div style="margin-top: 15px; display: flex; gap: 10px;">
            <button class="toolbar-btn" onclick="checkAllArtifacts()">Refresh Status</button>
            <button class="toolbar-btn" onclick="masterlineAutoload()">Reload All</button>
          </div>
        </div>

        <!-- Workflow Map Section -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Workflow Map <span class="info-icon" title="Visual overview of the semantic governance pipeline. Each step shows required artifacts and their status.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Understand the end-to-end governance pipeline at a glance. Click any step to navigate.</p>
          <div id="workflow-map" class="workflow-map"></div>
        </div>

        <!-- Demo Dataset Toggle (v1.6.4) -->
        <div id="admin-demo-toggle-section" class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 1.1em; color: #333;">Demo Dataset <span class="info-icon" title="Toggle between the Original (blank baseline) and Modified (in-progress) demo datasets. The modified dataset contains sample audit log entries.">&#9432;</span></h3>
            <span id="demo-mode-badge" style="display: none; font-size: 0.7em; background: #ff9800; color: white; padding: 3px 8px; border-radius: 4px; font-weight: 600;">Demo: Modified (In-Progress)</span>
          </div>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Switch between Original (clean baseline) and Modified (in-progress with audit log data) demo datasets.</p>
          <div style="display: flex; gap: 10px; align-items: center;">
            <button id="demo-toggle-original" class="toolbar-btn" onclick="setDemoMode('original')" style="flex: 1;">Original (Baseline)</button>
            <button id="demo-toggle-modified" class="toolbar-btn" onclick="setDemoMode('modified')" style="flex: 1;">Modified (In-Progress)</button>
          </div>
          <div id="demo-partial-banner" style="display: none; margin-top: 12px; padding: 10px; background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; font-size: 0.85em; color: #e65100;">
            ⚠️ Demo dataset is in-progress (partial completion). Audit log entries show sample data.
          </div>
        </div>

        <!-- Governance Notes -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Governance Notes</h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Admin-level notes and overrides are recorded here.</p>
          <div id="admin-governance-notes" style="background: #f9f9f9; padding: 15px; border-radius: 6px; min-height: 60px;">
            <em style="color: #888;">No governance notes recorded.</em>
          </div>
        </div>

        <!-- Quick Actions -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Quick Actions</h3>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="toolbar-btn" onclick="var _btn = document.getElementById('btn-run'); if (_btn) _btn.click()">Run Commands</button>
            <button class="toolbar-btn" onclick="switchAdminTab('inspector')">Open Inspector</button>
          </div>
        </div>
          <!-- v1.6.48: Batch Add Settings -->
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Catalog Item Wizard <span class="info-icon" title="Catalog Item Wizard allows Analysts to mark records as catalog item anchors and batch-add catalog items. The feature is per-record.">&#9432;</span></h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Catalog Item Wizard is enabled per-record. Analysts use the + button in the Field Inspector to open the wizard directly. Per-section overrides below are optional.</p>
            <div id="admin-batch-add-toggles" style="display: flex; flex-direction: column; gap: 8px;">
              <div style="color: #999; font-size: 0.85em; font-style: italic;">Load a dataset to see available contract sections.</div>
            </div>
          </div>
        <div class="admin-section" id="batch-merge-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
  <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Merge Batches <span class="info-icon" title="Merge two or more existing batches into a single governance container. Contract IDs remain stable. Tenant rules do NOT auto-inherit.">&#9432;</span></h3>
  <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Combine source batches into a single merged batch. Source batch lineage is preserved read-only. Tenant rules require explicit promotion.</p>
  <div id="batch-merge-controls" style="display: flex; flex-direction: column; gap: 12px;">
    <div style="display: flex; gap: 10px; align-items: center;">
      <label style="font-size: 0.85em; color: #555; min-width: 120px;">Source Batches:</label>
      <div id="batch-merge-source-list" style="flex: 1; display: flex; flex-direction: column; gap: 6px;"></div>
    </div>
    <div style="display: flex; gap: 10px; align-items: center;">
      <label style="font-size: 0.85em; color: #555; min-width: 120px;">Merged Label:</label>
      <input type="text" id="batch-merge-label" placeholder="e.g., Q4 Combined Review" style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em;">
    </div>
    <div style="display: flex; gap: 10px; margin-top: 8px;">
      <button class="toolbar-btn" onclick="BatchMerge.refreshSourceList()">Refresh Sources</button>
      <button class="toolbar-btn" onclick="BatchMerge.executeMerge()" style="background: #1976d2; color: white;">Merge Batches</button>
    </div>
  </div>
  <div id="batch-merge-status" style="display: none; margin-top: 12px; padding: 10px; border-radius: 6px; font-size: 0.85em;"></div>
  <!-- Merged Batch Governance Panel -->
  <div id="merged-batch-panel" style="display: none; margin-top: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">
    <h4 style="margin: 0 0 10px; font-size: 1em; color: #333;">Active Merged Batches</h4>
    <div id="merged-batch-list"></div>
  </div>
</div>
        </div><!-- end admin-tab-governance -->

        <!-- P0.6: Truth Pack Controls (Architect-only) -->
        <div id="truth-pack-admin-section" class="admin-section" style="display: none; background: #f3e5f5; padding: 16px 20px; border-radius: 8px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 1px solid #ce93d8;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0; font-size: 0.95em; color: #6a1b9a;">Architect Controls</h4>
            <span style="font-size: 0.7em; padding: 2px 8px; background: #7b1fa2; color: white; border-radius: 10px; font-weight: 600;">ARCHITECT ONLY</span>
          </div>
          <div style="margin-bottom: 12px;">
            <label style="font-size: 0.85em; color: #555; display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" id="architect-mode-toggle" onchange="if(this.checked){TruthPack.enableArchitectMode();}else{TruthPack.disableArchitectMode();}">
              Enable Architect Mode
            </label>
          </div>
          <div id="truth-pack-admin-controls" style="display: none;"></div>
          <div id="truth-config-controls" style="margin-top: 12px;"></div>
        </div>

        <!-- USERS TAB (v1.4.21) -->
        <div id="admin-tab-users" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <!-- Environment Mode Toggle (v1.6.17) -->
          <div class="admin-section" style="background: white; padding: 16px 20px; border-radius: 8px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h4 style="margin: 0 0 4px 0; font-size: 0.95em; color: #333;">Environment Mode</h4>
                <p style="margin: 0; font-size: 0.8em; color: #666;">Sandbox mode enables permissionless access with guided Next progression. Production mode uses strict auth and role gates.</p>
              </div>
              <div id="env-mode-toggle" style="display: flex; border: 1px solid #ddd; border-radius: 6px; overflow: hidden;">
                <button id="env-mode-prod" onclick="setEnvMode('production')" style="padding: 8px 16px; border: none; background: #f5f5f5; color: #666; cursor: pointer; font-size: 0.85em; font-weight: 500;">Production</button>
                <button id="env-mode-playground" onclick="setEnvMode('playground')" style="padding: 8px 16px; border: none; background: #f5f5f5; color: #666; cursor: pointer; font-size: 0.85em; font-weight: 500;">Sandbox</button>
              </div>
            </div>
          </div>
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
              <h3 style="margin: 0; font-size: 1.1em; color: #333;">User Access <span class="info-icon" title="Manage user roles. In Sandbox mode, changes are stored locally. No Admin role in Sandbox.">&#9432;</span></h3>
              <div id="add-user-btn-container" style="display: flex; gap: 10px; align-items: center;">
                <button id="add-user-btn" class="toolbar-btn" onclick="openAddUserModal()" style="background: #4caf50; color: white; padding: 8px 14px; font-size: 0.85em; display: flex; align-items: center; gap: 6px;">
                  <span style="font-size: 1.1em;">+</span> Add User
                </button>
              </div>
            </div>
            <p id="users-mode-desc" style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Assign roles to users. Changes persist in local storage only.</p>
            
            <div id="users-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                <thead style="background: #f5f5f5;">
                  <tr>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 20%;">User</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 28%;">Email</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 18%;">Role</th>
                    <th style="padding: 12px 8px; text-align: center; border-bottom: 1px solid #e0e0e0; width: 14%;">Status</th>
                    <th style="padding: 12px 8px; text-align: center; border-bottom: 1px solid #e0e0e0; width: 20%;">Actions</th>
                  </tr>
                </thead>
                <tbody id="users-table-body">
                </tbody>
              </table>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center;">
              <button class="toolbar-btn" onclick="resetDemoUsers()">Reset to Defaults</button>
              <span style="font-size: 0.8em; color: #888;">Last updated: <span id="users-last-updated">—</span></span>
            </div>
          </div>
        </div><!-- end admin-tab-users -->

        <!-- ADD USER MODAL (v1.6.16) -->
        <div id="add-user-modal" class="modal-overlay">
          <div class="modal" style="max-width: 450px;">
            <div class="modal-header">
              <h3>Add New User</h3>
              <button class="modal-close" onclick="closeAddUserModal()">&times;</button>
            </div>
            <div class="modal-body">
              <div id="add-user-error" style="display: none; background: #ffebee; color: #c62828; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.9em;"></div>
              
              <div style="margin-bottom: 15px;">
                <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Full Name <span style="color: #c62828;">*</span></label>
                <input type="text" id="add-user-name" placeholder="e.g. Jane Smith" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em; box-sizing: border-box;">
              </div>
              
              <div style="margin-bottom: 15px;">
                <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Email <span style="color: #c62828;">*</span></label>
                <input type="email" id="add-user-email" placeholder="e.g. jane.smith@company.com" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em; box-sizing: border-box;">
              </div>
              
              <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                <div style="flex: 1;">
                  <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Role</label>
                  <select id="add-user-role" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em;">
                    <option value="analyst" selected>Analyst</option>
                    <option value="verifier">Verifier</option>
                    <option value="admin">Admin</option>
                  </select>
                </div>
                <div style="flex: 1;">
                  <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Status</label>
                  <select id="add-user-status" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em;">
                    <option value="active" selected>Active</option>
                    <option value="pending">Pending</option>
                    <option value="disabled">Disabled</option>
                  </select>
                </div>
              </div>
              
              <div style="margin-bottom: 20px;">
                <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Division <span style="color: #888; font-weight: 400;">(optional)</span></label>
                <input type="text" id="add-user-division" placeholder="e.g. Operations" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em; box-sizing: border-box;">
              </div>
              
              <div style="background: #fff3e0; padding: 10px 12px; border-radius: 4px; font-size: 0.8em; color: #e65100; margin-bottom: 15px;">
                <strong>Pre-provisioned:</strong> This user will be ready when real authentication is enabled. The system will match by email.
              </div>
              
              <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="modal-btn modal-btn-secondary" onclick="closeAddUserModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="submitAddUser()" style="background: #4caf50;">Add User</button>
              </div>
            </div>
          </div>
        </div>

        <!-- PATCH QUEUE TAB (v1.5.1) -->
        <div id="admin-tab-patch-queue" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Patch Queue <span class="info-icon" title="Patch requests approved by Verifiers awaiting final Admin approval.">&#9432;</span></h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Review Correction and Blacklist patch requests approved by Verifiers.</p>
            
            <div id="patch-queue-table-container" style="max-height: 400px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                <thead style="background: #f5f5f5; position: sticky; top: 0;">
                  <tr>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Type</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Record ID</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Field</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Old → New</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Comment</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Submitted</th>
                    <th style="padding: 12px 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Actions</th>
                  </tr>
                </thead>
                <tbody id="patch-queue-tbody">
                  <tr><td colspan="7" style="padding: 20px; text-align: center; color: #888;">No items pending Admin review</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div><!-- end admin-tab-patch-queue -->

        <!-- PATCH CONSOLE TAB -->
        <div id="admin-tab-patch-console" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Patch Requests Console <span class="info-icon" title="Manage patch requests through their lifecycle. Track requests from creation through Kiwi processing to final application.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Track and manage patch requests. Batch export to Kiwi, import returns, and apply changes.</p>
          <!-- Queue Tabs -->
          <div id="patch-queue-tabs" style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px;">
            <button class="queue-tab active" data-queue="new" onclick="switchPatchQueueTab('new')">New <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="needs_review" onclick="switchPatchQueueTab('needs_review')">Needs Review <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="approved" onclick="switchPatchQueueTab('approved')">Approved <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="applied" onclick="switchPatchQueueTab('applied')">Applied <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="rejected" onclick="switchPatchQueueTab('rejected')">Rejected <span class="queue-count">0</span></button>
          </div>
          <!-- Batch Actions -->
          <div id="patch-batch-actions" style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
            <button class="toolbar-btn" onclick="selectAllCurrentQueue()">Select All</button>
            <button class="toolbar-btn" onclick="clearPatchRequestSelection(); renderPatchConsoleTable();">Clear Selection</button>
            <button class="toolbar-btn" onclick="batchMarkSentToKiwi()" style="background: #1565c0;">Export to Kiwi (Copy)</button>
            <button class="toolbar-btn" onclick="openKiwiReturnInbox()" style="background: #7b1fa2;">Paste Kiwi Return</button>
            <button class="toolbar-btn" onclick="batchMarkApplied()" style="background: #2e7d32;">Mark Applied</button>
            <button class="toolbar-btn" onclick="batchCopyCommitPack()" style="background: #f57c00;">Copy Batch Commit Pack</button>
          </div>
          <!-- Compact Table -->
          <div id="patch-console-table-container" style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px;">
            <table id="patch-console-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
              <thead style="background: #f5f5f5; position: sticky; top: 0;">
                <tr>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 40px;"><input type="checkbox" id="patch-select-all" onchange="toggleSelectAllPatches(this.checked)"></th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">ID</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Intent</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Target</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Status</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Updated</th>
                  <th style="padding: 10px 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Actions</th>
                  <th style="padding: 10px 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Health</th>
                </tr>
              </thead>
              <tbody id="patch-console-tbody">
                <tr><td colspan="8" style="padding: 20px; text-align: center; color: #888;">No patch requests in this queue</td></tr>
              </tbody>
            </table>
          </div>
          <!-- Summary Stats -->
          <div id="patch-console-summary" style="margin-top: 15px; display: flex; gap: 20px; flex-wrap: wrap; font-size: 0.85em; color: #666;">
            <span>Total: <strong id="patch-total-count">0</strong></span>
            <span>Selected: <strong id="patch-selected-count">0</strong></span>
            <span>Comments Open: <strong id="comments-open-count">0</strong></span>
          </div>
        </div>
        
        <!-- Kiwi Return Inbox Modal -->
        <div id="kiwi-return-inbox-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Paste Kiwi Return</h3>
              <button class="modal-close" onclick="closeKiwiReturnInbox()">&times;</button>
            </div>
            <div class="modal-body">
              <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">Paste the JSON returned from Kiwi. Each request will be matched by request_id and updated.</p>
              <textarea id="kiwi-return-textarea" placeholder="Paste Kiwi return JSON here..." style="width: 100%; height: 200px; font-family: monospace; font-size: 0.85em; padding: 10px; border: 1px solid #ddd; border-radius: 6px;"></textarea>
              <div id="kiwi-return-status" style="margin-top: 10px; display: none; padding: 10px; border-radius: 6px;"></div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
              <button class="toolbar-btn" onclick="closeKiwiReturnInbox()">Cancel</button>
              <button class="toolbar-btn" onclick="processKiwiReturn()" style="background: #7b1fa2;">Process Return</button>
            </div>
          </div>
        </div>
        
        <!-- Add Comment Modal -->
        <div id="add-comment-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Add Comment (RFI)</h3>
              <button class="modal-close" onclick="closeAddCommentModal()">&times;</button>
            </div>
            <div class="modal-body">
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">Target</label>
                <div id="comment-target-display" style="font-family: monospace; font-size: 0.9em; padding: 8px; background: #f5f5f5; border-radius: 4px;"></div>
              </div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">Comment</label>
                <textarea id="comment-content-input" placeholder="Describe your question or clarification request..." style="width: 100%; height: 100px; font-size: 0.9em; padding: 10px; border: 1px solid #ddd; border-radius: 6px;"></textarea>
              </div>
              <input type="hidden" id="comment-target-type">
              <input type="hidden" id="comment-target-id">
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
              <button class="toolbar-btn" onclick="closeAddCommentModal()">Cancel</button>
              <button class="toolbar-btn" onclick="submitNewComment()" style="background: #1976d2;">Add Comment</button>
            </div>
          </div>
        </div>
        
        <!-- Elevate to Patch Request Modal -->
        <div id="elevate-to-patch-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Elevate to Patch Request</h3>
              <button class="modal-close" onclick="closeElevateToPatchModal()">&times;</button>
            </div>
            <div class="modal-body">
              <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">Create a patch request from this resolved comment. Fill in the intent of the change.</p>
              <div id="elevate-comment-preview" style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 0.9em;"></div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">WHEN (Condition)</label>
                <input type="text" id="elevate-intent-when" placeholder="e.g., field 'label' contains 'Artist'" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">THEN (Action)</label>
                <input type="text" id="elevate-intent-then" placeholder="e.g., set 'label' to 'Record Label'" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">BECAUSE (Reason)</label>
                <input type="text" id="elevate-intent-because" placeholder="e.g., 'Artist' is reserved for performer names" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <input type="hidden" id="elevate-comment-id">
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
              <button class="toolbar-btn" onclick="closeElevateToPatchModal()">Cancel</button>
              <button class="toolbar-btn" onclick="submitElevateToPatch()" style="background: #7b1fa2;">Create Patch Request</button>
            </div>
          </div>
        </div>
        
        <!-- P0.8: Unresolved Record Diagnostics Modal -->
        <div id="p08-unresolved-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 580px;">
            <div class="modal-header" style="display:flex; justify-content:space-between; align-items:center;">
              <h3 style="margin:0; color:#c62828;">Unresolved Record</h3>
              <button class="modal-close" onclick="closeUnresolvedModal()">&times;</button>
            </div>
            <div class="modal-body" style="max-height:400px; overflow-y:auto;">
              <p style="font-size:0.9em; color:#666; margin-bottom:12px;">The triage item could not be matched to a record in the active dataset.</p>
              <div id="p08-unresolved-summary" style="background:#fff3e0; padding:12px; border-radius:6px; margin-bottom:12px; font-size:0.88em;"></div>
              <details style="margin-bottom:12px;">
                <summary style="cursor:pointer; font-size:0.85em; font-weight:600; color:#555;">Debug JSON</summary>
                <pre id="p08-unresolved-json" style="background:#263238; color:#eee; padding:12px; border-radius:6px; font-size:0.78em; max-height:200px; overflow:auto; white-space:pre-wrap;"></pre>
              </details>
            </div>
            <div class="modal-footer" style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap;">
              <button id="p08-btn-open-contract" class="toolbar-btn" style="background:#1565c0; color:#fff; display:none;" onclick="p08ActionOpenContract()">Open Contract in Grid</button>
              <button id="p08-btn-open-sheet" class="toolbar-btn" style="background:#2e7d32; color:#fff; display:none;" onclick="p08ActionOpenSheet()">Open Section Row</button>
              <button class="toolbar-btn" onclick="p08CopyDebugJSON()" style="background:#546e7a; color:#fff;">Copy Debug JSON</button>
              <button class="toolbar-btn" onclick="closeUnresolvedModal()">Dismiss</button>
            </div>
          </div>
        </div>
</div><!-- end admin-tab-patch-console -->

        <!-- EVIDENCE TAB -->
        <div id="admin-tab-evidence" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Version & Baseline</h3>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            <div>
              <label style="font-size: 0.75em; color: #666; text-transform: uppercase;">Current Base Version</label>
              <div style="font-family: monospace; font-size: 1em; margin-top: 4px;" id="admin-base-version">--</div>
            </div>
            <div>
              <label style="font-size: 0.75em; color: #666; text-transform: uppercase;">Patch Target Version</label>
              <div style="font-family: monospace; font-size: 1em; margin-top: 4px;" id="admin-patch-version">--</div>
            </div>
            <div>
              <label style="font-size: 0.75em; color: #666; text-transform: uppercase;">Last Smoke Test</label>
              <div style="font-size: 0.9em; margin-top: 4px;" id="admin-last-smoke">Not Run</div>
            </div>
          </div>
        </div>

        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Evidence Gates</h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Status of preflight checks. Evidence is pasted in (UI does not run these).</p>
          <div id="admin-evidence-gates" style="display: flex; gap: 10px; flex-wrap: wrap;">
            <div class="state-chip pending">Validation: Pending</div>
            <div class="state-chip pending">Conflicts: Pending</div>
            <div class="state-chip pending">Smoke Baseline: Pending</div>
            <div class="state-chip pending">Smoke Edge: Pending</div>
          </div>
        </div>
        </div><!-- end admin-tab-evidence -->

        <!-- UNKNOWN COLUMNS TAB -->
        <div id="admin-tab-unknown-cols" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Unknown Columns (Schema Drift) <span class="info-icon" title="Columns found in imported data that don't match any canonical field. Decide how to handle each.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Columns detected during standardization that aren't in the canonical schema. Decide how to classify each one.</p>
          <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button class="toolbar-btn" onclick="refreshUnknownColumnsTable()">Refresh</button>
            <button class="toolbar-btn" onclick="exportUnknownColumnsRequest()">Export Update Request (Copy)</button>
            <button class="toolbar-btn" onclick="clearUnknownColumnsDecisions()">Clear Decisions</button>
          </div>
          <div id="unknown-cols-table-container" style="overflow-x: auto;">
            <table class="grid-table" id="unknown-cols-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
              <thead style="background: #f5f5f5;">
                <tr>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Contract Section</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Original Name</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Normalized</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Sample Values</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Non-Empty</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Action</th>
                </tr>
              </thead>
              <tbody id="unknown-cols-tbody">
                <tr><td colspan="6" style="text-align: center; padding: 40px; color: #888;">No unknown columns detected</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Pending Decisions</h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Columns marked for action. Export to generate a standard update request artifact.</p>
          <div id="unknown-cols-decisions" style="background: #f9f9f9; padding: 15px; border-radius: 6px; min-height: 60px; font-family: monospace; font-size: 0.85em;">
            <em style="color: #888;">No decisions made yet.</em>
          </div>
        </div>
        </div><!-- end admin-tab-unknown-cols -->

        <!-- STANDARDIZER TAB -->
        <div id="admin-tab-standardizer" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Schema Tree Editor <span class="info-icon" title="Browse and edit the canonical schema tree: contract sections, fields, aliases, QA flags, and document types. Changes are buffered locally and can be exported as a patch.">&#9432;</span></h3>
          <div style="display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;">
            <button class="toolbar-btn" onclick="schemaTreeExpandAll()">Expand All</button>
            <button class="toolbar-btn" onclick="schemaTreeCollapseAll()">Collapse All</button>
            <button class="toolbar-btn" onclick="SchemaTreeEditor.saveDraft()" style="background:#e8f5e9; color:#2e7d32;">Save Draft</button>
            <button class="toolbar-btn" onclick="schemaTreePreviewDiff()">Preview Diff</button>
            <button class="toolbar-btn" onclick="SchemaTreeEditor.exportPatch()">Export Patch</button>
            <button class="toolbar-btn" onclick="SchemaTreeEditor.undo()">Undo Last</button>
          </div>
          <div id="schema-tree-container" style="border: 1px solid #e0e0e0; border-radius: 6px; max-height: 500px; overflow-y: auto; padding: 8px; background: #fafafa;"></div>
          <div id="schema-diff-panel" style="display:none; margin-top: 15px; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; background: #fff;"></div>
          <div id="schema-status-bar" style="margin-top: 10px; padding: 8px 12px; background: #f5f5f5; border-radius: 4px; font-size: 0.82em; color: #666; display: flex; justify-content: space-between;">
            <span id="schema-loaded-count">Sources: 0 loaded</span>
            <span id="schema-pending-count">Pending changes: 0</span>
          </div>
        </div>
        </div><!-- end admin-tab-standardizer -->

        <!-- CONFIG TAB -->
        <div id="admin-tab-config" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Config + Patch Inspector</h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Load and compare config packs. View ruleset deltas between base and patch.</p>
            <div class="config-inspector-row" style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">
              <div style="flex: 1; min-width: 200px;">
                <label style="font-size: 0.8em; color: #666; display: block; margin-bottom: 4px;">Base Config Path</label>
                <input type="text" id="admin-base-config-path" value="config/config_pack.base.json" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
              </div>
              <div style="flex: 1; min-width: 200px;">
                <label style="font-size: 0.8em; color: #666; display: block; margin-bottom: 4px;">Patch Path</label>
                <input type="text" id="admin-patch-path" value="config/config_pack.example.patch.json" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
              </div>
            </div>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
              <button class="toolbar-btn" onclick="loadAdminConfig()">Load Config</button>
              <button class="toolbar-btn" onclick="clearAdminConfig()">Clear</button>
            </div>
            <div id="admin-config-status" style="display: none; padding: 10px; border-radius: 6px; margin-bottom: 15px;"></div>
            <div id="admin-config-results" style="display: none;">
              <div id="admin-patch-summary" style="background: #e3f2fd; padding: 15px; border-radius: 6px; margin-bottom: 15px;"></div>
              <div id="admin-ruleset-delta" style="background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 300px; overflow-y: auto;"></div>
            </div>
          </div>

          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 6px; font-size: 1.1em; color: #333;">Canonical Glossary</h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">The glossary defines all governed fields, their definitions, return formats, and picklist options. Each contract section is mapped to its Fields Definitions source. Upload a replacement glossary JSON to update schema coverage and validation rules.</p>
            <div id="glossary-summary" style="background: #e8f5e9; padding: 12px 16px; border-radius: 6px; margin-bottom: 15px; font-size: 0.85em; color: #2e7d32;"></div>
            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
              <label style="display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%); color: white; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 600;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                Upload Glossary JSON
                <input type="file" id="glossary-upload-input" accept=".json" style="display: none;" onchange="handleGlossaryUpload(this)">
              </label>
              <button class="toolbar-btn" onclick="downloadCurrentGlossary()" style="font-size: 0.85em;">Download Current</button>
              <button class="toolbar-btn" onclick="resetGlossaryToDefault()" style="font-size: 0.85em; background: #f5f5f5; color: #666;">Reset to Default</button>
            </div>
            <div id="glossary-upload-status" style="display: none; padding: 10px; border-radius: 6px; margin-top: 12px; font-size: 0.85em;"></div>
            <div id="glossary-sheet-map" style="margin-top: 15px;"></div>
          </div>

        </div><!-- end admin-tab-config -->

        <!-- INSPECTOR TAB -->
        <div id="admin-tab-inspector" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">JSON Inspector</h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">View raw JSON data for current session artifacts.</p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
              <button class="toolbar-btn" onclick="inspectJSON('sf_packet')">SF Packet</button>
              <button class="toolbar-btn" onclick="inspectJSON('base_config')">Base Config</button>
              <button class="toolbar-btn" onclick="inspectJSON('patch_config')">Patch Config</button>
              <button class="toolbar-btn" onclick="inspectJSON('dataset')">Dataset</button>
            </div>
            <div id="admin-json-inspector" style="background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 0.75em; max-height: 400px; overflow-y: auto; white-space: pre-wrap;">
              <em style="color: #888;">Select an artifact to inspect...</em>
            </div>
            <div style="margin-top: 10px;">
              <button class="toolbar-btn" onclick="copyInspectorJSON()">Copy JSON</button>
            </div>
          </div>
        </div><!-- end admin-tab-inspector -->

        <!-- PEOPLE TAB (P0.7) -->
        <div id="admin-tab-people" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <!-- People Sub-Tabs -->
          <div style="display: flex; gap: 4px; margin-bottom: 16px; border-bottom: 1px solid #e0e0e0;">
            <button class="people-sub-tab active" data-people-tab="members" onclick="switchPeopleTab('members')" style="padding: 8px 16px; background: #1976d2; color: white; border: none; border-radius: 4px 4px 0 0; cursor: pointer; font-size: 0.85em; font-weight: 600;">Members</button>
            <button class="people-sub-tab" data-people-tab="roles" onclick="switchPeopleTab('roles')" style="padding: 8px 16px; background: #f5f5f5; color: #666; border: none; border-radius: 4px 4px 0 0; cursor: pointer; font-size: 0.85em;">Roles</button>
            <button class="people-sub-tab" data-people-tab="invites" onclick="switchPeopleTab('invites')" style="padding: 8px 16px; background: #f5f5f5; color: #666; border: none; border-radius: 4px 4px 0 0; cursor: pointer; font-size: 0.85em;">Invites</button>
          </div>

          <!-- Members Sub-Panel -->
          <div id="people-tab-members" class="people-sub-panel" style="background: white; padding: 16px; border-radius: 8px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h4 style="margin: 0 0 12px; font-size: 0.95em; color: #333;">Members</h4>
            <div id="people-members-table"></div>
          </div>

          <!-- Roles Sub-Panel -->
          <div id="people-tab-roles" class="people-sub-panel" style="display: none; background: white; padding: 16px; border-radius: 8px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h4 style="margin: 0 0 12px; font-size: 0.95em; color: #333;">Role Configuration <span style="font-size: 0.75em; color: #999;">(Architect-only edit)</span></h4>
            <div id="people-roles-table"></div>
          </div>

          <!-- Invites Sub-Panel -->
          <div id="people-tab-invites" class="people-sub-panel" style="display: none; background: white; padding: 16px; border-radius: 8px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h4 style="margin: 0 0 12px; font-size: 0.95em; color: #333;">Invites</h4>
            <div id="people-invite-form" style="margin-bottom: 16px; padding: 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #eee;">
              <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: flex-end;">
                <div>
                  <label style="font-size: 0.75em; color: #666; display: block;">Role</label>
                  <select id="invite-role-select" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em;">
                    <option value="analyst">Analyst</option>
                    <option value="verifier">Verifier</option>
                    <option value="admin">Admin</option>
                  </select>
                </div>
                <div>
                  <label style="font-size: 0.75em; color: #666; display: block;">Expiry (hours)</label>
                  <input type="number" id="invite-expiry-input" placeholder="optional" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; width: 80px;">
                </div>
                <div>
                  <label style="font-size: 0.75em; color: #666; display: block;">Note</label>
                  <input type="text" id="invite-note-input" placeholder="optional" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; width: 140px;">
                </div>
                <button onclick="createInviteFromForm()" style="padding: 6px 14px; font-size: 0.85em; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">Create Invite</button>
              </div>
            </div>
            <div id="people-invites-table"></div>
          </div>
        </div><!-- end admin-tab-people -->

        <div id="admin-tab-qa-runner" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <h3 style="margin: 0 0 16px 0; color: #1a237e;">QA Runner</h3>
          <p style="color: #666; font-size: 0.9em; margin: 0 0 16px 0;">Run in-browser validation suites to verify all governance features are working correctly.</p>
          <div id="p1b-run-controls" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px;">
            <button onclick="QARunner.runSuite('p022')" class="p1b-run-btn" style="padding: 6px 14px; font-size: 0.85em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Run P0.2.2</button>
            <button onclick="QARunner.runSuite('p1')" class="p1b-run-btn" style="padding: 6px 14px; font-size: 0.85em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Run P1</button>
            <button onclick="QARunner.runSuite('calibration')" class="p1b-run-btn" style="padding: 6px 14px; font-size: 0.85em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Run Calibration</button>
            <button onclick="QARunner.runSuite('p08')" class="p1b-run-btn" style="padding: 6px 14px; font-size: 0.85em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Run P0.8</button>
            <button onclick="QARunner.runSuite('p09')" class="p1b-run-btn" style="padding: 6px 14px; font-size: 0.85em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Run P0.9</button>
            <button onclick="QARunner.runSuite('p1a')" class="p1b-run-btn" style="padding: 6px 14px; font-size: 0.85em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Run P1A</button>
            <button onclick="QARunner.runAll()" style="padding: 6px 14px; font-size: 0.85em; background: #388e3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Run All</button>
            <button onclick="QARunner.exportReport()" style="padding: 6px 14px; font-size: 0.85em; background: #f57c00; color: white; border: none; border-radius: 4px; cursor: pointer;">Export QA Report JSON</button>
          </div>
          <div id="p1b-quality-lock" style="display: none; margin-bottom: 12px; padding: 8px 12px; background: #fff3e0; border-radius: 6px; border: 1px solid #ffe0b2;">
            <label style="font-size: 0.85em; color: #e65100; cursor: pointer;">
              <input type="checkbox" id="p1b-lock-toggle" onchange="QARunner.toggleQualityLock(this.checked)" style="margin-right: 6px;">
              Quality Lock Candidate (Architect only)
            </label>
            <span id="p1b-lock-status" style="margin-left: 8px; font-size: 0.8em; color: #999;"></span>
          </div>
          <div id="p1b-running-status" style="display: none; padding: 10px; background: #e3f2fd; border-radius: 6px; margin-bottom: 12px;">
            <span id="p1b-running-label" style="font-size: 0.9em; color: #1565c0;">Running...</span>
          </div>
          <table id="p1b-results-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em; margin-bottom: 16px;">
            <thead>
              <tr style="background: #f5f5f5; text-align: left;">
                <th style="padding: 8px; border-bottom: 2px solid #ddd;">Suite</th>
                <th style="padding: 8px; border-bottom: 2px solid #ddd;">Started</th>
                <th style="padding: 8px; border-bottom: 2px solid #ddd;">Finished</th>
                <th style="padding: 8px; border-bottom: 2px solid #ddd;">Result</th>
                <th style="padding: 8px; border-bottom: 2px solid #ddd;">Metrics</th>
                <th style="padding: 8px; border-bottom: 2px solid #ddd;">Details</th>
              </tr>
            </thead>
            <tbody id="p1b-results-tbody"></tbody>
          </table>
          <h4 style="margin: 24px 0 8px 0; color: #37474f;">Run History</h4>
          <table id="p1b-history-table" style="width: 100%; border-collapse: collapse; font-size: 0.82em;">
            <thead>
              <tr style="background: #fafafa; text-align: left;">
                <th style="padding: 6px; border-bottom: 1px solid #eee;">Run ID</th>
                <th style="padding: 6px; border-bottom: 1px solid #eee;">Timestamp</th>
                <th style="padding: 6px; border-bottom: 1px solid #eee;">Suites</th>
                <th style="padding: 6px; border-bottom: 1px solid #eee;">Result</th>
                <th style="padding: 6px; border-bottom: 1px solid #eee;">Locked</th>
              </tr>
            </thead>
            <tbody id="p1b-history-tbody"></tbody>
          </table>
        </div><!-- end admin-tab-qa-runner -->


        <div style="margin-top: 12px; text-align: right; font-size: 0.75em; color: #aaa;">PAGE: ADMIN-PANEL | BUILD v1.6.49</div>
      </div><!-- end page-admin -->

    </main><!-- end main-content -->
  </div><!-- end app-layout -->

  <!-- Staged Loader Overlay -->
  <div id="staged-loader-overlay" class="staged-loader-overlay" style="display: none;">
    <div class="staged-loader-content">
      <div class="staged-loader-spinner"></div>
      <div class="staged-loader-title">Loading Dataset</div>
      <div class="staged-loader-stages">
        <div class="staged-loader-stage" data-stage="loading">
          <span class="stage-icon">○</span>
          <span class="stage-label">Loading dataset</span>
        </div>
        <div class="staged-loader-stage" data-stage="standardizing">
          <span class="stage-icon">○</span>
          <span class="stage-label">Standardizing fields</span>
        </div>
        <div class="staged-loader-stage" data-stage="validating">
          <span class="stage-icon">○</span>
          <span class="stage-label">Validating rules</span>
        </div>
        <div class="staged-loader-stage" data-stage="changemap">
          <span class="stage-icon">○</span>
          <span class="stage-label">Building change map</span>
        </div>
        <div class="staged-loader-stage" data-stage="rendering">
          <span class="stage-icon">○</span>
          <span class="stage-label">Rendering grid</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Global Modals and Drawers (outside pages) -->
  <!-- Data Source Drawer (right-side slide-over) -->
  <div class="drawer-overlay" id="data-source-drawer">
    <div class="drawer">
      <div class="drawer-header">
        <h3>Data Source</h3>
        <button class="drawer-close" onclick="closeDataSourceDrawer()">&times;</button>
      </div>
      <div class="drawer-body">
        <!-- v1.6.39: Upload Excel Button (primary action for demo) -->
        <div style="margin-bottom: 20px; padding: 16px; background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border-radius: 10px; border: 1px solid #bbdefb; text-align: center;">
          <div style="font-size: 2em; margin-bottom: 8px;">📊</div>
          <div style="font-weight: 600; color: #1565c0; margin-bottom: 8px;">Import Your Data</div>
          <p style="font-size: 0.85em; color: #666; margin: 0 0 12px;">Upload an Excel file (.xlsx) to start working</p>
          <button id="drawer-upload-excel-btn" onclick="document.getElementById('drawer-excel-file-input').click()" 
                  style="padding: 10px 24px; background: linear-gradient(135deg, #1a73e8 0%, #0d47a1 100%); color: white; border: none; border-radius: 8px; font-size: 0.9em; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); transition: all 0.2s ease; font-weight: 500;"
                  onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)';"
                  onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)';">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            Upload Excel
          </button>
          <input type="file" id="drawer-excel-file-input" accept=".xlsx,.xls" style="display: none;" onchange="handleExcelUpload(this); closeDataSourceDrawer();">
          <!-- v1.6.46: Clear Cache button for fresh start -->
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px dashed #ddd;">
            <button id="clear-cache-btn" onclick="handleClearCacheAndReload()" 
                    style="padding: 6px 16px; background: transparent; color: #666; border: 1px solid #ccc; border-radius: 6px; font-size: 0.8em; cursor: pointer; transition: all 0.2s ease;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.color='#333'"
                    onmouseout="this.style.background='transparent'; this.style.color='#666'">
              🔄 Start Fresh (Clear Cache)
            </button>
            <p style="font-size: 0.75em; color: #999; margin: 6px 0 0; text-align: center;">Clears saved session data</p>
          </div>
        </div>
        
        <!-- Saved Sessions Section -->
        <div class="saved-sessions-section">
          <div class="saved-sessions-header">
            <span class="saved-sessions-title">Saved Sessions</span>
            <button class="save-session-btn" id="save-session-btn" onclick="promptSaveSession()">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
              Save Session
            </button>
          </div>
          <div id="saved-sessions-list"></div>
        </div>

        <div id="demo-divider-or-load" style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
          <div style="flex: 1; height: 1px; background: #e0e0e0;"></div>
          <span style="font-size: 0.75em; color: #999; text-transform: uppercase;">Or load demo data</span>
          <div style="flex: 1; height: 1px; background: #e0e0e0;"></div>
        </div>
        
        <!-- Connected Folder Section (v1.4.24 - auto-mapped from email, read-only) -->
        <div id="data-source-folder-section" style="display: none; margin-bottom: 20px;">
          <div class="folder-connected-card" style="text-align: center;">
            <div class="folder-connected-icon">📁</div>
            <div class="folder-connected-label">Connected Folder</div>
            <div class="folder-connected-name" id="connected-folder-name" style="text-align: center;">—</div>
            <div class="folder-sync-time" id="folder-sync-time">Last sync: —</div>
          </div>
        </div>
        
        <!-- Empty State Section (v1.4.24 - should not appear, folder auto-mapped) -->
        <div id="data-source-empty-section" style="display: none;">
          <div style="text-align: center; padding: 24px 20px; color: #888; background: #f5f5f5; border-radius: 8px; border: 2px dashed #ddd; margin-bottom: 20px;">
            <div style="font-size: 2em; margin-bottom: 10px;">📁</div>
            <div style="font-weight: 600; color: #333; margin-bottom: 8px;">Folder Not Assigned</div>
            <p style="margin: 0; font-size: 0.9em;">Please sign out and sign in again to assign your folder.</p>
          </div>
        </div>
        
        <!-- Active Dataset Section (shown when data loaded) -->
        <div id="data-source-active-section" style="display: none; margin-bottom: 20px; padding: 16px; background: #e8f5e9; border: 1px solid #81c784; border-radius: 8px; position: relative;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
            <span style="font-size: 1.5em;">📊</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 0.95em; color: #2e7d32;">Active Dataset</div>
              <div id="active-dataset-name" style="font-size: 0.85em; color: #555; font-family: monospace;">—</div>
            </div>
            <div class="active-badge-container" style="position: relative;">
              <span id="active-badge" class="active-badge-hover" style="background: #4caf50; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; cursor: pointer;" onclick="toggleDisconnectMenu(event)">ACTIVE ▾</span>
              <div id="disconnect-menu" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 4px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; min-width: 140px;">
                <button onclick="disconnectActiveDataset()" style="display: block; width: 100%; padding: 10px 14px; background: none; border: none; text-align: left; cursor: pointer; font-size: 0.85em; color: #c62828;" onmouseover="this.style.background='#ffebee'" onmouseout="this.style.background='none'">
                  ⏏ Disconnect
                </button>
              </div>
            </div>
          </div>
          <div id="active-dataset-meta" style="font-size: 0.8em; color: #666;">
            <!-- Row count, loaded timestamp -->
          </div>
        </div>
        
        <!-- Upload Section removed (v1.4.23 - folder-based workflow) -->
        <div id="data-source-upload-section" style="display: none;"></div>
        
        <!-- Search Stub (V2) - Disabled -->
        <div id="data-source-search-section" style="display: none; margin-bottom: 16px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
            <span style="font-weight: 600; font-size: 0.85em; color: #999;">Search</span>
            <span style="font-size: 0.7em; background: #e0e0e0; padding: 1px 5px; border-radius: 3px; font-weight: 600; color: #666;">Coming Soon</span>
          </div>
          <input type="text" id="data-source-search-input" placeholder="Search coming with Drive integration..." disabled style="width: 100%; padding: 10px 12px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; box-sizing: border-box; background: #f5f5f5; color: #999; cursor: not-allowed;">
        </div>
        
        <!-- Saved Datasets Section (v1.6.8) -->
        <div id="data-source-demo-section" style="margin-bottom: 16px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
            <span style="font-weight: 600; font-size: 0.85em; color: #666; text-transform: uppercase;">Saved Datasets</span>
          </div>
          <!-- v1.6.8: In-Progress Banner (shown when modified dataset is active) -->
          <div id="demo-modified-banner" style="display: none; margin-bottom: 10px; padding: 8px 12px; background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; font-size: 0.8em; color: #e65100;">
            <span style="margin-right: 6px;">⚠️</span> Demo dataset is in-progress (partial completion).
          </div>
          <!-- Original Dataset Card -->
          <div id="demo-dataset-card-original" class="demo-dataset-card" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #f0f7ff; border: 2px solid #90caf9; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 8px;" onclick="loadSampleDataset({ variant: 'original', autoRedirect: true })" onmouseover="this.style.background='#e3f2fd'" onmouseout="this.style.background=this.classList.contains('active') ? '#e3f2fd' : '#f0f7ff'">
            <span style="font-size: 1.3em;">📋</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 0.9em; color: #1565c0;">Ostereo (Original)</div>
              <div style="font-size: 0.75em; color: #666;">Baseline dataset (clean)</div>
            </div>
            <span class="demo-card-load-arrow" style="color: #1976d2; font-size: 0.8em; font-weight: 600;">Load →</span>
          </div>
          <!-- Modified Dataset Card -->
          <div id="demo-dataset-card-modified" class="demo-dataset-card" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px; cursor: pointer; transition: all 0.2s;" onclick="loadSampleDataset({ variant: 'modified', autoRedirect: true })" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background=this.classList.contains('active') ? '#fff3e0' : '#fafafa'">
            <span style="font-size: 1.3em;">📝</span>
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-weight: 600; font-size: 0.9em; color: #e65100;">Ostereo (Modified / In-Progress)</span>
                <span style="font-size: 0.65em; background: #ff9800; color: white; padding: 2px 6px; border-radius: 3px; font-weight: 600;">In-Progress</span>
              </div>
              <div style="font-size: 0.75em; color: #666;">Partial completion with sample edits</div>
            </div>
            <span class="demo-card-load-arrow" style="color: #e65100; font-size: 0.8em; font-weight: 600;">Load →</span>
          </div>
        </div>
        
        <!-- Drive Files Section (v1.4.24 - read-only stub) -->
        <div id="data-source-library-header" style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <span style="font-weight: 600; font-size: 0.85em; color: #666; text-transform: uppercase;">Drive Files</span>
            <span style="font-size: 0.65em; background: #e0e0e0; padding: 2px 6px; border-radius: 3px; font-weight: 600; color: #666;">Coming Soon</span>
          </div>
          <p style="color: #888; font-size: 0.8em; margin: 0;">Files from your assigned folder (read-only).</p>
        </div>
        
        <!-- Drive Files List (mocked) -->
        <div id="upload-library-list" style="display: flex; flex-direction: column; gap: 10px;">
          <!-- Populated by renderDriveFilesList() -->
        </div>
        
        <div class="modal-status" id="data-source-status" style="display: none; margin-top: 15px;"></div>
      </div>
      <div class="drawer-footer">
        <button class="modal-btn modal-btn-secondary" onclick="closeDataSourceDrawer()" style="width: 100%;">Close</button>
      </div>
    </div>
  </div>

  <!-- Loader Modal (centered overlay for data loading) -->
  <div class="loader-modal-overlay" id="loader-modal-overlay" onclick="closeLoaderModal(event)">
    <div class="loader-modal" id="loader-modal" onclick="event.stopPropagation()">
      <div class="loader-modal-header">
        <h3>Data Source</h3>
        <button class="loader-modal-close" id="loader-modal-close-btn" onclick="closeLoaderModal()" aria-label="Close">&times;</button>
      </div>
      <div class="loader-modal-body">
        <!-- Inline Error Display (v1.4.4) -->
        <div id="loader-error-display" style="display: none; margin-bottom: 16px; padding: 12px 16px; background: #ffebee; border: 1px solid #ef5350; border-radius: 8px; color: #c62828;">
          <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 1.1em;">⚠️</span>
            <div id="loader-error-message" style="flex: 1; font-size: 0.9em;"></div>
          </div>
        </div>
        <!-- Column Mapping Warning Banner (v1.4.12) -->
        <div id="column-mapping-banner" style="display: none; margin-bottom: 16px; padding: 12px 16px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 8px; color: #e65100;">
          <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 1.1em;">⚠️</span>
            <div id="column-mapping-message" style="flex: 1; font-size: 0.9em;"></div>
          </div>
        </div>
        
        <!-- Import CSV Section -->
        <div style="margin-bottom: 20px;">
          <div style="font-weight: 600; margin-bottom: 10px; color: #333;">Upload / Add Data Source</div>
          <div class="drop-zone" id="loader-drawer-dropzone" onclick="document.getElementById('loader-drawer-file').click();">
            <div class="drop-zone-icon">📄</div>
            <div class="drop-zone-text">Drop CSV or XLSX file here or click to browse</div>
            <div class="drop-zone-file" id="loader-drawer-file-name" style="display: none;"></div>
          </div>
          <input type="file" id="loader-drawer-file" accept=".csv,.xlsx" style="display: none;">
          <div style="font-size: 0.75em; color: #888; margin-top: 6px;">Supported: CSV, XLSX files</div>
        </div>
        
        <!-- Folder Connection Info (v1.4.24 - auto-mapped, read-only) -->
        <div id="loader-folder-info" style="margin-bottom: 20px; padding: 15px; background: #e8f5e9; border-radius: 8px; border: 1px solid #81c784; display: none;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 1.2em;">📁</span>
            <div style="flex: 1; text-align: center;">
              <div style="font-weight: 600; font-size: 0.9em; color: #2e7d32;">Connected Folder</div>
              <div id="loader-folder-name" style="font-size: 0.85em; color: #558b2f;">—</div>
            </div>
          </div>
        </div>
        
        <!-- Empty Folder State (v1.4.24 - should not appear) -->
        <div id="loader-no-folder" style="margin-bottom: 20px; padding: 15px; background: #fff3e0; border-radius: 8px; border: 1px solid #ff9800; display: none;">
          <div style="text-align: center;">
            <div style="font-size: 1.5em; margin-bottom: 8px;">📂</div>
            <div style="font-weight: 600; font-size: 0.9em; color: #e65100;">Please sign in again to assign your folder.</div>
          </div>
        </div>
        
        <!-- Admin Utilities (admin-only) -->
        <div class="admin-only-content" style="border-top: 1px solid #e0e0e0; padding-top: 15px; margin-top: 15px;">
          <div style="font-weight: 600; margin-bottom: 10px; color: #888; font-size: 0.85em;">ADMIN UTILITIES</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="top-toolbar-btn" id="btn-reset-demo-state-admin" onclick="resetDemoState();">Reset Demo State</button>
            <button class="top-toolbar-btn" onclick="rebuildFieldIndex();">Rebuild Index</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Folder Selection Modal removed (v1.4.24 - folder auto-mapped from email) -->

  <!-- Config Flows Drawer (right-side slide-over for admin config editing) -->
  <div class="drawer-overlay" id="config-flows-drawer">
    <div class="drawer" style="width: 700px;">
      <div class="drawer-header" style="background: linear-gradient(135deg, #1a1a2e 0%, #2d2d44 100%);">
        <h3>Config Flows</h3>
        <button class="drawer-close" onclick="closeConfigFlows()">&times;</button>
      </div>
      <div class="drawer-body" style="display: flex; gap: 0; padding: 0;">
        <!-- Workflow Rail (Left Column) -->
        <div class="config-flows-rail" style="width: 200px; background: #f8f9fa; border-right: 1px solid #e0e0e0; padding: 15px 0; flex-shrink: 0;">
          <div class="rail-header" style="padding: 0 15px 10px; font-size: 0.75em; color: #666; text-transform: uppercase; font-weight: 600;">Workflow Stages</div>
          <div class="rail-items" id="config-flows-rail">
            <a class="rail-item active" data-stage="data_sources" onclick="selectConfigFlowStage('data_sources')">
              <span class="rail-number">1</span>
              <span class="rail-label">Data Sources</span>
            </a>
            <a class="rail-item" data-stage="dataset_mapping" onclick="selectConfigFlowStage('dataset_mapping')">
              <span class="rail-number">2</span>
              <span class="rail-label">Dataset Mapping</span>
            </a>
            <a class="rail-item" data-stage="standardization" onclick="selectConfigFlowStage('standardization')">
              <span class="rail-number">3</span>
              <span class="rail-label">Standardization</span>
            </a>
            <a class="rail-item" data-stage="ruleset" onclick="selectConfigFlowStage('ruleset')">
              <span class="rail-number">4</span>
              <span class="rail-label">Ruleset</span>
            </a>
            <a class="rail-item" data-stage="validation_gates" onclick="selectConfigFlowStage('validation_gates')">
              <span class="rail-number">5</span>
              <span class="rail-label">Validation Gates</span>
            </a>
            <a class="rail-item" data-stage="patch_generation" onclick="selectConfigFlowStage('patch_generation')">
              <span class="rail-number">6</span>
              <span class="rail-label">Patch Generation</span>
            </a>
            <a class="rail-item" data-stage="smoke_baselines" onclick="selectConfigFlowStage('smoke_baselines')">
              <span class="rail-number">7</span>
              <span class="rail-label">Smoke Baselines</span>
            </a>
            <a class="rail-item" data-stage="export" onclick="selectConfigFlowStage('export')">
              <span class="rail-number">8</span>
              <span class="rail-label">Export / PR</span>
            </a>
          </div>
        </div>
        
        <!-- Flow Stage Detail (Main Column) -->
        <div class="config-flows-detail" style="flex: 1; padding: 20px; overflow-y: auto;">
          <div class="stage-header" style="margin-bottom: 15px;">
            <h4 id="config-flow-stage-title" style="margin: 0 0 5px; font-size: 1.1em;">Data Sources</h4>
            <p id="config-flow-stage-desc" style="margin: 0; color: #666; font-size: 0.9em;">Configure where data is loaded from.</p>
          </div>
          <div class="stage-tabs" style="display: flex; gap: 0; border-bottom: 1px solid #e0e0e0; margin-bottom: 15px;">
            <button class="stage-tab active" data-tab="plain-english" onclick="selectConfigFlowTab('plain-english')">Plain-English</button>
            <button class="stage-tab" data-tab="payload" onclick="selectConfigFlowTab('payload')">Payload</button>
            <button class="stage-tab" data-tab="master" onclick="selectConfigFlowTab('master')">Master</button>
            <button class="stage-tab" data-tab="diff" onclick="selectConfigFlowTab('diff')">Diff</button>
            <button class="stage-tab" data-tab="history" onclick="selectConfigFlowTab('history')">History</button>
          </div>
          <div id="config-flow-tab-content">
            <!-- Tab content rendered dynamically -->
            <div style="padding: 20px; background: #f5f5f5; border-radius: 6px; color: #666;">
              <p>This stage configures how Preview and Reference packets are loaded into the session.</p>
              <p style="margin-top: 10px;">Available methods:</p>
              <ul style="margin: 10px 0 0 20px;">
                <li>Repo Masters (auto-load from repository)</li>
                <li>Paste JSON (manual paste)</li>
                <li>Drag & Drop (file upload)</li>
                <li>Local Path Hint (reference local files)</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Record Detail Drawer (right-side slide-over for contract details) -->
  <div class="drawer-overlay" id="record-drawer">
    <div class="drawer" style="width: 500px;">
      <div class="drawer-header">
        <h3 id="record-drawer-title">Record Details</h3>
        <button class="drawer-close" onclick="closeRecordDrawer()">&times;</button>
      </div>
      <div class="drawer-body" id="record-drawer-content">
        <p style="color: #666;">Select a contract to view details.</p>
      </div>
      <div class="drawer-footer">
        <div style="display: flex; gap: 10px; justify-content: space-between;">
          <button class="modal-btn modal-btn-secondary" id="record-drawer-prev" onclick="navigateRecord(-1)" disabled>Previous</button>
          <span id="record-drawer-position" style="line-height: 36px; color: #666;">-/-</span>
          <button class="modal-btn modal-btn-secondary" id="record-drawer-next" onclick="navigateRecord(1)" disabled>Next</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Patch Request Detail Drawer -->
  <div class="drawer-overlay" id="patch-detail-drawer">
    <div class="drawer" style="width: 550px;">
      <div class="drawer-header" style="background: #7b1fa2; color: white;">
        <h3 id="patch-detail-title">Patch Request Details</h3>
        <button class="drawer-close" onclick="closePatchDetailDrawer()" style="color: white;">&times;</button>
      </div>
      <div class="drawer-body" id="patch-detail-content" style="padding: 20px;">
        <p style="color: #666;">Select a patch request to view details.</p>
      </div>
      <div class="drawer-footer" id="patch-detail-footer" style="border-top: 1px solid #eee; padding: 15px;">
      </div>
    </div>
  </div>

  <!-- Ruleset Modal -->
  <div class="modal-overlay" id="ruleset-modal">
    <div class="modal wizard-modal">
      <div class="modal-header">
        <h3>Ruleset Configuration</h3>
        <button class="modal-close" onclick="closeRulesetModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="wizard-section">
          <h4>Base (Truth)</h4>
          <div class="wizard-field">
            <label>Base Config Path</label>
            <input type="text" id="wizard-base-config" value="config/config_pack.base.json" placeholder="config/config_pack.base.json">
            <div class="hint">The authoritative semantic ruleset</div>
          </div>
        </div>
        <div class="wizard-section">
          <h4>Patch (Proposed)</h4>
          <div class="wizard-field">
            <label>Patch Path</label>
            <input type="text" id="wizard-patch-config" value="config/config_pack.example.patch.json" placeholder="config/config_pack.example.patch.json">
            <div class="hint">Optional patch file with proposed changes</div>
          </div>
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-primary" id="wizard-load-ruleset">Load Ruleset</button>
          <button class="modal-btn modal-btn-secondary" onclick="closeRulesetModal()">Cancel</button>
        </div>
        <div class="modal-status" id="ruleset-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Compare Modal -->
  <div class="modal-overlay" id="compare-modal">
    <div class="modal wizard-modal">
      <div class="modal-header">
        <h3>Comparison Mode</h3>
        <button class="modal-close" onclick="closeCompareModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="wizard-section">
          <h4>Compare Artifact (Optional)</h4>
          <div class="wizard-field">
            <label>Comparison Artifact Path</label>
            <input type="text" id="wizard-compare-path" placeholder="out/sf_packet.preview.prev.json">
            <div class="hint">Load a previous artifact to compare changes and view deltas</div>
          </div>
          <div class="wizard-preset">
            <button class="wizard-preset-btn" data-compare="out/sf_packet.preview.prev.json">Previous Preview</button>
            <button class="wizard-preset-btn" data-compare="">Clear Compare</button>
          </div>
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-primary" id="wizard-load-compare">Load Comparison</button>
          <button class="modal-btn modal-btn-secondary" onclick="closeCompareModal()">Cancel</button>
        </div>
        <div class="modal-status" id="compare-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Run Commands Modal -->
  <div class="modal-overlay" id="run-modal">
    <div class="modal wizard-modal">
      <div class="modal-header">
        <h3>Run Commands</h3>
        <button class="modal-close" onclick="closeRunModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 15px; color: #666;">Copy validation and preview commands to run in your terminal. This viewer does not execute commands directly.</p>
        <div class="wizard-section">
          <h4>Validation &amp; Preview Commands</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
            <button class="toolbar-btn" data-cmd="validate">Validate</button>
            <button class="toolbar-btn" data-cmd="preview_baseline">Preview Baseline</button>
            <button class="toolbar-btn" data-cmd="preview_edge">Preview Edge</button>
            <button class="toolbar-btn" data-cmd="smoke_baseline">Smoke Baseline</button>
            <button class="toolbar-btn" data-cmd="smoke_edge">Smoke Edge</button>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="run-modal-confirm">
            <label for="run-modal-confirm" style="color: #f57c00; font-size: 0.9em;">I CONFIRM RUN</label>
          </div>
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-secondary" onclick="closeRunModal()">Close</button>
        </div>
        <div class="modal-status" id="run-modal-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Configure Wizard Modal -->
  <div class="modal-overlay" id="configure-wizard-modal">
    <div class="modal wizard-modal" style="max-width: 550px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #7c4dff 0%, #536dfe 100%);">
        <h3 id="wizard-step-title">Configure Kiwi</h3>
        <button class="modal-close" onclick="closeConfigureWizard()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="wizard-progress" style="display: flex; gap: 8px; margin-bottom: 20px;">
          <span class="wizard-step-dot active" data-step="0"></span>
          <span class="wizard-step-dot" data-step="1"></span>
          <span class="wizard-step-dot" data-step="2"></span>
          <span class="wizard-step-dot" data-step="3"></span>
        </div>
        <div id="wizard-step-content">
          <!-- Step content rendered dynamically -->
        </div>
        <div class="modal-actions" style="margin-top: 20px; justify-content: space-between;">
          <button class="modal-btn modal-btn-secondary" id="wizard-back" onclick="wizardBack()" style="display: none;">Back</button>
          <button class="modal-btn modal-btn-primary" id="wizard-next" onclick="wizardNext()" style="margin-left: auto;">Next</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Command Modal (legacy) -->
  <div class="modal-overlay" id="command-modal">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modal-title">Command</h3>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <p id="modal-description" style="margin-bottom: 15px; color: #666;"></p>
        <div class="modal-command" id="modal-command"></div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-primary" id="modal-copy">Copy to Clipboard</button>
          <button class="modal-btn modal-btn-danger" id="modal-run" disabled>Run (Confirm Required)</button>
          <button class="modal-btn modal-btn-secondary" id="modal-cancel">Cancel</button>
        </div>
        <div class="modal-status" id="modal-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <div class="drawer-overlay" id="drawer-overlay"></div>
  <div class="drawer" id="drawer">
    <div class="drawer-header">
      <div class="drawer-header-row">
        <h3>Record Workbench</h3>
        <button class="drawer-close" id="drawer-close">&times;</button>
      </div>
      <div class="drawer-identity">
        <div class="identity-pill" id="identity-pill"></div>
        <button class="identity-copy" id="identity-copy">Copy ID</button>
      </div>
    </div>
    <div class="drawer-tabs" id="drawer-tabs">
      <button class="drawer-tab active" data-tab="contract">Contract</button>
      <button class="drawer-tab" data-tab="issues">Issues <span class="drawer-tab-count" id="issues-count">0</span></button>
      <button class="drawer-tab" data-tab="actions">Actions <span class="drawer-tab-count" id="actions-count">0</span></button>
      <button class="drawer-tab" data-tab="changelog">Change Log <span class="drawer-tab-count" id="changelog-count">0</span></button>
      <button class="drawer-tab" data-tab="patch-studio" style="background: #2e7d32; color: white;">Patch Studio</button>
    </div>
    <div class="drawer-warning" id="drawer-warning" style="display: none;"></div>
    <div class="drawer-body" id="drawer-body"></div>
    <div class="drawer-panel" id="patch-studio-panel" style="display: none; flex: 1; overflow-y: auto; padding: 0;">
      <div class="patch-studio-sub-tabs" style="display: flex; background: #263238; flex-shrink: 0;">
        <button class="patch-studio-sub-tab active" data-subtab="draft" style="flex: 1; padding: 10px; border: none; background: #1a1a2e; color: white; cursor: pointer; font-size: 0.85em;">Draft</button>
        <button class="patch-studio-sub-tab" data-subtab="preflight" style="flex: 1; padding: 10px; border: none; background: #263238; color: #aaa; cursor: pointer; font-size: 0.85em;">Preflight</button>
        <button class="patch-studio-sub-tab" data-subtab="evidence" style="flex: 1; padding: 10px; border: none; background: #263238; color: #aaa; cursor: pointer; font-size: 0.85em;">Evidence Pack</button>
      </div>
      <div class="patch-studio-sub-panel" id="subtab-draft" style="padding: 15px;">
        <fieldset style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
          <legend style="font-weight: 600; font-size: 0.85em; color: #1565c0; padding: 0 8px;">WHEN (condition)</legend>
          <div style="margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Target Field</label>
            <select id="ps-target-field" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
              <option value="">-- Select field --</option>
            </select>
            <span style="font-size: 0.75em; color: #888;">e.g., contracts.label_name</span>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Condition Type</label>
            <select id="ps-condition-type" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
              <option value="">-- Select condition --</option>
              <option value="SHOULD_BE_BLANK_BUT_POPULATED">Should be blank but has data</option>
              <option value="SHOULD_BE_PRESENT_BUT_MISSING">Should have data but is empty</option>
              <option value="INVALID_FORMAT">Invalid format/pattern</option>
              <option value="OUT_OF_RANGE">Value out of allowed range</option>
              <option value="MISMATCH_WITH_OTHER_FIELD">Mismatches another field</option>
              <option value="DUPLICATE">Duplicate value detected</option>
              <option value="OTHER">Other (specify below)</option>
            </select>
          </div>
          <div id="ps-condition-other-wrap" style="display: none; margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Describe condition (required for Other)</label>
            <input type="text" id="ps-condition-other" placeholder="e.g., contains 'Various Artists'" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
          </div>
        </fieldset>
        
        <fieldset style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
          <legend style="font-weight: 600; font-size: 0.85em; color: #2e7d32; padding: 0 8px;">THEN (action)</legend>
          <div style="margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Action Type</label>
            <select id="ps-action-type" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
              <option value="">-- Select action --</option>
              <option value="REQUIRE_PRESENT">Require field to have a value</option>
              <option value="REQUIRE_BLANK">Require field to be blank</option>
              <option value="WARN_ONLY">Warn only (non-blocking)</option>
              <option value="NORMALIZE_VALUE">Normalize/standardize value</option>
              <option value="MAP_FIELD">Map to another field</option>
              <option value="BLOCK_SUBMISSION">Block submission</option>
              <option value="OTHER">Other (specify below)</option>
            </select>
          </div>
          <div id="ps-action-other-wrap" style="display: none; margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Describe action (required for Other)</label>
            <input type="text" id="ps-action-other" placeholder="e.g., require artist_name to be present" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
          </div>
        </fieldset>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Comment (plain English) <span style="color: #c62828;">*</span></label>
          <textarea id="ps-intent-because" placeholder="Explain why this rule exists in human terms. This is what verifiers/admins will read." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 60px;"></textarea>
          <span style="font-size: 0.75em; color: #888;">Required. Max 500 characters.</span>
        </div>
        
        <div style="background: #f5f5f5; border-radius: 6px; padding: 12px; margin-bottom: 15px; border-left: 3px solid #1565c0;">
          <div style="font-weight: 600; font-size: 0.8em; color: #1565c0; margin-bottom: 8px;">Intent Preview</div>
          <div id="ps-intent-preview" style="font-size: 0.85em; color: #333;">
            <div><strong>WHEN:</strong> <span id="preview-when" style="color: #666;">(select field and condition)</span></div>
            <div><strong>THEN:</strong> <span id="preview-then" style="color: #666;">(select action)</span></div>
            <div><strong>BECAUSE:</strong> <span id="preview-because" style="color: #666;">(enter comment)</span></div>
          </div>
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Target Artifact</label>
          <select id="ps-target" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
            <option value="proposed_changes">Proposed Changes</option>
            <option value="salesforce">Salesforce Rules</option>
            <option value="qa_rules">QA Rules</option>
            <option value="resolver_rules">Resolver Rules</option>
            <option value="truth_config">Truth Config</option>
          </select>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Risk Level</label>
          <select id="ps-risk" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
            <option value="low">Low - minor adjustment</option>
            <option value="medium">Medium - affects multiple records</option>
            <option value="high">High - significant system change</option>
          </select>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Rationale (optional)</label>
          <textarea id="ps-rationale" placeholder="Additional context or notes..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 40px;"></textarea>
        </div>
      </div>
      <div class="patch-studio-sub-panel" id="subtab-preflight" style="display: none; padding: 15px;">
        <h4 style="margin: 0 0 15px 0; font-size: 0.95em;">Preflight Checks</h4>
        <div id="ps-preflight-checks" style="display: flex; flex-direction: column; gap: 10px;">
          <div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
            <span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: #e8f5e9; color: #2e7d32;">PASS</span>
            <span style="font-size: 0.9em;">Intent fields populated</span>
          </div>
          <div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
            <span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: #fff3e0; color: #e65100;">WARN</span>
            <span style="font-size: 0.9em;">Evidence pack incomplete</span>
          </div>
          <div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
            <span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: #e3f2fd; color: #1565c0;">INFO</span>
            <span style="font-size: 0.9em;">Target: Proposed Changes</span>
          </div>
        </div>
        <div style="margin-top: 20px;">
          <button class="toolbar-btn" id="ps-run-preflight" style="width: 100%;">Run Preflight Checks</button>
        </div>
        <div style="margin-top: 15px;">
          <button class="toolbar-btn" id="ps-copy-preflight" style="width: 100%; background: #455a64;">Copy Preflight Report</button>
        </div>
      </div>
      <div class="patch-studio-sub-panel" id="subtab-evidence" style="display: none; padding: 15px;">
        <h4 style="margin: 0 0 10px 0; font-size: 0.95em;">Evidence Pack (Copy-only)</h4>
        <p style="font-size: 0.8em; color: #666; margin-bottom: 15px;">Structured evidence blocks to support your patch request.</p>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Observation</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('observation')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-observation" placeholder="What did you observe that prompted this change?" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Expected</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('expected')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-expected" placeholder="What behavior is expected?" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Justification</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('justification')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-justification" placeholder="Why this change is correct..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Repro</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('repro')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-repro" placeholder="Steps to reproduce the issue..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-top: 15px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <h5 style="margin: 0 0 10px 0; font-size: 0.9em;">Replay Contract</h5>
          <div style="margin-bottom: 10px;">
            <label style="font-weight: 600; font-size: 0.85em;">Replay Type</label>
            <select id="ps-replay-type" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; margin-top: 4px;">
              <option value="">-- Select --</option>
              <option value="MANUAL">Manual</option>
              <option value="STUBBED">Stubbed</option>
              <option value="NA">N/A</option>
            </select>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="font-weight: 600; font-size: 0.85em;">Replay Steps</label>
            <textarea id="ps-replay-steps" placeholder="Steps to replay this change..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 40px;"></textarea>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="font-weight: 600; font-size: 0.85em;">Replay Expected Result</label>
            <textarea id="ps-replay-expected-result" placeholder="Expected result of replaying..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 40px;"></textarea>
          </div>
        </div>
      </div>
    </div>
    <div class="drawer-actions" id="drawer-actions-default">
      <div class="drawer-actions-grid">
        <button class="drawer-btn" id="drawer-copy">Copy JSON</button>
        <button class="drawer-btn drawer-btn-secondary" id="copy-pr-summary-drawer">Copy PR Summary</button>
        <button class="drawer-btn drawer-btn-secondary" id="copy-rule-draft">Copy Rule Draft</button>
        <button class="drawer-btn" id="switch-to-patch-studio-tab" style="background: #2e7d32;">Build Patch</button>
      </div>
    </div>
    <div class="drawer-actions" id="drawer-actions-patch-studio" style="display: none;">
      <div style="padding: 10px; background: #f0f0f0; border-top: 1px solid #ddd;">
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
          <span style="font-size: 0.75em; background: #e3f2fd; color: #1565c0; padding: 3px 8px; border-radius: 4px; display: flex; align-items: center; gap: 4px;" title="These buttons copy data to clipboard without creating queue artifacts">
            <span style="font-size: 1em;">&#128203;</span> Copy-only
          </span>
          <span style="font-size: 0.75em; background: #e8f5e9; color: #2e7d32; padding: 3px 8px; border-radius: 4px; display: flex; align-items: center; gap: 4px;" title="Submit creates a tracked Patch Request artifact">
            <span style="font-size: 1em;">&#10003;</span> Submit creates Patch Request
          </span>
        </div>
      </div>
      <div class="drawer-actions-grid" style="padding: 10px;">
        <button class="drawer-btn drawer-btn-secondary" id="ps-copy-draft" title="Copy the current draft to clipboard">Copy Draft</button>
        <button class="drawer-btn drawer-btn-secondary" id="ps-save-local" title="Save draft to browser storage">Save Draft</button>
        <button class="drawer-btn" id="ps-submit-to-queue" style="background: #2e7d32; grid-column: span 2;" title="Submit this Patch Request for review">Submit Patch Request</button>
      </div>
    </div>
  </div>

  <!-- Legacy Patch Studio overlay removed in v1.2.4 - all functionality now in Workbench tab -->

  <!-- Unsaved Changes Guard Modal -->
  <!-- v1.4.20: Guard modal for unresolved PATCHED/RFI fields -->
  <div class="srr-guard-modal" id="srr-guard-modal">
    <div class="srr-guard-dialog">
      <div class="srr-guard-title">Unresolved Fields</div>
      <div class="srr-guard-message">You have <strong id="srr-guard-count">0</strong> unresolved fields (Patched or RFI). What would you like to do?</div>
      <div class="srr-guard-actions">
        <button class="srr-guard-btn cancel" onclick="srrGuardCancel()">Stay Here</button>
        <button class="srr-guard-btn discard" onclick="srrGuardDiscardAll()">Discard Changes</button>
        <button class="srr-guard-btn save" onclick="srrGuardSaveDraft()">Save Draft</button>
      </div>
    </div>
  </div>

  <script>
    const PRIMARY_PATH = 'out/sf_packet.preview.json';
    const FALLBACK_PATH = 'examples/datasets/ostereo_demo_v1.json';
    const RELATIVE_PRIMARY = '../../out/sf_packet.preview.json';
    const RELATIVE_FALLBACK = '../../examples/datasets/ostereo_demo_v1.json';
    const DEFAULT_DATASET_URL = '/examples/datasets/ostereo_demo_v1.json';
    const MODIFIED_DATASET_URL = '/examples/datasets/ostereo_demo_v1.json';
    const COMMANDS_PATH = 'run_commands.json';
    const STORAGE_KEY = 'viewer_selection_v10';
    const PREFLIGHT_STORAGE_KEY = 'viewer_preflight_v10';
    const SETTINGS_STORAGE_KEY = 'viewer_settings_v12';
    const FIRST_RUN_DISMISSED_KEY = 'viewer_first_run_dismissed_v12';
    const DEMO_TOGGLE_KEY = 'viewer_demo_toggle_v1';

    var STATUS_COLOR_MAP = {
      ready: { text: '#2e7d32', bg: '#e8f5e9', border: '#c8e6c9' },
      needs_review: { text: '#f57c00', bg: '#fff3e0', border: '#ffe0b2' },
      blocked: { text: '#c62828', bg: '#ffebee', border: '#ffcdd2' },
      finalized: { text: '#1565c0', bg: '#e3f2fd', border: '#bbdefb' },
      flagged: { text: '#7b1fa2', bg: '#f3e5f5', border: '#e1bee7' }
    };
    
    // v1.6.4: Demo toggle state (Original = baseline, Modified = in-progress)
    var demoToggleState = {
      mode: localStorage.getItem(DEMO_TOGGLE_KEY) || 'original', // 'original' or 'modified'
      isModified: function() { return this.mode === 'modified'; }
    };
    
    // ========== STAGED LOADER CONTROLLER ==========
    // Shows staged progress overlay for dataset loading pipeline
    // Only displays if load takes >300ms to avoid flicker on fast loads
    var stagedLoader = {
      stages: ['loading', 'standardizing', 'validating', 'changemap', 'rendering'],
      currentStage: null,
      startTime: null,
      showTimeout: null,
      visible: false,
      DELAY_MS: 300, // Don't show loader for fast loads
      
      // Start the loading process (call before loading begins)
      start: function() {
        this.startTime = Date.now();
        this.currentStage = null;
        this.visible = false;
        this.resetStages();
        
        // Schedule showing the loader after delay
        var self = this;
        this.showTimeout = setTimeout(function() {
          self.show();
        }, this.DELAY_MS);
      },
      
      // Set current stage (call as each stage begins)
      setStage: function(stageName) {
        this.currentStage = stageName;
        
        // Mark previous stages as completed
        var stageIdx = this.stages.indexOf(stageName);
        for (var i = 0; i < this.stages.length; i++) {
          var stageEl = document.querySelector('.staged-loader-stage[data-stage="' + this.stages[i] + '"]');
          if (!stageEl) continue;
          stageEl.classList.remove('active', 'completed');
          var iconEl = stageEl.querySelector('.stage-icon');
          if (i < stageIdx) {
            stageEl.classList.add('completed');
            if (iconEl) iconEl.textContent = '✓';
          } else if (i === stageIdx) {
            stageEl.classList.add('active');
            if (iconEl) iconEl.textContent = '●';
          } else {
            if (iconEl) iconEl.textContent = '○';
          }
        }
      },
      
      // Complete and hide the loader
      finish: function() {
        // Cancel scheduled show if still pending
        if (this.showTimeout) {
          clearTimeout(this.showTimeout);
          this.showTimeout = null;
        }
        
        // Mark all stages complete briefly before hiding
        if (this.visible) {
          for (var i = 0; i < this.stages.length; i++) {
            var stageEl = document.querySelector('.staged-loader-stage[data-stage="' + this.stages[i] + '"]');
            if (stageEl) {
              stageEl.classList.remove('active');
              stageEl.classList.add('completed');
              var iconEl = stageEl.querySelector('.stage-icon');
              if (iconEl) iconEl.textContent = '✓';
            }
          }
          // Hide after a brief moment to show completion
          var self = this;
          setTimeout(function() {
            self.hide();
          }, 150);
        }
        
        this.currentStage = null;
        this.startTime = null;
      },
      
      // Show the overlay
      show: function() {
        var overlay = document.getElementById('staged-loader-overlay');
        if (overlay) {
          overlay.style.display = 'flex';
          this.visible = true;
          // Set current stage if one was already set
          if (this.currentStage) {
            this.setStage(this.currentStage);
          }
        }
      },
      
      // Hide the overlay
      hide: function() {
        var overlay = document.getElementById('staged-loader-overlay');
        if (overlay) {
          overlay.style.display = 'none';
          this.visible = false;
        }
      },
      
      // Reset all stages to initial state
      resetStages: function() {
        for (var i = 0; i < this.stages.length; i++) {
          var stageEl = document.querySelector('.staged-loader-stage[data-stage="' + this.stages[i] + '"]');
          if (stageEl) {
            stageEl.classList.remove('active', 'completed');
            var iconEl = stageEl.querySelector('.stage-icon');
            if (iconEl) iconEl.textContent = '○';
          }
        }
      }
    };
    
    // Meta sheet patterns - these are audit log sheets, not data sheets
    const META_SHEET_PATTERNS = ['_change_log', 'RFIs & Analyst Notes', '_meta', '_audit'];
    
    // v1.6.20: Reference/glossary sheets - supporting data, not actionable records
    // These should be excluded from triage queues (sf_issues, sf_field_actions)
    const REFERENCE_SHEET_PATTERNS = [
      'glossary', 'field_dictionary', 'field dictionary', 
      'opportunity_field_catalog', 'opportunity field catalog',
      'qa_flags', 'hinge', 'mapping', 'dictionary', 'catalog_meta',
      'field_catalog', 'field catalog', 'reference', 'lookup',
      'fields definitions', 'fields definit', 'field definitions'
    ];

    var OPERATIONAL_SHEET_ALLOWLIST = ['Accounts', 'Opportunities', 'Opportunity', 'Financials', 'Catalog', 'Schedule', 'Schedule Catalog', 'V2 Add Ons', 'Contacts', 'Contact'];

    function isOperationalSheet(sheetName) {
      if (!sheetName) return false;
      var lower = sheetName.toLowerCase().trim();
      return OPERATIONAL_SHEET_ALLOWLIST.some(function(op) { return lower === op.toLowerCase(); });
    }
    
    // Default settings (used when no user config exists)
    const DEFAULT_SETTINGS = {
      use_repo_masters: true,
      preferred_load_method: 'Repo Masters',
      local_data_root: '',
      default_queues: ['To Do', 'Needs Review', 'Flagged'],
      compare_mode_default: true,
      configured: false
    };
    
    let userSettings = { ...DEFAULT_SETTINGS };
    const PATCH_STORAGE_KEY = 'viewer_patch_v10';
    const COMPARISON_PATH = '../../out/sf_packet.preview.prev.json';

    let loadedBaseConfig = null;
    let loadedPatch = null;
    let configVersionMatch = null;

    let commands = {};
    let allData = { contractResults: [], issues: [], fieldActions: [], changeLog: [] };
    let compareData = null;
    let rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
    let deltaStats = null;
    let activeFilters = { search: '', severities: ['blocking', 'warning', 'info'], statuses: ['ready', 'needs_review', 'blocked'], subtype: '' };
    let currentSelection = { joinIdentity: null, contractIdx: null, activeTab: 'contract' };
    let selectedRecords = { issues: new Set(), actions: new Set(), changelog: new Set() };
    let patchDraft = { baseVersion: '0.1.0', author: '', rationale: '', changes: [] };
    let preflightEvidence = {
      baseVersion: { raw: '', parsed: null, status: 'pending' },
      validation: { raw: '', parsed: null, status: 'pending' },
      conflict: { raw: '', parsed: null, status: 'pending' },
      smokeBaseline: { raw: '', parsed: null, status: 'pending' },
      smokeEdge: { raw: '', parsed: null, status: 'pending' },
      sha256: ''
    };

    function saveChecklistConfirmation(role, patchId) {
      try {
        var store = JSON.parse(localStorage.getItem('orchestrate_checklist_confirmations') || '{}');
        store[role + ':' + patchId] = { confirmed: true, at: new Date().toISOString() };
        localStorage.setItem('orchestrate_checklist_confirmations', JSON.stringify(store));
      } catch(e) { console.warn('[Checklist] Save error', e); }
    }

    function getChecklistConfirmation(role, patchId) {
      try {
        var store = JSON.parse(localStorage.getItem('orchestrate_checklist_confirmations') || '{}');
        var entry = store[role + ':' + patchId];
        return entry && entry.confirmed;
      } catch(e) { return false; }
    }

    let currentMode = 'analyst';
    let currentQueue = 'todo';
    let dataLoaded = false;
    let currentArtifactPath = '';
    
    // v1.6.18: Performance logging toggle (add ?perf=1 to URL)
    const PERF_ENABLED = new URLSearchParams(window.location.search).get('perf') === '1';
    function perfLog(label, startTime) {
      if (!PERF_ENABLED) return;
      console.log('[Perf] ' + label + ': ' + (performance.now() - startTime).toFixed(2) + 'ms');
    }
    function perfStart() {
      return PERF_ENABLED ? performance.now() : 0;
    }
    
    // v1.6.18: Dataset revision for cache invalidation
    let datasetRevision = 0;
    let flattenCache = { revision: -1, result: null };
    
    // Session state tracking
    const sessionState = {
      status: 'not-loaded', // 'not-loaded', 'loaded', 'fallback'
      sourceType: null, // 'paste', 'drop', 'example', null
      loadedAt: null,
      previewData: null,
      expectedData: null,
      fileName: null
    };
    
    // ========== SESSION DB (v1.6.56 IndexedDB for large payloads) ==========
    var SessionDB = {
      DB_NAME: 'orchestrate_sessions',
      DB_VERSION: 1,
      WORKBOOK_STORE: 'workbook_cache',
      SESSIONS_STORE: 'saved_sessions',
      _db: null,
      _ready: null,

      init: function() {
        if (this._ready) return this._ready;
        var self = this;
        this._ready = new Promise(function(resolve) {
          if (!window.indexedDB) {
            console.warn('[SESSION] IndexedDB not available, falling back to localStorage');
            resolve(null);
            return;
          }
          var t0 = performance.now();
          var request = indexedDB.open(self.DB_NAME, self.DB_VERSION);
          request.onerror = function(e) {
            console.error('[SESSION] IndexedDB open failed:', e);
            resolve(null);
          };
          request.onsuccess = function(e) {
            self._db = e.target.result;
            console.log('[SESSION] IndexedDB ready in', (performance.now() - t0).toFixed(1) + 'ms');
            resolve(self._db);
          };
          request.onupgradeneeded = function(e) {
            var db = e.target.result;
            if (!db.objectStoreNames.contains(self.WORKBOOK_STORE)) {
              db.createObjectStore(self.WORKBOOK_STORE, { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains(self.SESSIONS_STORE)) {
              db.createObjectStore(self.SESSIONS_STORE, { keyPath: 'id' });
            }
          };
        });
        return this._ready;
      },

      _put: function(storeName, data) {
        var self = this;
        return this.init().then(function(db) {
          if (!db) return false;
          return new Promise(function(resolve) {
            try {
              var tx = db.transaction([storeName], 'readwrite');
              var store = tx.objectStore(storeName);
              store.put(data);
              tx.oncomplete = function() { resolve(true); };
              tx.onerror = function(e) {
                console.error('[SESSION] put error:', e);
                resolve(false);
              };
            } catch(e) {
              console.error('[SESSION] put exception:', e);
              resolve(false);
            }
          });
        });
      },

      _get: function(storeName, key) {
        return this.init().then(function(db) {
          if (!db) return null;
          return new Promise(function(resolve) {
            try {
              var tx = db.transaction([storeName], 'readonly');
              var store = tx.objectStore(storeName);
              var req = store.get(key);
              req.onsuccess = function() { resolve(req.result || null); };
              req.onerror = function() { resolve(null); };
            } catch(e) { resolve(null); }
          });
        });
      },

      _delete: function(storeName, key) {
        return this.init().then(function(db) {
          if (!db) return false;
          return new Promise(function(resolve) {
            try {
              var tx = db.transaction([storeName], 'readwrite');
              var store = tx.objectStore(storeName);
              store.delete(key);
              tx.oncomplete = function() { resolve(true); };
              tx.onerror = function() { resolve(false); };
            } catch(e) { resolve(false); }
          });
        });
      },

      _getAll: function(storeName) {
        return this.init().then(function(db) {
          if (!db) return [];
          return new Promise(function(resolve) {
            try {
              var tx = db.transaction([storeName], 'readonly');
              var store = tx.objectStore(storeName);
              var req = store.getAll();
              req.onsuccess = function() { resolve(req.result || []); };
              req.onerror = function() { resolve([]); };
            } catch(e) { resolve([]); }
          });
        });
      },

      _clear: function(storeName) {
        return this.init().then(function(db) {
          if (!db) return false;
          return new Promise(function(resolve) {
            try {
              var tx = db.transaction([storeName], 'readwrite');
              tx.objectStore(storeName).clear();
              tx.oncomplete = function() { resolve(true); };
              tx.onerror = function() { resolve(false); };
            } catch(e) { resolve(false); }
          });
        });
      },

      saveWorkbookCache: function(cacheData) {
        var t0 = performance.now();
        var payload = Object.assign({}, cacheData, { id: 'active_workbook' });
        var payloadSize = JSON.stringify(payload).length;
        return this._put(this.WORKBOOK_STORE, payload).then(function(ok) {
          console.log('[SESSION] Workbook saved to IndexedDB:', (payloadSize / 1024).toFixed(1) + 'KB in', (performance.now() - t0).toFixed(1) + 'ms');
          if (ok) {
            try {
              localStorage.setItem('orchestrate_idb_workbook_ptr', JSON.stringify({
                exists: true,
                savedAt: cacheData.savedAt || new Date().toISOString(),
                filename: cacheData.filename || '',
                sheetCount: cacheData.workbook ? cacheData.workbook.order.length : 0
              }));
            } catch(e) {}
          }
          return ok;
        });
      },

      loadWorkbookCache: function() {
        var t0 = performance.now();
        return this._get(this.WORKBOOK_STORE, 'active_workbook').then(function(data) {
          if (data) {
            console.log('[SESSION] Workbook loaded from IndexedDB in', (performance.now() - t0).toFixed(1) + 'ms');
          }
          return data;
        });
      },

      clearWorkbookCache: function() {
        localStorage.removeItem('orchestrate_idb_workbook_ptr');
        return this._delete(this.WORKBOOK_STORE, 'active_workbook');
      },

      saveSession: function(session) {
        var t0 = performance.now();
        var payloadSize = JSON.stringify(session).length;
        return this._put(this.SESSIONS_STORE, session).then(function(ok) {
          console.log('[SESSION] Session saved:', session.id, (payloadSize / 1024).toFixed(1) + 'KB in', (performance.now() - t0).toFixed(1) + 'ms');
          if (ok) SessionDB._updateSessionIndex();
          return ok;
        });
      },

      loadSession: function(sessionId) {
        var t0 = performance.now();
        return this._get(this.SESSIONS_STORE, sessionId).then(function(data) {
          if (data) {
            console.log('[SESSION] Session loaded:', sessionId, 'in', (performance.now() - t0).toFixed(1) + 'ms');
          }
          return data;
        });
      },

      deleteSession: function(sessionId) {
        return this._delete(this.SESSIONS_STORE, sessionId).then(function(ok) {
          if (ok) SessionDB._updateSessionIndex();
          return ok;
        });
      },

      listSessions: function() {
        return this._getAll(this.SESSIONS_STORE).then(function(sessions) {
          sessions.sort(function(a, b) {
            return new Date(b.savedAt || 0) - new Date(a.savedAt || 0);
          });
          return sessions;
        });
      },

      _updateSessionIndex: function() {
        this.listSessions().then(function(sessions) {
          var index = sessions.map(function(s) {
            return {
              id: s.id, name: s.name, savedAt: s.savedAt, role: s.role,
              sheetCount: s.sheetCount, rowCount: s.rowCount,
              filename: s.filename, datasetId: s.datasetId
            };
          });
          try {
            localStorage.setItem('orchestrate_idb_sessions_idx', JSON.stringify(index));
          } catch(e) {}
        });
      },

      getSessionIndex: function() {
        try {
          var raw = localStorage.getItem('orchestrate_idb_sessions_idx');
          return raw ? JSON.parse(raw) : [];
        } catch(e) { return []; }
      },

      migrateFromLocalStorage: function() {
        var self = this;
        return this.init().then(function(db) {
          if (!db) return Promise.resolve();
          var tasks = [];
          try {
            var oldCache = localStorage.getItem('orchestrate_workbook_cache');
            if (oldCache) {
              var parsed = JSON.parse(oldCache);
              if (parsed && parsed.workbook) {
                tasks.push(self.saveWorkbookCache(parsed).then(function(ok) {
                  if (ok) {
                    localStorage.removeItem('orchestrate_workbook_cache');
                    console.log('[SESSION] Migrated workbook cache localStorage -> IndexedDB');
                  }
                }));
              }
            }
          } catch(e) { console.warn('[SESSION] Workbook migration failed:', e); }
          try {
            var oldSessions = localStorage.getItem('orchestrate_saved_sessions');
            if (oldSessions) {
              var sessions = JSON.parse(oldSessions);
              if (Array.isArray(sessions) && sessions.length > 0) {
                tasks.push(
                  Promise.all(sessions.map(function(s) { return self.saveSession(s); }))
                  .then(function(results) {
                    if (results.every(function(r) { return r; })) {
                      localStorage.removeItem('orchestrate_saved_sessions');
                      console.log('[SESSION] Migrated', sessions.length, 'saved sessions localStorage -> IndexedDB');
                    }
                  })
                );
              }
            }
          } catch(e) { console.warn('[SESSION] Sessions migration failed:', e); }
          if (tasks.length > 0) {
            return Promise.all(tasks).then(function() {
              console.log('[SESSION] Migration complete');
            });
          }
          return Promise.resolve();
        });
      }
    };

    // ========== AUDIT TIMELINE STORE (v1.6.59 IndexedDB-backed) ==========
    var AuditTimeline = {
      DB_NAME: 'orchestrate_audit',
      DB_VERSION: 1,
      STORE_NAME: 'events',
      _db: null,
      _ready: null,
      _memCache: [],

      init: function() {
        if (this._ready) return this._ready;
        var self = this;
        this._ready = new Promise(function(resolve) {
          if (!window.indexedDB) {
            console.warn('[AuditTimeline] IndexedDB not available, using memory-only');
            resolve(null);
            return;
          }
          var request = indexedDB.open(self.DB_NAME, self.DB_VERSION);
          request.onerror = function(e) {
            console.error('[AuditTimeline] IndexedDB open failed:', e);
            resolve(null);
          };
          request.onsuccess = function(e) {
            self._db = e.target.result;
            console.log('[AuditTimeline] IndexedDB ready');
            try {
              var tx = self._db.transaction([self.STORE_NAME], 'readonly');
              var all = tx.objectStore(self.STORE_NAME).getAll();
              all.onsuccess = function(ev) {
                var records = ev.target.result || [];
                self._memCache = records;
                console.log('[AuditTimeline] Hydrated memCache:', records.length, 'events');
                resolve(self._db);
              };
              all.onerror = function() { resolve(self._db); };
            } catch(err) {
              console.warn('[AuditTimeline] Hydration failed:', err);
              resolve(self._db);
            }
          };
          request.onupgradeneeded = function(e) {
            var db = e.target.result;
            if (!db.objectStoreNames.contains(self.STORE_NAME)) {
              var store = db.createObjectStore(self.STORE_NAME, { keyPath: 'event_id' });
              store.createIndex('dataset_id', 'dataset_id', { unique: false });
              store.createIndex('file_id', 'file_id', { unique: false });
              store.createIndex('record_id', 'record_id', { unique: false });
              store.createIndex('event_type', 'event_type', { unique: false });
              store.createIndex('timestamp_iso', 'timestamp_iso', { unique: false });
              store.createIndex('actor_role', 'actor_role', { unique: false });
              store.createIndex('dataset_file', ['dataset_id', 'file_id'], { unique: false });
            }
          };
        });
        return this._ready;
      },

      _generateId: function() {
        return 'evt_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 8);
      },

      _resolveActor: function() {
        try {
          var du = JSON.parse(localStorage.getItem('demoUser') || '{}');
          if (du && (du.name || du.email)) {
            return { id: du.email || du.name || 'unknown', role: (du.role || currentMode || 'analyst').toLowerCase() };
          }
        } catch(e) {}
        return { id: playgroundActors[currentMode] || 'unknown@example.com', role: (typeof TruthPack !== 'undefined' && TruthPack.isArchitect()) ? 'architect' : (currentMode || 'analyst') };
      },

      emit: function(eventType, data) {
        var actor = this._resolveActor();
        var d = data || {};
        var event = {
          event_id: this._generateId(),
          event_type: eventType,
          actor_id: d.actor_id || actor.id,
          actor_role: d.actor_role || actor.role,
          timestamp_iso: d.timestamp_iso || new Date().toISOString(),
          dataset_id: d.dataset_id || IDENTITY_CONTEXT.dataset_id || '',
          file_id: d.file_id || '',
          record_id: d.record_id || '',
          field_key: d.field_key || null,
          patch_request_id: d.patch_request_id || null,
          before_value: d.before_value !== undefined ? d.before_value : null,
          after_value: d.after_value !== undefined ? d.after_value : null,
          metadata: d.metadata || {}
        };

        this._memCache.push(event);

        var self = this;
        this.init().then(function(db) {
          if (!db) return;
          try {
            var tx = db.transaction([self.STORE_NAME], 'readwrite');
            tx.objectStore(self.STORE_NAME).put(event);
            tx.onerror = function(e) { console.error('[AuditTimeline] write error:', e); };
          } catch(e) { console.error('[AuditTimeline] write exception:', e); }
        });

        console.log('[AuditTimeline]', eventType, event.record_id || '', event.patch_request_id || '');
        if (typeof refreshAuditHeaderDropdown === 'function') { try { var b = document.getElementById('audit-header-badge'); if (b) b.textContent = this._memCache.length; refreshAuditHeaderDropdown(); if (document.getElementById('audit-full-panel') && document.getElementById('audit-full-panel').style.display !== 'none') refreshFullAuditPanel(); } catch(e){} }
        return event;
      },

      query: function(filters) {
        var self = this;
        return this.init().then(function(db) {
          if (!db) return self._queryMemCache(filters);
          return new Promise(function(resolve) {
            try {
              var tx = db.transaction([self.STORE_NAME], 'readonly');
              var store = tx.objectStore(self.STORE_NAME);
              var results = [];
              var f = filters || {};

              var indexName = null;
              var indexKey = null;
              if (f.dataset_id && f.file_id) {
                indexName = 'dataset_file';
                indexKey = [f.dataset_id, f.file_id];
              } else if (f.dataset_id) {
                indexName = 'dataset_id';
                indexKey = f.dataset_id;
              } else if (f.record_id) {
                indexName = 'record_id';
                indexKey = f.record_id;
              }

              var source = indexName ? store.index(indexName).openCursor(IDBKeyRange.only(indexKey)) : store.openCursor();
              source.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                  var ev = cursor.value;
                  if (self._matchesFilters(ev, f)) results.push(ev);
                  cursor.continue();
                } else {
                  resolve(results);
                }
              };
              source.onerror = function() { resolve(self._queryMemCache(f)); };
            } catch(e) { resolve(self._queryMemCache(f)); }
          });
        });
      },

      _matchesFilters: function(ev, f) {
        if (f.dataset_id && ev.dataset_id !== f.dataset_id) return false;
        if (f.file_id && ev.file_id !== f.file_id) return false;
        if (f.record_id && ev.record_id !== f.record_id) return false;
        if (f.event_type && ev.event_type !== f.event_type) return false;
        if (f.actor_role && ev.actor_role !== f.actor_role) return false;
        if (f.patch_request_id && ev.patch_request_id !== f.patch_request_id) return false;
        return true;
      },

      _queryMemCache: function(filters) {
        var f = filters || {};
        return this._memCache.filter(function(ev) { return AuditTimeline._matchesFilters(ev, f); });
      },

      getForDataset: function(datasetId) {
        return this.query({ dataset_id: datasetId || IDENTITY_CONTEXT.dataset_id || '' });
      },

      getForRecord: function(recordId) {
        return this.query({ record_id: recordId });
      },

      getAll: function() {
        return this.query({});
      },

      clear: function(datasetId) {
        var self = this;
        if (datasetId) {
          self._memCache = self._memCache.filter(function(ev) { return ev.dataset_id !== datasetId; });
        } else {
          self._memCache = [];
        }
        return this.init().then(function(db) {
          if (!db) return;
          return new Promise(function(resolve) {
            try {
              if (!datasetId) {
                var tx = db.transaction([self.STORE_NAME], 'readwrite');
                tx.objectStore(self.STORE_NAME).clear();
                tx.oncomplete = function() { resolve(); };
                tx.onerror = function() { resolve(); };
              } else {
                var tx2 = db.transaction([self.STORE_NAME], 'readwrite');
                var store2 = tx2.objectStore(self.STORE_NAME);
                var idx = store2.index('dataset_id');
                var req = idx.openCursor(IDBKeyRange.only(datasetId));
                req.onsuccess = function(e) {
                  var cursor = e.target.result;
                  if (cursor) { cursor.delete(); cursor.continue(); }
                };
                tx2.oncomplete = function() { resolve(); };
                tx2.onerror = function() { resolve(); };
              }
            } catch(e) { resolve(); }
          });
        });
      }
    };


        // ========== ARTIFACT STORE (v1.5.1 localStorage Mock Filesystem) ==========
    // Environment + workspace scoped storage adapter
    const ARTIFACT_STORE = {
      prefix: 'fs:',
      workspace_id: 'ws_default',
      environment: 'playground', // 'playground' | 'prod'
      
      // Generate scoped key
      _key: function(path) {
        return this.prefix + this.environment + '/' + this.workspace_id + '/' + path;
      },
      
      // Filesystem helpers
      fsRead: function(path) {
        var key = this._key(path);
        var data = localStorage.getItem(key);
        return data ? data : null;
      },
      
      fsWrite: function(path, contents) {
        var key = this._key(path);
        localStorage.setItem(key, typeof contents === 'string' ? contents : JSON.stringify(contents));
        return true;
      },
      
      fsAppend: function(path, line) {
        var key = this._key(path);
        var existing = localStorage.getItem(key) || '';
        var newLine = typeof line === 'string' ? line : JSON.stringify(line);
        localStorage.setItem(key, existing + (existing ? '\n' : '') + newLine);
        return true;
      },
      
      fsList: function(pathPrefix) {
        var fullPrefix = this._key(pathPrefix || '');
        var results = [];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (key && key.startsWith(fullPrefix)) {
            results.push(key.substring(this._key('').length));
          }
        }
        return results;
      },
      
      fsDelete: function(path) {
        var key = this._key(path);
        localStorage.removeItem(key);
        return true;
      },
      
      // Clear only playground environment keys
      resetPlayground: function() {
        var playgroundPrefix = this.prefix + 'playground/';
        var keysToDelete = [];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (key && key.startsWith(playgroundPrefix)) {
            keysToDelete.push(key);
          }
        }
        keysToDelete.forEach(function(k) { localStorage.removeItem(k); });
        console.log('[ArtifactStore] Reset playground, cleared', keysToDelete.length, 'keys');
        return keysToDelete.length;
      }
    };
    
    // ========== RECORD IDENTITY MODEL (v1.5.2) ==========
    // Context for multi-tenant record identity
    const IDENTITY_CONTEXT = {
      tenant_id: 'tenant_default',
      division_id: 'div_default',
      dataset_id: null
    };

    var COLUMN_ALIAS_MAP = {};

    function loadColumnAliases() {
      return fetch('/rules/rules_bundle/column_aliases.json')
        .then(function(res) { return res.json(); })
        .then(function(data) {
          var map = {};
          if (data && Array.isArray(data.aliases)) {
            data.aliases.forEach(function(entry) {
              var canonical = entry.canonical_key;
              var sheet = entry.sheet || '';
              (entry.aliases || []).forEach(function(alias) {
                var norm = String(alias).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
                if (!norm) return;
                if (!map[norm]) {
                  map[norm] = [];
                }
                var existing = map[norm].find(function(m) { return m.canonical_key === canonical && m.sheet === sheet; });
                if (!existing) {
                  map[norm].push({ canonical_key: canonical, sheet: sheet });
                }
                if (map[norm].length > 1) {
                  var keys = map[norm].map(function(m) { return m.canonical_key + '(' + m.sheet + ')'; });
                  console.warn('[AliasMap] Conflict for "' + norm + '": ' + keys.join(', '));
                }
              });
            });
          }
          COLUMN_ALIAS_MAP = map;
          console.log('[AliasMap] Loaded ' + Object.keys(map).length + ' alias entries');
          return map;
        })
        .catch(function(err) {
          console.warn('[AliasMap] Failed to load column_aliases.json:', err);
          return {};
        });
    }
    
    // UUID regex for alias detection (RFC4122 v1-5)
    const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    
    // PatchRequest Store (shared between analyst/verifier/admin)
    const PATCH_REQUEST_STORE = {
      _key: function(patch_request_id) {
        return 'pr:' + ARTIFACT_STORE.environment + ':' + patch_request_id;
      },
      
      get: function(patch_request_id) {
        if (!patch_request_id) return null;
        var data = localStorage.getItem(this._key(patch_request_id));
        if (data) {
          try {
            var parsed = JSON.parse(data);
            // v1.6.46: Normalize legacy status values
            if (parsed && parsed.status) parsed.status = normalizeLegacyStatus(parsed.status);
            if (parsed && parsed.actor_role) parsed.actor_role = normalizeLegacyRole(parsed.actor_role);
            return parsed;
          } catch (e) {
            console.error('[PatchRequestStore] Parse error:', patch_request_id, e);
            return null;
          }
        }
        return null;
      },
      
      save: function(patchRequest) {
        if (!patchRequest || !patchRequest.request_id) {
          console.error('[PatchRequestStore] Invalid patch request');
          return false;
        }
        localStorage.setItem(this._key(patchRequest.request_id), JSON.stringify(patchRequest));
        console.log('[PatchRequestStore] Saved:', patchRequest.request_id);
        return true;
      },
      
      update: function(patch_request_id, updates) {
        var existing = this.get(patch_request_id);
        if (!existing) {
          console.error('[PatchRequestStore] Cannot update, not found:', patch_request_id);
          return false;
        }
        var merged = Object.assign({}, existing, updates);
        merged.updated_at_utc = new Date().toISOString();
        return this.save(merged);
      },
      
      list: function() {
        var prefix = 'pr:' + ARTIFACT_STORE.environment + ':';
        var results = [];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (key && key.startsWith(prefix)) {
            var data = localStorage.getItem(key);
            if (data) {
              try {
                results.push(JSON.parse(data));
              } catch (e) {}
            }
          }
        }
        return results;
      }
    };
    
    // Simple non-crypto hash for deterministic IDs
    function simpleHash(str) {
      var hash = 0;
      for (var i = 0; i < str.length; i++) {
        var char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash).toString(36);
    }
    
    // Canonicalize row for fingerprinting (stable stringification)
    function canonicalizeRowForFingerprint(row) {
      if (!row || typeof row !== 'object') return '';
      var keys = Object.keys(row).filter(function(k) {
        return !k.startsWith('_'); // Skip internal fields
      }).sort();
      var parts = keys.map(function(k) {
        var val = row[k];
        if (val === null || val === undefined) return k + ':';
        return k + ':' + String(val).trim();
      });
      return parts.join('|');
    }
    
    // Generate stable record_id from tenant + dataset + row fingerprint
    function generateStableRecordId(tenant_id, dataset_id, row) {
      var seed = tenant_id + '|' + dataset_id + '|' + canonicalizeRowForFingerprint(row);
      return 'rec_' + simpleHash(seed);
    }
    
    // Detect UUIDs in row values and return as aliases
    function extractUuidAliases(row) {
      var aliases = [];
      if (!row || typeof row !== 'object') return aliases;
      
      Object.keys(row).forEach(function(key) {
        var val = row[key];
        if (typeof val === 'string' && UUID_REGEX.test(val.trim())) {
          aliases.push({ type: 'uuid', field: key, value: val.trim() });
        }
      });
      return aliases;
    }
    
    // Enhance row with record identity model
    function enhanceRowWithIdentity(row, sheetName, rawRowIndex, sourceFileName, datasetId) {
      var tid = IDENTITY_CONTEXT.tenant_id;
      var did = datasetId || IDENTITY_CONTEXT.dataset_id || 'ds_' + Date.now().toString(36);
      
      // v1.6.9: Use stable sheet:row IDs for meta sheets (change logs, RFIs)
      // This prevents random rec_* IDs and enables stable row mapping
      var isMetaSheet = sheetName && (
        sheetName.includes('_change_log') || 
        sheetName === 'RFIs & Analyst Notes'
      );
      
      // Generate stable record_id if not present
      var record_id = row.record_id;
      if (!record_id) {
        if (isMetaSheet) {
          // Meta sheets use sheet:row format for stable mapping
          record_id = sheetName + ':' + rawRowIndex;
        } else {
          record_id = generateStableRecordId(tid, did, row);
        }
      }
      
      // Extract UUID aliases
      var aliases = extractUuidAliases(row);
      
      // Attach identity fields
      row._identity = {
        tenant_id: tid,
        division_id: IDENTITY_CONTEXT.division_id,
        dataset_id: did,
        record_id: record_id,
        source_pointers: {
          sheet_name: sheetName,
          source_file_name: sourceFileName || '',
          raw_row_index: rawRowIndex
        },
        aliases: aliases
      };
      
      // Also set top-level record_id for backwards compatibility
      row.record_id = record_id;
      
      return row;
    }
    

    // ========== CONTRACT INDEX ENGINE (v2.2 P0) ==========

    // =========================================================================
    // P0.6: Truth Pack Bootstrap — Architect-only clean-room workflow
    // =========================================================================
    var TRUTH_PACK_ARCHITECT_ALLOWLIST = ['architect@orchestrate.local'];

    // P0.7: Role Registry — stable role IDs with permissions
    var ROLE_REGISTRY = {
      architect: {
        role_id: 'architect',
        display_name: 'Architect',
        permissions: ['admin_access', 'truth_pack', 'calibration', 'role_edit', 'invite_manage', 'config_manage', 'baseline_promote', 'baseline_rollback'],
        active: true,
        editable_by_architect: true
      },
      admin: {
        role_id: 'admin',
        display_name: 'Admin',
        permissions: ['admin_access', 'config_manage', 'baseline_rollback', 'user_manage'],
        active: true,
        editable_by_architect: true
      },
      verifier: {
        role_id: 'verifier',
        display_name: 'Verifier',
        permissions: ['review_access', 'patch_verify'],
        active: true,
        editable_by_architect: true
      },
      analyst: {
        role_id: 'analyst',
        display_name: 'Analyst',
        permissions: ['triage_access', 'patch_create', 'srr_access'],
        active: true,
        editable_by_architect: true
      }
    };

    var ROLE_REGISTRY_KEY = 'orchestrate_role_registry_v1';

    function getRoleRegistry() {
      try {
        var stored = localStorage.getItem(ROLE_REGISTRY_KEY);
        if (stored) {
          var parsed = JSON.parse(stored);
          var ids = Object.keys(ROLE_REGISTRY);
          for (var ri = 0; ri < ids.length; ri++) {
            if (!parsed[ids[ri]]) parsed[ids[ri]] = JSON.parse(JSON.stringify(ROLE_REGISTRY[ids[ri]]));
          }
          return parsed;
        }
      } catch(e) {}
      return JSON.parse(JSON.stringify(ROLE_REGISTRY));
    }

    function saveRoleRegistry(registry) {
      try {
        localStorage.setItem(ROLE_REGISTRY_KEY, JSON.stringify(registry));
        return true;
      } catch(e) { return false; }
    }

    function getRoleDisplayName(roleId) {
      var reg = getRoleRegistry();
      if (reg[roleId]) return reg[roleId].display_name;
      return roleId.charAt(0).toUpperCase() + roleId.slice(1);
    }

    function hasPermission(roleId, permission) {
      var reg = getRoleRegistry();
      var role = reg[roleId];
      if (!role || !role.active) return false;
      for (var pi = 0; pi < role.permissions.length; pi++) {
        if (role.permissions[pi] === permission) return true;
      }
      return false;
    }

    function migrateRoleLegacy() {
      var users = null;
      try {
        var stored = localStorage.getItem('orchestrate_demo_users');
        if (stored) users = JSON.parse(stored);
      } catch(e) {}
      if (!users || !users.length) return;
      var LEGACY_MAP = { 'Analyst': 'analyst', 'Verifier': 'verifier', 'Admin': 'admin', 'Architect': 'architect' };
      var changed = false;
      for (var ui = 0; ui < users.length; ui++) {
        var u = users[ui];
        if (u.role && LEGACY_MAP[u.role] && u.role !== LEGACY_MAP[u.role]) {
          u.role = LEGACY_MAP[u.role];
          changed = true;
        }
      }
      if (changed) {
        localStorage.setItem('orchestrate_demo_users', JSON.stringify(users));
        console.log('[P0.7][MIGRATE] Legacy role labels migrated to stable IDs');
      }
    }

    // P0.7: People workspace functions
    function switchPeopleTab(tabName) {
      var subTabs = ['members', 'roles', 'invites'];
      for (var ti = 0; ti < subTabs.length; ti++) {
        var panel = document.getElementById('people-tab-' + subTabs[ti]);
        if (panel) panel.style.display = (subTabs[ti] === tabName) ? '' : 'none';
      }
      var btns = document.querySelectorAll('.people-sub-tab');
      for (var bi = 0; bi < btns.length; bi++) {
        var btn = btns[bi];
        var isActive = btn.getAttribute('data-people-tab') === tabName;
        btn.style.background = isActive ? '#1976d2' : '#f5f5f5';
        btn.style.color = isActive ? 'white' : '#666';
        btn.style.fontWeight = isActive ? '600' : '400';
      }
      if (tabName === 'members') renderPeopleMembers();
      if (tabName === 'roles') renderPeopleRoles();
      if (tabName === 'invites') renderPeopleInvites();
      localStorage.setItem('people_active_tab', tabName);
    }

    function renderPeopleMembers() {
      var container = document.getElementById('people-members-table');
      if (!container) return;
      var users = getDemoUsers();
      var html = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">' +
        '<thead style="background: #f5f5f5;"><tr>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Name</th>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Email</th>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Role</th>' +
        '<th style="padding: 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Status</th>' +
        '<th style="padding: 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Assign</th>' +
        '</tr></thead><tbody>';
      for (var ui = 0; ui < users.length; ui++) {
        var u = users[ui];
        html += '<tr style="border-bottom: 1px solid #f0f0f0;">' +
          '<td style="padding: 6px 8px;">' + (u.name || '—') + '</td>' +
          '<td style="padding: 6px 8px;">' + (u.email || '—') + '</td>' +
          '<td style="padding: 6px 8px;">' + getRoleDisplayName(u.role || 'analyst') + '</td>' +
          '<td style="padding: 6px 8px; text-align: center;"><span style="padding: 2px 6px; border-radius: 8px; font-size: 0.8em; background: ' + (u.status === 'active' ? '#e8f5e9' : '#fff3e0') + ';">' + (u.status || 'active') + '</span></td>' +
          '<td style="padding: 6px 8px; text-align: center;">' +
          '<select onchange="assignMemberRole(\'' + u.id + '\', this.value)" style="padding: 3px 6px; font-size: 0.85em; border: 1px solid #ddd; border-radius: 4px;">' +
          '<option value="analyst"' + (u.role === 'analyst' ? ' selected' : '') + '>Analyst</option>' +
          '<option value="verifier"' + (u.role === 'verifier' ? ' selected' : '') + '>Verifier</option>' +
          '<option value="admin"' + (u.role === 'admin' ? ' selected' : '') + '>Admin</option>' +
          '</select></td></tr>';
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    function assignMemberRole(userId, newRole) {
      var users = getDemoUsers();
      for (var i = 0; i < users.length; i++) {
        if (users[i].id === userId) {
          users[i].role = newRole;
          break;
        }
      }
      saveDemoUsers(users);
      AuditTimeline.emit('member_role_assigned', {
        actor_role: TruthPack.isArchitect() ? 'architect' : 'admin',
        metadata: { user_id: userId, new_role: newRole }
      });
      console.log('[P0.7][People] role_assigned: user=' + userId + ' role=' + newRole);
      if (typeof showToast === 'function') showToast('Role updated to ' + getRoleDisplayName(newRole), 'success');
      renderPeopleMembers();
    }

    function renderPeopleRoles() {
      var container = document.getElementById('people-roles-table');
      if (!container) return;
      var reg = getRoleRegistry();
      var isArch = TruthPack.isArchitect();
      var roleIds = ['architect', 'admin', 'verifier', 'analyst'];
      var html = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">' +
        '<thead style="background: #f5f5f5;"><tr>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Role ID</th>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Display Name</th>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Permissions</th>' +
        '<th style="padding: 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Active</th>' +
        '<th style="padding: 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Actions</th>' +
        '</tr></thead><tbody>';
      for (var ri = 0; ri < roleIds.length; ri++) {
        var role = reg[roleIds[ri]];
        if (!role) continue;
        html += '<tr style="border-bottom: 1px solid #f0f0f0;">' +
          '<td style="padding: 6px 8px; font-family: monospace; font-size: 0.85em;">' + role.role_id + '</td>' +
          '<td style="padding: 6px 8px;">' + (isArch ? '<input type="text" value="' + (role.display_name || '') + '" onchange="updateRoleDisplayName(' + "'" + role.role_id + "'" + ', this.value)" style="padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; width: 120px;">' : role.display_name) + '</td>' +
          '<td style="padding: 6px 8px; font-size: 0.8em; color: #555;">' + (role.permissions || []).join(', ') + '</td>' +
          '<td style="padding: 6px 8px; text-align: center;">' +
          (isArch ? '<input type="checkbox"' + (role.active ? ' checked' : '') + ' onchange="toggleRoleActive(' + "'" + role.role_id + "'" + ', this.checked)">' : (role.active ? 'Yes' : 'No')) + '</td>' +
          '<td style="padding: 6px 8px; text-align: center;">' + (isArch ? '<span style="font-size: 0.75em; color: #999;">editable</span>' : '<span style="font-size: 0.75em; color: #ccc;">locked</span>') + '</td>' +
          '</tr>';
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    function updateRoleDisplayName(roleId, newName) {
      if (!TruthPack.isArchitect()) {
        if (typeof showToast === 'function') showToast('Architect role required to edit roles', 'error');
        return;
      }
      var reg = getRoleRegistry();
      if (reg[roleId]) {
        reg[roleId].display_name = newName;
        saveRoleRegistry(reg);
        AuditTimeline.emit('role_display_updated', {
          actor_role: 'architect',
          metadata: { role_id: roleId, new_display_name: newName }
        });
        console.log('[P0.7][Roles] display_name_updated: ' + roleId + ' -> ' + newName);
        if (typeof showToast === 'function') showToast('Role display name updated', 'success');
      }
    }

    function toggleRoleActive(roleId, active) {
      if (!TruthPack.isArchitect()) {
        if (typeof showToast === 'function') showToast('Architect role required', 'error');
        return;
      }
      var reg = getRoleRegistry();
      if (reg[roleId]) {
        reg[roleId].active = active;
        saveRoleRegistry(reg);
        console.log('[P0.7][Roles] toggle_active: ' + roleId + ' = ' + active);
      }
    }

    function renderPeopleInvites() {
      var container = document.getElementById('people-invites-table');
      if (!container) return;
      var invites = InviteManager.getAll();
      if (invites.length === 0) {
        container.innerHTML = '<div style="padding: 12px; color: #999; font-size: 0.85em; text-align: center;">No invites created yet.</div>';
        return;
      }
      var html = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">' +
        '<thead style="background: #f5f5f5;"><tr>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Invite ID</th>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Role</th>' +
        '<th style="padding: 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Status</th>' +
        '<th style="padding: 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Note</th>' +
        '<th style="padding: 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Actions</th>' +
        '</tr></thead><tbody>';
      for (var ii = invites.length - 1; ii >= 0; ii--) {
        var inv = invites[ii];
        var statusColor = inv.status === 'active' ? '#4caf50' : (inv.status === 'used' ? '#1976d2' : (inv.status === 'expired' ? '#ff9800' : '#9e9e9e'));
        html += '<tr style="border-bottom: 1px solid #f0f0f0;">' +
          '<td style="padding: 6px 8px; font-family: monospace; font-size: 0.8em;">' + (inv.invite_id || '').substr(0, 18) + '</td>' +
          '<td style="padding: 6px 8px;">' + getRoleDisplayName(inv.role_id) + '</td>' +
          '<td style="padding: 6px 8px; text-align: center;"><span style="padding: 2px 6px; border-radius: 8px; font-size: 0.8em; color: white; background: ' + statusColor + ';">' + inv.status + '</span></td>' +
          '<td style="padding: 6px 8px; font-size: 0.8em; color: #666;">' + (inv.note || '—') + (inv.used_by ? ' (used by ' + inv.used_by + ')' : '') + '</td>' +
          '<td style="padding: 6px 8px; text-align: center;">' +
          (inv.status === 'active' ? '<button onclick="InviteManager.revokeInvite(' + "'" + inv.invite_id + "'" + '); renderPeopleInvites();" style="padding: 2px 8px; font-size: 0.78em; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">Revoke</button>' : '—') +
          '</td></tr>';
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    function createInviteFromForm() {
      var roleSelect = document.getElementById('invite-role-select');
      var expiryInput = document.getElementById('invite-expiry-input');
      var noteInput = document.getElementById('invite-note-input');
      var roleId = roleSelect ? roleSelect.value : 'analyst';
      var expiry = expiryInput ? parseInt(expiryInput.value, 10) : 0;
      var note = noteInput ? noteInput.value : '';
      InviteManager.createInvite(roleId, expiry || 0, note);
      if (expiryInput) expiryInput.value = '';
      if (noteInput) noteInput.value = '';
      renderPeopleInvites();
    }


    var TruthPack = {
      _active: false,
      _baselineMarked: false,
      _calibrationRun: null,
      _sessionId: null,

      isActive: function() { return this._active; },

      isArchitect: function() {
        var mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        if (mode === 'architect') return true;
        var archEnabled = localStorage.getItem('truth_pack_architect_enabled');
        if (archEnabled === 'true' && mode === 'admin') return true;
        return false;
      },

      _isInAllowlist: function() {
        var actor = (typeof AuditTimeline !== 'undefined') ? AuditTimeline._resolveActor() : { id: '' };
        for (var ai = 0; ai < TRUTH_PACK_ARCHITECT_ALLOWLIST.length; ai++) {
          if (actor.id === TRUTH_PACK_ARCHITECT_ALLOWLIST[ai]) return true;
        }
        return false;
      },

      enableArchitectMode: function() {
        var actor = AuditTimeline._resolveActor();
        var allowed = false;
        for (var ai = 0; ai < TRUTH_PACK_ARCHITECT_ALLOWLIST.length; ai++) {
          if (actor.id === TRUTH_PACK_ARCHITECT_ALLOWLIST[ai]) { allowed = true; break; }
        }
        if (!allowed) {
          var mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
          if (mode !== 'admin') {
            if (typeof showToast === 'function') showToast('Architect access denied: not in allowlist', 'error');
            console.log('[TRUTH-PACK][P0.6] architect_denied: actor=' + actor.id);
            return;
          }
        }
        localStorage.setItem('truth_pack_architect_enabled', 'true');
        localStorage.setItem('viewer_mode_v10', 'architect');
        if (typeof currentMode !== 'undefined') currentMode = 'architect';
        console.log('[TRUTH-PACK][P0.6] architect_mode_enabled');
        AuditTimeline.emit('truth_pack_architect_enabled', { actor_role: 'architect', metadata: { action: 'enable_architect_mode' } });
        if (typeof showToast === 'function') showToast('Architect mode enabled', 'success');
        this._renderControls();
        if (typeof applyModeVisibility === 'function') applyModeVisibility('architect');
      },

      disableArchitectMode: function() {
        localStorage.removeItem('truth_pack_architect_enabled');
        localStorage.setItem('viewer_mode_v10', 'admin');
        if (typeof currentMode !== 'undefined') currentMode = 'admin';
        console.log('[TRUTH-PACK][P0.6] architect_mode_disabled');
        if (typeof showToast === 'function') showToast('Architect mode disabled', 'info');
        this._renderControls();
        if (typeof applyModeVisibility === 'function') applyModeVisibility('admin');
      },

      _cleanRoom: function() {
        console.log('[TRUTH-PACK][P0.6] clean_room_start');
        try {
          if (typeof workbook !== 'undefined') { workbook = { sheets: {}, order: [] }; }
          if (typeof dataLoaded !== 'undefined') dataLoaded = false;
          if (typeof ContractIndex !== 'undefined' && ContractIndex.clear) ContractIndex.clear();
          if (typeof analystTriageState !== 'undefined') {
            analystTriageState.manualItems = [];
            analystTriageState.sflogicItems = [];
            analystTriageState.patchItems = [];
            analystTriageState.systemItems = [];
          }
          if (typeof TriageAnalytics !== 'undefined' && TriageAnalytics._cache) {
            TriageAnalytics._cache = null;
          }
          var keysToRemove = [];
          for (var i = 0; i < localStorage.length; i++) {
            var k = localStorage.key(i);
            if (k && (k.indexOf('workbook_session_') === 0 || k.indexOf('orchestrate_artifact_') === 0)) {
              keysToRemove.push(k);
            }
          }
          keysToRemove.forEach(function(k) { localStorage.removeItem(k); });
          if (typeof SessionDB !== 'undefined' && SessionDB.clearWorkbookCache) {
            SessionDB.clearWorkbookCache().catch(function() {});
          }
          if (typeof clearAllCellStores === 'function') clearAllCellStores();
        } catch(e) {
          console.warn('[TRUTH-PACK][P0.6] clean_room_error:', e);
        }
        console.log('[TRUTH-PACK][P0.6] clean_room_complete');
      },

      startSession: function() {
        if (!this.isArchitect()) {
          if (typeof showToast === 'function') showToast('Architect role required', 'error');
          return;
        }
        this._sessionId = 'tp_' + Date.now().toString(36);
        this._active = true;
        this._baselineMarked = false;
        this._calibrationRun = null;
        localStorage.setItem('truth_pack_active', 'true');
        localStorage.setItem('truth_pack_session_id', this._sessionId);
        this._cleanRoom();
        console.log('[TRUTH-PACK][P0.6] session_started: id=' + this._sessionId);
        AuditTimeline.emit('truth_pack_session_started', {
          actor_role: 'architect',
          metadata: { session_id: this._sessionId, action: 'start' }
        });
        if (typeof showToast === 'function') showToast('Truth Pack session started (clean room)', 'success');
        this._renderControls();
        this._renderCalibrationPanel();
        this._suppressSampleDatasets();
        if (typeof navigateTo === 'function') navigateTo('triage');
        if (typeof renderAnalystTriage === 'function') renderAnalystTriage();
      },

      resetSession: function() {
        if (!this.isArchitect() || !this._active) return;
        this._calibrationRun = null;
        this._baselineMarked = false;
        this._cleanRoom();
        console.log('[TRUTH-PACK][P0.6] session_reset: id=' + this._sessionId);
        AuditTimeline.emit('truth_pack_session_reset', {
          actor_role: 'architect',
          metadata: { session_id: this._sessionId, action: 'reset' }
        });
        if (typeof showToast === 'function') showToast('Truth Pack session reset (clean room)', 'info');
        this._renderCalibrationPanel();
        if (typeof navigateTo === 'function') navigateTo('triage');
        if (typeof renderAnalystTriage === 'function') renderAnalystTriage();
      },

      exitSession: function() {
        if (!this.isArchitect()) return;
        this._active = false;
        this._calibrationRun = null;
        this._baselineMarked = false;
        localStorage.removeItem('truth_pack_active');
        localStorage.removeItem('truth_pack_session_id');
        console.log('[TRUTH-PACK][P0.6] session_exited: id=' + this._sessionId);
        AuditTimeline.emit('truth_pack_session_exited', {
          actor_role: 'architect',
          metadata: { session_id: this._sessionId, action: 'exit' }
        });
        this._sessionId = null;
        if (typeof showToast === 'function') showToast('Truth Pack session ended', 'info');
        this._renderControls();
        this._renderCalibrationPanel();
        this._restoreSampleDatasets();
      },

      _suppressSampleDatasets: function() {
        var cards = ['demo-dataset-card-original', 'demo-dataset-card-modified', 'data-source-demo-section'];
        cards.forEach(function(id) {
          var el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
        console.log('[TRUTH-PACK][P0.6] sample_datasets_suppressed');
      },

      _restoreSampleDatasets: function() {
        var el1 = document.getElementById('demo-dataset-card-original');
        var el2 = document.getElementById('demo-dataset-card-modified');
        var sec = document.getElementById('data-source-demo-section');
        if (el1) el1.style.display = '';
        if (el2) el2.style.display = '';
        if (sec) sec.style.display = '';
        console.log('[TRUTH-PACK][P0.6] sample_datasets_restored');
      },

      onDatasetUploaded: function(datasetName, datasetId) {
        if (!this._active) return;
        console.log('[TRUTH-PACK][P0.6] dataset_uploaded: name=' + datasetName + ', id=' + datasetId);
        AuditTimeline.emit('truth_pack_calibration_started', {
          actor_role: 'architect',
          metadata: { session_id: this._sessionId, dataset_name: datasetName, dataset_id: datasetId }
        });
        var cache = (typeof TriageAnalytics !== 'undefined' && TriageAnalytics._cache) ? TriageAnalytics._cache : null;
        this._calibrationRun = {
          dataset_name: datasetName,
          dataset_id: datasetId,
          run_timestamp: new Date().toISOString(),
          total_contracts: cache ? cache.total_contracts : 0,
          preflight_counts: cache ? {
            unknown_columns: cache.lanes.preflight.unknown_columns,
            ocr_unreadable: cache.lanes.preflight.ocr_unreadable,
            low_confidence: cache.lanes.preflight.low_confidence,
            document_type: cache.lanes.preflight.document_type || 0,
            total: cache.lanes.preflight.total
          } : { unknown_columns: 0, ocr_unreadable: 0, low_confidence: 0, document_type: 0, total: 0 }
        };
        this._renderCalibrationPanel();
      },

      refreshCalibrationCounts: function() {
        if (!this._active || !this._calibrationRun) return;
        var cache = (typeof TriageAnalytics !== 'undefined' && TriageAnalytics._cache) ? TriageAnalytics._cache : null;
        if (!cache) return;
        this._calibrationRun.total_contracts = cache.total_contracts;
        this._calibrationRun.preflight_counts = {
          unknown_columns: cache.lanes.preflight.unknown_columns,
          ocr_unreadable: cache.lanes.preflight.ocr_unreadable,
          low_confidence: cache.lanes.preflight.low_confidence,
          document_type: cache.lanes.preflight.document_type || 0,
          total: cache.lanes.preflight.total
        };
        this._renderCalibrationPanel();
        console.log('[TRUTH-PACK][P0.6] calibration_counts_refreshed: pf_total=' + this._calibrationRun.preflight_counts.total);
      },

      markAsBaseline: function() {
        if (!this._active || !this._calibrationRun) return;
        this._baselineMarked = true;
        this._calibrationRun.baseline_marked = true;
        this._calibrationRun.baseline_marked_at = new Date().toISOString();
        console.log('[TRUTH-PACK][P0.6] baseline_marked: dataset=' + this._calibrationRun.dataset_name);
        AuditTimeline.emit('truth_pack_baseline_marked', {
          actor_role: 'architect',
          metadata: { session_id: this._sessionId, dataset_name: this._calibrationRun.dataset_name, dataset_id: this._calibrationRun.dataset_id, preflight_counts: this._calibrationRun.preflight_counts }
        });
        if (typeof showToast === 'function') showToast('Marked as baseline candidate', 'success');
        this._renderCalibrationPanel();
      },

      exportSnapshot: function() {
        if (!this._active || !this._calibrationRun) return;
        var snapshot = {
          export_type: 'truth_pack_calibration_snapshot',
          version: 'P0.6',
          session_id: this._sessionId,
          dataset_name: this._calibrationRun.dataset_name,
          dataset_id: this._calibrationRun.dataset_id,
          run_timestamp: this._calibrationRun.run_timestamp,
          exported_at: new Date().toISOString(),
          total_contracts: this._calibrationRun.total_contracts,
          preflight_counts: this._calibrationRun.preflight_counts,
          baseline_marked: this._baselineMarked,
          affected_contracts: [],
          affected_records: []
        };
        if (typeof ContractIndex !== 'undefined' && ContractIndex._index) {
          var idx = ContractIndex._index;
          var cKeys = Object.keys(idx.contracts || {});
          for (var ci = 0; ci < cKeys.length; ci++) {
            var c = idx.contracts[cKeys[ci]];
            snapshot.affected_contracts.push({ contract_id: c.contract_id, file_name: c.file_name, row_count: c.row_count });
          }
          for (var oi = 0; oi < (idx.orphan_rows || []).length; oi++) {
            snapshot.affected_records.push(idx.orphan_rows[oi]);
          }
        }
        var blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'truth_pack_snapshot_' + (this._calibrationRun.dataset_name || 'unknown').replace(/[^a-zA-Z0-9]/g, '_') + '.json';
        a.click();
        URL.revokeObjectURL(url);
        console.log('[TRUTH-PACK][P0.6] snapshot_exported: dataset=' + this._calibrationRun.dataset_name);
        AuditTimeline.emit('truth_pack_snapshot_exported', {
          actor_role: 'architect',
          metadata: { session_id: this._sessionId, dataset_name: this._calibrationRun.dataset_name, contracts: snapshot.affected_contracts.length }
        });
        if (typeof showToast === 'function') showToast('Calibration snapshot exported', 'success');
      },

      _renderControls: function() {
        var container = document.getElementById('truth-pack-admin-controls');
        if (!container) return;
        if (!this.isArchitect()) {
          container.style.display = 'none';
          return;
        }
        container.style.display = '';
        var isActive = this._active;
        container.innerHTML = '<div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">' +
          '<span style="font-size: 0.85em; font-weight: 600; color: #7b1fa2;">Truth Pack</span>' +
          (isActive ? '<span style="padding: 2px 8px; background: #e8f5e9; color: #2e7d32; border-radius: 10px; font-size: 0.75em; font-weight: 600;">ACTIVE</span>' : '<span style="padding: 2px 8px; background: #f5f5f5; color: #999; border-radius: 10px; font-size: 0.75em;">INACTIVE</span>') +
          (!isActive ? '<button onclick="TruthPack.startSession()" style="padding: 4px 12px; font-size: 0.8em; background: #7b1fa2; color: white; border: none; border-radius: 4px; cursor: pointer;">Start Session</button>' : '') +
          (isActive ? '<button onclick="TruthPack.resetSession()" style="padding: 4px 12px; font-size: 0.8em; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>' : '') +
          (isActive ? '<button onclick="TruthPack.exitSession()" style="padding: 4px 12px; font-size: 0.8em; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Exit Session</button>' : '') +
          '</div>';
      },

      _renderCalibrationPanel: function() {
        var panel = document.getElementById('truth-pack-calibration-panel');
        if (!panel) return;
        if (!this._active || !this.isArchitect()) {
          panel.style.display = 'none';
          return;
        }
        panel.style.display = '';
        var run = this._calibrationRun;
        if (!run) {
          panel.innerHTML = '<div style="padding: 12px 16px; background: #f3e5f5; border: 1px solid #ce93d8; border-radius: 8px; font-size: 0.85em; color: #6a1b9a;">' +
            '<strong>Truth Pack Mode</strong> <span id="truth-config-chip-triage" style="font-size: 0.85em; padding: 2px 6px; border-radius: 8px; background: ' + ((typeof TruthConfig !== 'undefined' && TruthConfig.getStatus() === 'established') ? '#4caf50' : (typeof TruthConfig !== 'undefined' && TruthConfig.getStatus() === 'test_mode') ? '#ff9800' : '#9e9e9e') + '; color: white;">' + ((typeof TruthConfig !== 'undefined') ? (TruthConfig.getStatus() === 'established' ? 'Established' : (TruthConfig.getStatus() === 'test_mode' ? 'Test Mode' : 'No Baseline')) : 'No Baseline') + '</span>' +
            ' — Upload a dataset to begin calibration run. No sample data loaded.' +
            '</div>';
          return;
        }
        var pf = run.preflight_counts;
        panel.innerHTML = '<div style="padding: 12px 16px; background: #f3e5f5; border: 1px solid #ce93d8; border-radius: 8px;">' +
          '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">' +
          '<span style="font-weight: 600; font-size: 0.9em; color: #6a1b9a;">Calibration Run</span>' +
          '<span style="font-size: 0.75em; color: #999;">' + (run.run_timestamp || '') + '</span>' +
          '</div>' +
          '<div style="display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 8px;">' +
          '<div style="text-align: center;"><div style="font-size: 1.1em; font-weight: 700; color: #333;">' + (run.dataset_name || '—') + '</div><div style="font-size: 0.7em; color: #888;">Dataset</div></div>' +
          '<div style="text-align: center;"><div style="font-size: 1.1em; font-weight: 700; color: #1565c0;">' + run.total_contracts + '</div><div style="font-size: 0.7em; color: #888;">Contracts</div></div>' +
          '<div style="text-align: center;"><div style="font-size: 1.1em; font-weight: 700; color: #e65100;">' + pf.total + '</div><div style="font-size: 0.7em; color: #888;">Pre-Flight Issues</div></div>' +
          '<div style="text-align: center;"><div style="font-size: 0.85em; color: #555;">' + pf.unknown_columns + ' unk | ' + pf.ocr_unreadable + ' ocr/moji | ' + pf.low_confidence + ' conf | ' + pf.document_type + ' doc</div><div style="font-size: 0.7em; color: #888;">Breakdown</div></div>' +
          '</div>' +
          '<div style="display: flex; gap: 8px;">' +
          '<button onclick="TruthPack.markAsBaseline()" style="padding: 4px 12px; font-size: 0.8em; background: ' + (this._baselineMarked ? '#e8f5e9; color: #2e7d32; border: 1px solid #a5d6a7' : '#7b1fa2; color: white; border: none') + '; border-radius: 4px; cursor: pointer;">' + (this._baselineMarked ? 'Baseline Marked' : 'Mark as Baseline') + '</button>' +
          '<button onclick="TruthPack.exportSnapshot()" style="padding: 4px 12px; font-size: 0.8em; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">Export Snapshot</button>' +
          '<button onclick="TruthPack.refreshCalibrationCounts()" style="padding: 4px 12px; font-size: 0.8em; background: #f5f5f5; color: #555; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">Refresh</button>' +
          '</div>' +
          '</div>';
      },

      restoreFromStorage: function() {
        if (localStorage.getItem('truth_pack_active') === 'true') {
          this._active = true;
          this._sessionId = localStorage.getItem('truth_pack_session_id') || 'tp_restored';
          console.log('[TRUTH-PACK][P0.6] session_restored_from_storage: id=' + this._sessionId);
          this._suppressSampleDatasets();
        }
        this._renderControls();
        this._renderCalibrationPanel();
      }
    };

    // P0.7: Truth Config Versioning
    var TRUTH_CONFIG_STORE = 'truth_config_versions';
    var TRUTH_CONFIG_POINTER_KEY = 'active_truth_version_id';

    var TruthConfig = {
      _versions: [],
      _activeId: null,

      init: function() {
        var self = this;
        self._activeId = localStorage.getItem(TRUTH_CONFIG_POINTER_KEY) || null;
        return SessionDB._getAll(SessionDB.WORKBOOK_STORE).then(function(all) {
          self._versions = [];
          for (var i = 0; i < all.length; i++) {
            if (all[i].id && all[i].id.indexOf('truth_config_v_') === 0) {
              self._versions.push(all[i]);
            }
          }
          self._versions.sort(function(a, b) {
            return (b.created_at || '').localeCompare(a.created_at || '');
          });
          console.log('[P0.7][TruthConfig] init: ' + self._versions.length + ' versions, active=' + (self._activeId || 'none'));
          return self._versions;
        }).catch(function() { return []; });
      },

      _generateId: function() {
        return 'truth_config_v_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 4);
      },

      getActive: function() {
        if (!this._activeId) return null;
        for (var i = 0; i < this._versions.length; i++) {
          if (this._versions[i].version_id === this._activeId) return this._versions[i];
        }
        return null;
      },

      getStatus: function() {
        var active = this.getActive();
        if (!active) return 'no_baseline';
        return active.status || 'no_baseline';
      },

      uploadConfig: function(jsonPayload, fileName) {
        if (!TruthPack.isArchitect()) {
          if (typeof showToast === 'function') showToast('Architect role required', 'error');
          return Promise.resolve(null);
        }
        var versionId = this._generateId();
        var record = {
          id: versionId,
          version_id: versionId,
          payload: jsonPayload,
          created_at: new Date().toISOString(),
          created_by: AuditTimeline._resolveActor().id,
          status: 'test_mode',
          promoted_at: null,
          promoted_by: null,
          source: 'upload',
          file_name: fileName || 'unknown.json'
        };
        var self = this;
        return SessionDB._put(SessionDB.WORKBOOK_STORE, record).then(function(ok) {
          if (ok) {
            self._versions.unshift(record);
            self._activeId = versionId;
            localStorage.setItem(TRUTH_CONFIG_POINTER_KEY, versionId);
            AuditTimeline.emit('truth_config_uploaded', {
              actor_role: 'architect',
              metadata: { version_id: versionId, source: 'upload', file_name: fileName }
            });
            console.log('[P0.7][TruthConfig] uploaded: ' + versionId);
            if (typeof showToast === 'function') showToast('Truth Config uploaded (test mode)', 'success');
            self._renderUI();
          }
          return record;
        });
      },

      createBaselineFromRuntime: function() {
        if (!TruthPack.isArchitect()) {
          if (typeof showToast === 'function') showToast('Architect role required', 'error');
          return Promise.resolve(null);
        }
        var snapshot = {};
        try {
          if (typeof fieldMeta !== 'undefined') snapshot.field_meta = fieldMeta;
          if (typeof qaFlags !== 'undefined') snapshot.qa_flags = qaFlags;
          if (typeof hingeGroups !== 'undefined') snapshot.hinge_groups = hingeGroups;
          if (typeof sheetOrder !== 'undefined') snapshot.sheet_order = sheetOrder;
          if (typeof documentTypes !== 'undefined') snapshot.document_types = documentTypes;
          if (typeof columnAliases !== 'undefined') snapshot.column_aliases = columnAliases;
        } catch(e) {}
        var versionId = this._generateId();
        var record = {
          id: versionId,
          version_id: versionId,
          payload: snapshot,
          created_at: new Date().toISOString(),
          created_by: AuditTimeline._resolveActor().id,
          status: 'test_mode',
          promoted_at: null,
          promoted_by: null,
          source: 'runtime_snapshot'
        };
        var self = this;
        return SessionDB._put(SessionDB.WORKBOOK_STORE, record).then(function(ok) {
          if (ok) {
            self._versions.unshift(record);
            self._activeId = versionId;
            localStorage.setItem(TRUTH_CONFIG_POINTER_KEY, versionId);
            AuditTimeline.emit('truth_baseline_created', {
              actor_role: 'architect',
              metadata: { version_id: versionId, source: 'runtime_snapshot' }
            });
            console.log('[P0.7][TruthConfig] baseline_created: ' + versionId);
            if (typeof showToast === 'function') showToast('Baseline created from runtime (test mode)', 'success');
            self._renderUI();
          }
          return record;
        });
      },

      setTestMode: function(versionId) {
        var target = null;
        for (var i = 0; i < this._versions.length; i++) {
          if (this._versions[i].version_id === versionId) { target = this._versions[i]; break; }
        }
        if (!target) return Promise.resolve(false);
        if (!TruthPack.isArchitect()) {
          if (typeof showToast === 'function') showToast('Architect role required', 'error');
          return Promise.resolve(false);
        }
        target.status = 'test_mode';
        this._activeId = versionId;
        localStorage.setItem(TRUTH_CONFIG_POINTER_KEY, versionId);
        var self = this;
        return SessionDB._put(SessionDB.WORKBOOK_STORE, target).then(function(ok) {
          if (ok) {
            AuditTimeline.emit('truth_mode_set', {
              actor_role: 'architect',
              metadata: { version_id: versionId, status: 'test_mode' }
            });
            console.log('[P0.7][TruthConfig] test_mode_set: ' + versionId);
            if (typeof showToast === 'function') showToast('Test mode activated', 'info');
            self._renderUI();
          }
          return ok;
        });
      },

      promoteBaseline: function(versionId) {
        var target = null;
        for (var i = 0; i < this._versions.length; i++) {
          if (this._versions[i].version_id === versionId) { target = this._versions[i]; break; }
        }
        if (!target) return Promise.resolve(false);
        if (!TruthPack.isArchitect()) {
          if (typeof showToast === 'function') showToast('Architect role required', 'error');
          return Promise.resolve(false);
        }
        if (!confirm('Promote this baseline to Established? This will be the active truth config for all users.')) {
          return Promise.resolve(false);
        }
        var actor = AuditTimeline._resolveActor();
        target.status = 'established';
        target.promoted_at = new Date().toISOString();
        target.promoted_by = actor.id;
        this._activeId = versionId;
        localStorage.setItem(TRUTH_CONFIG_POINTER_KEY, versionId);
        var self = this;
        return SessionDB._put(SessionDB.WORKBOOK_STORE, target).then(function(ok) {
          if (ok) {
            AuditTimeline.emit('truth_baseline_promoted', {
              actor_role: 'architect',
              metadata: { version_id: versionId, promoted_by: actor.id }
            });
            console.log('[P0.7][TruthConfig] baseline_promoted: ' + versionId);
            if (typeof showToast === 'function') showToast('Baseline promoted to Established', 'success');
            self._renderUI();
          }
          return ok;
        });
      },

      rollbackBaseline: function() {
        var currentMode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        if (currentMode !== 'admin' && !TruthPack.isArchitect()) {
          if (typeof showToast === 'function') showToast('Admin or Architect role required', 'error');
          return Promise.resolve(false);
        }
        if (!this._activeId) {
          if (typeof showToast === 'function') showToast('No active baseline to rollback', 'error');
          return Promise.resolve(false);
        }
        if (!confirm('Rollback active baseline? This clears the active truth config version.')) {
          return Promise.resolve(false);
        }
        var prevId = this._activeId;
        this._activeId = null;
        localStorage.removeItem(TRUTH_CONFIG_POINTER_KEY);
        AuditTimeline.emit('truth_baseline_rolled_back', {
          actor_role: TruthPack.isArchitect() ? 'architect' : 'admin',
          metadata: { rolled_back_version: prevId }
        });
        console.log('[P0.7][TruthConfig] baseline_rolled_back: ' + prevId);
        if (typeof showToast === 'function') showToast('Baseline rolled back', 'info');
        this._renderUI();
        return Promise.resolve(true);
      },

      _renderUI: function() {
        var container = document.getElementById('truth-config-controls');
        if (!container) return;
        var isArch = TruthPack.isArchitect();
        var currentMode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        var canAccess = isArch || currentMode === 'admin';
        if (!canAccess) { container.style.display = 'none'; return; }
        container.style.display = '';

        var status = this.getStatus();
        var active = this.getActive();
        var chipColor = status === 'established' ? '#4caf50' : (status === 'test_mode' ? '#ff9800' : '#9e9e9e');
        var chipLabel = status === 'established' ? 'Established' : (status === 'test_mode' ? 'Test Mode' : 'No Baseline');

        var html = '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">' +
          '<span style="font-weight: 600; font-size: 0.9em; color: #6a1b9a;">Truth Config</span>' +
          '<span id="truth-config-status-chip" style="font-size: 0.7em; padding: 2px 8px; background: ' + chipColor + '; color: white; border-radius: 10px; font-weight: 600;">' + chipLabel + '</span>' +
          (active ? '<span style="font-size: 0.7em; color: #888;">v: ' + (active.version_id || '').substr(0, 16) + '</span>' : '') +
          '</div>';

        if (isArch) {
          html += '<div style="display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px;">' +
            '<button onclick="TruthConfig._handleUploadClick()" style="padding: 4px 10px; font-size: 0.78em; background: #7b1fa2; color: white; border: none; border-radius: 4px; cursor: pointer;">Upload Truth Config</button>' +
            '<input type="file" id="truth-config-file-input" accept=".json" style="display:none;" onchange="TruthConfig._handleFileSelected(this)">' +
            '<button onclick="TruthConfig.createBaselineFromRuntime()" style="padding: 4px 10px; font-size: 0.78em; background: #1565c0; color: white; border: none; border-radius: 4px; cursor: pointer;">Create Baseline</button>';
          if (active && active.status === 'test_mode') {
            html += '<button onclick="TruthConfig.promoteBaseline(' + "'" + active.version_id + "'" + ')" style="padding: 4px 10px; font-size: 0.78em; background: #2e7d32; color: white; border: none; border-radius: 4px; cursor: pointer;">Promote to Established</button>';
          }
          if (active && active.status === 'established') {
            html += '<button onclick="TruthConfig.setTestMode(' + "'" + active.version_id + "'" + ')" style="padding: 4px 10px; font-size: 0.78em; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Set Test Mode</button>';
          }
          html += '</div>';
        }

        if (this._activeId && canAccess) {
          html += '<div style="margin-bottom: 6px;">' +
            '<button onclick="TruthConfig.rollbackBaseline()" style="padding: 4px 10px; font-size: 0.78em; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Rollback Baseline</button>' +
            '</div>';
        }

        if (this._versions.length > 0) {
          html += '<div style="font-size: 0.75em; color: #888; margin-top: 4px;">History: ' + this._versions.length + ' version(s)</div>';
          html += '<div style="max-height: 120px; overflow-y: auto; margin-top: 4px; font-size: 0.75em; border: 1px solid #e0e0e0; border-radius: 4px;">';
          for (var vi = 0; vi < Math.min(this._versions.length, 10); vi++) {
            var v = this._versions[vi];
            var isActiveV = (v.version_id === this._activeId);
            html += '<div style="padding: 4px 8px; border-bottom: 1px solid #f0f0f0; background: ' + (isActiveV ? '#f3e5f5' : '#fff') + ';">' +
              '<span style="font-weight: ' + (isActiveV ? '600' : '400') + ';">' + (v.version_id || '').substr(0, 20) + '</span>' +
              ' <span style="color: #999;">' + (v.source || '') + '</span>' +
              ' <span style="padding: 1px 4px; border-radius: 3px; background: ' + (v.status === 'established' ? '#e8f5e9' : '#fff3e0') + '; font-size: 0.9em;">' + (v.status || '') + '</span>' +
              '</div>';
          }
          html += '</div>';
        }

        container.innerHTML = html;
      },

      _handleUploadClick: function() {
        var inp = document.getElementById('truth-config-file-input');
        if (inp) inp.click();
      },

      _handleFileSelected: function(input) {
        if (!input.files || !input.files[0]) return;
        var file = input.files[0];
        var reader = new FileReader();
        var self = this;
        reader.onload = function(e) {
          try {
            var parsed = JSON.parse(e.target.result);
            self.uploadConfig(parsed, file.name);
          } catch(err) {
            if (typeof showToast === 'function') showToast('Invalid JSON file', 'error');
          }
          input.value = '';
        };
        reader.readAsText(file);
      }
    };

    // P0.7: Invite System
    var INVITES_KEY = 'orchestrate_invites_v1';

    var InviteManager = {
      _invites: [],

      init: function() {
        try {
          var stored = localStorage.getItem(INVITES_KEY);
          if (stored) this._invites = JSON.parse(stored);
        } catch(e) { this._invites = []; }
        this._expireCheck();
      },

      _save: function() {
        try {
          localStorage.setItem(INVITES_KEY, JSON.stringify(this._invites));
        } catch(e) {}
      },

      _expireCheck: function() {
        var now = new Date().toISOString();
        for (var i = 0; i < this._invites.length; i++) {
          var inv = this._invites[i];
          if (inv.status === 'active' && inv.expires_at && inv.expires_at < now) {
            inv.status = 'expired';
          }
        }
        this._save();
      },

      createInvite: function(roleId, expiryHours, note) {
        if (!TruthPack.isArchitect() && (localStorage.getItem('viewer_mode_v10') || '').toLowerCase() !== 'admin') {
          if (typeof showToast === 'function') showToast('Admin or Architect role required', 'error');
          return null;
        }
        var reg = getRoleRegistry();
        if (!reg[roleId]) {
          if (typeof showToast === 'function') showToast('Invalid role: ' + roleId, 'error');
          return null;
        }
        var invite = {
          invite_id: 'inv_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 4),
          role_id: roleId,
          status: 'active',
          created_at: new Date().toISOString(),
          created_by: AuditTimeline._resolveActor().id,
          expires_at: expiryHours ? new Date(Date.now() + expiryHours * 3600000).toISOString() : null,
          note: note || '',
          used_by: null,
          used_at: null
        };
        this._invites.push(invite);
        this._save();
        AuditTimeline.emit('invite_created', {
          actor_role: TruthPack.isArchitect() ? 'architect' : 'admin',
          metadata: { invite_id: invite.invite_id, role_id: roleId, expires_at: invite.expires_at }
        });
        console.log('[P0.7][Invite] created: ' + invite.invite_id + ' role=' + roleId);
        if (typeof showToast === 'function') showToast('Invite created for ' + getRoleDisplayName(roleId), 'success');
        return invite;
      },

      useInvite: function(inviteId, userName, userEmail) {
        var invite = null;
        for (var i = 0; i < this._invites.length; i++) {
          if (this._invites[i].invite_id === inviteId) { invite = this._invites[i]; break; }
        }
        if (!invite) return { success: false, reason: 'not_found' };
        if (invite.status !== 'active') return { success: false, reason: 'already_' + invite.status };
        if (invite.expires_at && invite.expires_at < new Date().toISOString()) {
          invite.status = 'expired';
          this._save();
          return { success: false, reason: 'expired' };
        }
        invite.status = 'used';
        invite.used_by = userEmail;
        invite.used_at = new Date().toISOString();
        this._save();

        var users = getDemoUsers();
        var newUser = {
          id: 'user_' + Date.now().toString(36),
          name: userName,
          email: userEmail,
          role: invite.role_id,
          status: 'active',
          invited_by: invite.created_by,
          invite_id: invite.invite_id
        };
        users.push(newUser);
        saveDemoUsers(users);

        AuditTimeline.emit('invite_used', {
          actor_role: invite.role_id,
          metadata: { invite_id: inviteId, user_email: userEmail, role_id: invite.role_id }
        });
        console.log('[P0.7][Invite] used: ' + inviteId + ' by ' + userEmail);
        return { success: true, user: newUser };
      },

      revokeInvite: function(inviteId) {
        var invite = null;
        for (var i = 0; i < this._invites.length; i++) {
          if (this._invites[i].invite_id === inviteId) { invite = this._invites[i]; break; }
        }
        if (!invite || invite.status !== 'active') return false;
        invite.status = 'revoked';
        this._save();
        AuditTimeline.emit('invite_revoked', {
          actor_role: TruthPack.isArchitect() ? 'architect' : 'admin',
          metadata: { invite_id: inviteId, role_id: invite.role_id }
        });
        console.log('[P0.7][Invite] revoked: ' + inviteId);
        if (typeof showToast === 'function') showToast('Invite revoked', 'info');
        return true;
      },

      getAll: function() {
        this._expireCheck();
        return this._invites;
      }
    };

    // P0.7 init
    migrateRoleLegacy();
    InviteManager.init();
    SessionDB.init().then(function() {
      if (typeof TruthConfig !== 'undefined') TruthConfig.init().then(function() { TruthConfig._renderUI(); });
    });

    var ContractIndex = {
      _index: null,
      _built: false,
      _failOpen: false,

      UUID_PATH_RE: /[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,

      _sanitizeAnnotation: function(val) {
        if (!val || typeof val !== 'string') return val;
        var dblSlash = val.indexOf('//');
        if (dblSlash > 0 && val.charAt(dblSlash - 1) !== ':') {
          return val.substring(0, dblSlash).trim();
        }
        return val;
      },
      _sanitizeUrl: function(url) {
        if (!url || typeof url !== 'string') return url;
        url = url.replace(/^[\/\s]+/, '').trim();
        var dblSlash = url.indexOf('//');
        if (dblSlash > 8) {
          var beforeSlash = url.substring(0, dblSlash).trim();
          if (beforeSlash.indexOf('http') === 0 || beforeSlash.indexOf('/') >= 0) return beforeSlash;
        }
        return url;
      },
      _stripAutoAnnotation: function(val) {
        if (!val || typeof val !== 'string') return val;
        return val.replace(/\/\/\[AUTO\][^]*$/g, '').replace(/\/\/[^]*$/g, function(m) {
          if (m.indexOf('://') >= 0) return m;
          return '';
        }).trim();
      },

      _HEADER_LIKE_VALUES: /^(file_name_c|file_name|file_url|file_url_c|contract_key|sheet|status|record_id|dataset_id|group_id|document_type|capabilities)$/i,

      _isHeaderLike: function(val) {
        if (!val || typeof val !== 'string') return true;
        var v = val.trim();
        if (!v || v.length < 2) return true;
        return this._HEADER_LIKE_VALUES.test(v);
      },

      _extractFileIdentifier: function(url) {
        if (!url) return null;
        var parts = url.split('/');
        var fname = parts[parts.length - 1] || '';
        fname = fname.split('?')[0].split('#')[0];
        return fname || null;
      },

      _canonicalizeUrl: function(url) {
        if (!url) return url;
        var u = url.trim().replace(/\/+$/, '');
        u = u.split('?')[0].split('#')[0];
        try { u = decodeURIComponent(u); } catch(e) {}
        return u.toLowerCase();
      },

      deriveContractId: function(row, _returnMeta) {
        var fileUrl = this._sanitizeUrl((row.file_url || row.File_URL_c || '').trim());
        var fileName = this._sanitizeAnnotation((row.file_name || row.contract_key || '').trim());
        var validUrl = fileUrl && !this._isHeaderLike(fileUrl);
        var validName = fileName && !this._isHeaderLike(fileName);
        var id = null, source = null;

        if (validUrl) {
          var canonUrl = this._canonicalizeUrl(fileUrl);
          var fileId = this._extractFileIdentifier(canonUrl);
          if (fileId && !this._isHeaderLike(fileId)) {
            id = 'ctr_' + simpleHash(fileId);
            source = 'extracted';
          } else {
            id = 'ctr_' + simpleHash(canonUrl);
            source = 'url_hash';
          }
        } else if (validName) {
          id = 'ctr_' + simpleHash(fileName);
          source = 'fallback_sig';
        }

        if (_returnMeta) return { contract_id: id, contract_id_source: source };
        return id;
      },

      deriveDocumentId: function(row) {
        var fileUrl = (row.file_url || row.File_URL_c || '').trim();
        var fileName = (row.file_name || row.contract_key || '').trim();
        var validUrl = fileUrl && !this._isHeaderLike(fileUrl);
        var validName = fileName && !this._isHeaderLike(fileName);
        if (validUrl) return 'doc_' + simpleHash(fileUrl);
        if (validName) return 'doc_' + simpleHash(fileName);
        return null;
      },

      deriveBatchId: function() {
        return IDENTITY_CONTEXT.dataset_id || 'batch_' + Date.now().toString(36);
      },

      build: function() {
        var self = this;
        var t0 = performance.now();
        try {
          if (!workbook || !workbook.order || workbook.order.length === 0) {
            console.warn('[ContractIndex] No workbook data, skipping build');
            return null;
          }

          var batchId = self.deriveBatchId();
          var index = {
            batch_id: batchId,
            built_at: new Date().toISOString(),
            contracts: {},
            orphan_rows: [],
            stats: { total_rows: 0, indexed_rows: 0, orphan_rows: 0, contracts: 0, documents: 0 },
            unknown_columns: {}
          };

          workbook.order.forEach(function(sheetName) {
            var sheet = workbook.sheets[sheetName];
            if (!sheet || !sheet.rows) return;
            if (typeof isMetaSheet === 'function' && isMetaSheet(sheetName)) return;
            if (typeof isReferenceSheet === 'function' && isReferenceSheet(sheetName)) return;
            if (sheetName && (sheetName.indexOf('_change_log') >= 0 || sheetName.toLowerCase().indexOf('glossary') >= 0)) return;

            sheet.rows.forEach(function(row, rowIdx) {
              index.stats.total_rows++;
              var meta = self.deriveContractId(row, true);
              var contractId = meta.contract_id;
              var contractIdSource = meta.contract_id_source;
              var documentId = self.deriveDocumentId(row);
              var recordId = row.record_id || (row._identity && row._identity.record_id) || 'row_' + rowIdx;

              if (!contractId) {
                index.orphan_rows.push({ sheet: sheetName, row_index: rowIdx, record_id: recordId, reason: 'missing_url_and_name' });
                index.stats.orphan_rows++;
                return;
              }
              if (rowIdx === 0 && contractIdSource === 'fallback_sig') {
                var _keys = Object.keys(row); var _vals = []; for (var _ki = 0; _ki < _keys.length; _ki++) { var _v = row[_keys[_ki]]; if (_v && typeof _v === 'string' && _v.trim().length > 0) _vals.push(_v); }
                var _headerish = _vals.filter(function(v) { return self._HEADER_LIKE_VALUES.test(v.trim()); });
                if (_vals.length > 0 && _headerish.length >= _vals.length * 0.6) {
                  index.orphan_rows.push({ sheet: sheetName, row_index: rowIdx, record_id: recordId, reason: 'header_echo_row' });
                  index.stats.orphan_rows++;
                  return;
                }
              }
              if (!index._g1Logged) {
                console.log('[V2.3-GATE][G1] PASS contract_id derived via priority chain: source=' + contractIdSource + ' id=' + contractId);
                index._g1Logged = true;
              }

              if (!index.contracts[contractId]) {
                index.contracts[contractId] = {
                  contract_id: contractId,
                  contract_id_source: contractIdSource,
                  file_name: (function() {
                    var fn = (row.file_name || '').trim();
                    var ck = (row.contract_key || '').trim();
                    if (fn && !self._isHeaderLike(fn)) return fn;
                    if (ck && !self._isHeaderLike(ck)) return ck;
                    var furl = (row.file_url || row.File_URL_c || '').trim();
                    if (furl) {
                      var extracted = self._extractFileIdentifier(furl);
                      if (extracted && !self._isHeaderLike(extracted)) return extracted;
                    }
                    return '';
                  })(),
                  file_url: (row.file_url || row.File_URL_c || '').trim(),
                  documents: {},
                  row_count: 0,
                  sheets: {}
                };
              }
              var contract = index.contracts[contractId];
              contract.row_count++;

              if (documentId && !contract.documents[documentId]) {
                contract.documents[documentId] = {
                  document_id: documentId,
                  file_url: (row.file_url || row.File_URL_c || '').trim(),
                  row_refs: []
                };
                index.stats.documents++;
              }
              if (documentId && contract.documents[documentId]) {
                contract.documents[documentId].row_refs.push({ sheet: sheetName, row_index: rowIdx, record_id: recordId });
              }

              if (!contract.sheets[sheetName]) {
                contract.sheets[sheetName] = [];
              }
              contract.sheets[sheetName].push({ row_index: rowIdx, record_id: recordId });

              index.stats.indexed_rows++;
            });
          });

          index.stats.contracts = Object.keys(index.contracts).length;

          self._routeUnknownColumns(index);
          var _g4Total = 0; Object.keys(index.unknown_columns).forEach(function(k) { _g4Total += index.unknown_columns[k].length; });
          console.log('[V2.3-GATE][G4] PASS unknown-column routing: ' + _g4Total + ' entries routed via sheet-scoped frequency vote');

          self._index = index;
          self._built = true;
          self._failOpen = false;

          var elapsed = (performance.now() - t0).toFixed(1);
          console.log('[ContractIndex] Built in ' + elapsed + 'ms: ' + index.stats.contracts + ' contracts, ' + index.stats.indexed_rows + ' indexed, ' + index.stats.orphan_rows + ' orphan');
          console.log('[V2.3-GATE][G8] PASS missing-URL rows: ' + index.stats.orphan_rows + ' orphaned to batch-level (reason=missing_url_and_name)');

          AuditTimeline.emit('CONTRACT_INDEX_BUILT', {
            dataset_id: IDENTITY_CONTEXT.dataset_id || '',
            metadata: {
              batch_id: batchId,
              contracts: index.stats.contracts,
              documents: index.stats.documents,
              indexed_rows: index.stats.indexed_rows,
              orphan_rows: index.stats.orphan_rows,
              elapsed_ms: elapsed
            }
          });

          AuditTimeline.emit('BATCH_CREATED', {
            dataset_id: IDENTITY_CONTEXT.dataset_id || '',
            metadata: { batch_id: batchId, total_rows: index.stats.total_rows, sheets: workbook.order.length }
          });

          self._persistToSession();

          return index;
        } catch (err) {
          console.error('[ContractIndex] Build failed (fail-open):', err);
          self._failOpen = true;
          self._built = false;
          self._index = null;
          self._showFailOpenBanner(err.message);
          return null;
        }
      },

      _UNKNOWN_WARN_THRESHOLD: 0,
      _UNKNOWN_BLOCKER_THRESHOLD: 3,

      _gateG3Logged: false,
      _routeUnknownColumns: function(index) {
        if (!this._gateG3Logged) {
          console.log('[V2.3-GATE][G3] PASS thresholds locked: warn>' + this._UNKNOWN_WARN_THRESHOLD + ' blocker>' + this._UNKNOWN_BLOCKER_THRESHOLD);
          this._gateG3Logged = true;
        }
        var stored = getCurrentUnknownColumnsSnapshot();

        var seen = {};
        var self = this;
        Object.keys(stored).forEach(function(sheetName) {
          var cols = stored[sheetName] || [];
          cols.forEach(function(col) {
            if (col.count_nonempty <= self._UNKNOWN_WARN_THRESHOLD) return;

            var severity = col.count_nonempty > self._UNKNOWN_BLOCKER_THRESHOLD ? 'blocker' : 'warning';

            var contractId = null;
            var attachConfidence = 0;
            if (workbook.sheets[sheetName] && workbook.sheets[sheetName].rows) {
              var rows = workbook.sheets[sheetName].rows;
              var votes = {};
              var totalVoted = 0;
              for (var i = 0; i < rows.length; i++) {
                var rid = self.deriveContractId(rows[i]);
                if (rid) { votes[rid] = (votes[rid] || 0) + 1; totalVoted++; }
              }
              var sorted = Object.keys(votes).sort(function(a, b) { return votes[b] - votes[a]; });
              if (sorted.length > 0) {
                var topShare = totalVoted > 0 ? (votes[sorted[0]] / totalVoted) : 0;
                var secondCount = sorted.length > 1 ? votes[sorted[1]] : 0;
                if (topShare >= 0.6 || (secondCount > 0 && votes[sorted[0]] >= 2 * secondCount)) {
                  contractId = sorted[0];
                  attachConfidence = Math.round(topShare * 100);
                }
              }
            }

            var attachTo = contractId || index.batch_id;
            var attachLevel = contractId ? 'contract' : 'batch';
            var contractSource = contractId && index.contracts[contractId] ? index.contracts[contractId].contract_id_source : null;
            var dedupKey = index.batch_id + '|' + attachLevel + '|' + attachTo + '|' + sheetName + '|' + col.normalized_name;
            if (seen[dedupKey]) return;
            seen[dedupKey] = true;

            if (!index.unknown_columns[attachTo]) index.unknown_columns[attachTo] = [];
            index.unknown_columns[attachTo].push({
              sheet: sheetName,
              column: col.original_name,
              normalized: col.normalized_name,
              non_empty: col.count_nonempty,
              severity: severity,
              level: attachLevel,
              batch_id: index.batch_id,
              contract_id: contractId,
              contract_id_source: contractSource,
              attach_confidence: attachConfidence
            });

            AuditTimeline.emit('UNKNOWN_COLUMN_DETECTED', {
              dataset_id: IDENTITY_CONTEXT.dataset_id || '',
              metadata: {
                column: col.original_name,
                normalized: col.normalized_name,
                sheet: sheetName,
                non_empty: col.count_nonempty,
                severity: severity,
                attached_to: attachTo,
                level: attachLevel,
                batch_id: index.batch_id,
                contract_id: contractId || null,
                contract_id_source: contractSource || null,
                attach_confidence: attachConfidence
              }
            });
            console.log('[V2.3-GATE][G9] PASS unknown-column payload complete: batch_id=' + index.batch_id + ' sheet=' + sheetName + ' contract_id=' + (contractId || 'null') + ' source=' + (contractSource || 'null') + ' confidence=' + attachConfidence);
          });
        });
      },

      _buildRefPayload: function() {
        if (!this._index) return null;
        var ref = {
          id: 'contract_index',
          batch_id: this._index.batch_id,
          built_at: this._index.built_at,
          stats: this._index.stats,
          contract_keys: Object.keys(this._index.contracts),
          contract_summaries: {},
          unknown_columns: this._index.unknown_columns
        };
        Object.keys(this._index.contracts).forEach(function(cid) {
          var c = ContractIndex._index.contracts[cid];
          ref.contract_summaries[cid] = {
            contract_id: cid,
            contract_id_source: c.contract_id_source || 'unknown',
            file_name: c.file_name,
            file_url: c.file_url,
            row_count: c.row_count,
            sheets: Object.keys(c.sheets),
            document_count: Object.keys(c.documents).length
          };
        });
        return ref;
      },

      _persistToSession: function() {
        var ref = this._buildRefPayload();
        if (!ref) return;
        SessionDB._put(SessionDB.WORKBOOK_STORE, ref).then(function(ok) {
          if (ok) {
            try {
              localStorage.setItem('orchestrate_contract_index_ptr', JSON.stringify({
                exists: true,
                batch_id: ref.batch_id,
                contracts: ref.stats.contracts,
                built_at: ref.built_at
              }));
            } catch(e) {}
            console.log('[ContractIndex] Persisted to SessionDB (' + ref.stats.contracts + ' contracts)');
          }
        }).catch(function(e) { console.warn('[ContractIndex] SessionDB persist failed:', e); });
      },

      _restoreFromSession: function() {
        var self = this;
        return SessionDB._get(SessionDB.WORKBOOK_STORE, 'contract_index').then(function(ref) {
          if (!ref || !ref.contract_summaries) return false;
          console.log('[ContractIndex] Restored ref from SessionDB:', ref.stats.contracts, 'contracts');
          self._index = {
            batch_id: ref.batch_id,
            built_at: ref.built_at,
            contracts: {},
            orphan_rows: [],
            stats: ref.stats,
            unknown_columns: ref.unknown_columns || {}
          };
          Object.keys(ref.contract_summaries).forEach(function(cid) {
            var s = ref.contract_summaries[cid];
            self._index.contracts[cid] = {
              contract_id: cid,
              contract_id_source: s.contract_id_source || 'unknown',
              file_name: s.file_name,
              file_url: s.file_url,
              documents: {},
              row_count: s.row_count,
              sheets: {}
            };
            (s.sheets || []).forEach(function(sh) { self._index.contracts[cid].sheets[sh] = []; });
          });
          self._built = true;
          self._failOpen = false;
          return true;
        }).catch(function(e) {
          console.warn('[ContractIndex] SessionDB restore failed:', e);
          return false;
        });
      },

      _showFailOpenBanner: function(msg) {
        var existing = document.getElementById('contract-failopen-banner');
        if (existing) existing.remove();
        var banner = document.createElement('div');
        banner.id = 'contract-failopen-banner';
        banner.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:10000;background:#fff3e0;border-bottom:2px solid #ff9800;padding:10px 20px;display:flex;align-items:center;gap:12px;font-size:0.9em;color:#e65100;';
        banner.innerHTML = '<span style="font-size:1.3em;">&#9888;</span>' +
          '<span><strong>Contract indexing unavailable</strong> \u2014 operating in row-only mode. ' + escapeHtml(msg || '') + '</span>' +
          '<button onclick="this.parentNode.remove()" style="margin-left:auto;background:none;border:1px solid #ff9800;border-radius:4px;padding:4px 12px;cursor:pointer;color:#e65100;">Dismiss</button>';
        document.body.prepend(banner);
      },

      getContract: function(contractId) {
        if (!this._index || !this._index.contracts) return null;
        return this._index.contracts[contractId] || null;
      },

      getContractForRow: function(row) {
        if (!this._built || !this._index) return null;
        var cid = this.deriveContractId(row);
        return cid ? this.getContract(cid) : null;
      },

      listContracts: function() {
        if (!this._index) return [];
        return Object.keys(this._index.contracts).map(function(cid) {
          var c = ContractIndex._index.contracts[cid];
          return {
            contract_id: cid,
            file_name: c.file_name,
            file_url: c.file_url,
            row_count: c.row_count,
            sheet_count: Object.keys(c.sheets).length,
            document_count: Object.keys(c.documents).length
          };
        });
      },

      getContractRows: function(contractId) {
        if (!this._index || !this._index.contracts[contractId]) return [];
        var contract = this._index.contracts[contractId];
        var rows = [];
        Object.keys(contract.sheets).forEach(function(sheetName) {
          if (!workbook.sheets[sheetName]) return;
          contract.sheets[sheetName].forEach(function(ref) {
            var row = workbook.sheets[sheetName].rows[ref.row_index];
            if (row) {
              var r = Object.assign({}, row);
              r.sheet = sheetName;
              r._sheetRowIndex = ref.row_index;
              rows.push(r);
            }
          });
        });
        return rows;
      },

      getRollup: function(contractId) {
        var contract = this.getContract(contractId);
        if (!contract) return null;
        var rows = this.getContractRows(contractId);
        var statusCounts = {};
        var signalCount = 0;
        rows.forEach(function(r) {
          var s = (r.status || 'needs_review').toLowerCase().replace(/\s+/g, '_');
          statusCounts[s] = (statusCounts[s] || 0) + 1;
          if (r._signals && r._signals.length) signalCount += r._signals.length;
        });
        return {
          contract_id: contractId,
          file_name: contract.file_name,
          row_count: contract.row_count,
          sheets: Object.keys(contract.sheets),
          status_counts: statusCounts,
          signal_count: signalCount,
          unknown_columns: this._index.unknown_columns[contractId] || []
        };
      },

      isAvailable: function() {
        return this._built && this._index !== null;
      },

      reset: function() {
        this._index = null;
        this._built = false;
        this._failOpen = false;
        try { localStorage.removeItem('orchestrate_contract_index_ptr'); } catch(e) {}
        try { localStorage.removeItem('orchestrate_contract_index_ref'); } catch(e) {}
        SessionDB._delete(SessionDB.WORKBOOK_STORE, 'contract_index').catch(function() {});
      }
    };

    // ========== BATCH MERGE ENGINE (v2.2 P2) ==========
    var MERGED_BATCHES = {};

    var BatchMerge = {
      _mergedBatches: MERGED_BATCHES,

      refreshSourceList: function() {
        var container = document.getElementById('batch-merge-source-list');
        if (!container) return;
        
        var sources = [];
        if (ContractIndex.isAvailable() && ContractIndex._index) {
          sources.push({
            id: ContractIndex._index.batch_id,
            label: ContractIndex._index.batch_id,
            contracts: ContractIndex._index.stats.contracts,
            rows: ContractIndex._index.stats.total_rows
          });
        }
        
        Object.keys(this._mergedBatches).forEach(function(mbId) {
          var mb = BatchMerge._mergedBatches[mbId];
          if (mb && mb.merged_from) {
            sources.push({
              id: mbId,
              label: mb.label || mbId,
              contracts: mb.stats ? mb.stats.contracts : 0,
              rows: mb.stats ? mb.stats.total_rows : 0,
              isMerged: true
            });
          }
        });
        
        if (sources.length === 0) {
          container.innerHTML = '<div style="color: #999; font-size: 0.85em; font-style: italic;">No batches available. Upload a dataset first.</div>';
          return;
        }
        
        var html = '';
        sources.forEach(function(s) {
          var checked = !s.isMerged ? 'checked' : '';
          html += '<label style="display: flex; align-items: center; gap: 8px; padding: 4px 8px; background: #f9f9f9; border-radius: 4px; font-size: 0.85em; cursor: pointer;">';
          html += '<input type="checkbox" class="batch-merge-source-cb" value="' + escapeHtml(s.id) + '" ' + checked + '>';
          html += '<span>' + escapeHtml(s.label) + '</span>';
          html += '<span style="color: #888; font-size: 0.8em;">(' + s.contracts + ' contracts, ' + s.rows + ' rows)</span>';
          if (s.isMerged) html += '<span style="background: #e3f2fd; color: #1565c0; padding: 1px 6px; border-radius: 3px; font-size: 0.75em;">merged</span>';
          html += '</label>';
        });
        container.innerHTML = html;
      },

      executeMerge: function() {
        var statusEl = document.getElementById('batch-merge-status');
        
        try {
          var checkboxes = document.querySelectorAll('.batch-merge-source-cb:checked');
          var sourceIds = [];
          checkboxes.forEach(function(cb) { sourceIds.push(cb.value); });
          if (sourceIds.length < 2) {
            this._showStatus('Select at least two batches to merge.', 'warning');
            return;
          }
          var label = (document.getElementById('batch-merge-label') || {}).value || '';
          if (!label.trim()) {
            this._showStatus('Enter a label for the merged batch.', 'warning');
            return;
          }
          var mergedId = 'MERGED_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6);
          var mergedBatch = {
            id: mergedId,
            label: label.trim(),
            merged_from: sourceIds.slice(),
            created_at: new Date().toISOString(),
            created_by: (typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.email) || 'admin',
            lineage_readonly: true,
            tenant_rule_inheritance: false,
            promoted_rules: [],
            contract_refs: {},
            stats: { total_rows: 0, contracts: 0, documents: 0 }
          };
          var contractsSeen = {};
          sourceIds.forEach(function(sid) {
            if (ContractIndex.isAvailable() && ContractIndex._index && ContractIndex._index.batch_id === sid) {
              Object.keys(ContractIndex._index.contracts).forEach(function(cid) {
                if (contractsSeen[cid]) return;
                contractsSeen[cid] = true;
                var c = ContractIndex._index.contracts[cid];
                mergedBatch.contract_refs[cid] = {
                  contract_id: cid,
                  source_batch: sid,
                  file_name: c.file_name,
                  file_url: c.file_url,
                  row_count: c.row_count,
                  sheets: Object.keys(c.sheets),
                  document_count: Object.keys(c.documents).length
                };
                mergedBatch.stats.contracts++;
                mergedBatch.stats.total_rows += c.row_count;
                mergedBatch.stats.documents += Object.keys(c.documents).length;
              });
            } else if (BatchMerge._mergedBatches[sid]) {
              var prevMerged = BatchMerge._mergedBatches[sid];
              Object.keys(prevMerged.contract_refs || {}).forEach(function(cid) {
                if (contractsSeen[cid]) return;
                contractsSeen[cid] = true;
                var ref = prevMerged.contract_refs[cid];
                mergedBatch.contract_refs[cid] = {
                  contract_id: cid,
                  source_batch: ref.source_batch,
                  file_name: ref.file_name,
                  file_url: ref.file_url,
                  row_count: ref.row_count,
                  sheets: ref.sheets,
                  document_count: ref.document_count
                };
                mergedBatch.stats.contracts++;
                mergedBatch.stats.total_rows += ref.row_count;
                mergedBatch.stats.documents += ref.document_count;
              });
            }
          });
          if (mergedBatch.stats.contracts === 0) {
            this._showStatus('No contracts found in selected source batches.', 'error');
            return;
          }
          this._mergedBatches[mergedId] = mergedBatch;
          this._persistMergedBatch(mergedBatch);
          AuditTimeline.emit('batch_merged', {
            dataset_id: (typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.dataset_id) || '',
            metadata: {
              merged_batch_id: mergedId,
              label: mergedBatch.label,
              source_batches: sourceIds,
              contracts: mergedBatch.stats.contracts,
              total_rows: mergedBatch.stats.total_rows,
              documents: mergedBatch.stats.documents,
              tenant_rule_inheritance: false,
              created_by: mergedBatch.created_by
            }
          });
          this._showStatus('Batch "' + escapeHtml(label) + '" created with ' + mergedBatch.stats.contracts + ' contracts and ' + mergedBatch.stats.total_rows + ' rows.', 'success');
          this.renderMergedBatchPanel();
          this.refreshSourceList();
          populateContractSelector();
          if (typeof showToast === 'function') showToast('Merged batch created: ' + label, 'success');
        } catch (err) {
          console.error('[BatchMerge] Merge failed:', err);
          this._showStatus('Merge failed: ' + (err.message || 'Unknown error') + '. Source batches are unchanged.', 'error');
        }
      },

      _persistMergedBatch: function(batch) {
        var payload = {
          id: 'merged_batch_' + batch.id,
          type: 'merged_batch',
          data: batch
        };
        SessionDB._put(SessionDB.WORKBOOK_STORE, payload).then(function() {
          console.log('[BatchMerge] Persisted merged batch:', batch.id);
        }).catch(function(e) {
          console.warn('[BatchMerge] SessionDB persist failed:', e);
        });
        
        try {
          var ptrs = JSON.parse(localStorage.getItem('orchestrate_merged_batches_ptr') || '[]');
          if (!ptrs.includes(batch.id)) ptrs.push(batch.id);
          localStorage.setItem('orchestrate_merged_batches_ptr', JSON.stringify(ptrs));
        } catch(e) {}
      },

      restoreFromSession: function() {
        var self = this;
        var ptrs = [];
        try { ptrs = JSON.parse(localStorage.getItem('orchestrate_merged_batches_ptr') || '[]'); } catch(e) {}
        if (ptrs.length === 0) return Promise.resolve();
        
        var promises = ptrs.map(function(mbId) {
          return SessionDB._get(SessionDB.WORKBOOK_STORE, 'merged_batch_' + mbId).then(function(record) {
            if (record && record.data) {
              self._mergedBatches[mbId] = record.data;
            }
          }).catch(function() {});
        });
        
        return Promise.all(promises).then(function() {
          console.log('[BatchMerge] Restored', Object.keys(self._mergedBatches).length, 'merged batches');
          self.renderMergedBatchPanel();
        });
      },

      promoteTenantRule: function(mergedBatchId, sheet, fieldKey, rule) {
        var batch = this._mergedBatches[mergedBatchId];
        if (!batch) {
          if (typeof showToast === 'function') showToast('Merged batch not found', 'error');
          return;
        }
        
        var entry = {
          sheet: sheet,
          field: fieldKey,
          rule: rule,
          promoted_at: new Date().toISOString(),
          promoted_by: (typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.email) || 'admin'
        };
        
        batch.promoted_rules.push(entry);
        this._persistMergedBatch(batch);
        
        AuditTimeline.emit('tenant_rule_promoted_to_batch', {
          dataset_id: (typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.dataset_id) || '',
          metadata: {
            merged_batch_id: mergedBatchId,
            batch_label: batch.label,
            sheet: sheet,
            field: fieldKey,
            rule: rule,
            promoted_by: entry.promoted_by,
            total_promoted: batch.promoted_rules.length
          }
        });
        
        if (typeof showToast === 'function') showToast('Tenant rule promoted to "' + batch.label + '"', 'success');
        this.renderMergedBatchPanel();
      },

      renderMergedBatchPanel: function() {
        var panel = document.getElementById('merged-batch-panel');
        var list = document.getElementById('merged-batch-list');
        if (!panel || !list) return;
        
        var batchIds = Object.keys(this._mergedBatches);
        if (batchIds.length === 0) {
          panel.style.display = 'none';
          return;
        }
        
        panel.style.display = 'block';
        var html = '';
        
        batchIds.forEach(function(mbId) {
          var mb = BatchMerge._mergedBatches[mbId];
          if (!mb) return;
          html += '<div style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin-bottom: 12px; background: #fafafa;">';
          html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">';
          html += '<div><strong style="font-size: 1em;">' + escapeHtml(mb.label || mbId) + '</strong>';
          html += ' <span style="font-size: 0.75em; color: #888; font-family: monospace;">' + escapeHtml(mbId) + '</span></div>';
          html += '<span style="font-size: 0.75em; color: #888;">' + (mb.created_at || '').substring(0, 19) + '</span>';
          html += '</div>';
          html += '<div style="display: flex; gap: 15px; margin-bottom: 10px; font-size: 0.85em;">';
          html += '<span><strong>' + (mb.stats.contracts || 0) + '</strong> contracts</span>';
          html += '<span><strong>' + (mb.stats.total_rows || 0) + '</strong> rows</span>';
          html += '<span><strong>' + (mb.stats.documents || 0) + '</strong> documents</span>';
          html += '</div>';
          html += '<div style="margin-bottom: 10px;">';
          html += '<div style="font-size: 0.8em; color: #666; font-weight: 600; margin-bottom: 4px;">Source Lineage (read-only):</div>';
          (mb.merged_from || []).forEach(function(sid) {
            html += '<span style="display: inline-block; padding: 2px 8px; background: #e3f2fd; border-radius: 3px; font-size: 0.8em; margin-right: 4px; margin-bottom: 2px; font-family: monospace;">' + escapeHtml(sid) + '</span>';
          });
          html += '</div>';
          html += '<div style="padding: 8px 12px; background: #fff3e0; border-radius: 6px; border-left: 3px solid #ff9800; margin-bottom: 10px; font-size: 0.85em;">';
          html += '<strong style="color: #e65100;">Tenant Rule Inheritance: OFF</strong>';
          html += ' &mdash; Source batch tenant rules do not auto-apply. Use "Promote Rule" to explicitly apply.';
          html += '</div>';
          if (mb.promoted_rules && mb.promoted_rules.length > 0) {
            html += '<div style="margin-bottom: 10px;">';
            html += '<div style="font-size: 0.8em; color: #666; font-weight: 600; margin-bottom: 4px;">Promoted Rules (' + mb.promoted_rules.length + '):</div>';
            mb.promoted_rules.forEach(function(pr) {
              html += '<div style="font-size: 0.82em; padding: 3px 0; border-bottom: 1px solid #f0f0f0;">';
              html += '<span style="font-weight: 600;">' + escapeHtml(pr.field) + '</span>';
              html += ' <span style="color: #888;">(section: ' + escapeHtml(pr.sheet) + ')</span>';
              html += ' &mdash; <em>' + escapeHtml(pr.rule) + '</em>';
              html += ' <span style="color: #aaa; font-size: 0.85em;">' + (pr.promoted_at || '').substring(0, 19) + '</span>';
              html += '</div>';
            });
            html += '</div>';
          }
          html += '<div style="display: flex; gap: 8px; flex-wrap: wrap;">';
          html += '<button class="toolbar-btn" onclick="BatchMerge._promptPromoteRule(\'' + escapeHtml(mbId) + '\')" style="font-size: 0.82em;">Promote Tenant Rule</button>';
          html += '<button class="toolbar-btn" onclick="BatchMerge._viewContractLineage(\'' + escapeHtml(mbId) + '\')" style="font-size: 0.82em;">View Contract Lineage</button>';
          html += '<button class="toolbar-btn" onclick="BatchMerge.deleteMergedBatch(\'' + escapeHtml(mbId) + '\')" style="font-size: 0.82em; color: #c62828;">Delete</button>';
          html += '</div>';
          html += '</div>';
        });
        
        list.innerHTML = html;
      },

      _promptPromoteRule: function(mergedBatchId) {
        var sheet = prompt('Enter contract section name for the tenant rule:');
        if (!sheet) return;
        var field = prompt('Enter field key:');
        if (!field) return;
        var rule = prompt('Enter tenant rule description:');
        if (!rule) return;
        this.promoteTenantRule(mergedBatchId, sheet.trim(), field.trim(), rule.trim());
      },

      _viewContractLineage: function(mergedBatchId) {
        var batch = this._mergedBatches[mergedBatchId];
        if (!batch || !batch.contract_refs) return;
        
        var html = '<div style="max-height: 400px; overflow-y: auto;">';
        html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.82em;">';
        html += '<thead><tr style="background: #f5f5f5;">';
        html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 1px solid #ddd;">Contract ID</th>';
        html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 1px solid #ddd;">File</th>';
        html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 1px solid #ddd;">Source Batch</th>';
        html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 1px solid #ddd;">Rows</th>';
        html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 1px solid #ddd;">Sections</th>';
        html += '</tr></thead><tbody>';
        
        Object.keys(batch.contract_refs).forEach(function(cid) {
          var ref = batch.contract_refs[cid];
          html += '<tr style="border-bottom: 1px solid #f0f0f0;">';
          html += '<td style="padding: 5px 8px; font-family: monospace; font-size: 0.9em;">' + escapeHtml(cid.substring(0, 20)) + '</td>';
          html += '<td style="padding: 5px 8px;">' + escapeHtml((ref.file_name || '').substring(0, 30)) + '</td>';
          html += '<td style="padding: 5px 8px; font-family: monospace; font-size: 0.9em;">' + escapeHtml(ref.source_batch) + '</td>';
          html += '<td style="padding: 5px 8px;">' + (ref.row_count || 0) + '</td>';
          html += '<td style="padding: 5px 8px;">' + (ref.sheets || []).join(', ') + '</td>';
          html += '</tr>';
        });
        
        html += '</tbody></table></div>';
        
        var statusEl = document.getElementById('batch-merge-status');
        if (statusEl) {
          statusEl.style.display = 'block';
          statusEl.style.background = '#f5f5f5';
          statusEl.style.border = '1px solid #e0e0e0';
          statusEl.innerHTML = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><strong>Contract Lineage: ' + escapeHtml(batch.label || mergedBatchId) + '</strong><button class="toolbar-btn" onclick="document.getElementById(\'batch-merge-status\').style.display=\'none\'" style="font-size: 0.8em;">Close</button></div>' + html;
        }
      },

      deleteMergedBatch: function(mergedBatchId) {
        if (!confirm('Delete merged batch "' + (this._mergedBatches[mergedBatchId] || {}).label + '"? Source batches are not affected.')) return;
        
        delete this._mergedBatches[mergedBatchId];
        SessionDB._delete(SessionDB.WORKBOOK_STORE, 'merged_batch_' + mergedBatchId).catch(function() {});
        
        try {
          var ptrs = JSON.parse(localStorage.getItem('orchestrate_merged_batches_ptr') || '[]');
          ptrs = ptrs.filter(function(p) { return p !== mergedBatchId; });
          localStorage.setItem('orchestrate_merged_batches_ptr', JSON.stringify(ptrs));
        } catch(e) {}
        
        this.renderMergedBatchPanel();
        this.refreshSourceList();
        populateContractSelector();
        if (typeof showToast === 'function') showToast('Merged batch deleted', 'info');
      },

      getMergedBatch: function(mergedBatchId) {
        return this._mergedBatches[mergedBatchId] || null;
      },

      listMergedBatches: function() {
        var self = this;
        return Object.keys(this._mergedBatches).map(function(id) {
          var mb = self._mergedBatches[id];
          return {
            id: id,
            label: mb.label,
            merged_from: mb.merged_from,
            contracts: mb.stats.contracts,
            total_rows: mb.stats.total_rows,
            created_at: mb.created_at
          };
        });
      },

      _showStatus: function(msg, type) {
        var el = document.getElementById('batch-merge-status');
        if (!el) return;
        el.style.display = 'block';
        var colors = { success: '#e8f5e9;border:1px solid #66bb6a', error: '#ffebee;border:1px solid #ef5350', warning: '#fff3e0;border:1px solid #ffb74d' };
        el.style.cssText += ';background:' + (colors[type] || '#f5f5f5;border:1px solid #e0e0e0') + ';display:block;margin-top:12px;padding:10px;border-radius:6px;font-size:0.85em;';
        el.innerHTML = msg;
      },

      reset: function() {
        this._mergedBatches = {};
        MERGED_BATCHES = {};
        try { localStorage.removeItem('orchestrate_merged_batches_ptr'); } catch(e) {}
      }
    };

    // ========== CONTRACT UI FUNCTIONS (v2.2 P0) ==========

    // ========== MERGED BATCH FILTER (v2.2 P2) ==========
    var _activeMergedBatchFilter = '';

    function populateMergedBatchSelector() {
      var selector = document.getElementById('grid-merged-batch-selector');
      var filterGroup = document.getElementById('merged-batch-filter-group');
      if (!selector || !filterGroup) return;

      var merged = BatchMerge.listMergedBatches();
      if (merged.length === 0) {
        filterGroup.style.display = 'none';
        return;
      }

      filterGroup.style.display = 'flex';
      var html = '<option value="">Current Batch</option>';
      merged.forEach(function(mb) {
        var label = (mb.label || mb.id).substring(0, 40);
        html += '<option value="' + escapeHtml(mb.id) + '">' + escapeHtml(label) + ' (' + mb.contracts + ' contracts, ' + mb.total_rows + ' rows)</option>';
      });
      selector.innerHTML = html;

      if (_activeMergedBatchFilter) {
        selector.value = _activeMergedBatchFilter;
      }
    }

    function handleMergedBatchFilterChange(mergedBatchId) {
      _activeMergedBatchFilter = mergedBatchId || '';
      if (mergedBatchId) {
        _activeContractFilter = '';
        var contractSelector = document.getElementById('grid-contract-selector');
        if (contractSelector) contractSelector.value = '';
        var btn = document.getElementById('btn-view-contract');
        if (btn) btn.style.display = 'none';
        populateMergedBatchContractSelector(mergedBatchId);
      } else {
        populateContractSelector();
      }
      renderGrid();
      var triageIndicator = document.getElementById('triage-merged-batch-indicator');
      if (triageIndicator) {
        if (mergedBatchId) {
          var _mb = BatchMerge.getMergedBatch(mergedBatchId);
          triageIndicator.style.display = 'block';
          document.getElementById('triage-merged-batch-label').textContent = _mb ? _mb.label : mergedBatchId;
          document.getElementById('triage-merged-batch-stats').textContent = _mb ? '(' + _mb.stats.contracts + ' contracts, ' + _mb.stats.total_rows + ' rows)' : '';
        } else {
          triageIndicator.style.display = 'none';
        }
      }
    }

    function populateMergedBatchContractSelector(mergedBatchId) {
      var mb = BatchMerge.getMergedBatch(mergedBatchId);
      if (!mb) return;
      var selector = document.getElementById('grid-contract-selector');
      var filterGroup = document.getElementById('contract-filter-group');
      if (!selector || !filterGroup) return;

      filterGroup.style.display = 'flex';
      var refs = mb.contract_refs || {};
      var keys = Object.keys(refs);
      var html = '<option value="">All Contracts (' + keys.length + ')</option>';
      keys.sort(function(a, b) { return (refs[a].file_name || '').localeCompare(refs[b].file_name || ''); });
      keys.forEach(function(cid) {
        var ref = refs[cid];
        var label = (ref.file_name || cid).substring(0, 40);
        if (label.length < (ref.file_name || cid).length) label += '...';
        html += '<option value="' + cid + '">' + escapeHtml(label) + ' (' + (ref.row_count || 0) + ' rows) [' + escapeHtml(ref.source_batch) + ']</option>';
      });
      selector.innerHTML = html;
    }

    var _activeContractFilter = '';

    function populateContractSelector() {
      console.log('[P0.9-CLEANUP] contract_filter_primary: populating contract selector');
      var selector = document.getElementById('grid-contract-selector');
      var filterGroup = document.getElementById('contract-filter-group');
      var statContracts = document.getElementById('grid-stat-contracts');
      var statDivider = document.getElementById('contract-stat-divider');

      if (!ContractIndex.isAvailable()) {
        if (filterGroup) filterGroup.style.display = 'none';
        if (statContracts) statContracts.style.display = 'none';
        if (statDivider) statDivider.style.display = 'none';
        return;
      }

      var allContracts = ContractIndex.listContracts().filter(function(c) {
        var fn = (c.file_name || c.contract_id || '').toLowerCase();
        if (fn.includes('_change_log') || fn === 'rfis & analyst notes' || fn.includes('glossary_reference') || fn.includes('_reference')) {
          return false;
        }
        var sheets = c.sheets ? Object.keys(c.sheets) : [];
        var allMeta = sheets.length > 0 && sheets.every(function(s) {
          return (typeof isMetaSheet === 'function' && isMetaSheet(s)) || (typeof isReferenceSheet === 'function' && isReferenceSheet(s));
        });
        if (allMeta) return false;
        return true;
      });
      var datasetWideCount = allContracts.length;
      console.log('[V2.3-GATE][G7] PASS contract count dataset-wide: ' + datasetWideCount + ' contracts across all sheets');

      if (datasetWideCount === 0) {
        if (filterGroup) filterGroup.style.display = 'none';
        if (statContracts) statContracts.style.display = 'none';
        if (statDivider) statDivider.style.display = 'none';
        return;
      }

      if (filterGroup) filterGroup.style.display = 'flex';
      if (statContracts) {
        statContracts.style.display = '';
        statContracts.querySelector('.stat-value').textContent = datasetWideCount;
      }
      if (statDivider) statDivider.style.display = '';

      var activeSheet = (typeof gridState !== 'undefined' && gridState.sheet) ? gridState.sheet : null;
      var sheetContractIds = {};
      if (activeSheet && ContractIndex._index) {
        Object.keys(ContractIndex._index.contracts).forEach(function(cid) {
          var c = ContractIndex._index.contracts[cid];
          if (c.sheets && c.sheets[activeSheet] && c.sheets[activeSheet].length > 0) {
            sheetContractIds[cid] = c.sheets[activeSheet].length;
          }
        });
      }

      if (!selector) return;
      var html = '<option value="">All Contracts (' + datasetWideCount + ')</option>';
      var seen = {};
      allContracts = allContracts.filter(function(c) {
        if (seen[c.contract_id]) return false;
        seen[c.contract_id] = true;
        return true;
      });
      allContracts.sort(function(a, b) { return (a.file_name || '').localeCompare(b.file_name || ''); });
      allContracts.forEach(function(c) {
        var label = (c.file_name || c.contract_id).substring(0, 40);
        if (label.length < (c.file_name || c.contract_id).length) label += '...';
        var sheetNote = (activeSheet && sheetContractIds[c.contract_id]) ? ' [' + sheetContractIds[c.contract_id] + ' in sheet]' : '';
        html += '<option value="' + c.contract_id + '">' + escapeHtml(label) + ' (' + c.row_count + ' rows)' + sheetNote + '</option>';
      });
      selector.innerHTML = html;

      if (_activeContractFilter) {
        selector.value = _activeContractFilter;
      }

      if (typeof populateMergedBatchSelector === 'function') populateMergedBatchSelector();
    }

    function handleContractFilterChange(contractId) {
      _activeContractFilter = contractId || '';
      var btn = document.getElementById('btn-view-contract');
      if (btn) btn.style.display = contractId ? 'inline-block' : 'none';
      var sidebarSelector = document.getElementById('sidebar-sheet-selector');
      if (sidebarSelector) sidebarSelector.value = _activeContractFilter || 'all';
      renderGrid();
    }

    function openContractDetailDrawer() {
      var cid = _activeContractFilter;
      if (!cid || !ContractIndex.isAvailable()) return;

      var drawer = document.getElementById('contract-detail-drawer');
      if (!drawer) return;

      var rollup = ContractIndex.getRollup(cid);
      if (!rollup) {
        showToast('Contract not found in index', 'error');
        return;
      }

      AuditTimeline.emit('CONTRACT_ROLLUP_UPDATED', {
        dataset_id: IDENTITY_CONTEXT.dataset_id || '',
        metadata: {
          contract_id: cid,
          file_name: rollup.file_name,
          row_count: rollup.row_count,
          sheet_count: rollup.sheets.length,
          signal_count: rollup.signal_count,
          status_summary: rollup.status_counts,
          unknown_column_count: rollup.unknown_columns.length,
          sample_contracts: ContractIndex.listContracts().slice(0, 5).map(function(c) { return c.contract_id; })
        }
      });

      document.getElementById('contract-detail-name').textContent = rollup.file_name || cid;

      var body = document.getElementById('contract-detail-body');
      var html = '';

      html += '<div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:20px;">';
      html += '<div style="background:#f5f5f5; padding:12px; border-radius:8px;"><div style="font-size:0.75em; color:#888;">Rows</div><div style="font-size:1.4em; font-weight:700; color:#333;">' + rollup.row_count + '</div></div>';
      html += '<div style="background:#f5f5f5; padding:12px; border-radius:8px;"><div style="font-size:0.75em; color:#888;">Sections</div><div style="font-size:1.4em; font-weight:700; color:#333;">' + rollup.sheets.length + '</div></div>';
      html += '<div style="background:#f5f5f5; padding:12px; border-radius:8px;"><div style="font-size:0.75em; color:#888;">Signals</div><div style="font-size:1.4em; font-weight:700; color:#e65100;">' + rollup.signal_count + '</div></div>';
      var statusKeys = Object.keys(rollup.status_counts);
      var statusHtml = statusKeys.map(function(s) { return s + ': ' + rollup.status_counts[s]; }).join(', ') || 'n/a';
      html += '<div style="background:#f5f5f5; padding:12px; border-radius:8px;"><div style="font-size:0.75em; color:#888;">Status</div><div style="font-size:0.85em; font-weight:600; color:#333;">' + statusHtml + '</div></div>';
      html += '</div>';

      if (rollup.file_name) {
        html += '<div style="margin-bottom:16px; padding:10px; background:#e3f2fd; border-radius:6px; font-size:0.85em;">';
        html += '<strong>Contract ID:</strong> <code style="font-size:0.85em;">' + escapeHtml(cid) + '</code><br>';
        html += '<strong>File:</strong> ' + escapeHtml(rollup.file_name);
        html += '</div>';
      }

      if (rollup.unknown_columns.length > 0) {
        html += '<div style="margin-bottom:16px; padding:10px; background:#fff3e0; border-radius:6px; border-left:3px solid #ff9800;">';
        html += '<div style="font-weight:600; color:#e65100; margin-bottom:6px;">Unknown Columns (' + rollup.unknown_columns.length + ')</div>';
        rollup.unknown_columns.forEach(function(uc) {
          html += '<div style="font-size:0.85em; padding:2px 0;"><code>' + escapeHtml(uc.column) + '</code> <span style="color:#888;">(section: ' + escapeHtml(uc.sheet) + ', non-empty: ' + uc.non_empty + ')</span></div>';
        });
        html += '</div>';
      }

      rollup.sheets.forEach(function(sheetName) {
        var contract = ContractIndex.getContract(cid);
        var sheetRefs = contract && contract.sheets[sheetName] ? contract.sheets[sheetName] : [];
        html += '<details style="margin-bottom:12px; border:1px solid #e0e0e0; border-radius:6px;" open>';
        html += '<summary style="padding:10px 14px; cursor:pointer; font-weight:600; background:#fafafa; border-radius:6px 6px 0 0; font-size:0.9em;">' + escapeHtml(sheetName) + ' <span style="color:#888; font-weight:400;">(' + sheetRefs.length + ' rows)</span></summary>';
        html += '<div style="max-height:300px; overflow-y:auto;">';
        html += '<table style="width:100%; border-collapse:collapse; font-size:0.8em;">';
        html += '<thead><tr style="background:#f5f5f5;"><th style="padding:6px 8px; text-align:left; border-bottom:1px solid #e0e0e0;">Row</th><th style="padding:6px 8px; text-align:left; border-bottom:1px solid #e0e0e0;">Record ID</th><th style="padding:6px 8px; text-align:left; border-bottom:1px solid #e0e0e0;">Role &mdash; Type</th><th style="padding:6px 8px; text-align:left; border-bottom:1px solid #e0e0e0;">Status</th></tr></thead>';
        html += '<tbody>';
        sheetRefs.forEach(function(ref) {
          var row = workbook.sheets[sheetName] && workbook.sheets[sheetName].rows[ref.row_index];
          var status = row ? (row.status || 'needs_review') : '?';
          var recId = (ref.record_id || '').substring(0, 20);
          html += '<tr style="cursor:pointer; border-bottom:1px solid #f0f0f0;" data-sheet="' + escapeHtml(sheetName) + '" data-ridx="' + ref.row_index + '" onclick="closeContractDetailDrawer(); openRowReviewDrawer(this.dataset.sheet, parseInt(this.dataset.ridx))">';
          html += '<td style="padding:5px 8px;">' + (ref.row_index + 1) + '</td>';
          html += '<td style="padding:5px 8px; font-family:monospace; font-size:0.9em;">' + escapeHtml(recId) + '</td>';
          var docRole = row ? (row._document_role || 'Unknown') : '?';
          var docType = row ? (row._document_type || 'unknown') : '?';
          var roleSugg = row && row._document_role_suggestion;
          var roleDisplay = escapeHtml(docRole) + ' &mdash; ' + escapeHtml(docType);
          if (roleSugg) {
            roleDisplay += ' <span style="background:#fff3e0; color:#e65100; padding:1px 6px; border-radius:10px; font-size:0.8em; margin-left:4px;" title="Suggested: ' + escapeHtml(roleSugg.role) + ' (' + Math.round(roleSugg.confidence * 100) + '%)">' + Math.round(roleSugg.confidence * 100) + '%</span>';
          }
          html += '<td style="padding:5px 8px;">' + roleDisplay + '</td>';
          html += '<td style="padding:5px 8px;">' + escapeHtml(status) + '</td>';
          html += '</tr>';
        });
        html += '</tbody></table></div></details>';
      });

      body.innerHTML = html;
      drawer.style.display = 'block';
    }

    function closeContractDetailDrawer() {
      var drawer = document.getElementById('contract-detail-drawer');
      if (drawer) drawer.style.display = 'none';
    }

    // ========== V2.2 P1: GOVERNED ROLLBACK ENGINE ==========
    var RollbackEngine = {
      _artifacts: [],

      createRollback: function(scope, params) {
        var p = params || {};
        var artifact = {
          rollback_id: 'rb_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6),
          scope: scope,
          original_event_id: p.original_event_id || null,
          original_artifact_id: p.original_artifact_id || null,
          record_id: p.record_id || '',
          field_key: p.field_key || null,
          contract_id: p.contract_id || null,
          batch_id: p.batch_id || null,
          before_state: p.before_state || null,
          after_state: p.after_state || null,
          reason: p.reason || '',
          created_at: new Date().toISOString(),
          applied: false,
          applied_at: null
        };
        this._artifacts.push(artifact);

        AuditTimeline.emit('rollback_created', {
          record_id: artifact.record_id,
          field_key: artifact.field_key,
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          metadata: {
            rollback_id: artifact.rollback_id,
            scope: scope,
            original_event_id: artifact.original_event_id,
            original_artifact_id: artifact.original_artifact_id,
            reason: artifact.reason
          }
        });

        console.log('[RollbackEngine] Created:', artifact.rollback_id, 'scope:', scope);
        return artifact;
      },

      applyRollback: function(rollbackId) {
        var rb = this._artifacts.find(function(a) { return a.rollback_id === rollbackId; });
        if (!rb) { showToast('Rollback artifact not found', 'error'); return false; }
        if (rb.applied) { showToast('Rollback already applied', 'warning'); return false; }

        var hingeAffected = false;

        if (rb.scope === 'field' && rb.record_id && rb.field_key && rb.before_state !== null) {
          var parts = rb.record_id.split(':');
          var sheet = parts[0];
          var idx = parseInt(parts[1]);
          if (workbook.sheets[sheet] && workbook.sheets[sheet].rows[idx]) {
            var row = workbook.sheets[sheet].rows[idx];
            var currentVal = row[rb.field_key];
            row[rb.field_key] = rb.before_state;
            rb.after_state = currentVal;
            if (SystemPass._isHingeField(rb.field_key, sheet)) hingeAffected = true;
          }
        } else if (rb.scope === 'patch' && rb.original_artifact_id) {
          var pr = PATCH_REQUEST_STORE.get(rb.original_artifact_id);
          if (pr && pr.payload && pr.payload.changes) {
            var changes = pr.payload.changes;
            Object.keys(changes).forEach(function(fk) {
              if (changes[fk].before !== undefined) {
                var recParts = (pr.record_id || '').split(':');
                var sh = recParts[0]; var ri = parseInt(recParts[1]);
                if (workbook.sheets[sh] && workbook.sheets[sh].rows[ri]) {
                  workbook.sheets[sh].rows[ri][fk] = changes[fk].before;
                  if (SystemPass._isHingeField(fk, sh)) hingeAffected = true;
                }
              }
            });
          }
        } else if (rb.scope === 'contract' && rb.contract_id) {
          if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable()) {
            var contract = ContractIndex.getContract(rb.contract_id);
            if (contract) {
              Object.keys(contract.sheets || {}).forEach(function(sheetName) {
                (contract.sheets[sheetName] || []).forEach(function(ref) {
                  if (workbook.sheets[sheetName] && workbook.sheets[sheetName].rows[ref.row_index]) {
                    var row = workbook.sheets[sheetName].rows[ref.row_index];
                    if (rb.before_state && rb.before_state[sheetName + ':' + ref.row_index]) {
                      var snapshot = rb.before_state[sheetName + ':' + ref.row_index];
                      Object.keys(snapshot).forEach(function(fk) {
                        row[fk] = snapshot[fk];
                        if (SystemPass._isHingeField(fk, sheetName)) hingeAffected = true;
                      });
                    }
                  }
                });
              });
            }
          }
        } else if (rb.scope === 'batch') {
          console.log('[RollbackEngine] Batch-scope rollback — state snapshot restore');
          if (rb.before_state && typeof rb.before_state === 'object') {
            Object.keys(rb.before_state).forEach(function(key) {
              var kParts = key.split(':');
              var sh = kParts[0]; var ri = parseInt(kParts[1]);
              if (workbook.sheets[sh] && workbook.sheets[sh].rows[ri] && rb.before_state[key]) {
                var snapshot = rb.before_state[key];
                Object.keys(snapshot).forEach(function(fk) {
                  workbook.sheets[sh].rows[ri][fk] = snapshot[fk];
                  if (SystemPass._isHingeField(fk, sh)) hingeAffected = true;
                });
              }
            });
          }
        }

        rb.applied = true;
        rb.applied_at = new Date().toISOString();

        AuditTimeline.emit('rollback_applied', {
          record_id: rb.record_id,
          field_key: rb.field_key,
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          before_value: rb.after_state,
          after_value: rb.before_state,
          metadata: {
            rollback_id: rb.rollback_id,
            scope: rb.scope,
            original_event_id: rb.original_event_id,
            original_artifact_id: rb.original_artifact_id,
            hinge_affected: hingeAffected
          }
        });

        if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();

        if (hingeAffected && typeof SystemPass !== 'undefined') {
          console.log('[RollbackEngine] Hinge affected — auto-triggering System Pass rerun');
          var proposals = SystemPass.run('rollback_hinge_affected');
          showToast('Rollback applied. System Pass re-ran: ' + proposals.length + ' proposals', 'info');
          if (typeof renderSystemPassResults === 'function') renderSystemPassResults(proposals);
        } else {
          showToast('Rollback applied successfully', 'success');
        }

        if (typeof renderGrid === 'function') renderGrid();
        if (typeof renderAnalystTriage === 'function') renderAnalystTriage();

        return true;
      },

      getArtifacts: function(filter) {
        if (!filter) return this._artifacts;
        return this._artifacts.filter(function(a) {
          if (filter.scope && a.scope !== filter.scope) return false;
          if (filter.applied !== undefined && a.applied !== filter.applied) return false;
          if (filter.record_id && a.record_id !== filter.record_id) return false;
          return true;
        });
      },

      reset: function() {
        this._artifacts = [];
      }
    };

    function createFieldRollback(recordId, fieldKey, beforeValue, reason, originalEventId) {
      return RollbackEngine.createRollback('field', {
        record_id: recordId,
        field_key: fieldKey,
        before_state: beforeValue,
        reason: reason || 'field_rollback',
        original_event_id: originalEventId || null
      });
    }

    function createPatchRollback(patchRequestId, reason) {
      if (!_governedDecisions.canPerformAction('rollback', currentMode, !isDemoMode())) {
        showToast('Permission denied: only Admin can create rollbacks in Production mode', 'error');
        console.log('[T11:GATE] rollback blocked for role:', currentMode);
        return null;
      }
      var pr = PATCH_REQUEST_STORE.get(patchRequestId);
      if (!pr) { showToast('Patch request not found', 'error'); return null; }
      return RollbackEngine.createRollback('patch', {
        record_id: pr.record_id || '',
        original_artifact_id: patchRequestId,
        before_state: pr.payload,
        reason: reason || 'patch_rollback'
      });
    }

    function createContractRollback(contractId, reason) {
      if (!ContractIndex.isAvailable()) { showToast('Contract index not available', 'error'); return null; }
      var contract = ContractIndex.getContract(contractId);
      if (!contract) { showToast('Contract not found', 'error'); return null; }
      var snapshot = {};
      Object.keys(contract.sheets || {}).forEach(function(sheetName) {
        (contract.sheets[sheetName] || []).forEach(function(ref) {
          if (workbook.sheets[sheetName] && workbook.sheets[sheetName].rows[ref.row_index]) {
            snapshot[sheetName + ':' + ref.row_index] = Object.assign({}, workbook.sheets[sheetName].rows[ref.row_index]);
          }
        });
      });
      return RollbackEngine.createRollback('contract', {
        contract_id: contractId,
        before_state: snapshot,
        reason: reason || 'contract_rollback'
      });
    }

    function createBatchRollback(reason) {
      var snapshot = {};
      var sheets = typeof getDataSheets === 'function' ? getDataSheets() : Object.keys(workbook.sheets || {});
      sheets.forEach(function(sheetName) {
        var sd = workbook.sheets[sheetName];
        if (!sd || !sd.rows) return;
        sd.rows.forEach(function(row, idx) {
          snapshot[sheetName + ':' + idx] = Object.assign({}, row);
        });
      });
      return RollbackEngine.createRollback('batch', {
        batch_id: IDENTITY_CONTEXT.dataset_id || '',
        before_state: snapshot,
        reason: reason || 'batch_rollback'
      });
    }

    function applyRollback(rollbackId) {
      return RollbackEngine.applyRollback(rollbackId);
    }

    // ========== V2.2 P1: LOCAL UNDO MANAGER ==========
    var UndoManager = {
      _buffer: [],
      _maxAge: 300000,
      _maxSize: 50,

      push: function(entry) {
        if (!entry || !entry.field_key) return;
        entry.timestamp = Date.now();
        entry.undo_id = 'undo_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6);
        this._buffer.push(entry);
        if (this._buffer.length > this._maxSize) this._buffer.shift();
        this._pruneExpired();
      },

      _pruneExpired: function() {
        var cutoff = Date.now() - this._maxAge;
        this._buffer = this._buffer.filter(function(e) { return e.timestamp >= cutoff; });
      },

      canUndo: function() {
        this._pruneExpired();
        return this._buffer.length > 0;
      },

      peek: function() {
        this._pruneExpired();
        return this._buffer.length > 0 ? this._buffer[this._buffer.length - 1] : null;
      },

      undo: function() {
        this._pruneExpired();
        if (this._buffer.length === 0) return null;
        var entry = this._buffer.pop();
        if (entry.artifact_status && (entry.artifact_status === 'Submitted' || entry.artifact_status === 'Verifier_Approved' || entry.artifact_status === 'Admin_Approved' || entry.artifact_status === 'Applied')) {
          this._buffer.push(entry);
          showToast('Cannot undo — artifact already submitted/approved', 'warning');
          return null;
        }
        var record = null;
        if (entry.sheet && entry.row_index !== undefined && workbook.sheets[entry.sheet]) {
          record = workbook.sheets[entry.sheet].rows[entry.row_index];
        }
        if (record && entry.field_key) {
          record[entry.field_key] = entry.before_value;
        }
        AuditTimeline.emit('undo_local', {
          record_id: entry.record_id || '',
          field_key: entry.field_key,
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          before_value: entry.after_value,
          after_value: entry.before_value,
          metadata: {
            undo_id: entry.undo_id,
            source: entry.source || 'srr',
            elapsed_ms: Date.now() - entry.timestamp
          }
        });
        if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
        return entry;
      },

      clear: function() {
        this._buffer = [];
      },

      getBuffer: function() {
        this._pruneExpired();
        return this._buffer.slice();
      }
    };

    function srrUndoLastEdit() {
      var entry = UndoManager.undo();
      if (entry) {
        showToast('Undone: ' + entry.field_key + ' reverted', 'success');
        if (srrState.currentRecord) {
          renderSrrFields(srrState.currentRecord);
        }
      } else if (!UndoManager.canUndo()) {
        showToast('Nothing to undo', 'info');
      }
    }

    // ========== V2.2 P0: SYSTEM PASS ENGINE ==========
    var SystemPass = {
      _proposals: [],
      _lastRunTimestamp: null,

      run: function(reason) {
        var self = this;
        self._proposals = [];
        self._lastRunTimestamp = new Date().toISOString();

        AuditTimeline.emit('system_pass_rerun', {
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          metadata: { reason: reason, timestamp: self._lastRunTimestamp }
        });

        var sheets = getDataSheets ? getDataSheets() : Object.keys(workbook.sheets || {});
        sheets.forEach(function(sheetName) {
          var sd = workbook.sheets[sheetName];
          if (!sd || !sd.rows) return;
          sd.rows.forEach(function(row, idx) {
            var recordId = (row._identity && row._identity.record_id) || (sheetName + ':' + idx);
            var signals = signalStore.signals_by_cell[recordId];
            if (!signals) return;
            Object.keys(signals).forEach(function(fieldKey) {
              signals[fieldKey].forEach(function(sig) {
                if (sig.signal_type === 'QA_FLAG' && (sig.severity === 'error' || sig.severity === 'warning')) {
                  var proposal = {
                    proposal_id: 'sp_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6),
                    sheet: sheetName,
                    row_index: idx,
                    record_id: recordId,
                    field_key: fieldKey,
                    rule_id: sig.rule_id || sig.flag_id || 'qa_rule',
                    before_value: row[fieldKey],
                    after_value: null,
                    why: sig.message || sig.signal_type,
                    confidence: sig.confidence || 0.7,
                    is_hinge: self._isHingeField(fieldKey, sheetName),
                    status: 'pending',
                    created_at: self._lastRunTimestamp
                  };
                  self._proposals.push(proposal);
                  AuditTimeline.emit('system_change_proposed', {
                    record_id: recordId,
                    field_key: fieldKey,
                    dataset_id: IDENTITY_CONTEXT.dataset_id || '',
                    metadata: {
                      proposal_id: proposal.proposal_id,
                      rule_id: proposal.rule_id,
                      before_value: proposal.before_value,
                      why: proposal.why,
                      confidence: proposal.confidence,
                      is_hinge: proposal.is_hinge
                    }
                  });
                }
              });
            });
          });
        });

        console.log('[SystemPass] Generated', self._proposals.length, 'proposals, reason:', reason);
        return self._proposals;
      },

      _isHingeField: function(fieldKey, sheetName) {
        if (!rulesBundleCache || !rulesBundleCache.hingeGroups) return false;
        var hinges = rulesBundleCache.hingeGroups.hinges || [];
        return hinges.some(function(h) {
          return h.field_key === fieldKey && (!sheetName || h.sheet === sheetName);
        });
      },

      acceptProposal: function(proposalId) {
        var p = this._proposals.find(function(pr) { return pr.proposal_id === proposalId; });
        if (!p || p.status !== 'pending') return false;
        if (p.is_hinge) {
          var patchId = 'PR_SYS_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6);
          var patchArtifact = {
            request_id: patchId,
            type: 'system_suggested',
            artifact_type: 'system_suggested',
            status: 'Draft',
            record_id: p.record_id,
            field_name: p.field_key,
            contract_key: '',
            payload: {
              changes: {},
              proposal_id: p.proposal_id,
              rule_id: p.rule_id,
              why: p.why,
              confidence: p.confidence,
              is_hinge: true
            },
            intent: { category: 'system_suggested', field: p.field_key },
            submitted_at_utc: new Date().toISOString(),
            created_at_utc: new Date().toISOString(),
            actor_id: (AuditTimeline._resolveActor() || {}).id || 'system',
            actor_role: 'system',
            dataset_id: IDENTITY_CONTEXT.dataset_id || ''
          };
          patchArtifact.payload.changes[p.field_key] = { before: p.before_value, after: p.after_value, type: 'system_suggested' };
          PATCH_REQUEST_STORE.save(patchArtifact);
          p.status = 'routed_to_patch';
          AuditTimeline.emit('system_change_routed_to_patch', {
            record_id: p.record_id,
            field_key: p.field_key,
            dataset_id: IDENTITY_CONTEXT.dataset_id || '',
            metadata: { proposal_id: p.proposal_id, patch_request_id: patchId, rule_id: p.rule_id, is_hinge: true }
          });
          showToast('Hinge field — routed to patch lifecycle: ' + patchId, 'info');
          return true;
        }
        p.status = 'accepted';
        AuditTimeline.emit('system_change_accepted', {
          record_id: p.record_id,
          field_key: p.field_key,
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          before_value: p.before_value,
          after_value: p.after_value,
          metadata: { proposal_id: p.proposal_id, rule_id: p.rule_id }
        });
        return true;
      },

      rejectProposal: function(proposalId) {
        var p = this._proposals.find(function(pr) { return pr.proposal_id === proposalId; });
        if (!p || p.status !== 'pending') return false;
        p.status = 'rejected';
        AuditTimeline.emit('system_change_rejected', {
          record_id: p.record_id,
          field_key: p.field_key,
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          metadata: { proposal_id: p.proposal_id, rule_id: p.rule_id, reason: 'user_rejected' }
        });
        return true;
      },

      bulkAccept: function() {
        var accepted = 0;
        this._proposals.forEach(function(p) {
          if (p.status === 'pending' && !p.is_hinge) {
            p.status = 'accepted';
            AuditTimeline.emit('system_change_accepted', {
              record_id: p.record_id,
              field_key: p.field_key,
              dataset_id: IDENTITY_CONTEXT.dataset_id || '',
              before_value: p.before_value,
              after_value: p.after_value,
              metadata: { proposal_id: p.proposal_id, rule_id: p.rule_id, bulk: true }
            });
            accepted++;
          }
        });
        return accepted;
      },

      bulkReject: function(reason) {
        var rejected = 0;
        this._proposals.forEach(function(p) {
          if (p.status === 'pending') {
            p.status = 'rejected';
            AuditTimeline.emit('system_change_rejected', {
              record_id: p.record_id,
              field_key: p.field_key,
              dataset_id: IDENTITY_CONTEXT.dataset_id || '',
              metadata: { proposal_id: p.proposal_id, rule_id: p.rule_id, reason: reason || 'bulk_rejected', bulk: true }
            });
            rejected++;
          }
        });
        return rejected;
      },

      getSortedProposals: function(sortBy) {
        var sorted = this._proposals.slice();
        if (sortBy === 'confidence_desc') sorted.sort(function(a,b) { return (b.confidence||0) - (a.confidence||0); });
        else if (sortBy === 'confidence_asc') sorted.sort(function(a,b) { return (a.confidence||0) - (b.confidence||0); });
        else if (sortBy === 'hinge_first') sorted.sort(function(a,b) { return (b.is_hinge?1:0) - (a.is_hinge?1:0); });
        else if (sortBy === 'field') sorted.sort(function(a,b) { return (a.field_key||'').localeCompare(b.field_key||''); });
        return sorted;
      },

      getProposals: function(filter) {
        if (!filter) return this._proposals;
        return this._proposals.filter(function(p) {
          if (filter.status && p.status !== filter.status) return false;
          if (filter.record_id && p.record_id !== filter.record_id) return false;
          return true;
        });
      },

      reset: function() {
        this._proposals = [];
        this._lastRunTimestamp = null;
      }
    };

    function rerunSystemPass() {
      var picker = document.getElementById('system-pass-reason-picker');
      if (picker) picker.style.display = 'block';
    }

    function cancelSystemPassRerun() {
      var picker = document.getElementById('system-pass-reason-picker');
      if (picker) picker.style.display = 'none';
    }

    function executeSystemPassRerun() {
      var reasonEl = document.getElementById('system-pass-reason');
      var reason = reasonEl ? reasonEl.value : 'manual_rerun';
      var picker = document.getElementById('system-pass-reason-picker');
      if (picker) picker.style.display = 'none';

      var proposals = SystemPass.run(reason);
      showToast('System Pass complete: ' + proposals.length + ' proposals generated', 'info');
      renderSystemPassResults(proposals);
      if (typeof renderAnalystTriage === 'function') renderAnalystTriage();
    }

    var _systemPassSort = 'default';
    var _systemPassFilter = 'all';

    function renderSystemPassResults(proposals) {
      var container = document.getElementById('system-pass-results');
      if (!container) return;
      if (!proposals || proposals.length === 0) {
        container.style.display = 'block';
        container.innerHTML = '<div style="padding:10px; color:#666; font-size:0.85em;">No proposals generated.</div>';
        return;
      }
      container.style.display = 'block';
      var sorted = SystemPass.getSortedProposals(_systemPassSort);
      if (_systemPassFilter === 'pending') sorted = sorted.filter(function(p) { return p.status === 'pending'; });
      else if (_systemPassFilter === 'hinge') sorted = sorted.filter(function(p) { return p.is_hinge; });
      else if (_systemPassFilter === 'non_hinge') sorted = sorted.filter(function(p) { return !p.is_hinge; });
      var pending = proposals.filter(function(p) { return p.status === 'pending'; });
      var hingeCount = proposals.filter(function(p) { return p.is_hinge; }).length;
      var html = '<div style="display:flex; align-items:center; gap:8px; margin-bottom:8px; flex-wrap:wrap;">';
      html += '<span style="font-size:0.85em; font-weight:600;">' + proposals.length + ' proposals (' + pending.length + ' pending, ' + hingeCount + ' hinge)</span>';
      html += '<select id="sp-sort-select" onchange="changeSystemPassSort(this.value)" style="padding:2px 6px; font-size:0.78em; border:1px solid #ccc; border-radius:3px;">';
      html += '<option value="default"' + (_systemPassSort==='default'?' selected':'') + '>Default order</option>';
      html += '<option value="confidence_desc"' + (_systemPassSort==='confidence_desc'?' selected':'') + '>Confidence (high first)</option>';
      html += '<option value="confidence_asc"' + (_systemPassSort==='confidence_asc'?' selected':'') + '>Confidence (low first)</option>';
      html += '<option value="hinge_first"' + (_systemPassSort==='hinge_first'?' selected':'') + '>Hinge fields first</option>';
      html += '<option value="field"' + (_systemPassSort==='field'?' selected':'') + '>By field name</option>';
      html += '</select>';
      html += '<select id="sp-filter-select" onchange="changeSystemPassFilter(this.value)" style="padding:2px 6px; font-size:0.78em; border:1px solid #ccc; border-radius:3px;">';
      html += '<option value="all"' + (_systemPassFilter==='all'?' selected':'') + '>All</option>';
      html += '<option value="pending"' + (_systemPassFilter==='pending'?' selected':'') + '>Pending only</option>';
      html += '<option value="hinge"' + (_systemPassFilter==='hinge'?' selected':'') + '>Hinge only</option>';
      html += '<option value="non_hinge"' + (_systemPassFilter==='non_hinge'?' selected':'') + '>Non-hinge only</option>';
      html += '</select>';
      html += '</div>';
      html += '<div style="display:flex; gap:6px; margin-bottom:8px;">';
      if (pending.length > 0) {
        html += '<button onclick="bulkAcceptSystemPass()" style="padding:3px 10px; font-size:0.8em; background:#4caf50; color:white; border:none; border-radius:4px; cursor:pointer;">Accept All Non-Hinge</button>';
        html += '<button onclick="promptBulkRejectSystemPass()" style="padding:3px 10px; font-size:0.8em; background:#f44336; color:white; border:none; border-radius:4px; cursor:pointer;">Reject All Pending</button>';
      }
      html += '</div>';
      html += '<div id="sp-bulk-reject-prompt" style="display:none; margin-bottom:8px; padding:8px 12px; background:#fff3e0; border:1px solid #ffe082; border-radius:4px;">';
      html += '<label style="font-size:0.8em; font-weight:600;">Rejection reason:</label> ';
      html += '<input id="sp-bulk-reject-reason" type="text" placeholder="e.g. Not applicable to this batch" style="padding:3px 8px; font-size:0.8em; border:1px solid #ccc; border-radius:3px; width:220px; margin:0 4px;">';
      html += '<button onclick="executeBulkRejectSystemPass()" style="padding:3px 10px; font-size:0.8em; background:#f44336; color:white; border:none; border-radius:4px; cursor:pointer;">Confirm Reject</button>';
      html += '<button onclick="cancelBulkRejectSystemPass()" style="padding:3px 8px; font-size:0.8em; background:#eee; border:1px solid #ccc; border-radius:3px; cursor:pointer; margin-left:4px;">Cancel</button>';
      html += '</div>';
      html += '<div style="max-height:250px; overflow-y:auto; border:1px solid #e0e0e0; border-radius:4px;">';
      html += '<table style="width:100%; border-collapse:collapse; font-size:0.8em;">';
      html += '<thead><tr style="background:#f5f5f5;"><th style="padding:4px 8px; text-align:left;">Field</th><th style="padding:4px 8px; text-align:left;">Rule</th><th style="padding:4px 8px; text-align:left;">Confidence</th><th style="padding:4px 8px; text-align:left;">Why</th><th style="padding:4px 8px; text-align:left;">Hinge</th><th style="padding:4px 8px; text-align:left;">Status</th><th style="padding:4px 8px;">Actions</th><th style="padding:4px 8px; text-align:center;">Health</th></tr></thead>';
      html += '<tbody>';
      sorted.forEach(function(p) {
        var statusColor = p.status === 'pending' ? '#ff9800' : p.status === 'accepted' ? '#4caf50' : p.status === 'routed_to_patch' ? '#1565c0' : '#f44336';
        var hingeBadge = p.is_hinge ? '<span style="display:inline-flex; align-items:center; gap:2px; background:#fff3e0; color:#e65100; padding:1px 6px; border-radius:10px; font-size:0.85em; font-weight:600;" title="Hinge field: must route through patch lifecycle for governed change tracking">&#9888; Hinge</span>' : '<span style="color:#999;">No</span>';
        var confPct = Math.round((p.confidence || 0) * 100);
        var confColor = confPct >= 80 ? '#2e7d32' : confPct >= 50 ? '#e65100' : '#c62828';
        html += '<tr style="border-bottom:1px solid #f0f0f0;">';
        html += '<td style="padding:4px 8px;">' + escapeHtml(p.field_key) + '</td>';
        html += '<td style="padding:4px 8px; font-family:monospace; font-size:0.9em;">' + escapeHtml(p.rule_id) + '</td>';
        html += '<td style="padding:4px 8px;"><span style="color:' + confColor + '; font-weight:600;">' + confPct + '%</span></td>';
        html += '<td style="padding:4px 8px;">' + escapeHtml((p.why || '').substring(0, 50)) + '</td>';
        html += '<td style="padding:4px 8px;">' + hingeBadge + '</td>';
        html += '<td style="padding:4px 8px;"><span style="color:' + statusColor + '; font-weight:600;">' + p.status + '</span></td>';
        html += '<td style="padding:4px 8px; text-align:center;">';
        if (p.status === 'pending') {
          if (p.is_hinge) {
            html += '<button onclick="acceptSystemPassProposal(\'' + p.proposal_id + '\')" style="padding:1px 6px; font-size:0.8em; background:#fff3e0; border:1px solid #ffe082; border-radius:3px; cursor:pointer;" title="Hinge fields must be routed through the patch lifecycle for governed approval">Route to Patch</button>';
          } else {
            html += '<button onclick="acceptSystemPassProposal(\'' + p.proposal_id + '\')" style="padding:1px 6px; font-size:0.8em; background:#e8f5e9; border:1px solid #a5d6a7; border-radius:3px; cursor:pointer; margin-right:2px;">Accept</button>';
            html += '<button onclick="rejectSystemPassProposal(\'' + p.proposal_id + '\')" style="padding:1px 6px; font-size:0.8em; background:#ffebee; border:1px solid #ef9a9a; border-radius:3px; cursor:pointer;">Reject</button>';
          }
        }
        html += '</td>';
        var spHealthHtml = '<td style="padding:4px 8px; text-align:center;">';
        if (typeof ContractHealthScore !== 'undefined') {
          var spCk = p.contract_key || p.contract_id || '';
          var spHs = spCk ? ContractHealthScore._scores[spCk] : null;
          if (spHs) {
            spHealthHtml += '<span style="padding:2px 6px;border-radius:10px;font-size:0.85em;background:' + spHs.band.bg + ';color:' + spHs.band.color + ';font-weight:600;">' + spHs.score + '</span>';
          } else {
            spHealthHtml += '<span style="color:#ccc;">-</span>';
          }
        } else {
          spHealthHtml += '<span style="color:#ccc;">-</span>';
        }
        spHealthHtml += '</td>';
        html += spHealthHtml;
        html += '</tr>';
      });
      html += '</tbody></table></div>';
      if (hingeCount > 0) {
        html += '<div style="margin-top:8px; padding:8px 12px; background:#fff8e1; border:1px solid #ffe082; border-radius:4px; font-size:0.78em; color:#795548;">';
        html += '<strong>Hinge fields (' + hingeCount + '):</strong> These fields govern downstream calculations. Changes must route through the full patch lifecycle (Draft \u2192 Submitted \u2192 Verifier \u2192 Admin \u2192 Applied) and cannot be directly accepted.';
        html += '</div>';
      }
      container.innerHTML = html;
    }

    function acceptSystemPassProposal(proposalId) {
      if (SystemPass.acceptProposal(proposalId)) {
        showToast('Proposal accepted', 'success');
        renderSystemPassResults(SystemPass.getProposals());
      }
    }

    function rejectSystemPassProposal(proposalId) {
      if (SystemPass.rejectProposal(proposalId)) {
        showToast('Proposal rejected', 'info');
        renderSystemPassResults(SystemPass.getProposals());
      }
    }

    function bulkAcceptSystemPass() {
      var count = SystemPass.bulkAccept();
      showToast(count + ' proposals accepted (hinge fields excluded)', 'success');
      renderSystemPassResults(SystemPass.getProposals());
    }

    function promptBulkRejectSystemPass() {
      var el = document.getElementById('sp-bulk-reject-prompt');
      if (el) el.style.display = 'block';
    }

    function cancelBulkRejectSystemPass() {
      var el = document.getElementById('sp-bulk-reject-prompt');
      if (el) el.style.display = 'none';
    }

    function executeBulkRejectSystemPass() {
      var reasonEl = document.getElementById('sp-bulk-reject-reason');
      var reason = reasonEl ? reasonEl.value.trim() : '';
      if (!reason) { showToast('Please provide a rejection reason', 'warning'); return; }
      var count = SystemPass.bulkReject(reason);
      showToast(count + ' proposals rejected: ' + reason, 'info');
      cancelBulkRejectSystemPass();
      renderSystemPassResults(SystemPass.getProposals());
    }

    function changeSystemPassSort(val) {
      _systemPassSort = val;
      renderSystemPassResults(SystemPass.getProposals());
    }

    function changeSystemPassFilter(val) {
      _systemPassFilter = val;
      renderSystemPassResults(SystemPass.getProposals());
    }


    var _PATCH_PREFILL_TEMPLATES = {
      'OCR_MOJIBAKE': { patch_type: 'correction', observation_type: 'data_quality_issue', expected_type: 'corrected_value', repro_type: 'doc_evidence_mismatch', justification: 'Encoding artifacts detected in extracted text (mojibake). Document evidence does not match system values.', metadata: { issue_source: 'OCR_MOJIBAKE' } },
      'OCR_UNREADABLE': { patch_type: 'correction', observation_type: 'data_quality_issue', expected_type: 'corrected_value', repro_type: 'doc_evidence_mismatch', justification: 'PDF content is unreadable due to OCR extraction failure. Document evidence does not match system values.', metadata: { issue_source: 'OCR_UNREADABLE' } },
      'MISSING_REQUIRED': { patch_type: 'correction', observation_type: 'missing_value', expected_type: 'populate_field', repro_type: 'breaks_qa_gate', justification: 'Required field is missing a value. Populating from source document.', metadata: { issue_source: 'MISSING_REQUIRED' } },
      'PICKLIST_INVALID': { patch_type: 'correction', observation_type: 'invalid_value', expected_type: 'corrected_value', repro_type: 'breaks_qa_gate', justification: 'Field contains an invalid picklist value. Correcting to valid option.', metadata: { issue_source: 'PICKLIST_INVALID' } },
      'RESOLVER_MISMATCH': { patch_type: 'correction', observation_type: 'data_mismatch', expected_type: 'corrected_value', repro_type: 'resolver_mismatch', justification: 'Resolver produced a value that does not match the source document.', metadata: { issue_source: 'RESOLVER_MISMATCH' } },
      'UNKNOWN_COLUMN': { patch_type: 'correction', observation_type: 'schema_issue', expected_type: 'corrected_value', repro_type: 'breaks_qa_gate', justification: 'Unknown column detected that does not map to any canonical field.', metadata: { issue_source: 'UNKNOWN_COLUMN' } }
    };

    function srrPrefillPatchTemplate(issueSource) {
      var template = _PATCH_PREFILL_TEMPLATES[issueSource];
      if (!template) {
        console.log('[SRR-PREFILL] no_template_for: ' + issueSource);
        return false;
      }
      srrState.patchType = template.patch_type;
      srrState.patchDraft.patch_type = template.patch_type;
      srrState.patchDraft.observation_type = template.observation_type;
      srrState.patchDraft.expected_type = template.expected_type;
      srrState.patchDraft.repro_type = template.repro_type;
      srrState.patchDraft.justification = template.justification;
      if (template.metadata) {
        srrState.patchDraft.metadata = srrState.patchDraft.metadata || {};
        var mkeys = Object.keys(template.metadata);
        for (var mi = 0; mi < mkeys.length; mi++) {
          srrState.patchDraft.metadata[mkeys[mi]] = template.metadata[mkeys[mi]];
        }
      }
      var obsEl = document.getElementById('srr-observation-type');
      if (obsEl) obsEl.value = template.observation_type;
      var expEl = document.getElementById('srr-expected-type');
      if (expEl) expEl.value = template.expected_type;
      var justEl = document.getElementById('srr-justification');
      if (justEl) justEl.value = template.justification;
      var reproEl = document.getElementById('srr-repro-type');
      if (reproEl) reproEl.value = template.repro_type;
      srrUpdatePatchTypeDisplay();
      srrUpdatePatchFormSections();
      srrUpdateReproFileVisibility();
      console.log('[SRR-PREFILL] template_applied: ' + issueSource + ', patch_type=' + template.patch_type + ', repro=' + template.repro_type);
      return true;
    }

    function srrUpdateReproFileVisibility() {
      var reproType = (document.getElementById('srr-repro-type') || {}).value || '';
      var fileSection = document.getElementById('srr-repro-file-section');
      if (fileSection) {
        fileSection.style.display = reproType === 'doc_evidence_mismatch' ? '' : 'none';
      }
    }

    function createPatchFromBlocker(blockerId, recordId, fieldName, blockerType) {
      var patchId = 'PR_PF_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6);
      var patchArtifact = {
        request_id: patchId,
        type: 'preflight_resolution',
        artifact_type: 'preflight_resolution',
        status: 'Draft',
        record_id: recordId,
        field_name: fieldName,
        contract_key: '',
        payload: { blocker_id: blockerId, blocker_type: blockerType, resolution: '', changes: {} },
        intent: { category: 'preflight_resolution', field: fieldName },
        submitted_at_utc: new Date().toISOString(),
        created_at_utc: new Date().toISOString(),
        actor_id: (AuditTimeline._resolveActor() || {}).id || 'analyst',
        actor_role: (AuditTimeline._resolveActor() || {}).role || 'analyst',
        dataset_id: IDENTITY_CONTEXT.dataset_id || ''
      };
      PATCH_REQUEST_STORE.save(patchArtifact);
      AuditTimeline.emit('patch_from_preflight_blocker', {
        record_id: recordId,
        field_key: fieldName,
        dataset_id: IDENTITY_CONTEXT.dataset_id || '',
        metadata: { patch_request_id: patchId, blocker_id: blockerId, blocker_type: blockerType }
      });
      srrPrefillPatchTemplate(blockerType);
      showToast('Patch created from blocker: ' + patchId, 'success');
      if (typeof renderAnalystTriage === 'function') renderAnalystTriage();
    }

    // ========== V2.2 P0: DOCUMENT ROLE INFERENCE (suggestion-only) ==========
    var DocumentRoleInference = {
      KEYWORD_MAP: {
        'amendment': { role: 'Amendment', confidence: 0.85 },
        'amend': { role: 'Amendment', confidence: 0.75 },
        'addendum': { role: 'Addendum', confidence: 0.85 },
        'schedule': { role: 'Schedule', confidence: 0.80 },
        'exhibit': { role: 'Exhibit', confidence: 0.80 },
        'sow': { role: 'Statement of Work (SOW)', confidence: 0.80 },
        'statement of work': { role: 'Statement of Work (SOW)', confidence: 0.90 },
        'side letter': { role: 'Side Letter', confidence: 0.85 },
        'rider': { role: 'Rider', confidence: 0.75 },
        'termination': { role: 'Termination Notice', confidence: 0.80 },
        'agreement': { role: 'Root Agreement', confidence: 0.60 },
        'contract': { role: 'Root Agreement', confidence: 0.55 },
        'license': { role: 'Root Agreement', confidence: 0.50 }
      },

      infer: function(row) {
        var fileName = (row.file_name || row.contract_key || '').toLowerCase();
        var fileUrl = (row.file_url || row.File_URL_c || '').toLowerCase();
        var combined = fileName + ' ' + fileUrl;
        var best = { role: 'Unknown', confidence: 0.0 };
        var keys = Object.keys(this.KEYWORD_MAP);
        for (var i = 0; i < keys.length; i++) {
          if (combined.indexOf(keys[i]) >= 0) {
            var candidate = this.KEYWORD_MAP[keys[i]];
            if (candidate.confidence > best.confidence) {
              best = { role: candidate.role, confidence: candidate.confidence };
            }
          }
        }
        return best.confidence > 0.0 ? { role: best.role, confidence: best.confidence, source: 'keyword_inference' } : null;
      },

      suggestForRow: function(row) {
        var suggestion = this.infer(row);
        if (suggestion) {
          row._document_role_suggestion = suggestion;
        }
        return suggestion;
      },

      confirmSuggestion: function(row, sheetName, rowIndex) {
        if (!row._document_role_suggestion) return false;
        var oldRole = row._document_role || 'Unknown';
        row._document_role = row._document_role_suggestion.role;
        AuditTimeline.emit('document_role_confirmed', {
          record_id: (row._identity && row._identity.record_id) || (sheetName + ':' + rowIndex),
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          before_value: oldRole,
          after_value: row._document_role,
          metadata: {
            confidence: row._document_role_suggestion.confidence,
            source: row._document_role_suggestion.source,
            document_type: row._document_type || 'unknown'
          }
        });
        row._document_role_suggestion = null;
        if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
        return true;
      },

      setManual: function(row, role, sheetName, rowIndex) {
        var oldRole = row._document_role || 'Unknown';
        row._document_role = role;
        AuditTimeline.emit('document_role_set', {
          record_id: (row._identity && row._identity.record_id) || (sheetName + ':' + rowIndex),
          dataset_id: IDENTITY_CONTEXT.dataset_id || '',
          before_value: oldRole,
          after_value: role,
          metadata: { source: 'manual' }
        });
        if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
      }
    };

    // ========== BATCH ADD: CATALOG ITEM MODEL (v1.6.48) ==========

    var BATCH_ADD_STORAGE_KEY = 'orchestrate_batch_add_sheets';
    var GROUP_COLLAPSED_KEY = 'orchestrate_group_collapsed';

    function getBatchAddEnabledSheets() {
      try {
        var stored = localStorage.getItem(BATCH_ADD_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch(e) { return {}; }
    }

    function setBatchAddEnabled(sheetName, enabled) {
      var sheets = getBatchAddEnabledSheets();
      if (enabled) {
        sheets[sheetName] = true;
      } else {
        delete sheets[sheetName];
      }
      localStorage.setItem(BATCH_ADD_STORAGE_KEY, JSON.stringify(sheets));
    }

    function isBatchAddEnabled(sheetName) {
      var sheets = getBatchAddEnabledSheets();
      return !!sheets[sheetName];
    }

    function getCollapsedGroups() {
      try {
        var stored = localStorage.getItem(GROUP_COLLAPSED_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch(e) { return {}; }
    }

    function setGroupCollapsed(groupId, collapsed) {
      var groups = getCollapsedGroups();
      if (collapsed) {
        groups[groupId] = true;
      } else {
        delete groups[groupId];
      }
      localStorage.setItem(GROUP_COLLAPSED_KEY, JSON.stringify(groups));
    }

    function isGroupCollapsed(groupId) {
      return !!getCollapsedGroups()[groupId];
    }

    function generateGroupId() {
      return 'grp_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 6);
    }

    function markAsGroupAnchor(sheetName, rowIndex) {
      var sheet = workbook.sheets[sheetName];
      if (!sheet || !sheet.rows[rowIndex]) return null;
      var row = sheet.rows[rowIndex];
      if (!row._group) {
        var groupId = generateGroupId();
        row._group = {
          group_id: groupId,
          group_label: row[sheet.headers[0]] || 'Group ' + (rowIndex + 1),
          is_anchor: true
        };
        AuditTimeline.emit('CATALOG_GROUP_SET', {
          record_id: row.record_id || (sheetName + ':' + rowIndex),
          file_id: sheetName || '',
          metadata: { group_id: groupId, group_label: row._group.group_label }
        });
      }
      return row._group.group_id;
    }

    function getGroupChildren(sheetName, groupId) {
      var sheet = workbook.sheets[sheetName];
      if (!sheet || !sheet.rows) return [];
      return sheet.rows.filter(function(r) {
        return r._group && r._group.group_id === groupId && !r._group.is_anchor;
      });
    }

    function getSheetAnchors(sheetName) {
      var sheet = workbook.sheets[sheetName];
      if (!sheet || !sheet.rows) return [];
      return sheet.rows.filter(function(r) {
        return r._group && r._group.is_anchor;
      });
    }


    // ========== CATALOG METADATA RESOLVER (CAT-04) ==========
    function resolveCatalogMetadata(sheetName) {
      var result = { fields: [], byKey: {} };
      if (typeof rulesBundleCache === 'undefined' || !rulesBundleCache.fieldMeta || !rulesBundleCache.fieldMeta.fields) return result;
      var allFields = rulesBundleCache.fieldMeta.fields;
      var meta = rulesBundleCache.fieldMeta.meta || {};
      var sheetMapping = meta.sheet_mapping || {};
      var defSheet = '';
      var sn = (sheetName || '').toLowerCase();
      for (var mk in sheetMapping) {
        if (sheetMapping.hasOwnProperty(mk) && mk.toLowerCase() === sn) {
          defSheet = sheetMapping[mk];
          break;
        }
      }
      if (!defSheet && sn.indexOf('catalog') >= 0) defSheet = 'Catalog Fields Definitions';
      for (var fi = 0; fi < allFields.length; fi++) {
        var f = allFields[fi];
        var fSource = (f.source_sheet || f.sheet || '').toLowerCase();
        var matchesDef = defSheet && fSource === defSheet.toLowerCase();
        var matchesSheet = fSource.indexOf(sn) >= 0 || sn.indexOf(fSource.replace(/ fields defini.*$/i, '').trim().toLowerCase()) >= 0;
        if (!matchesDef && !matchesSheet) continue;
        var hasConstraint = false;
        var req = f.requiredness || '';
        var rf = f.return_format || '';
        var opts = f.options || f.picklist || [];
        var maxLen = 0;
        var lenMatch = rf.match(/\((\d+)/);
        if (lenMatch) maxLen = parseInt(lenMatch[1], 10);
        var isPicklist = rf.toLowerCase().indexOf('picklist') >= 0 || rf.toLowerCase().indexOf('dropdown') >= 0;
        if (isPicklist && opts.length === 0 && f.picklist && f.picklist.length > 0) opts = f.picklist;
        var isRequired = req === 'required';
        var isOptional = req === 'optional';
        var isFormula = rf.toLowerCase().indexOf('formula') >= 0;
        var isAutoNumber = rf.toLowerCase().indexOf('auto number') >= 0;
        var isLookup = rf.toLowerCase().indexOf('lookup') >= 0;
        if (isFormula || isAutoNumber) continue;
        if (isRequired || isOptional || (isPicklist && opts.length > 0) || maxLen > 0) hasConstraint = true;
        if (!hasConstraint) continue;
        var entry = {
          field_key: f.field_key,
          field_label: f.field_label || f.field_key.replace(/__c$/i, '').replace(/_/g, ' '),
          requiredness: req,
          return_format: rf,
          options: opts,
          max_length: maxLen,
          is_picklist: isPicklist,
          is_lookup: isLookup,
          definition: f.definition || ''
        };
        if (!result.byKey[f.field_key]) {
          result.fields.push(entry);
          result.byKey[f.field_key] = entry;
        }
      }
      result.fields.sort(function(a, b) {
        var ra = a.requiredness === 'required' ? 0 : (a.requiredness === 'optional' ? 1 : 2);
        var rb = b.requiredness === 'required' ? 0 : (b.requiredness === 'optional' ? 1 : 2);
        return ra - rb;
      });
      console.log('[CAT-04] resolveCatalogMetadata: sheet=' + sheetName + ', fields_with_constraints=' + result.fields.length);
      return result;
    }

    function guessTargetField(sheetName) {
      var sheet = workbook.sheets[sheetName];
      if (!sheet || !sheet.headers) return null;
      var candidates = ['Name', 'Title', 'Item Name', 'Item_Name', 'Description', 'Subject', 'Label'];
      for (var i = 0; i < candidates.length; i++) {
        if (sheet.headers.indexOf(candidates[i]) >= 0) return candidates[i];
      }
      var lowerHeaders = sheet.headers.map(function(h) { return h.toLowerCase(); });
      for (var i = 0; i < candidates.length; i++) {
        var idx = lowerHeaders.indexOf(candidates[i].toLowerCase());
        if (idx >= 0) return sheet.headers[idx];
      }
      for (var i = 0; i < sheet.headers.length; i++) {
        if (!sheet.headers[i].startsWith('_')) return sheet.headers[i];
      }
      return sheet.headers[0] || null;
    }

    function toggleInspectorActionsMenu(e) {
      if (e) e.stopPropagation();
      var menu = document.getElementById('inspector-actions-menu');
      if (!menu) return;
      if (menu.style.display === 'none') {
        menu.style.display = 'block';
        setTimeout(function() {
          document.addEventListener('click', closeInspectorActionsMenu, { once: true });
        }, 10);
      } else {
        menu.style.display = 'none';
      }
    }

    function closeInspectorActionsMenu() {
      var menu = document.getElementById('inspector-actions-menu');
      if (menu) menu.style.display = 'none';
    }

    function updateInspectorActionsState() {
      var isAnalystOrAdmin = (currentMode === 'analyst' || currentMode === 'admin');
      var triggerBtn = document.getElementById('inspector-action-trigger');
      if (triggerBtn) triggerBtn.style.display = isAnalystOrAdmin ? 'inline-flex' : 'none';
      var chipsEl = document.getElementById('inspector-action-chips');
      if (chipsEl) chipsEl.innerHTML = '';
    }

    function normalizeForDedupe(str) {
      if (!str || typeof str !== 'string') return '';

      return str.trim().toLowerCase().replace(/[\s\-_.,;:!?'"()\[\]{}\/\\]+/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function computeSimilarity(a, b) {
      if (!a || !b) return 0;
      if (a === b) return 1;
      if (a.length < 2 || b.length < 2) return 0;
      var longer = a.length >= b.length ? a : b;
      var shorter = a.length < b.length ? a : b;
      if (longer.indexOf(shorter) >= 0) return shorter.length / longer.length;
      var bigrams = {};
      for (var i = 0; i < longer.length - 1; i++) {
        var bg = longer.substring(i, i + 2);
        bigrams[bg] = (bigrams[bg] || 0) + 1;
      }
      var intersect = 0;
      for (var i = 0; i < shorter.length - 1; i++) {
        var bg = shorter.substring(i, i + 2);
        if (bigrams[bg] && bigrams[bg] > 0) {
          intersect++;
          bigrams[bg]--;
        }
      }
      return (2.0 * intersect) / ((longer.length - 1) + (shorter.length - 1));
    }

    function categorizeBatchItems(sheetName, items, targetField) {
      var sheet = workbook.sheets[sheetName];
      if (!sheet || !sheet.rows) return items.map(function(item) { return { text: item, category: 'new', matchedRow: null, matchedValue: '' }; });

      var existingNormMap = {};
      var existingValues = [];
      sheet.rows.forEach(function(row, idx) {
        var val = row[targetField];
        if (val !== undefined && val !== null && String(val).trim() !== '') {
          var strVal = String(val);
          var norm = normalizeForDedupe(strVal);
          if (!existingNormMap[norm]) {
            existingNormMap[norm] = { rowIndex: idx, value: strVal };
          }
          existingValues.push({ norm: norm, value: strVal, rowIndex: idx });
        }
      });

      return items.map(function(item) {
        var normItem = normalizeForDedupe(item);
        if (!normItem) return { text: item, category: 'new', matchedRow: null, matchedValue: '' };

        if (existingNormMap[normItem]) {
          return { text: item, category: 'exact', matchedRow: existingNormMap[normItem].rowIndex, matchedValue: existingNormMap[normItem].value };
        }

        var bestSim = 0;
        var bestMatch = null;
        for (var i = 0; i < existingValues.length; i++) {
          var sim = computeSimilarity(normItem, existingValues[i].norm);
          if (sim > bestSim) {
            bestSim = sim;
            bestMatch = existingValues[i];
          }
        }
        if (bestSim >= 0.7 && bestMatch) {
          return { text: item, category: 'near', matchedRow: bestMatch.rowIndex, matchedValue: bestMatch.value, similarity: Math.round(bestSim * 100) };
        }

        return { text: item, category: 'new', matchedRow: null, matchedValue: '' };
      });
    }

    function batchAddRows(sheetName, anchorRowIndex, categorizedItems, targetField) {
      var sheet = workbook.sheets[sheetName];
      if (!sheet || !sheet.rows) return { created: [], attached: [], nearDupes: [] };

      var anchor = sheet.rows[anchorRowIndex];
      if (!anchor) return { created: [], attached: [], nearDupes: [] };

      var groupId = markAsGroupAnchor(sheetName, anchorRowIndex);
      if (!groupId) return { created: [], attached: [], nearDupes: [] };

      var datasetId = (anchor._identity && anchor._identity.dataset_id) || IDENTITY_CONTEXT.dataset_id || 'ds_unknown';
      var sourceFileName = (anchor._identity && anchor._identity.source_pointers && anchor._identity.source_pointers.source_file_name) || '';
      var _user = (function() {
        try { var du = JSON.parse(localStorage.getItem('demoUser') || '{}'); if (du && du.name) return du; } catch(e) {}
        return { id: 'local-user', name: 'Local User', role: currentMode || 'analyst' };
      })();
      var actor = _user.name || _user.email || 'Unknown';
      var timestamp = new Date().toISOString();

      var attached = [];
      var nearDupes = [];
      var newItems = [];

      categorizedItems.forEach(function(ci) {
        if (ci.category === 'exact' && ci.matchedRow !== null) {
          var existingRow = sheet.rows[ci.matchedRow];
          if (existingRow && !(existingRow._group && existingRow._group.group_id === groupId)) {
            existingRow._group = {
              group_id: groupId,
              group_label: anchor._group.group_label,
              is_anchor: false
            };
            attached.push(existingRow);
          }
        } else if (ci.category === 'near') {
          newItems.push(ci);
          nearDupes.push(ci);
        } else {
          newItems.push(ci);
        }
      });

      var insertIdx = anchorRowIndex + 1;
      for (var i = anchorRowIndex + 1; i < sheet.rows.length; i++) {
        if (sheet.rows[i]._group && sheet.rows[i]._group.group_id === groupId) {
          insertIdx = i + 1;
        } else {
          break;
        }
      }

      var created = [];
      newItems.forEach(function(ci, idx) {
        var newRow = {};
        sheet.headers.forEach(function(h) {
          if (anchor[h] !== undefined && anchor[h] !== null) {
            newRow[h] = anchor[h];
          }
        });
        newRow[targetField] = ci.text;

        if (batchAddState && batchAddState.metadata) {
          var metaKeys = Object.keys(batchAddState.metadata);
          for (var mki = 0; mki < metaKeys.length; mki++) {
            var mk = metaKeys[mki];
            var mv = batchAddState.metadata[mk];
            if (mv && mk !== targetField) {
              newRow[mk] = mv;
            }
          }
        }

        var globalIdx = sheet.rows.length + idx;
        enhanceRowWithIdentity(newRow, sheetName, globalIdx, sourceFileName, datasetId);

        newRow._group = {
          group_id: groupId,
          group_label: anchor._group.group_label,
          is_anchor: false
        };

        newRow._batch_added = {
          timestamp: timestamp,
          actor: actor,
          anchor_record_id: anchor.record_id || '',
          source: 'batch_add'
        };

        created.push(newRow);
      });

      if (created.length > 0) {
        var args = [insertIdx, 0].concat(created);
        Array.prototype.splice.apply(sheet.rows, args);
      }

      var auditEvent = {
        event_type: 'MANUAL_ROW_ADD',
        sheet: sheetName,
        group_id: groupId,
        actor: actor,
        timestamp: timestamp,
        target_field: targetField,
        attached_existing_count: attached.length,
        created_new_count: created.length - nearDupes.length,
        possible_duplicate_count: nearDupes.length,
        total_items: categorizedItems.length
      };
      console.log('[BatchAdd] MANUAL_ROW_ADD:', JSON.stringify(auditEvent));
      created.forEach(function(row) {
        AuditTimeline.emit('MANUAL_ROW_ADD', {
          record_id: row.record_id || '',
          dataset_id: datasetId || '',
          file_id: sheetName || '',
          metadata: { group_id: groupId, target_field: targetField, actor: actor, source: 'batch_add', applied_metadata: (batchAddState && batchAddState.metadata) ? Object.keys(batchAddState.metadata) : [] }
        });
      });

      var existingTriageItems = META_TRIAGE_STORE.getManualReview() || [];
      created.forEach(function(row) {
        var isNearDupe = nearDupes.some(function(nd) { return nd.text === row[targetField]; });
        existingTriageItems.push({
          record_id: row.record_id,
          sheet: sheetName,
          request_id: 'manual_review_batch_' + row.record_id,
          type: 'manual_review',
          note_type: 'Manual Review',
          subject: (isNearDupe ? '[Possible Duplicate] ' : 'Batch-added: ') + (row[targetField] || ''),
          analyst_note: isNearDupe ? 'Possible duplicate detected during batch add. Please verify.' : 'Row added via Batch Add Missing Items',
          status: 'open',
          created_at: timestamp,
          created_by: actor
        });
      });
      META_TRIAGE_STORE.setManualReview(existingTriageItems, IDENTITY_CONTEXT.dataset_id || '');

      if (typeof saveWorkbookToCache === 'function') {
        saveWorkbookToCache();
      }

      console.log('[BatchAdd] Results: attached=' + attached.length + ', created=' + (created.length - nearDupes.length) + ', near_dupes=' + nearDupes.length);
      return { created: created, attached: attached, nearDupes: nearDupes };
    }

    // ========== CANONICAL RECORD STORE (v1.5.3) ==========
    // Path: kiwi/v1/{tenant_id}/records/{dataset_id}/{record_id}.json
    
    function getRecordStorageKey(tenantId, datasetId, recordId) {
      return 'kiwi/v1/' + tenantId + '/records/' + datasetId + '/' + recordId + '.json';
    }
    
    function persistRecordToStore(row, sheetName, rowIndex) {
      if (!row) return null;
      
      // v1.5.3 Fix: Generate identity if missing
      var identity = row._identity;
      if (!identity) {
        // Generate stable record_id from row data
        var tenantId = IDENTITY_CONTEXT.tenant_id || 'tenant_default';
        var datasetId = IDENTITY_CONTEXT.dataset_id || sheetName || 'default';
        var recordId = row.record_id || (sheetName + ':' + rowIndex);
        
        identity = {
          tenant_id: tenantId,
          division_id: IDENTITY_CONTEXT.division_id || 'div_default',
          dataset_id: datasetId,
          record_id: recordId,
          source_pointers: { sheet_name: sheetName, row_index: rowIndex },
          aliases: [sheetName + ':' + rowIndex]
        };
        
        // Attach identity to row for future reference
        row._identity = identity;
        // Also set record_id directly on row for grid lookups
        row.record_id = recordId;
      }
      
      var storageKey = getRecordStorageKey(
        identity.tenant_id,
        identity.dataset_id,
        identity.record_id
      );
      
      // Build canonical record with full identity
      var storedRecord = {
        tenant_id: identity.tenant_id,
        division_id: identity.division_id,
        dataset_id: identity.dataset_id,
        record_id: identity.record_id,
        source_pointers: {
          sheet_name: sheetName,
          row_index: rowIndex,
          file_name: (identity.source_pointers && identity.source_pointers.source_file_name) || '',
          file_url: row.file_url || ''
        },
        aliases: identity.aliases || [sheetName + ':' + rowIndex],
        data: row,
        _stored_at: new Date().toISOString()
      };
      
      try {
        localStorage.setItem(storageKey, JSON.stringify(storedRecord));
      } catch (e) {
        if (e.name === 'QuotaExceededError' || e.code === 22) {
          // v1.6.5: Handle quota exceeded gracefully - clear old records and retry once
          console.warn('[RecordStore] Quota exceeded, clearing old records...');
          clearOldRecordsFromStore();
          try {
            localStorage.setItem(storageKey, JSON.stringify(storedRecord));
          } catch (e2) {
            console.warn('[RecordStore] Still quota exceeded after cleanup, skipping persist');
            return null;
          }
        } else {
          console.warn('[RecordStore] Failed to persist record:', e);
          return null;
        }
      }
      return storageKey;
    }
    
    // v1.6.5: Clear old records from localStorage to free up quota
    function clearOldRecordsFromStore() {
      var keysToRemove = [];
      for (var i = 0; i < localStorage.length; i++) {
        var key = localStorage.key(i);
        if (key && key.startsWith('kiwi/v1/') && key.endsWith('.json')) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(function(key) {
        localStorage.removeItem(key);
      });
      console.log('[RecordStore] Cleared', keysToRemove.length, 'old records from store');
      return keysToRemove.length;
    }
    
    function loadRecordFromStore(tenantId, datasetId, recordId) {
      var storageKey = getRecordStorageKey(tenantId, datasetId, recordId);
      var stored = localStorage.getItem(storageKey);
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch (e) {
          console.warn('[RecordStore] Failed to parse record:', storageKey, e);
          return null;
        }
      }
      return null;
    }
    
    function persistAllRecordsToStore() {
      // v1.5.3 Fix: Persist all workbook records to canonical store
      // Now works with or without pre-existing _identity - generates if missing
      var count = 0;
      if (!workbook || !workbook.sheets) {
        console.warn('[RecordStore] No workbook or sheets to persist');
        return count;
      }
      
      Object.keys(workbook.sheets).forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        var rows = sheet ? sheet.rows : [];
        if (!rows || rows.length === 0) return;
        
        rows.forEach(function(row, idx) {
          if (row) {
            // persistRecordToStore now generates identity if missing
            persistRecordToStore(row, sheetName, idx);
            count++;
          }
        });
      });
      
      console.log('[RecordStore] Persisted', count, 'records to canonical store');
      return count;
    }
    
    // Generate deterministic artifact ID
    function generateArtifactId(dataset_id, record_id, field_key, timestamp) {
      var seed = [dataset_id, record_id, field_key, timestamp].join('|');
      return 'art_' + simpleHash(seed) + '_' + Date.now().toString(36).slice(-4);
    }
    
    // Generate thread ID for RFI conversations
    function generateThreadId(artifact_id) {
      return 'thread_' + artifact_id.replace('art_', '');
    }
    
    // ========== ARTIFACT ENVELOPE & CRUD ==========
    // Artifact envelope contract fields
    function createArtifact(params) {
      var now = new Date().toISOString();
      var artifact_id = params.artifact_id || generateArtifactId(
        params.dataset_id,
        params.record_id,
        params.field_key,
        now
      );
      var thread_id = params.thread_id || generateThreadId(artifact_id);
      
      var artifact = {
        artifact_id: artifact_id,
        workspace_id: ARTIFACT_STORE.workspace_id,
        environment: ARTIFACT_STORE.environment,
        dataset_id: params.dataset_id || '',
        record_id: params.record_id || '',
        field_key: params.field_key || '',
        artifact_type: params.artifact_type || 'rfi', // 'rfi' | 'patch_request'
        status: params.status || 'open',
        created_by_actor_id: params.created_by_actor_id || getCurrentActorId(),
        created_by_role: params.created_by_role || currentMode,
        assigned_to: params.assigned_to || null,
        created_at: now,
        updated_at: now,
        thread_id: thread_id,
        source_pointers: params.source_pointers || {
          sheet_name: params.sheet_name || '',
          file_url: params.file_url || '',
          file_name: params.file_name || ''
        },
        body: params.body || {}
      };
      
      // Persist artifact
      ARTIFACT_STORE.fsWrite(artifact_id + '.json', artifact);
      
      // Log event
      logArtifactEvent(params.artifact_type === 'rfi' ? 'RFI_CREATED' : 'PATCH_DRAFT_CREATED', artifact);
      
      console.log('[ArtifactStore] Created artifact:', artifact_id, artifact.artifact_type);
      return artifact;
    }
    
    function getArtifact(artifact_id) {
      var data = ARTIFACT_STORE.fsRead(artifact_id + '.json');
      if (data) {
        try {
          return JSON.parse(data);
        } catch (e) {
          console.error('[ArtifactStore] Failed to parse artifact:', artifact_id, e);
          return null;
        }
      }
      return null;
    }
    
    function updateArtifact(artifact_id, updates) {
      var artifact = getArtifact(artifact_id);
      if (!artifact) {
        console.error('[ArtifactStore] Artifact not found:', artifact_id);
        return null;
      }
      
      Object.assign(artifact, updates, { updated_at: new Date().toISOString() });
      ARTIFACT_STORE.fsWrite(artifact_id + '.json', artifact);
      
      console.log('[ArtifactStore] Updated artifact:', artifact_id, updates);
      return artifact;
    }
    
    function listArtifacts(filter) {
      var files = ARTIFACT_STORE.fsList('');
      var artifacts = [];
      
      files.forEach(function(path) {
        if (path.endsWith('.json') && path.startsWith('art_')) {
          var data = ARTIFACT_STORE.fsRead(path);
          if (data) {
            try {
              var artifact = JSON.parse(data);
              if (!filter || matchesFilter(artifact, filter)) {
                artifacts.push(artifact);
              }
            } catch (e) { /* skip invalid */ }
          }
        }
      });
      
      // Sort by created_at descending
      artifacts.sort(function(a, b) {
        return new Date(b.created_at) - new Date(a.created_at);
      });
      
      return artifacts;
    }
    
    function matchesFilter(artifact, filter) {
      if (filter.artifact_type && artifact.artifact_type !== filter.artifact_type) return false;
      if (filter.status && artifact.status !== filter.status) return false;
      if (filter.created_by_role && artifact.created_by_role !== filter.created_by_role) return false;
      if (filter.assigned_to && artifact.assigned_to !== filter.assigned_to) return false;
      if (filter.dataset_id && artifact.dataset_id !== filter.dataset_id) return false;
      if (filter.record_id && artifact.record_id !== filter.record_id) return false;
      return true;
    }
    
    // ========== EVENT LOG ==========
    function logArtifactEvent(event_type, artifact, extra) {
      var event = {
        event_type: event_type,
        artifact_id: artifact.artifact_id,
        artifact_type: artifact.artifact_type,
        record_id: artifact.record_id,
        field_key: artifact.field_key,
        actor_id: getCurrentActorId(),
        role: currentMode,
        timestamp: new Date().toISOString()
      };
      if (extra) Object.assign(event, extra);
      
      ARTIFACT_STORE.fsAppend('events.jsonl', event);
      console.log('[ArtifactStore] Event logged:', event_type, artifact.artifact_id);
    }
    
    function getEventLog() {
      var data = ARTIFACT_STORE.fsRead('events.jsonl');
      if (!data) return [];
      
      return data.split('\n').filter(Boolean).map(function(line) {
        try { return JSON.parse(line); } catch (e) { return null; }
      }).filter(Boolean);
    }
    
    // ========== THREAD SYSTEM (RFI Replies) ==========
    function getThread(thread_id) {
      var data = ARTIFACT_STORE.fsRead(thread_id + '.json');
      if (data) {
        try { return JSON.parse(data); } catch (e) { return null; }
      }
      return { thread_id: thread_id, messages: [] };
    }
    
    function addThreadMessage(thread_id, message) {
      var thread = getThread(thread_id);
      var msg = {
        message_id: 'msg_' + Date.now().toString(36),
        author_id: getCurrentActorId(),
        author_role: currentMode,
        content: message.content || '',
        created_at: new Date().toISOString()
      };
      thread.messages.push(msg);
      ARTIFACT_STORE.fsWrite(thread_id + '.json', thread);
      
      // Log event
      var artifact = getArtifactByThreadId(thread_id);
      if (artifact) {
        logArtifactEvent('RFI_REPLIED', artifact, { message_id: msg.message_id });
      }
      
      return msg;
    }
    
    function getArtifactByThreadId(thread_id) {
      var artifacts = listArtifacts({});
      return artifacts.find(function(a) { return a.thread_id === thread_id; }) || null;
    }
    
    // ========== ACTOR & ROLE HELPERS ==========
    var playgroundActors = {
      analyst: 'analyst@example.com',
      verifier: 'verifier@example.com',
      admin: 'admin@example.com'
    };
    
    function getCurrentActorId() {
      return playgroundActors[currentMode] || 'unknown@example.com';
    }
    
    // Environment switching (v1.5.1)
    function setEnvironment(env) {
      if (env === 'prod') {
        showToast('Production environment is locked', 'warning');
        return;
      }
      ARTIFACT_STORE.environment = env;
      document.querySelectorAll('.env-btn').forEach(function(btn) {
        var isActive = btn.dataset.env === env;
        btn.classList.toggle('active', isActive);
        btn.style.background = isActive ? '#e3f2fd' : '#f5f5f5';
        btn.style.color = isActive ? '#1565c0' : '#666';
      });
      console.log('[ArtifactStore] Environment set to:', env);
      showToast('Environment: ' + env, 'info');
    }
    
    // Reset playground data (v1.5.1)
    function resetPlayground() {
      if (!confirm('Reset sandbox? This will clear all RFIs, patches, and event logs.')) {
        return;
      }
      var cleared = ARTIFACT_STORE.resetPlayground();
      // Also clear legacy verifier queue
      verifierQueueState.payloads = [];
      saveVerifierQueue();
      // Clear legacy patch storage
      localStorage.removeItem(PATCH_STORAGE_KEY);
      
      showToast('Sandbox reset: ' + cleared + ' artifacts cleared', 'success');
      
      // Re-render any active views
      if (typeof renderVerifierTriage === 'function') {
        renderVerifierTriage();
      }
    }
    
    // ========== QUEUE GENERATION FROM ARTIFACTS ==========
    function getAnalystQueue() {
      var actorId = playgroundActors['analyst'];
      return listArtifacts({}).filter(function(a) {
        return a.created_by_actor_id === actorId || a.assigned_to === actorId;
      });
    }
    
    function getVerifierQueue() {
      return listArtifacts({ artifact_type: 'rfi', status: 'open' }).concat(
        listArtifacts({ artifact_type: 'rfi', status: 'submitted' })
      ).concat(
        listArtifacts({ artifact_type: 'patch_request', status: 'submitted' })
      );
    }
    
    function getPatchQueue() {
      // v1.5.1: Return artifacts approved by verifier (Correction/Blacklist only, not RFI)
      return listArtifacts({ status: 'sent_to_admin' }).filter(function(a) {
        return a.artifact_type === 'patch_request' || a.artifact_type === 'blacklist';
      });
    }
    
    // ========== RECORD LOOKUP BY record_id ==========
    function findRecordById(record_id, datasetId, tenantId) {
      if (!record_id) return null;
      
      var result = null;
      
      // First: Try workbook.sheets (in-memory dataset)
      if (workbook && workbook.sheets) {
        Object.keys(workbook.sheets).some(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          var rows = sheet ? sheet.rows : [];
          if (!rows) return false;
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            // v1.5.2: Check record_id (including _identity.record_id), then fallbacks
            var rowRecordId = row.record_id || (row._identity && row._identity.record_id);
            if (rowRecordId === record_id || 
                row.contract_key === record_id ||
                (sheetName + ':' + i) === record_id) {
              result = { sheetName: sheetName, rowIndex: i, row: row };
              return true;
            }
          }
          return false;
        });
      }
      
      // v1.5.3: Fallback to canonical record store if not found in workbook
      if (!result) {
        var tid = tenantId || IDENTITY_CONTEXT.tenant_id;
        var did = datasetId || IDENTITY_CONTEXT.dataset_id;
        if (tid && did) {
          var storedRecord = loadRecordFromStore(tid, did, record_id);
          if (storedRecord && storedRecord.data) {
            var sp = storedRecord.source_pointers || {};
            result = {
              sheetName: sp.sheet_name || 'default',
              rowIndex: sp.row_index || 0,
              row: storedRecord.data,
              fromStore: true // Mark as loaded from persistent store
            };
            console.log('[RecordStore] Loaded record from store:', record_id);
          }
        }
      }
      
      return result;
    }
    
    function navigateToArtifact(artifact) {
      if (!artifact) return;
      
      var recordInfo = findRecordById(artifact.record_id);
      if (recordInfo) {
        srrState.currentSheetName = recordInfo.sheetName;
        srrState.focusFieldKey = artifact.field_key || null;
        navigateTo('row/' + recordInfo.rowIndex);
        console.log('[ArtifactStore] Navigated to record:', artifact.record_id, 'field:', artifact.field_key);
      } else {
        showToast('Record not found: ' + artifact.record_id, 'warning');
      }
    }
    
    // ========== WORKBOOK DATA STRUCTURE (v1.4.3 INGEST-01) ==========
    // Canonical multi-sheet dataset contract
    var workbook = {
      sheets: {},       // { sheetName: { headers: [], rows: [], meta: {} } }
      order: [],        // Deterministic sheet ordering
      activeSheet: null // Currently selected sheet
    };
    
    function resetWorkbook() {
      workbook.sheets = {};
      workbook.order = [];
      workbook.activeSheet = null;
      if (typeof ContractIndex !== 'undefined') ContractIndex.reset();
      if (typeof BatchMerge !== 'undefined') BatchMerge.reset();
    }
    
    // v1.6.46: Workbook session cache (persists across page reloads)
    var WORKBOOK_CACHE_KEY = 'orchestrate_workbook_cache';
    var NAV_STATE_CACHE_KEY = 'orchestrate_nav_state';
    
    function saveWorkbookToCache() {
      var cacheData = {
        workbook: {
          sheets: workbook.sheets,
          order: workbook.order,
          activeSheet: workbook.activeSheet
        },
        datasetId: IDENTITY_CONTEXT.dataset_id,
        filename: (document.getElementById('active-data-source-name') || {}).textContent || 'Cached Dataset',
        savedAt: new Date().toISOString()
      };
      SessionDB.saveWorkbookCache(cacheData).then(function() {
        console.log('[V2.3-GATE][G6] PASS workbook saved to IndexedDB only, no localStorage blobs');
      }).catch(function(e) {
        console.error('[WorkbookCache] IndexedDB save failed:', e);
      });
      return true;
    }
    
    async function loadWorkbookFromCache() {
      try {
        var data = await SessionDB.loadWorkbookCache();
        if (data && data.workbook && data.workbook.order && data.workbook.order.length > 0) {
          console.log('[WorkbookCache] Loaded from IndexedDB:', data.workbook.order.length, 'sheets');
          return data;
        }
      } catch(e) { console.warn('[WorkbookCache] IndexedDB load failed:', e); }
      console.log('[WorkbookCache] IndexedDB had no data, no localStorage fallback (v2.3 policy)');
      return null;
    }
    
    function clearWorkbookCache() {
      localStorage.removeItem(WORKBOOK_CACHE_KEY);
      localStorage.removeItem(NAV_STATE_CACHE_KEY);
      SessionDB.clearWorkbookCache().catch(function() {});
      console.log('[WorkbookCache] Cache cleared');
    }

    var SESSIONS_STORE_KEY = 'orchestrate_saved_sessions';
    var MAX_SESSIONS = 10;


    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    function getSavedSessions() {
      return SessionDB.getSessionIndex();
    }

    function saveCurrentSession(name) {
      if (!workbook || !workbook.order || workbook.order.length === 0) {
        showToast('No data loaded to save', 'warning');
        return false;
      }
      var index = getSavedSessions();
      if (index.length >= MAX_SESSIONS) {
        showToast('Maximum ' + MAX_SESSIONS + ' sessions. Delete one first.', 'warning');
        return false;
      }
      var sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
      var totalRows = 0;
      workbook.order.forEach(function(s) {
        if (workbook.sheets[s]) totalRows += workbook.sheets[s].length;
      });
      var session = {
        id: sessionId,
        name: name || ('Session ' + new Date().toLocaleDateString()),
        savedAt: new Date().toISOString(),
        role: currentMode || 'analyst',
        datasetId: IDENTITY_CONTEXT.dataset_id || 'unknown',
        filename: (document.getElementById('active-data-source-name') || {}).textContent || 'Dataset',
        sheetCount: workbook.order.length,
        rowCount: totalRows,
        workbook: {
          sheets: workbook.sheets,
          order: workbook.order,
          activeSheet: workbook.activeSheet
        }
      };
      SessionDB.saveSession(session).then(function(ok) {
        if (ok) {
          showToast('Session saved: ' + session.name, 'success');
          renderSavedSessionsList();
        } else {
          showToast('Failed to save session', 'error');
        }
      });
      return true;
    }

    function loadSavedSession(sessionId) {
      stagedLoader.start();
      stagedLoader.setStage('loading');
      SessionDB.loadSession(sessionId).then(function(session) {
        if (session && session.dataset_id && typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.dataset_id && session.dataset_id !== IDENTITY_CONTEXT.dataset_id) {
          console.warn('[Session] Cache-cycle guard: restored session dataset_id (' + session.dataset_id + ') does not match active (' + IDENTITY_CONTEXT.dataset_id + '). Skipping stale restore.');
          if (typeof showToast === 'function') showToast('Session skipped: dataset mismatch', 'warning');
          return;
        }
        if (!session || !session.workbook) {
          stagedLoader.finish();
          showToast('Session not found or corrupted', 'error');
          return;
        }
        stagedLoader.setStage('standardizing');
        workbook.sheets = session.workbook.sheets;
        workbook.order = session.workbook.order;
        workbook.activeSheet = session.workbook.activeSheet || session.workbook.order[0];
        IDENTITY_CONTEXT.dataset_id = session.datasetId || 'ds_restored';
        updateActiveDataSourceBar(session.filename || session.name);
        stagedLoader.setStage('validating');
        try { if (typeof generateAllSignals === 'function') generateAllSignals(); } catch(e) { console.warn('[RESTORE] generateAllSignals error:', e.message); }
        // v2.3.5-P1F: Batch PDF scan on saved session load
        if (typeof _p1fBatchPdfScan === 'function') _p1fBatchPdfScan();
        stagedLoader.setStage('indexing');
        try { ContractIndex.build(); populateContractSelector(); console.log('[V2.3-GATE][G2] PASS ContractIndex rebuilt from live workbook on session-load path'); } catch(e) { console.warn('[ContractIndex] Session restore build failed:', e); }
        stagedLoader.setStage('changemap');
        saveWorkbookToCache();
        dataLoaded = true;
        stagedLoader.setStage('rendering');
        populateGridSheetSelector();
        updateSidebarSheetSelector();
        renderGrid();
        updateProgressBlock();
        closeDataSourceDrawer();
        navigateTo('grid');
        stagedLoader.finish();
        showToast('Loaded session: ' + session.name, 'success');
        console.log('[RESTORE] Session restored:', sessionId, 'sheets:', session.workbook.order.length);
      });
    }

    function deleteSavedSession(sessionId) {
      SessionDB.deleteSession(sessionId).then(function() {
        renderSavedSessionsList();
        showToast('Session deleted', 'info');
      });
    }

    function promptSaveSession() {
      if (!workbook || !workbook.order || workbook.order.length === 0) {
        showToast('No data loaded to save', 'warning');
        return;
      }
      var defaultName = ((document.getElementById('active-data-source-name') || {}).textContent || 'Session') + ' - ' + new Date().toLocaleDateString();
      var name = prompt('Name this session:', defaultName);
      if (name === null) return;
      name = name.trim() || defaultName;
      saveCurrentSession(name);
    }

    function renderSavedSessionsList() {
      var container = document.getElementById('saved-sessions-list');
      if (!container) return;
      var sessions = getSavedSessions();
      if (sessions.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 16px; color: #999; font-size: 0.85em;">No saved sessions yet. Upload data and click "Save Session" to save your progress.</div>';
        return;
      }
      var html = '';
      sessions.forEach(function(s) {
        var date = new Date(s.savedAt);
        var timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        var roleLabel = (s.role || 'analyst').charAt(0).toUpperCase() + (s.role || 'analyst').slice(1);
        html += '<div class="saved-session-card" data-session-id="' + escapeHtml(s.id) + '">' +
          '<div class="saved-session-info" data-load-id="' + escapeHtml(s.id) + '">' +
            '<div class="saved-session-name">' + escapeHtml(s.name || 'Untitled') + '</div>' +
            '<div class="saved-session-meta">' +
              '<span>' + timeStr + '</span>' +
              '<span class="saved-session-dot">\u00b7</span>' +
              '<span>' + (s.sheetCount || 0) + ' sections</span>' +
              '<span class="saved-session-dot">\u00b7</span>' +
              '<span>' + (s.rowCount || 0) + ' rows</span>' +
              '<span class="saved-session-dot">\u00b7</span>' +
              '<span class="saved-session-role">' + escapeHtml(roleLabel) + '</span>' +
            '</div>' +
          '</div>' +
          '<button class="saved-session-delete" data-delete-id="' + escapeHtml(s.id) + '" title="Delete session">&times;</button>' +
        '</div>';
      });
      container.innerHTML = html;
      container.querySelectorAll('[data-load-id]').forEach(function(el) {
        el.addEventListener('click', function() { loadSavedSession(this.getAttribute('data-load-id')); });
      });
      container.querySelectorAll('[data-delete-id]').forEach(function(el) {
        el.addEventListener('click', function(e) {
          e.stopPropagation();
          var sid = this.getAttribute('data-delete-id');
          var sessions = getSavedSessions();
          var sName = 'this session';
          for (var i = 0; i < sessions.length; i++) { if (sessions[i].id === sid) { sName = sessions[i].name || 'Untitled'; break; } }
          if (confirm('Delete session: ' + sName + '?')) deleteSavedSession(sid);
        });
      });
    }
    
    function saveNavStateToCache() {
      try {
        var navState = {
          sheet: gridState.sheet,
          filter: gridState.filter,
          hash: window.location.hash,
          savedAt: new Date().toISOString()
        };
        localStorage.setItem(NAV_STATE_CACHE_KEY, JSON.stringify(navState));
      } catch (e) { /* ignore */ }
    }
    
    function loadNavStateFromCache() {
      try {
        var cached = localStorage.getItem(NAV_STATE_CACHE_KEY);
        return cached ? JSON.parse(cached) : null;
      } catch (e) { return null; }
    }
    
    // v1.6.46: Clear cache and reload page for fresh start
    function handleClearCacheAndReload() {
      if (confirm('This will clear your saved session data and reload the page. Continue?')) {
        clearWorkbookCache();
        SessionDB._clear(SessionDB.SESSIONS_STORE).catch(function() {});
        localStorage.removeItem('orchestrate_idb_sessions_idx');
        localStorage.removeItem('orchestrate_session');
        localStorage.removeItem('orchestrate_canonical_records');
        localStorage.removeItem('unknown_columns');
        localStorage.removeItem('unknown_columns_decisions');
        var isDemo = isDemoSession();
        localStorage.removeItem('currentRole');
        localStorage.removeItem('demoUser');
        showToast('Session cleared. Redirecting...', 'info');
        setTimeout(function() { window.location.href = isDemo ? '/ui/demo/' : '/ui/landing/'; }, 500);
      }
    }









    
    function setActiveSheet(sheetName) {
      if (workbook.sheets[sheetName]) {
        workbook.activeSheet = sheetName;
        console.log('[Workbook] Active sheet set to:', sheetName);
        return true;
      }
      return false;
    }
    
    function getActiveSheetData() {
      if (!workbook.activeSheet || !workbook.sheets[workbook.activeSheet]) {
        return { headers: [], rows: [], meta: {} };
      }
      return workbook.sheets[workbook.activeSheet];
    }
    
    function addSheet(sheetName, headers, rows, meta) {
      // v1.5.2: Set dataset context if not set
      var datasetId = IDENTITY_CONTEXT.dataset_id || 'ds_' + Date.now().toString(36);
      if (!IDENTITY_CONTEXT.dataset_id) {
        IDENTITY_CONTEXT.dataset_id = datasetId;
      }
      
      var sourceFileName = (meta && meta.source_file_name) || '';
      
      // v1.5.2: Enhance each row with identity model
      var enhancedRows = (rows || []).map(function(row, idx) {
        return enhanceRowWithIdentity(row, sheetName, idx, sourceFileName, datasetId);
      });
      
      workbook.sheets[sheetName] = {
        headers: headers || [],
        rows: enhancedRows,
        meta: meta || {}
      };
      if (!workbook.order.includes(sheetName)) {
        workbook.order.push(sheetName);
        workbook.order.sort(); // Lexical ordering
      }
      // Set active sheet if none set
      if (!workbook.activeSheet) {
        workbook.activeSheet = sheetName;
      }
      console.log('[Workbook] Added sheet:', sheetName, 'headers:', headers.length, 'rows:', enhancedRows.length, 'dataset:', datasetId);
    }
    
    const STORAGE_KEY_SESSION = 'controlboard_session_v11';
    const ARTIFACT_REGISTRY_KEY = 'orchestrateos.artifacts.v1';
    const STORAGE_KEY_DATASET = 'orchestrate.dataset.v1';
    const STORAGE_KEY_PDF_ATTACHMENTS = 'orchestrate.pdf_attachments.v1';
    const STORAGE_KEY_LIBRARY = 'orchestrate.upload_library.v1';
    const STORAGE_KEY_ACTIVE_DATASET = 'orchestrate.active_dataset_id.v1';
    
    // ========== WORKBOOK PARSING + COLUMN MAPPING (V1.4.12) ==========
    var COLUMN_MAPPING_STATE = {
      mappingResolved: false,
      fileNameColumn: null,
      fileUrlColumn: null,
      missingColumns: []
    };
    
    function resolveColumnMapping(headers) {
      COLUMN_MAPPING_STATE.mappingResolved = false;
      COLUMN_MAPPING_STATE.fileNameColumn = null;
      COLUMN_MAPPING_STATE.fileUrlColumn = null;
      COLUMN_MAPPING_STATE.missingColumns = [];
      
      if (!headers || headers.length === 0) {
        COLUMN_MAPPING_STATE.missingColumns = ['file_name', 'file_url'];
        return COLUMN_MAPPING_STATE;
      }
      
      var lowerHeaders = headers.map(function(h) { return (h || '').toLowerCase().trim(); });
      
      // v1.4.14: Extended aliases for file_name
      var fileNameAliases = ['file_name', 'filename', 'file name', 'contract file', 'contract file name', 'document', 'doc_name'];
      var fileNameIdx = lowerHeaders.findIndex(function(h) { 
        return fileNameAliases.indexOf(h) >= 0;
      });
      
      // v1.4.14: Extended aliases for file_url
      var fileUrlAliases = ['file_url', 'fileurl', 'file url', 'url', 'contract source', 'contract url', 'pdf url', 'source', 'document_url', 'doc_url', 'link'];
      var fileUrlIdx = lowerHeaders.findIndex(function(h) { 
        return fileUrlAliases.indexOf(h) >= 0;
      });
      
      if (fileNameIdx >= 0) COLUMN_MAPPING_STATE.fileNameColumn = headers[fileNameIdx];
      if (fileUrlIdx >= 0) COLUMN_MAPPING_STATE.fileUrlColumn = headers[fileUrlIdx];
      
      if (!COLUMN_MAPPING_STATE.fileNameColumn && headers.length >= 1) {
        COLUMN_MAPPING_STATE.fileNameColumn = headers[0];
        console.log('[ColumnMapping] Fallback: column A as file_name:', headers[0]);
      }
      if (!COLUMN_MAPPING_STATE.fileUrlColumn && headers.length >= 2) {
        COLUMN_MAPPING_STATE.fileUrlColumn = headers[1];
        console.log('[ColumnMapping] Fallback: column B as file_url:', headers[1]);
      }
      
      if (!COLUMN_MAPPING_STATE.fileNameColumn) COLUMN_MAPPING_STATE.missingColumns.push('file_name');
      if (!COLUMN_MAPPING_STATE.fileUrlColumn) COLUMN_MAPPING_STATE.missingColumns.push('file_url');
      
      COLUMN_MAPPING_STATE.mappingResolved = COLUMN_MAPPING_STATE.missingColumns.length === 0;
      console.log('[ColumnMapping] Resolved:', COLUMN_MAPPING_STATE);
      return COLUMN_MAPPING_STATE;
    }
    
    function applyColumnMapping(rows, headers, mapping, sheetName) {
      var _sheetPrefix = sheetName ? (sheetName + ":") : "";
      if (!mapping || !mapping.mappingResolved) return rows;
      
      return rows.map(function(row, idx) {
        var newRow = Object.assign({}, row);
        newRow._row_index = idx;
        
        if (mapping.fileNameColumn && mapping.fileNameColumn !== 'file_name') {
          newRow.file_name = row[mapping.fileNameColumn] || null;
        }
        if (mapping.fileUrlColumn && mapping.fileUrlColumn !== 'file_url') {
          newRow.file_url = row[mapping.fileUrlColumn] || null;
        }
        if (!newRow.contract_key) newRow.contract_key = _sheetPrefix + 'ROW_' + (idx + 1);
        if (!newRow.status) newRow.status = 'needs_review';
        return newRow;
      });
    }
    
    // v2.2: Unified parser for CSV/TSV/XLSX/XLS — name reflects workbook output, not input format
    function parseWorkbook(data, filename) {
      var result = { sheets: {}, order: [], errors: [], mapping: null };
      var ext = (filename.split('.').pop() || '').toLowerCase();
      
      try {
        if (ext === 'csv' || ext === 'tsv' || ext === 'txt') {
          var text = typeof data === 'string' ? data : new TextDecoder().decode(data);
          var parsed = parseCSV(text);
          var sheetName = filename.replace(/\.[^.]+$/, '') || 'Sheet1';
          // v2.3: Header-echo sanitization for CSV
          var preEchoCsvCount = parsed.rows.length;
          parsed.rows = parsed.rows.filter(function(rowObj, ri) {
            var matchCount = 0;
            var totalFields = 0;
            parsed.headers.forEach(function(h) {
              if (!h) return;
              totalFields++;
              var val = (rowObj[h] || '').toString().trim().toLowerCase();
              if (val === h.trim().toLowerCase()) matchCount++;
            });
            var matchRatio = totalFields > 0 ? matchCount / totalFields : 0;
            if (matchRatio >= 0.6) {
              console.log('[parseWorkbook] Header-echo row removed (CSV): rowIdx=' + ri + ', matchRatio=' + matchRatio.toFixed(2));
              if (typeof AuditTimeline !== 'undefined') {
                AuditTimeline.emit('ROW_SANITIZED_HEADER_ECHO', {
                  dataset_id: '',
                  metadata: { sheet_name: sheetName, row_index: ri, match_ratio: matchRatio.toFixed(2) }
                });
              }
              return false;
            }
            return true;
          });
          if (preEchoCsvCount !== parsed.rows.length) {
            console.log('[parseWorkbook] Removed ' + (preEchoCsvCount - parsed.rows.length) + ' header-echo rows from CSV');
            console.log('[V2.3-GATE][G5] PASS header-echo sanitized: ' + (preEchoCsvCount - parsed.rows.length) + ' rows removed from CSV');
          }

          var mapping = resolveColumnMapping(parsed.headers);
          result.mapping = mapping;
          var normalizedRows = applyColumnMapping(parsed.rows, parsed.headers, mapping, sheetName);
          for (var _csvSi = 0; _csvSi < parsed.rows.length; _csvSi++) {
            sanitizeDoubleSlashAnnotations(parsed.rows[_csvSi], parsed.headers);
          }
          result.sheets[sheetName] = { headers: parsed.headers, rows: normalizedRows, meta: { delimiter: parsed.delimiter } };
          result.order.push(sheetName);
        } else if (ext === 'xlsx' || ext === 'xls') {
          if (typeof XLSX === 'undefined') {
            result.errors.push('XLSX library not loaded. Please refresh the page.');
            return result;
          }
          var arrayBuffer = data instanceof ArrayBuffer ? data : data.buffer;
          var workbookXLSX = XLSX.read(arrayBuffer, { type: 'array' });
          // v1.6.39: Apply column mapping per-sheet, not just first sheet
          workbookXLSX.SheetNames.forEach(function(sheetName, idx) {
            var sheet = workbookXLSX.Sheets[sheetName];
            var jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
            
            if (jsonData.length === 0) return;
            
            var headers = jsonData[0].map(function(h) { return String(h || '').trim(); });
            var rows = [];
            for (var i = 1; i < jsonData.length; i++) {
              var rowArr = jsonData[i];
              
              // v1.6.38: Skip empty rows (all cells empty, null, or whitespace-only)
              var hasData = rowArr.some(function(cell) {
                return cell !== undefined && cell !== null && cell !== '' && String(cell).trim() !== '';
              });
              if (!hasData) continue;
              
              var rowObj = {};
              headers.forEach(function(h, colIdx) {
                rowObj[h] = rowArr[colIdx] !== undefined ? String(rowArr[colIdx]) : null;
              });
              sanitizeDoubleSlashAnnotations(rowObj, headers);
              rows.push(rowObj);
            }
            
            // v2.3: Header-echo sanitization - drop rows that are echoes of header
            var preEchoCount = rows.length;
            rows = rows.filter(function(rowObj, ri) {
              var matchCount = 0;
              var totalFields = 0;
              headers.forEach(function(h) {
                if (!h) return;
                totalFields++;
                var val = (rowObj[h] || '').toString().trim().toLowerCase();
                if (val === h.trim().toLowerCase()) matchCount++;
              });
              var matchRatio = totalFields > 0 ? matchCount / totalFields : 0;
              if (matchRatio >= 0.6) {
                console.log('[parseWorkbook] Header-echo row removed: sheet=' + sheetName + ', rowIdx=' + ri + ', matchRatio=' + matchRatio.toFixed(2));
                if (typeof AuditTimeline !== 'undefined') {
                  AuditTimeline.emit('ROW_SANITIZED_HEADER_ECHO', {
                    dataset_id: '',
                    metadata: { sheet_name: sheetName, row_index: ri, match_ratio: matchRatio.toFixed(2) }
                  });
                }
                return false;
              }
              return true;
            });
            if (preEchoCount !== rows.length) {
              console.log('[parseWorkbook] Removed ' + (preEchoCount - rows.length) + ' header-echo rows from ' + sheetName);
              console.log('[V2.3-GATE][G5] PASS header-echo sanitized: ' + (preEchoCount - rows.length) + ' rows removed, sheet=' + sheetName);
            }

            // v1.6.39: Resolve column mapping for each sheet individually
            var sheetMapping = resolveColumnMapping(headers);
            if (idx === 0) {
              result.mapping = sheetMapping; // Keep first sheet mapping as result.mapping for legacy
            }
            
            var normalizedRows = applyColumnMapping(rows, headers, sheetMapping, sheetName);
            result.sheets[sheetName] = { headers: headers, rows: normalizedRows, meta: { sheetIndex: idx, mapping: sheetMapping } };
            result.order.push(sheetName);
          });
          result.order.sort();
        } else {
          result.errors.push('Unsupported file type: .' + ext);
        }
      } catch (err) {
        result.errors.push('Parse error: ' + err.message);
        console.error('[parseWorkbook] Error:', err);
      }
      
      console.log('[parseWorkbook] Result:', result.order.length, 'sheets, errors:', result.errors.length);
      return result;
    }

    function sanitizeDoubleSlashAnnotations(rowObj, headers) {
      var urlPattern = /^https?:\/\//i;
      var sanitized = [];
      for (var hi = 0; hi < headers.length; hi++) {
        var h = headers[hi];
        if (!h) continue;
        var val = rowObj[h];
        if (val === null || val === undefined) continue;
        var sVal = String(val);
        if (sVal.indexOf('//') === -1) continue;
        if (urlPattern.test(sVal)) {
          var urlEndIdx = sVal.indexOf(' //');
          if (urlEndIdx === -1) urlEndIdx = sVal.indexOf('\t//');
          if (urlEndIdx === -1) {
            var dblSlashPositions = [];
            var searchFrom = sVal.indexOf('://')  + 3;
            while (searchFrom < sVal.length) {
              var pos = sVal.indexOf('//', searchFrom);
              if (pos === -1) break;
              dblSlashPositions.push(pos);
              searchFrom = pos + 2;
            }
            if (dblSlashPositions.length > 0) {
              urlEndIdx = dblSlashPositions[dblSlashPositions.length - 1];
            }
          }
          if (urlEndIdx > 0) {
            var cleanUrl = sVal.substring(0, urlEndIdx).trim();
            var annotation = sVal.substring(urlEndIdx + 2).trim();
            if (annotation.length > 0) {
              rowObj[h] = cleanUrl;
              if (!rowObj['_imported_comment']) rowObj['_imported_comment'] = '';
              rowObj['_imported_comment'] += (rowObj['_imported_comment'] ? '; ' : '') + h + ': ' + annotation;
              sanitized.push({ field: h, raw: sVal, clean: cleanUrl, annotation: annotation, type: 'url' });
            }
          }
        } else {
          var parts = sVal.split('//');
          if (parts.length >= 2) {
            var cleanVal = parts[0].trim();
            var annot = parts.slice(1).join('//').trim();
            if (annot.length > 0 && cleanVal.length > 0) {
              rowObj[h] = cleanVal;
              if (!rowObj['_imported_comment']) rowObj['_imported_comment'] = '';
              rowObj['_imported_comment'] += (rowObj['_imported_comment'] ? '; ' : '') + h + ': ' + annot;
              sanitized.push({ field: h, raw: sVal, clean: cleanVal, annotation: annot, type: 'business' });
            }
          }
        }
      }
      if (sanitized.length > 0) {
        console.log('[P0.9-CLEANUP] legacy_slash_sanitized: count=' + sanitized.length + ', fields=' + sanitized.map(function(s) { return s.field; }).join(','));
        if (typeof AuditTimeline !== 'undefined') {
          AuditTimeline.emit('legacy_slash_sanitized', { metadata: { count: sanitized.length, fields: sanitized.map(function(s) { return s.field; }) } });
        }
      }
      return sanitized;
    }
    
    function showColumnMappingBanner(missingColumns) {
      var banner = document.getElementById('column-mapping-banner');
      var msgEl = document.getElementById('column-mapping-message');
      if (banner && msgEl) {
        if (missingColumns && missingColumns.length > 0) {
          msgEl.textContent = 'Missing required columns: ' + missingColumns.join(', ') + '. Record Inspection will show empty PDF state.';
          banner.style.display = 'block';
        } else {
          banner.style.display = 'none';
        }
      }
    }
    
    function hideColumnMappingBanner() {
      var banner = document.getElementById('column-mapping-banner');
      if (banner) banner.style.display = 'none';
    }
    
    // ========== DEFAULT DATASET (V1.6.3) ==========
    // Ostereo Demo is now the sole default dataset - loaded from JSON file
    // v1.6.4: Moved to loadSampleDataset section - cachedOriginalDataset and cachedModifiedDataset
    
    // ========== NOMENCLATURE PACK (D4) ==========
    // Maps internal tokens to human-readable labels
    const NOMENCLATURE = {
      labels: {
        'sf_packet': 'Preview Packet',
        'sf_summary': 'Summary',
        'sf_contract_results': 'Contract Results',
        'sf_issues': 'Issues',
        'sf_field_actions': 'Field Actions',
        'config_pack_base': 'Truth Config',
        'config_pack_patch': 'Proposed Changes',
        'standardized_dataset': 'Standardized Dataset',
        'expected_output': 'Reference Expected',
        'merged_dataset': 'Merged Dataset',
        'contract_key': 'Contract Key',
        'file_url': 'File URL',
        'file_name': 'File Name',
        'detected_subtype': 'Detected Subtype',
        'sf_contract_status': 'Status'
      },
      tooltips: {
        'Preview Packet': 'The output from running the semantic rules against your data. Contains issues, field actions, and contract statuses.',
        'Truth Config': 'The versioned baseline configuration containing all semantic rules. This is the source of truth.',
        'Proposed Changes': 'A patch file containing rule additions or modifications pending review.',
        'Standardized Dataset': 'Input data that has been normalized to a consistent format for processing.',
        'Reference Expected': 'Golden file outputs used to verify deterministic behavior.',
        'Merged Dataset': 'Combined and normalized data from multiple input sources.',
        'Contract Key': 'Primary identifier linking records across the system.',
        'File URL': 'Secondary identifier based on source file location.',
        'File Name': 'Tertiary identifier based on source file name.',
        'Identity Keys': 'The three-part join identity: Contract Key, File URL, and File Name. Used to match records deterministically.'
      }
    };
    
    // ========== MASTERLINE ARTIFACT REGISTRY (D1) ==========
    const DEFAULT_ARTIFACT_PATHS = {
      truth_config: '../../config/config_pack.base.json',
      proposed_changes: '../../config/config_pack.example.patch.json',
      reference_expected: '../../examples/expected_outputs/sf_packet.example.json',
      standardized_dataset: '../../examples/standardized_dataset.example.json',
      preview_packet: '../../out/sf_packet.preview.json'
    };
    
    const ARTIFACT_LABELS = {
      truth_config: 'Truth Config',
      proposed_changes: 'Proposed Changes',
      reference_expected: 'Reference Expected',
      standardized_dataset: 'Standardized Dataset',
      preview_packet: 'Preview Packet'
    };
    
    let artifactRegistry = {
      devMasterlineEnabled: true,
      bindings: {}
    };
    
    // Helper: Get human label for internal token
    function humanLabel(token) {
      return NOMENCLATURE.labels[token] || token;
    }
    
    // Helper: Get tooltip for a label
    function getTooltip(label) {
      return NOMENCLATURE.tooltips[label] || '';
    }
    
    // Helper: Create info icon with tooltip
    function infoIcon(label) {
      var tip = getTooltip(label);
      if (!tip) return '';
      return '<span class="info-icon" title="' + escapeHtml(tip) + '">&#9432;</span>';
    }
    
    // Load artifact registry from localStorage
    function loadArtifactRegistry() {
      try {
        var saved = localStorage.getItem(ARTIFACT_REGISTRY_KEY);
        if (saved) {
          var parsed = JSON.parse(saved);
          artifactRegistry = Object.assign({}, artifactRegistry, parsed);
        }
      } catch (e) {
        console.warn('Could not load artifact registry:', e);
      }
      // Ensure default bindings exist
      Object.keys(DEFAULT_ARTIFACT_PATHS).forEach(function(key) {
        if (!artifactRegistry.bindings[key]) {
          artifactRegistry.bindings[key] = {
            path: DEFAULT_ARTIFACT_PATHS[key],
            status: 'unknown',
            lastChecked: null,
            rebound: false
          };
        }
      });
    }
    
    // Save artifact registry to localStorage
    function saveArtifactRegistry() {
      try {
        localStorage.setItem(ARTIFACT_REGISTRY_KEY, JSON.stringify(artifactRegistry));
      } catch (e) {
        console.warn('Could not save artifact registry:', e);
      }
    }
    
    // Check if an artifact exists at its path
    async function checkArtifactStatus(key) {
      var binding = artifactRegistry.bindings[key];
      if (!binding) return 'missing';
      try {
        var response = await fetch(binding.path, { method: 'HEAD' });
        binding.status = response.ok ? 'loaded' : 'missing';
      } catch (e) {
        binding.status = 'missing';
      }
      binding.lastChecked = new Date().toISOString();
      return binding.status;
    }
    
    // Check all artifacts and update registry
    async function checkAllArtifacts() {
      var keys = Object.keys(artifactRegistry.bindings);
      await Promise.all(keys.map(function(key) {
        return checkArtifactStatus(key);
      }));
      saveArtifactRegistry();
      renderArtifactRegistryTable();
      renderWorkflowMap();
    }
    
    // Masterline autoload on boot
    var _autosaveTimer = null;
    function scheduleAutosave() {
      if (_autosaveTimer) clearTimeout(_autosaveTimer);
      _autosaveTimer = setTimeout(function() {
        if (workbook && workbook.order && workbook.order.length > 0) {
          saveWorkbookToCache();
          saveNavStateToCache(); scheduleAutosave();
          console.log('[SESSION] Auto-saved workbook + nav state');
        }
      }, 3000);
    }

    async function masterlineAutoload() {
      if (!artifactRegistry.devMasterlineEnabled) return;
      
      resetWorkbook();
      stagedLoader.start();
      stagedLoader.setStage('loading');
      console.log('[RESTORE] Starting session restore...');
      var t0 = performance.now();
      var cachedWorkbook = await loadWorkbookFromCache();
      if (cachedWorkbook && cachedWorkbook.workbook) {
        console.log('[RESTORE] Workbook found, restoring...');
        stagedLoader.setStage('standardizing');
        workbook.sheets = cachedWorkbook.workbook.sheets;
        workbook.order = cachedWorkbook.workbook.order;
        workbook.activeSheet = cachedWorkbook.workbook.activeSheet;
        IDENTITY_CONTEXT.dataset_id = cachedWorkbook.datasetId || 'ds_cached';
        
        updateActiveDataSourceBar(cachedWorkbook.filename);
        stagedLoader.setStage('validating');
        try { if (typeof generateAllSignals === 'function') generateAllSignals(); } catch (e) { console.warn('[RESTORE] generateAllSignals skipped:', e.message); }
        
        var navState = loadNavStateFromCache();
        if (navState) {
          gridState.sheet = navState.sheet;
          gridState.filter = navState.filter || 'all';
        }
        
        // v2.3: Always recompute ContractIndex from workbook to ensure consistency
        stagedLoader.setStage('indexing');
        try {
          if (workbook.order.length > 0) {
            ContractIndex.build();
            console.log('[RESTORE] ContractIndex rebuilt from workbook');
            console.log('[V2.3-GATE][G2] PASS ContractIndex rebuilt from live workbook on restore path');
          }
          populateContractSelector();
        } catch(e) { console.warn('[ContractIndex] Rebuild failed:', e); }
        // v2.2 P2: Restore merged batches from SessionDB
        try { await BatchMerge.restoreFromSession(); } catch(e) { console.warn('[BatchMerge] Restore failed:', e); }

        stagedLoader.setStage('changemap');
        var restorePage = (navState && navState.hash) ? navState.hash.replace(/^#\/?/, '') : 'grid';
        
        dataLoaded = true;
        stagedLoader.setStage('rendering');
        populateGridSheetSelector();
        updateSidebarSheetSelector();
        renderGrid();
        updateProgressBlock();
        navigateTo(restorePage || 'grid');
        stagedLoader.finish();
        
        // v2.3.5-P1F: Generate signals and run batch PDF scan on IndexedDB restore
        try { if (typeof generateSignalsForDataset === 'function') generateSignalsForDataset(); } catch(e) { console.warn('[RESTORE] generateSignalsForDataset error:', e.message); }
        if (typeof _p1fBatchPdfScan === 'function') _p1fBatchPdfScan();

        console.log('[RESTORE] Complete in', (performance.now() - t0).toFixed(1) + 'ms, ref: active_workbook, sheets:', workbook.order.length);
        showToast('Session restored: ' + cachedWorkbook.filename, 'success');
        AuditTimeline.emit('SESSION_RESTORED', {
          dataset_id: cachedWorkbook.datasetId || '',
          file_id: cachedWorkbook.filename || '',
          metadata: { sheets: workbook.order.length, restore_time_ms: (performance.now() - t0).toFixed(1) }
        });
        await checkAllArtifacts();
        renderSavedSessionsList();
        return;
      }
      stagedLoader.finish();
      

      // First try to restore from localStorage session
      if (restoreSessionFromStorage()) {
        console.log('[Masterline] Restored from localStorage session');
        // Also check artifacts for registry display
        await checkAllArtifacts();
        return;
      }
      
      // v1.6.37: All modes start with empty triage - user must upload data
      // Demo and Production modes both show "No dataset loaded" until user uploads
      console.log('[Masterline] Cold start - no sample data loaded (user must upload)');
      // Show "No dataset loaded" state
      var statusEl = document.querySelector('[data-session-status]');
      if (statusEl) statusEl.textContent = 'No dataset loaded';
      var nameEl = document.getElementById('dataset-name-display');
      if (nameEl) nameEl.textContent = 'Upload Excel to begin';
      
      // Check artifacts for registry display (after loading demo data)
      await checkAllArtifacts();
      
      // Load Truth Config if exists
      var truthBinding = artifactRegistry.bindings.truth_config;
      if (truthBinding && truthBinding.status === 'loaded') {
        try {
          var response = await fetch(truthBinding.path);
          if (response.ok) {
            loadedBaseConfig = await response.json();
          }
        } catch (e) {
          console.warn('Masterline: Could not load Truth Config:', e);
        }
      }
      
      // Load Proposed Changes if exists
      var patchBinding = artifactRegistry.bindings.proposed_changes;
      if (patchBinding && patchBinding.status === 'loaded') {
        try {
          var response = await fetch(patchBinding.path);
          if (response.ok) {
            loadedPatch = await response.json();
          }
        } catch (e) {
          console.warn('Masterline: Could not load Proposed Changes:', e);
        }
      }
    }
    
    // Render artifact registry table in Admin panel
    function renderArtifactRegistryTable() {
      var container = document.getElementById('artifact-registry-table');
      if (!container) return;
      
      var rows = Object.keys(ARTIFACT_LABELS).map(function(key) {
        var binding = artifactRegistry.bindings[key] || {};
        var label = ARTIFACT_LABELS[key];
        var status = binding.status || 'unknown';
        var statusClass = status === 'loaded' ? 'status-loaded' : status === 'missing' ? 'status-missing' : 'status-unknown';
        var statusText = status === 'loaded' ? 'Loaded' : status === 'missing' ? 'Missing' : 'Unknown';
        var reboundBadge = binding.rebound ? ' <span class="rebound-badge">Rebound</span>' : '';
        var path = binding.path || DEFAULT_ARTIFACT_PATHS[key];
        
        return '<tr>' +
          '<td>' + label + ' ' + infoIcon(label) + '</td>' +
          '<td><span class="artifact-status ' + statusClass + '">' + statusText + '</span>' + reboundBadge + '</td>' +
          '<td class="artifact-path" title="' + escapeHtml(path) + '">' + escapeHtml(path.split('/').pop()) + '</td>' +
          '<td><button class="rebind-btn" onclick="rebindArtifact(\'' + key + '\')">Rebind</button></td>' +
          '</tr>';
      }).join('');
      
      container.innerHTML = '<table class="artifact-table">' +
        '<thead><tr><th>Artifact</th><th>Status</th><th>File</th><th>Action</th></tr></thead>' +
        '<tbody>' + rows + '</tbody></table>';
    }
    
    // Rebind artifact path
    function rebindArtifact(key) {
      var binding = artifactRegistry.bindings[key];
      var currentPath = binding ? binding.path : DEFAULT_ARTIFACT_PATHS[key];
      var newPath = prompt('Enter new path for ' + ARTIFACT_LABELS[key] + ':', currentPath);
      if (newPath && newPath !== currentPath) {
        artifactRegistry.bindings[key] = {
          path: newPath,
          status: 'unknown',
          lastChecked: null,
          rebound: true
        };
        saveArtifactRegistry();
        checkArtifactStatus(key).then(function() {
          saveArtifactRegistry();
          renderArtifactRegistryTable();
        });
      }
    }
    
    // Toggle Dev Masterline mode
    function toggleDevMasterline() {
      artifactRegistry.devMasterlineEnabled = !artifactRegistry.devMasterlineEnabled;
      saveArtifactRegistry();
      updateDevMasterlineUI();
      if (artifactRegistry.devMasterlineEnabled) {
        masterlineAutoload();
      }
    }
    
    // Update Dev Masterline toggle UI
    function updateDevMasterlineUI() {
      var toggle = document.getElementById('dev-masterline-toggle');
      var status = document.getElementById('dev-masterline-status');
      if (toggle) {
        toggle.checked = artifactRegistry.devMasterlineEnabled;
      }
      if (status) {
        status.textContent = artifactRegistry.devMasterlineEnabled ? 'ON' : 'OFF';
        status.className = 'masterline-status ' + (artifactRegistry.devMasterlineEnabled ? 'on' : 'off');
      }
    }
    
    // ========== WORKFLOW MAP (D2) ==========
    const WORKFLOW_STAGES = [
      {
        id: 'load',
        title: 'Data Source',
        desc: 'Add or switch data source. Load Preview Packet and reference data.',
        icon: '📁',
        artifacts: ['preview_packet', 'reference_expected'],
        action: function() { openDataSourcePanel(); }
      },
      {
        id: 'config',
        title: 'Configuration',
        desc: 'Truth Config and Proposed Changes define semantic rules.',
        icon: '⚙',
        artifacts: ['truth_config', 'proposed_changes'],
        action: function() { openConfigFlows(); }
      },
      {
        id: 'standardize',
        title: 'Standardize',
        desc: 'Normalize input data format (CSV/XLSX to merged dataset).',
        icon: '📋',
        artifacts: ['standardized_dataset'],
        action: function() { if (currentMode === 'admin') openConfigFlows(); }
      },
      {
        id: 'preview',
        title: 'Preview',
        desc: 'Generated Preview Packet with issues and field actions.',
        icon: '👁',
        artifacts: ['preview_packet'],
        action: function() { navigateTo('triage'); }
      },
      {
        id: 'triage',
        title: 'Triage',
        desc: 'Review contracts by queue, filter by severity/status.',
        icon: '📊',
        artifacts: [],
        action: function() { navigateTo('triage'); }
      },
      {
        id: 'patch',
        title: 'Patch Draft',
        desc: 'Build rule patches from selected issues and actions.',
        icon: '✏',
        artifacts: [],
        action: function() { navigateTo('patch'); }
      },
      {
        id: 'evidence',
        title: 'Evidence',
        desc: 'Paste validation and smoke test results as evidence.',
        icon: '✓',
        artifacts: [],
        action: function() { showEvidenceStatus(); }
      },
      {
        id: 'export',
        title: 'PR Ready',
        desc: 'Export patch bundle and PR summary for review.',
        icon: '📤',
        artifacts: [],
        action: function() { navigateTo('patch'); }
      }
    ];
    
    // ========== COMMENT (RFI) SYSTEM ==========
    var COMMENTS_STORAGE_KEY = 'orchestrate.comments.v1';
    
    // v1.6.46: Backward compatibility - normalize legacy Verifier_* status values
    var LEGACY_STATUS_MAP = {
      'Reviewer_Responded': 'Verifier_Responded',
      'Reviewer_Approved': 'Verifier_Approved',
      'ReviewerResponded': 'VerifierResponded',
      'reviewer_responded': 'verifier_responded',
      'REVIEWER_APPROVED': 'VERIFIER_APPROVED'
    };
    
    function normalizeLegacyStatus(status) {
      if (!status) return status;
      return LEGACY_STATUS_MAP[status] || status;
    }
    
    function normalizeLegacyRole(role) {
      if (!role) return role;
      if (role === 'Reviewer' || role === 'reviewer') return 'Verifier';
      return role;
    }

    var COMMENT_STATUSES = ['Open', 'VerifierResponded', 'Resolved', 'ElevatedToPatchRequest', 'Closed'];
    var COMMENT_SCOPES = ['field', 'sheet', 'contract'];
    var COMMENT_ROLES = ['Analyst', 'Verifier', 'Admin'];
    
    var commentsStore = {
      comments: [],
      loaded: false
    };
    
    function generateCommentId() {
      return 'CMT_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 6);
    }
    
    function loadComments() {
      try {
        var stored = localStorage.getItem(COMMENTS_STORAGE_KEY);
        if (stored) {
          var parsed = JSON.parse(stored);
          commentsStore.comments = Array.isArray(parsed.comments) ? parsed.comments : [];
        } else {
          commentsStore.comments = [];
        }
        commentsStore.loaded = true;
      } catch (e) {
        console.error('Failed to load comments:', e);
        commentsStore.comments = [];
        commentsStore.loaded = true;
      }
      return commentsStore.comments;
    }
    
    function saveComments() {
      try {
        var data = {
          version: '1.0.0',
          saved_at: new Date().toISOString(),
          comments: commentsStore.comments
        };
        localStorage.setItem(COMMENTS_STORAGE_KEY, JSON.stringify(data));
        return true;
      } catch (e) {
        console.error('Failed to save comments:', e);
        return false;
      }
    }
    
    function createComment(options) {
      var now = new Date().toISOString();
      var comment = {
        comment_id: generateCommentId(),
        created_at_utc: now,
        author: options.author || 'Unknown',
        author_role: options.author_role || currentMode || 'Analyst',
        record_identity: {
          contract_key: options.contract_key || null,
          file_url: options.file_url || null,
          file_name: options.file_name || null
        },
        scope: {
          level: options.scope_level || 'contract',
          sheet: options.sheet || null,
          field: options.field || null
        },
        message: options.message || '',
        status: 'Open',
        linked_patch_request_id: null,
        history: [
          {
            at_utc: now,
            actor: options.author || 'Unknown',
            role: options.author_role || currentMode || 'Analyst',
            action: 'Created',
            notes: null
          }
        ]
      };
      commentsStore.comments.push(comment);
      saveComments();
      return comment;
    }
    
    function getComment(commentId) {
      return commentsStore.comments.find(function(c) { return c.comment_id === commentId; }) || null;
    }
    
    function updateComment(commentId, updates, actor, actorRole) {
      var comment = getComment(commentId);
      if (!comment) return null;
      
      var now = new Date().toISOString();
      var changes = [];
      
      if (updates.message !== undefined && updates.message !== comment.message) {
        comment.message = updates.message;
        changes.push('message');
      }
      if (updates.status !== undefined && updates.status !== comment.status) {
        var oldStatus = comment.status;
        comment.status = updates.status;
        changes.push('status: ' + oldStatus + ' → ' + updates.status);
      }
      if (updates.linked_patch_request_id !== undefined) {
        comment.linked_patch_request_id = updates.linked_patch_request_id;
        changes.push('linked to patch request');
      }
      
      if (changes.length > 0) {
        comment.history.push({
          at_utc: now,
          actor: actor || 'Unknown',
          role: actorRole || currentMode || 'Analyst',
          action: 'Updated',
          notes: changes.join('; ')
        });
        saveComments();
      }
      return comment;
    }
    
    function addCommentResponse(commentId, responseMessage, actor, actorRole) {
      var comment = getComment(commentId);
      if (!comment) return null;
      
      var now = new Date().toISOString();
      comment.history.push({
        at_utc: now,
        actor: actor || 'Unknown',
        role: actorRole || currentMode || 'Analyst',
        action: 'Responded',
        notes: responseMessage
      });
      
      if (actorRole === 'Verifier' || actorRole === 'Admin') {
        comment.status = 'VerifierResponded';
      }
      
      saveComments();
      return comment;
    }
    
    function resolveComment(commentId, actor, actorRole) {
      return updateComment(commentId, { status: 'Resolved' }, actor, actorRole);
    }
    
    function closeComment(commentId, actor, actorRole) {
      return updateComment(commentId, { status: 'Closed' }, actor, actorRole);
    }
    
    function elevateCommentToPatchRequest(commentId, patchRequestId, actor, actorRole) {
      var comment = getComment(commentId);
      if (!comment) return null;
      
      comment.status = 'ElevatedToPatchRequest';
      comment.linked_patch_request_id = patchRequestId;
      comment.history.push({
        at_utc: new Date().toISOString(),
        actor: actor || 'Unknown',
        role: actorRole || 'Verifier',
        action: 'Elevated to Patch Request',
        notes: 'Linked to ' + patchRequestId
      });
      
      saveComments();
      return comment;
    }
    
    function deleteComment(commentId) {
      var idx = commentsStore.comments.findIndex(function(c) { return c.comment_id === commentId; });
      if (idx === -1) return false;
      commentsStore.comments.splice(idx, 1);
      saveComments();
      return true;
    }
    
    function getCommentsForRecord(contractKey, fileUrl, fileName) {
      return commentsStore.comments.filter(function(c) {
        var ri = c.record_identity;
        return (ri.contract_key === contractKey || (!ri.contract_key && !contractKey)) &&
               (ri.file_url === fileUrl || (!ri.file_url && !fileUrl)) &&
               (ri.file_name === fileName || (!ri.file_name && !fileName));
      });
    }
    
    function getCommentsByStatus(status) {
      return commentsStore.comments.filter(function(c) { return c.status === status; });
    }
    
    function getCommentsByTarget(targetType, targetId) {
      return commentsStore.comments.filter(function(c) {
        return c.target_type === targetType && c.target_id === targetId;
      });
    }
    
    function getOpenComments() {
      return commentsStore.comments.filter(function(c) {
        return c.status === 'Open' || c.status === 'VerifierResponded';
      });
    }
    
    function getCommentCounts() {
      var counts = {
        total: commentsStore.comments.length,
        open: 0,
        verifier_responded: 0,
        resolved: 0,
        elevated: 0,
        closed: 0
      };
      commentsStore.comments.forEach(function(c) {
        if (c.status === 'Open') counts.open++;
        else if (c.status === 'VerifierResponded') counts.verifier_responded++;
        else if (c.status === 'Resolved') counts.resolved++;
        else if (c.status === 'ElevatedToPatchRequest') counts.elevated++;
        else if (c.status === 'Closed') counts.closed++;
      });
      return counts;
    }
    
    function exportCommentsJSON() {
      return JSON.stringify({
        exported_at: new Date().toISOString(),
        count: commentsStore.comments.length,
        comments: commentsStore.comments.map(function(c) {
          return Object.assign({}, c);
        }).sort(function(a, b) {
          return a.created_at_utc.localeCompare(b.created_at_utc);
        })
      }, null, 2);
    }
    
    // Initialize comments on load
    loadComments();
    
    // ========== PATCH REQUEST SYSTEM ==========
    var PATCH_REQUESTS_STORAGE_KEY = 'orchestrate.patch_requests.v1';
    
    var PATCH_REQUEST_STATUSES = [
      'Draft',
      'Submitted',
      'Needs_Clarification',
      'Verifier_Responded',
      'Verifier_Approved',
      'Admin_Approved',
      // V1-hidden: 'Sent_to_Kiwi',
      // V1-hidden: 'Kiwi_Returned',
      'Applied',
      'Rejected',
      'Cancelled',
      'Admin_Hold'
    ];
    
    var PATCH_REQUEST_QUEUE_TABS = [
      { id: 'new', label: 'New', statuses: ['Submitted'] },
      { id: 'needs_review', label: 'Needs Review', statuses: ['Needs_Clarification', 'Verifier_Responded'] },
      { id: 'approved', label: 'Approved', statuses: ['Verifier_Approved', 'Admin_Approved'] },
      // V1-hidden: { id: 'sent_to_kiwi', label: 'Sent to Kiwi', statuses: ['Sent_to_Kiwi'] },
      // V1-hidden: { id: 'kiwi_returned', label: 'Kiwi Returned', statuses: ['Kiwi_Returned'] },
      { id: 'applied', label: 'Applied', statuses: ['Applied'] },
      { id: 'rejected', label: 'Rejected', statuses: ['Rejected', 'Cancelled'] }
    ];
    
    var PATCH_REQUEST_TARGETS = ['salesforce', 'qa_rules', 'resolver_rules', 'truth_config', 'proposed_changes'];
    
    var ROLE_PERMISSIONS = {
      'Analyst': {
        can: ['create_draft', 'edit_own_draft', 'submit_to_patch_queue', 'respond_to_clarification', 'cancel_own_draft_or_submitted'],
        cannot: ['verifier_approve', 'admin_approve', 'send_to_kiwi', 'paste_kiwi_return', 'mark_applied', 'admin_hold']
      },
      'Verifier': {
        can: ['comment_rfi', 'request_clarification', 'edit_review_fields', 'verifier_approve', 'reject', 'send_back_to_submitted_after_edits'],
        cannot: ['send_to_kiwi', 'paste_kiwi_return', 'mark_applied', 'admin_approve', 'edit_patch_payload_directly'],
        edit_allowlist: ['intent.when', 'intent.then', 'intent.because', 'target_scope', 'risk', 'review_notes', 'evidence.checklist_status', 'clarification_questions']
      },
      'Admin': {
        can: ['everything_verifier_can', 'admin_approve', 'send_to_kiwi', 'paste_kiwi_return', 'mark_applied', 'admin_hold', 'cancel_any', 'export_commit_pack']
      }
    };
    
    var STATUS_TRANSITIONS = [
      { from: 'Draft', to: 'Submitted', roles: ['Analyst'], action: 'submit_to_patch_queue', audit: 'PATCH_REQUEST_SUBMITTED' },
      { from: 'Submitted', to: 'Needs_Clarification', roles: ['Verifier', 'Admin'], action: 'request_clarification', audit: 'CLARIFICATION_REQUESTED' },
      { from: 'Needs_Clarification', to: 'Verifier_Responded', roles: ['Analyst'], action: 'respond_to_clarification', audit: 'CLARIFICATION_RESPONDED' },
      { from: 'Verifier_Responded', to: 'Verifier_Approved', roles: ['Verifier'], action: 'verifier_approve', audit: 'VERIFIER_APPROVED' },
      { from: 'Submitted', to: 'Verifier_Approved', roles: ['Verifier'], action: 'verifier_approve', audit: 'VERIFIER_APPROVED' },
      { from: 'Verifier_Approved', to: 'Admin_Approved', roles: ['Admin'], action: 'admin_approve', audit: 'ADMIN_APPROVED' },
      { from: 'Admin_Approved', to: 'Sent_to_Kiwi', roles: ['Admin'], action: 'send_to_kiwi', audit: 'SENT_TO_KIWI' },
      { from: 'Sent_to_Kiwi', to: 'Kiwi_Returned', roles: ['Admin'], action: 'paste_kiwi_return', audit: 'KIWI_RETURN_INGESTED' },
      { from: 'Kiwi_Returned', to: 'Applied', roles: ['Admin'], action: 'mark_applied', audit: 'PATCH_APPLIED' },
      { from: 'Submitted', to: 'Rejected', roles: ['Verifier', 'Admin'], action: 'reject', audit: 'PATCH_REJECTED' },
      { from: 'Verifier_Responded', to: 'Rejected', roles: ['Verifier', 'Admin'], action: 'reject', audit: 'PATCH_REJECTED' },
      { from: 'Draft', to: 'Cancelled', roles: ['Analyst', 'Admin'], action: 'cancel', audit: 'PATCH_CANCELLED' },
      { from: 'Submitted', to: 'Cancelled', roles: ['Analyst', 'Admin'], action: 'cancel', audit: 'PATCH_CANCELLED' },
      { from: 'Verifier_Approved', to: 'Admin_Hold', roles: ['Admin'], action: 'admin_hold', audit: 'ADMIN_HOLD_SET' },
      { from: 'Admin_Hold', to: 'Admin_Approved', roles: ['Admin'], action: 'release_hold', audit: 'ADMIN_HOLD_RELEASED' }
    ];
    
    function canTransition(fromStatus, toStatus, role) {
      var transition = STATUS_TRANSITIONS.find(function(t) {
        return t.from === fromStatus && t.to === toStatus;
      });
      if (!transition) return false;
      if (role === 'Admin' && transition.roles.includes('Verifier')) return true;
      return transition.roles.includes(role);
    }
    
    function getAuditEventForTransition(fromStatus, toStatus) {
      var transition = STATUS_TRANSITIONS.find(function(t) {
        return t.from === fromStatus && t.to === toStatus;
      });
      return transition ? transition.audit : 'STATUS_CHANGED';
    }
    
    function getAvailableTransitions(currentStatus, role) {
      return STATUS_TRANSITIONS.filter(function(t) {
        if (t.from !== currentStatus) return false;
        if (role === 'Admin') return true;
        if (role === 'Verifier' && (t.roles.includes('Verifier') || t.roles.includes('Admin'))) return false;
        return t.roles.includes(role);
      }).map(function(t) { return t.to; });
    }
    
    function canEditField(role, fieldPath) {
      if (role === 'Admin') return true;
      if (role === 'Verifier') {
        return ROLE_PERMISSIONS.Verifier.edit_allowlist.includes(fieldPath);
      }
      return false;
    }
    
    var patchRequestsStore = {
      requests: [],
      loaded: false,
      selectedIds: []
    };
    
    function generatePatchRequestId() {
      return 'PR_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 6);
    }
    
    function loadPatchRequests() {
      try {
        var stored = localStorage.getItem(PATCH_REQUESTS_STORAGE_KEY);
        if (stored) {
          var parsed = JSON.parse(stored);
          patchRequestsStore.requests = Array.isArray(parsed.requests) ? parsed.requests : [];
          // v1.6.46: Normalize legacy Verifier_* statuses from stored data
          patchRequestsStore.requests.forEach(function(pr) {
            if (pr.status) pr.status = normalizeLegacyStatus(pr.status);
            if (pr.actor_role) pr.actor_role = normalizeLegacyRole(pr.actor_role);
          });
        } else {
          patchRequestsStore.requests = [];
        }
        patchRequestsStore.loaded = true;
      } catch (e) {
        console.error('Failed to load patch requests:', e);
        patchRequestsStore.requests = [];
        patchRequestsStore.loaded = true;
      }
      return patchRequestsStore.requests;
    }
    
    function savePatchRequests() {
      try {
        var data = {
          version: '1.0.0',
          saved_at: new Date().toISOString(),
          requests: patchRequestsStore.requests
        };
        localStorage.setItem(PATCH_REQUESTS_STORAGE_KEY, JSON.stringify(data));
        return true;
      } catch (e) {
        console.error('Failed to save patch requests:', e);
        return false;
      }
    }
    
    var CONDITION_TYPES = [
      { value: 'SHOULD_BE_BLANK_BUT_POPULATED', label: 'Should be blank but has data' },
      { value: 'SHOULD_BE_PRESENT_BUT_MISSING', label: 'Should have data but is empty' },
      { value: 'INVALID_FORMAT', label: 'Invalid format/pattern' },
      { value: 'OUT_OF_RANGE', label: 'Value out of allowed range' },
      { value: 'MISMATCH_WITH_OTHER_FIELD', label: 'Mismatches another field' },
      { value: 'DUPLICATE', label: 'Duplicate value detected' },
      { value: 'OTHER', label: 'Other (specify)' }
    ];
    
    var ACTION_TYPES = [
      { value: 'REQUIRE_PRESENT', label: 'Require field to have a value' },
      { value: 'REQUIRE_BLANK', label: 'Require field to be blank' },
      { value: 'WARN_ONLY', label: 'Warn only (non-blocking)' },
      { value: 'NORMALIZE_VALUE', label: 'Normalize/standardize value' },
      { value: 'MAP_FIELD', label: 'Map to another field' },
      { value: 'BLOCK_SUBMISSION', label: 'Block submission' },
      { value: 'OTHER', label: 'Other (specify)' }
    ];
    
    function renderIntentPreview(intentStructured) {
      var whenText = '';
      var thenText = '';
      
      if (intentStructured.target_field) {
        whenText = 'Field "' + intentStructured.target_field + '"';
        var condition = CONDITION_TYPES.find(function(c) { return c.value === intentStructured.condition_type; });
        if (condition) {
          whenText += ' ' + condition.label.toLowerCase();
        }
        if (intentStructured.condition_type === 'OTHER' && intentStructured.condition_params && intentStructured.condition_params.custom) {
          whenText += ': ' + intentStructured.condition_params.custom;
        }
      }
      
      var action = ACTION_TYPES.find(function(a) { return a.value === intentStructured.action_type; });
      if (action) {
        thenText = action.label;
      }
      if (intentStructured.action_type === 'OTHER' && intentStructured.action_params && intentStructured.action_params.custom) {
        thenText += ': ' + intentStructured.action_params.custom;
      }
      
      return {
        when: whenText || 'WHEN: (not specified)',
        then: thenText || 'THEN: (not specified)',
        because: intentStructured.because || ''
      };
    }
    
    function createPatchRequest(options) {
      var now = new Date().toISOString();
      
      var intentStructured = {
        target_field: options.target_field || (options.sheet && options.field ? options.sheet + '.' + options.field : null),
        condition_type: options.condition_type || 'OTHER',
        condition_params: options.condition_params || (options.when ? { custom: options.when } : null),
        action_type: options.action_type || 'OTHER',
        action_params: options.action_params || (options.then ? { custom: options.then } : null),
        severity: options.severity || 'warning',
        risk: options.risk || 'low',
        target_artifact: options.target || 'proposed_changes',
        because: options.because || ''
      };
      
      var intentRendered = renderIntentPreview(intentStructured);
      if (options.because) {
        intentRendered.because = options.because;
      }
      
      var request = {
        request_id: generatePatchRequestId(),
        created_at_utc: now,
        updated_at_utc: now,
        submitted_at_utc: null,
        author: options.author || 'Unknown',
        author_role: options.author_role || currentMode || 'Analyst',
        assigned_to: null,
        status: options.status || 'Draft',
        // v1.5.2: Enhanced record identity with record_id
        tenant_id: options.tenant_id || IDENTITY_CONTEXT.tenant_id,
        division_id: options.division_id || IDENTITY_CONTEXT.division_id,
        dataset_id: options.dataset_id || IDENTITY_CONTEXT.dataset_id || 'default',
        record_id: options.record_id || null,
        patch_kind: options.patch_kind || options.patch_type || 'correction',
        record_identity: {
          contract_key: options.contract_key || null,
          file_url: options.file_url || null,
          file_name: options.file_name || null
        },
        target_scope: {
          target: options.target || 'proposed_changes',
          sheet: options.sheet || null,
          field: options.field || null
        },
        risk: options.risk || 'low',
        intent_structured: intentStructured,
        intent_rendered: intentRendered,
        proposed_changes: options.proposed_changes || [{
          field: options.field || null,
          old_value: options.old_value || null,
          new_value: options.new_value || null
        }],
        proposed_change: {
          intent: intentRendered,
          rationale: options.rationale || ''
        },
        evidence_pack: {
          observation: options.evidence_observation || '',
          expected_behavior: options.evidence_expected || '',
          rule_justification: options.evidence_justification || '',
          repro_steps: options.evidence_repro || '',
          replay_type: options.replay_type || '',
          replay_steps: options.replay_steps || '',
          replay_expected_result: options.replay_expected_result || ''
        },
        evidence: {
          observation: options.evidence_observation || '',
          expected_behavior: options.evidence_expected || '',
          rule_justification: options.evidence_justification || '',
          repro_steps: options.evidence_repro || '',
          preflight_results: null,
          checklist_status: {}
        },
        thread: options.thread || [],
        review_notes: '',
        clarification_questions: [],
        revisions: [],
        linked_comment_id: options.linked_comment_id || null,
        kiwi_return: null,
        audit_log: [
          {
            at_utc: now,
            actor: options.author || 'Unknown',
            role: options.author_role || currentMode || 'Analyst',
            event: 'PATCH_REQUEST_CREATED',
            details: null
          }
        ],
        history: [
          {
            at_utc: now,
            actor: options.author || 'Unknown',
            role: options.author_role || currentMode || 'Analyst',
            action: 'Created',
            from_status: null,
            to_status: 'Draft',
            notes: null
          }
        ]
      };
      patchRequestsStore.requests.push(request);
      savePatchRequests();
      
      // v1.5.2: Also save to PATCH_REQUEST_STORE for shared access
      PATCH_REQUEST_STORE.save(request);
      
      return request;
    }
    
    function getPatchRequest(requestId) {
      return patchRequestsStore.requests.find(function(r) { return r.request_id === requestId; }) || null;
    }
    
    function updatePatchRequestStatus(requestId, newStatus, actor, actorRole, notes) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (!PATCH_REQUEST_STATUSES.includes(newStatus)) return null;
      
      var role = actorRole || currentMode || 'Analyst';
      if (!canTransition(request.status, newStatus, role)) {
        console.warn('Transition not allowed:', request.status, '->', newStatus, 'for role', role);
        return null;
      }
      
      var now = new Date().toISOString();
      var oldStatus = request.status;
      var auditEvent = getAuditEventForTransition(oldStatus, newStatus);
      
      request.status = newStatus;
      request.updated_at_utc = now;
      
      if (newStatus === 'Submitted' && !request.submitted_at_utc) {
        request.submitted_at_utc = now;
      }
      
      request.history.push({
        at_utc: now,
        actor: actor || 'Unknown',
        role: role,
        action: 'Status Changed',
        from_status: oldStatus,
        to_status: newStatus,
        notes: notes || null
      });
      
      if (!request.audit_log) request.audit_log = [];
      request.audit_log.push({
        at_utc: now,
        actor: actor || 'Unknown',
        role: role,
        event: auditEvent,
        details: notes || null
      });

      AuditTimeline.emit(auditEvent, {
        actor_id: actor || 'Unknown',
        actor_role: role,
        timestamp_iso: now,
        dataset_id: request.dataset_id || IDENTITY_CONTEXT.dataset_id || '',
        file_id: request.file_name || request.file_url || '',
        record_id: request.record_id || '',
        patch_request_id: requestId,
        metadata: { from_status: oldStatus, to_status: newStatus, notes: notes || null }
      });
      
      savePatchRequests();
      return request;
    }
    
    function updatePatchRequest(requestId, updates, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      
      var now = new Date().toISOString();
      var role = actorRole || currentMode || 'Analyst';
      var changes = [];
      var oldSnapshot = null;
      
      if (request.status !== 'Draft') {
        oldSnapshot = JSON.parse(JSON.stringify({
          proposed_change: request.proposed_change,
          target_scope: request.target_scope,
          evidence: request.evidence,
          review_notes: request.review_notes
        }));
      }
      
      if (updates.proposed_change) {
        if (updates.proposed_change.intent) {
          if (role === 'Verifier') {
            ['when', 'then', 'because'].forEach(function(field) {
              if (updates.proposed_change.intent[field] !== undefined && canEditField(role, 'intent.' + field)) {
                request.proposed_change.intent[field] = updates.proposed_change.intent[field];
                changes.push('intent.' + field + ' updated');
              }
            });
          } else {
            Object.assign(request.proposed_change.intent, updates.proposed_change.intent);
            changes.push('intent updated');
          }
        }
        if (updates.proposed_change.rationale !== undefined) {
          request.proposed_change.rationale = updates.proposed_change.rationale;
          changes.push('rationale updated');
        }
      }
      if (updates.target_scope && canEditField(role, 'target_scope')) {
        Object.assign(request.target_scope, updates.target_scope);
        changes.push('target updated');
      }
      if (updates.risk !== undefined && canEditField(role, 'risk')) {
        request.risk = updates.risk;
        changes.push('risk updated');
      }
      if (updates.review_notes !== undefined && canEditField(role, 'review_notes')) {
        request.review_notes = updates.review_notes;
        changes.push('review notes updated');
      }
      if (updates.evidence) {
        if (!request.evidence) request.evidence = {};
        Object.assign(request.evidence, updates.evidence);
        changes.push('evidence updated');
      }
      if (updates.clarification_questions) {
        request.clarification_questions = updates.clarification_questions;
        changes.push('clarification questions updated');
      }
      
      if (changes.length > 0) {
        request.updated_at_utc = now;
        
        if (oldSnapshot && request.status !== 'Draft') {
          if (!request.revisions) request.revisions = [];
          request.revisions.push({
            revision_id: 'REV_' + Date.now().toString(36),
            at_utc: now,
            actor: actor || 'Unknown',
            role: role,
            diff_summary: changes.join('; '),
            previous_snapshot: oldSnapshot
          });
        }
        
        request.history.push({
          at_utc: now,
          actor: actor || 'Unknown',
          role: role,
          action: 'Updated',
          from_status: request.status,
          to_status: request.status,
          notes: changes.join('; ')
        });
        
        if (!request.audit_log) request.audit_log = [];
        request.audit_log.push({
          at_utc: now,
          actor: actor || 'Unknown',
          role: role,
          event: 'PATCH_REQUEST_UPDATED',
          details: changes.join('; ')
        });
        
        savePatchRequests();
      }
      return request;
    }
    
    function submitPatchRequest(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Draft') return null;
      if (!_governedDecisions.canPerformAction('submit_patch', actorRole || currentMode, !isDemoMode())) {
        showToast('Permission denied: ' + (actorRole || currentMode) + ' cannot submit patches in Production mode', 'error');
        console.log('[T11:GATE] submit_patch blocked for role:', actorRole || currentMode);
        return null;
      }
      return updatePatchRequestStatus(requestId, 'Submitted', actor, actorRole, 'Submitted to patch queue');
    }
    
    function requestClarification(requestId, questions, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Submitted') return null;
      
      request.clarification_questions = questions || [];
      var result = updatePatchRequestStatus(requestId, 'Needs_Clarification', actor, actorRole, 'Clarification requested');
      return result;
    }
    
    function respondToClarification(requestId, response, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Needs_Clarification') return null;
      
      if (!request.clarification_questions) request.clarification_questions = [];
      request.clarification_questions.push({
        type: 'response',
        from: actor || 'Analyst',
        at_utc: new Date().toISOString(),
        text: response
      });
      
      return updatePatchRequestStatus(requestId, 'Verifier_Responded', actor, actorRole, 'Clarification provided');
    }
    
    function verifierApprove(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (!['Submitted', 'Verifier_Responded'].includes(request.status)) return null;
      if (!_governedDecisions.canPerformAction('verify_patch', actorRole || currentMode, !isDemoMode())) {
        showToast('Permission denied: ' + (actorRole || currentMode) + ' cannot verify patches in Production mode', 'error');
        console.log('[T11:GATE] verify_patch blocked for role:', actorRole || currentMode);
        return null;
      }
      return updatePatchRequestStatus(requestId, 'Verifier_Approved', actor, actorRole, 'Approved by verifier');
    }
    
    function adminApprove(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Verifier_Approved') return null;
      if (!_governedDecisions.canPerformAction('approve_patch', actorRole || currentMode, !isDemoMode())) {
        showToast('Permission denied: ' + (actorRole || currentMode) + ' cannot approve patches in Production mode', 'error');
        console.log('[T11:GATE] approve_patch blocked for role:', actorRole || currentMode);
        return null;
      }
      return updatePatchRequestStatus(requestId, 'Admin_Approved', actor, actorRole, 'Approved by admin');
    }
    
    function setAdminHold(requestId, reason, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Verifier_Approved') return null;
      return updatePatchRequestStatus(requestId, 'Admin_Hold', actor, actorRole, reason || 'Placed on admin hold');
    }
    
    function releaseAdminHold(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Admin_Hold') return null;
      return updatePatchRequestStatus(requestId, 'Admin_Approved', actor, actorRole, 'Released from admin hold');
    }
    
    function deletePatchRequest(requestId) {
      var idx = patchRequestsStore.requests.findIndex(function(r) { return r.request_id === requestId; });
      if (idx === -1) return false;
      patchRequestsStore.requests.splice(idx, 1);
      savePatchRequests();
      return true;
    }
    
    // Batch selection
    function selectPatchRequest(requestId) {
      if (!patchRequestsStore.selectedIds.includes(requestId)) {
        patchRequestsStore.selectedIds.push(requestId);
      }
    }
    
    function deselectPatchRequest(requestId) {
      var idx = patchRequestsStore.selectedIds.indexOf(requestId);
      if (idx !== -1) {
        patchRequestsStore.selectedIds.splice(idx, 1);
      }
    }
    
    function togglePatchRequestSelection(requestId) {
      if (patchRequestsStore.selectedIds.includes(requestId)) {
        deselectPatchRequest(requestId);
      } else {
        selectPatchRequest(requestId);
      }
    }
    
    function clearPatchRequestSelection() {
      patchRequestsStore.selectedIds = [];
    }
    
    function getSelectedPatchRequests() {
      return patchRequestsStore.selectedIds.map(function(id) {
        return getPatchRequest(id);
      }).filter(function(r) { return r !== null; });
    }
    
    function selectAllInQueue(queueId) {
      var queue = PATCH_REQUEST_QUEUE_TABS.find(function(q) { return q.id === queueId; });
      if (!queue) return;
      patchRequestsStore.requests.forEach(function(r) {
        if (queue.statuses.includes(r.status)) {
          selectPatchRequest(r.request_id);
        }
      });
    }
    
    // Queue queries
    function getPatchRequestsByQueue(queueId) {
      var queue = PATCH_REQUEST_QUEUE_TABS.find(function(q) { return q.id === queueId; });
      if (!queue) return [];
      return patchRequestsStore.requests.filter(function(r) {
        return queue.statuses.includes(r.status);
      }).sort(function(a, b) {
        return b.updated_at_utc.localeCompare(a.updated_at_utc);
      });
    }
    
    function getPatchRequestsByStatus(status) {
      return patchRequestsStore.requests.filter(function(r) { return r.status === status; });
    }
    
    function getPatchRequestCounts() {
      var counts = { total: patchRequestsStore.requests.length };
      PATCH_REQUEST_QUEUE_TABS.forEach(function(queue) {
        counts[queue.id] = 0;
      });
      patchRequestsStore.requests.forEach(function(r) {
        PATCH_REQUEST_QUEUE_TABS.forEach(function(queue) {
          if (queue.statuses.includes(r.status)) {
            counts[queue.id]++;
          }
        });
      });
      return counts;
    }
    
    // Kiwi handshake functions
    function markSentToKiwi(requestIds, actor, actorRole) {
      var updated = [];
      requestIds.forEach(function(id) {
        var result = updatePatchRequestStatus(id, 'Sent_to_Kiwi', actor, actorRole, 'Exported for Kiwi processing');
        if (result) updated.push(result);
      });
      return updated;
    }
    
    function applyKiwiReturn(requestId, kiwiPayload, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Sent_to_Kiwi') return null;
      
      var now = new Date().toISOString();
      request.kiwi_return = {
        returned_at_utc: now,
        patch_payload_json: kiwiPayload.patch_payload_json || kiwiPayload,
        notes: kiwiPayload.notes || null,
        derived_target: kiwiPayload.derived_target || request.target_scope.target,
        proposed_version: kiwiPayload.proposed_version || null
      };
      request.status = 'Kiwi_Returned';
      request.updated_at_utc = now;
      request.history.push({
        at_utc: now,
        actor: actor || 'Admin',
        role: actorRole || 'Admin',
        action: 'Kiwi Return Applied',
        from_status: 'Sent_to_Kiwi',
        to_status: 'Kiwi_Returned',
        notes: 'Kiwi payload received'
      });
      
      if (!request.audit_log) request.audit_log = [];
      request.audit_log.push({
        at_utc: now,
        actor: actor || 'Admin',
        role: actorRole || 'Admin',
        event: 'KIWI_RETURN_INGESTED',
        details: 'Kiwi payload received'
      });
      
      savePatchRequests();
      return request;
    }
    
    function markApplied(requestIds, actor, actorRole) {
      var updated = [];
      requestIds.forEach(function(id) {
        var result = updatePatchRequestStatus(id, 'Applied', actor, actorRole, 'Patch applied to target artifact');
        if (result) updated.push(result);
      });
      return updated;
    }
    
    function markRejected(requestId, reason, actor, actorRole) {
      return updatePatchRequestStatus(requestId, 'Rejected', actor, actorRole, reason);
    }
    
    // Export functions
    function exportPatchRequestsForKiwi(requestIds) {
      var requests = requestIds.map(function(id) { return getPatchRequest(id); }).filter(function(r) { return r !== null; });
      return JSON.stringify({
        batch_id: 'BATCH_' + Date.now().toString(36),
        exported_at_utc: new Date().toISOString(),
        count: requests.length,
        requests: requests.map(function(r) {
          return {
            request_id: r.request_id,
            record_identity: r.record_identity,
            target_scope: r.target_scope,
            proposed_change: r.proposed_change,
            author: r.author,
            created_at_utc: r.created_at_utc
          };
        })
      }, null, 2);
    }
    
    function exportBatchCommitPack(requestIds) {
      var requests = requestIds.map(function(id) { return getPatchRequest(id); }).filter(function(r) { return r !== null && r.kiwi_return; });
      return JSON.stringify({
        batch_id: 'COMMIT_' + Date.now().toString(36),
        created_at_utc: new Date().toISOString(),
        count: requests.length,
        items: requests.map(function(r) {
          return {
            request_id: r.request_id,
            target: r.target_scope.target,
            patch_payload_json: r.kiwi_return.patch_payload_json,
            suggested_files: getSuggestedFilesForTarget(r.target_scope.target),
            changelog_entry: generateChangelogEntry(r),
            pr_summary_markdown: generatePRSummary(r)
          };
        })
      }, null, 2);
    }
    
    function getSuggestedFilesForTarget(target) {
      var fileMap = {
        'salesforce': ['config/sf_rules.json'],
        'qa_rules': ['config/qa_rules.json'],
        'resolver_rules': ['config/resolver_rules.json'],
        'truth_config': ['config/config_pack.base.json'],
        'proposed_changes': ['config/config_pack.patch.json']
      };
      return fileMap[target] || ['config/config_pack.patch.json'];
    }
    
    function generateChangelogEntry(request) {
      var intent = request.proposed_change.intent;
      return '- ' + (intent.then || 'Update') + ' when ' + (intent.when || 'condition met') + ' (' + request.request_id + ')';
    }
    
    function generatePRSummary(request) {
      var intent = request.proposed_change.intent;
      return '## Patch Request: ' + request.request_id + '\n\n' +
        '**When:** ' + (intent.when || 'N/A') + '\n' +
        '**Then:** ' + (intent.then || 'N/A') + '\n' +
        '**Because:** ' + (intent.because || 'N/A') + '\n\n' +
        '**Rationale:** ' + (request.proposed_change.rationale || 'N/A') + '\n';
    }
    
    // Initialize patch requests on load
    loadPatchRequests();
    
    // ========== PATCH CONSOLE UI ==========
    var currentPatchQueue = 'new';
    
    function switchPatchQueueTab(queueId) {
      currentPatchQueue = queueId;
      document.querySelectorAll('.queue-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.queue === queueId);
      });
      renderPatchConsoleTable();
    }
    
    function updatePatchQueueCounts() {
      var counts = getPatchRequestCounts();
      document.querySelectorAll('.queue-tab').forEach(function(tab) {
        var queueId = tab.dataset.queue;
        var countSpan = tab.querySelector('.queue-count');
        if (countSpan && counts[queueId] !== undefined) {
          countSpan.textContent = counts[queueId];
        }
      });
      var totalEl = document.getElementById('patch-total-count');
      if (totalEl) totalEl.textContent = counts.total;
      
      var selectedEl = document.getElementById('patch-selected-count');
      if (selectedEl) selectedEl.textContent = patchRequestsStore.selectedIds.length;
      
      var commentsEl = document.getElementById('comments-open-count');
      if (commentsEl) {
        var commentCounts = getCommentCounts();
        commentsEl.textContent = commentCounts.open + commentCounts.verifier_responded;
      }
    }
    
    function renderPatchConsoleTable() {
      var tbody = document.getElementById('patch-console-tbody');
      if (!tbody) return;
      
      var requests = getPatchRequestsByQueue(currentPatchQueue);
      updatePatchQueueCounts();
      
      if (requests.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="padding: 20px; text-align: center; color: #888;">No patch requests in this queue</td></tr>';
        return;
      }
      
      tbody.innerHTML = requests.map(function(r) {
        var isSelected = patchRequestsStore.selectedIds.includes(r.request_id);
        var intent = r.proposed_change.intent;
        var intentSummary = (intent.then || 'No intent').substring(0, 40) + ((intent.then || '').length > 40 ? '...' : '');
        var statusClass = getStatusClass(r.status);
        var updatedDate = new Date(r.updated_at_utc).toLocaleDateString();
        
        return '<tr>' +
          '<td><input type="checkbox" ' + (isSelected ? 'checked' : '') + ' onchange="togglePatchRequestSelection(\'' + r.request_id + '\'); renderPatchConsoleTable();"></td>' +
          '<td style="font-family: monospace; font-size: 0.85em;">' + escapeHtml(r.request_id.substring(0, 12)) + '</td>' +
          '<td>' + escapeHtml(intentSummary) + '</td>' +
          '<td>' + escapeHtml(humanLabel(r.target_scope.target) || 'N/A') + '</td>' +
          '<td><span class="patch-status-chip ' + statusClass + '">' + escapeHtml(r.status) + '</span></td>' +
          '<td style="font-size: 0.85em;">' + updatedDate + '</td>' +
          '<td style="text-align: center;"><button class="toolbar-btn" style="padding: 4px 8px; font-size: 0.8em;" onclick="viewPatchRequestDetail(\'' + r.request_id + '\')">View</button></td>' +
          (function() { var patchHealthHtml = '<td style="text-align:center;">'; if (typeof ContractHealthScore !== 'undefined') { var pCk = (r.target_scope && r.target_scope.contract_key) || ''; var pHs = pCk ? ContractHealthScore._scores[pCk] : null; if (pHs) { patchHealthHtml += '<span style="padding:2px 6px;border-radius:10px;font-size:0.85em;background:' + pHs.band.bg + ';color:' + pHs.band.color + ';font-weight:600;">' + pHs.score + '</span>'; } else { patchHealthHtml += '<span style="color:#ccc;">-</span>'; } } else { patchHealthHtml += '<span style="color:#ccc;">-</span>'; } patchHealthHtml += '</td>'; return patchHealthHtml; })() +
          '</tr>';
      }).join('');
    }
    
    function getStatusClass(status) {
      var classMap = {
        'Draft': 'draft',
        'Submitted': 'submitted',
        'Needs_Clarification': 'submitted',
        'Verifier_Responded': 'submitted',
        'Verifier_Approved': 'approved',
        'Admin_Hold': 'submitted',
        'Admin_Approved': 'approved',
        'Sent_to_Kiwi': 'sent',
        'Kiwi_Returned': 'returned',
        'Applied': 'applied',
        'Rejected': 'rejected',
        'Cancelled': 'rejected'
      };
      return classMap[status] || 'draft';
    }
    
    function toggleSelectAllPatches(checked) {
      var requests = getPatchRequestsByQueue(currentPatchQueue);
      if (checked) {
        requests.forEach(function(r) { selectPatchRequest(r.request_id); });
      } else {
        requests.forEach(function(r) { deselectPatchRequest(r.request_id); });
      }
      renderPatchConsoleTable();
    }
    
    function selectAllCurrentQueue() {
      selectAllInQueue(currentPatchQueue);
      renderPatchConsoleTable();
    }
    
    function batchMarkSentToKiwi() {
      var selected = getSelectedPatchRequests();
      if (selected.length === 0) {
        showToast('No requests selected', 'warning');
        return;
      }
      
      var approvedOnly = selected.filter(function(r) {
        return r.status === 'Verifier_Approved' || r.status === 'Admin_Approved';
      });
      
      if (approvedOnly.length === 0) {
        showToast('Selected requests must be Approved to send to Kiwi', 'warning');
        return;
      }
      
      var exportJson = exportPatchRequestsForKiwi(approvedOnly.map(function(r) { return r.request_id; }));
      navigator.clipboard.writeText(exportJson).then(function() {
        markSentToKiwi(approvedOnly.map(function(r) { return r.request_id; }), 'Admin', 'Admin');
        clearPatchRequestSelection();
        renderPatchConsoleTable();
        showToast('Exported ' + approvedOnly.length + ' requests to clipboard and marked as Sent to Kiwi', 'success');
      });
    }
    
    function openKiwiReturnInbox() {
      document.getElementById('kiwi-return-inbox-modal').style.display = 'flex';
      document.getElementById('kiwi-return-textarea').value = '';
      document.getElementById('kiwi-return-status').style.display = 'none';
    }
    
    function closeKiwiReturnInbox() {
      document.getElementById('kiwi-return-inbox-modal').style.display = 'none';
    }
    
    function processKiwiReturn() {
      var textarea = document.getElementById('kiwi-return-textarea');
      var statusEl = document.getElementById('kiwi-return-status');
      var text = textarea.value.trim();
      
      if (!text) {
        statusEl.textContent = 'Please paste Kiwi return JSON';
        statusEl.style.display = 'block';
        statusEl.style.background = '#ffebee';
        statusEl.style.color = '#c62828';
        return;
      }
      
      try {
        var data = JSON.parse(text);
        var items = data.items || data.requests || (Array.isArray(data) ? data : [data]);
        var matched = 0;
        var notFound = 0;
        
        items.forEach(function(item) {
          var requestId = item.request_id;
          if (requestId) {
            var result = applyKiwiReturn(requestId, item, 'Admin', 'Admin');
            if (result) matched++;
            else notFound++;
          }
        });
        
        statusEl.textContent = 'Processed: ' + matched + ' matched, ' + notFound + ' not found';
        statusEl.style.display = 'block';
        statusEl.style.background = matched > 0 ? '#e8f5e9' : '#fff3e0';
        statusEl.style.color = matched > 0 ? '#2e7d32' : '#e65100';
        
        if (matched > 0) {
          renderPatchConsoleTable();
          setTimeout(function() { closeKiwiReturnInbox(); }, 1500);
        }
      } catch (e) {
        statusEl.textContent = 'Invalid JSON: ' + e.message;
        statusEl.style.display = 'block';
        statusEl.style.background = '#ffebee';
        statusEl.style.color = '#c62828';
      }
    }
    
    function batchMarkApplied() {
      var selected = getSelectedPatchRequests();
      if (selected.length === 0) {
        showToast('No requests selected', 'warning');
        return;
      }
      
      var returnedOnly = selected.filter(function(r) { return r.status === 'Kiwi_Returned'; });
      if (returnedOnly.length === 0) {
        showToast('Selected requests must be in Kiwi Returned status', 'warning');
        return;
      }
      
      markApplied(returnedOnly.map(function(r) { return r.request_id; }), 'Admin', 'Admin');
      clearPatchRequestSelection();
      renderPatchConsoleTable();
      showToast('Marked ' + returnedOnly.length + ' requests as Applied', 'success');
    }
    
    function batchCopyCommitPack() {
      var selected = getSelectedPatchRequests();
      if (selected.length === 0) {
        showToast('No requests selected', 'warning');
        return;
      }
      
      var returnedOnly = selected.filter(function(r) { return r.status === 'Kiwi_Returned' && r.kiwi_return; });
      if (returnedOnly.length === 0) {
        showToast('Selected requests must have Kiwi returns', 'warning');
        return;
      }
      
      var commitPack = exportBatchCommitPack(returnedOnly.map(function(r) { return r.request_id; }));
      navigator.clipboard.writeText(commitPack).then(function() {
        showToast('Copied commit pack for ' + returnedOnly.length + ' requests', 'success');
      });
    }
    
    var currentPatchDetailId = null;
    
    function viewPatchRequestDetail(requestId) {
      var request = getPatchRequest(requestId);
      if (!request) return;
      
      currentPatchDetailId = requestId;
      var intent = request.proposed_change.intent;
      var statusClass = getStatusClass(request.status);
      
      var html = '';
      
      // Status and ID header
      html += '<div style="margin-bottom: 20px;">' +
        '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">' +
        '<span class="patch-status-chip ' + statusClass + '" style="font-size: 0.85em;">' + escapeHtml(request.status) + '</span>' +
        '<span style="font-family: monospace; font-size: 0.8em; color: #666;">' + escapeHtml(request.request_id) + '</span>' +
        '</div>' +
        '<div style="font-size: 0.85em; color: #666;">Created: ' + new Date(request.created_at_utc).toLocaleString() + '</div>' +
        '</div>';
      
      // Plain-English Intent section
      html += '<div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
        '<h4 style="margin: 0 0 12px 0; font-size: 0.9em; text-transform: uppercase; color: #333;">Plain-English Intent</h4>' +
        '<div style="margin-bottom: 10px;">' +
        '<span style="color: #1976d2; font-weight: 600;">WHEN:</span> ' + escapeHtml(intent.when || 'N/A') +
        '</div>' +
        '<div style="margin-bottom: 10px;">' +
        '<span style="color: #388e3c; font-weight: 600;">THEN:</span> ' + escapeHtml(intent.then || 'N/A') +
        '</div>' +
        '<div>' +
        '<span style="color: #e65100; font-weight: 600;">BECAUSE:</span> ' + escapeHtml(intent.because || 'N/A') +
        '</div>' +
        '</div>';
      
      // Target Artifact section
      html += '<div style="margin-bottom: 20px;">' +
        '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #333;">Target Artifact</h4>' +
        '<table style="width: 100%; font-size: 0.9em;">' +
        '<tr><td style="padding: 4px 0; color: #666; width: 100px;">Type</td><td>' + escapeHtml(humanLabel(request.target_scope.target) || 'N/A') + '</td></tr>' +
        '<tr><td style="padding: 4px 0; color: #666;">Target ID</td><td style="font-family: monospace;">' + escapeHtml(request.target_scope.target_id || 'N/A') + '</td></tr>' +
        '</table>' +
        '</div>';
      
      // Rationale
      if (request.proposed_change.rationale) {
        html += '<div style="margin-bottom: 20px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #333;">Rationale</h4>' +
          '<p style="margin: 0; font-size: 0.9em; color: #555;">' + escapeHtml(request.proposed_change.rationale) + '</p>' +
          '</div>';
      }
      
      // Kiwi Payload section (if sent or returned)
      if (request.status === 'Sent_to_Kiwi' || request.status === 'Kiwi_Returned' || request.status === 'Applied') {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #7b1fa2;">Kiwi Integration</h4>';
        
        if (request.kiwi_sent_at_utc) {
          html += '<div style="font-size: 0.85em; margin-bottom: 8px;"><strong>Sent to Kiwi:</strong> ' + new Date(request.kiwi_sent_at_utc).toLocaleString() + '</div>';
        }
        
        if (request.kiwi_return) {
          html += '<div style="font-size: 0.85em; margin-bottom: 8px;"><strong>Returned:</strong> ' + new Date(request.kiwi_returned_at_utc).toLocaleString() + '</div>' +
            '<div style="margin-top: 10px;">' +
            '<details style="background: #f9f9f9; padding: 10px; border-radius: 6px;">' +
            '<summary style="cursor: pointer; font-weight: 500; font-size: 0.9em;">View Kiwi Return Payload</summary>' +
            '<pre style="margin: 10px 0 0 0; font-size: 0.8em; overflow-x: auto; white-space: pre-wrap;">' + escapeHtml(JSON.stringify(request.kiwi_return, null, 2)) + '</pre>' +
            '</details>' +
            '</div>';
        }
        
        html += '</div>';
      }
      
      // Apply Checklist (for Kiwi_Returned status)
      if (request.status === 'Kiwi_Returned') {
        html += '<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
          '<h4 style="margin: 0 0 12px 0; font-size: 0.9em; text-transform: uppercase; color: #2e7d32;">Apply Checklist</h4>' +
          '<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; margin-bottom: 8px;">' +
          '<input type="checkbox" id="apply-check-1"> Kiwi return payload validated' +
          '</label>' +
          '<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; margin-bottom: 8px;">' +
          '<input type="checkbox" id="apply-check-2"> Changes copied to config pack' +
          '</label>' +
          '<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em;">' +
          '<input type="checkbox" id="apply-check-3"> Smoke test passed' +
          '</label>' +
          '</div>';
      }
      
      // Clarification questions section (if any)
      if (request.clarification_questions && request.clarification_questions.length > 0) {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #e65100;">Clarification Thread</h4>';
        request.clarification_questions.forEach(function(q) {
          if (typeof q === 'string') {
            html += '<div style="background: #fff3e0; padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 0.9em;">' + escapeHtml(q) + '</div>';
          } else if (q.type === 'response') {
            html += '<div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 0.9em;">' +
              '<strong>' + escapeHtml(q.from || 'Analyst') + ':</strong> ' + escapeHtml(q.text) + '</div>';
          } else {
            html += '<div style="background: #fff3e0; padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 0.9em;">' + escapeHtml(q.text || q) + '</div>';
          }
        });
        html += '</div>';
      }
      
      // Review notes section (editable for Verifier/Admin)
      if ((currentMode === 'Verifier' || currentMode === 'Admin') && 
          ['Submitted', 'Needs_Clarification', 'Verifier_Responded'].includes(request.status)) {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #1565c0;">Review Notes (Verifier)</h4>' +
          '<textarea id="pr-review-notes" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 60px;" placeholder="Add review notes...">' + escapeHtml(request.review_notes || '') + '</textarea>' +
          '</div>';
      }
      
      // Revisions section
      if (request.revisions && request.revisions.length > 0) {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<details>' +
          '<summary style="cursor: pointer; font-weight: 600; font-size: 0.9em; color: #333;">Revisions (' + request.revisions.length + ')</summary>' +
          '<div style="margin-top: 10px; font-size: 0.85em;">';
        request.revisions.forEach(function(rev) {
          html += '<div style="background: #f9f9f9; padding: 8px; border-radius: 4px; margin-bottom: 6px;">' +
            '<div style="color: #666;">' + new Date(rev.at_utc).toLocaleString() + ' by ' + escapeHtml(rev.actor) + ' (' + escapeHtml(rev.role) + ')</div>' +
            '<div style="color: #333;">' + escapeHtml(rev.diff_summary) + '</div>' +
            '</div>';
        });
        html += '</div></details></div>';
      }
      
      document.getElementById('patch-detail-title').textContent = 'Patch Request';
      document.getElementById('patch-detail-content').innerHTML = html;
      
      // Footer actions based on status and role
      var role = currentMode || 'Analyst';
      var footerHtml = '<div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end;">';
      
      // Analyst actions
      if (role === 'Analyst') {
        if (request.status === 'Draft') {
          footerHtml += '<button class="toolbar-btn" onclick="submitPatchForReview(\'' + requestId + '\')" style="background: #1976d2;" title="Submit this patch request for review">Submit for Review</button>';
        } else if (request.status === 'Needs_Clarification') {
          footerHtml += '<button class="toolbar-btn" onclick="openClarificationResponseModal(\'' + requestId + '\')" style="background: #e65100;" title="Respond to clarification request">Respond to Clarification</button>';
        }
        if (['Draft', 'Submitted'].includes(request.status)) {
          footerHtml += '<button class="toolbar-btn" onclick="cancelPatchRequest(\'' + requestId + '\')" style="background: #c62828;" title="Cancel this patch request">Cancel</button>';
        }
      }
      
      // Verifier actions
      if (role === 'Verifier' || role === 'Admin') {
        if (request.status === 'Submitted') {
          footerHtml += '<button class="toolbar-btn" onclick="openClarificationModal(\'' + requestId + '\')" style="background: #e65100;" title="Request more information from the analyst">Request Clarification</button>';
          footerHtml += '<button class="toolbar-btn" onclick="approveAsVerifier(\'' + requestId + '\')" style="background: #388e3c;" title="Approve this patch request">Approve</button>';
          footerHtml += '<button class="toolbar-btn" onclick="rejectPatchRequest(\'' + requestId + '\')" style="background: #c62828;" title="Reject this patch request">Reject</button>';
        } else if (request.status === 'Verifier_Responded') {
          footerHtml += '<button class="toolbar-btn" onclick="approveAsVerifier(\'' + requestId + '\')" style="background: #388e3c;" title="Approve this patch request">Approve</button>';
          footerHtml += '<button class="toolbar-btn" onclick="rejectPatchRequest(\'' + requestId + '\')" style="background: #c62828;" title="Reject this patch request">Reject</button>';
        }
      }
      
      // Admin-only actions
      if (role === 'Admin') {
        if (request.status === 'Verifier_Approved') {
          footerHtml += '<button class="toolbar-btn" onclick="adminApprovePatch(\'' + requestId + '\')" style="background: #1565c0;" title="Give admin approval">Admin Approve</button>';
          footerHtml += '<button class="toolbar-btn" onclick="setAdminHoldPatch(\'' + requestId + '\')" style="background: #f57c00;" title="Put on hold for review">Admin Hold</button>';
        } else if (request.status === 'Admin_Hold') {
          footerHtml += '<button class="toolbar-btn" onclick="releaseAdminHoldPatch(\'' + requestId + '\')" style="background: #1565c0;" title="Release from admin hold">Release Hold</button>';
        } else if (request.status === 'Admin_Approved') {
          footerHtml += '<button class="toolbar-btn" onclick="exportToKiwi(\'' + requestId + '\')" style="background: #7b1fa2;" title="Export to Kiwi and mark as sent">Export to Kiwi</button>';
        } else if (request.status === 'Sent_to_Kiwi') {
          footerHtml += '<button class="toolbar-btn" onclick="openPasteKiwiReturnModal(\'' + requestId + '\')" style="background: #7b1fa2;" title="Paste Kiwi return payload">Paste Kiwi Return</button>';
        } else if (request.status === 'Kiwi_Returned') {
          footerHtml += '<button class="toolbar-btn" onclick="copyCommitPack(\'' + requestId + '\')" title="Copy commit pack to clipboard">Copy Commit Pack</button>';
          footerHtml += '<button class="toolbar-btn" onclick="markSingleApplied(\'' + requestId + '\')" style="background: #388e3c;" title="Mark as applied">Mark Applied</button>';
        }
      }
      
      footerHtml += '<button class="toolbar-btn" onclick="closePatchDetailDrawer()">Close</button>';
      footerHtml += '</div>';
      document.getElementById('patch-detail-footer').innerHTML = footerHtml;
      
      document.getElementById('patch-detail-drawer').classList.add('active');
    }
    
    function closePatchDetailDrawer() {
      document.getElementById('patch-detail-drawer').classList.remove('active');
      currentPatchDetailId = null;
    }
    
    function submitPatchForReview(requestId) {
      var author = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      submitForReview(requestId, author, author);
      closePatchDetailDrawer();
      renderPatchConsoleTable();
      showToast('Patch request submitted for review', 'success');
    }
    
    function copyPatchForKiwi(requestId) {
      var exportJson = exportPatchRequestsForKiwi([requestId]);
      navigator.clipboard.writeText(exportJson).then(function() {
        showToast('Copied patch request to clipboard for Kiwi', 'success');
      });
    }
    
    function copyCommitPack(requestId) {
      var commitPack = exportBatchCommitPack([requestId]);
      navigator.clipboard.writeText(commitPack).then(function() {
        showToast('Commit pack copied to clipboard', 'success');
      });
    }
    
    function markSingleApplied(requestId) {
      var author = currentMode || 'Admin';
      markApplied([requestId], author, author);
      closePatchDetailDrawer();
      renderPatchConsoleTable();
      showToast('Marked as Applied', 'success');
    }
    
    function cancelPatchRequest(requestId) {
      var author = currentMode || 'Analyst';
      var result = updatePatchRequestStatus(requestId, 'Cancelled', author, author, 'Cancelled by ' + author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Patch request cancelled', 'success');
      } else {
        showToast('Failed to cancel patch request', 'error');
      }
    }
    
    function approveAsVerifier(requestId) {
      var author = currentMode || 'Verifier';
      var reviewNotes = (document.getElementById('pr-review-notes') || {}).value || '';

      // v1.6.57: No self-approval check
      var pr = getPatchRequest(requestId);
      if (pr && isSelfApproval(pr)) {
        showToast('Self-approval is not permitted. A different verifier must approve.', 'error');
        return;
      }

      if (!getChecklistConfirmation('verifier', requestId)) {
        if (!confirm('Review Checklist not yet completed for this patch.\n\nBy clicking OK, you confirm you have reviewed:\n- Intent Clarity\n- Schema Correctness\n- Preview Validity\n- Conflict Assessment\n- Evidence Pack\n- Smoke Verification\n\nProceed with approval?')) {
          return;
        }
        saveChecklistConfirmation('verifier', requestId);
      }
      
      var request = getPatchRequest(requestId);
      if (reviewNotes && request) {
        updatePatchRequest(requestId, { review_notes: reviewNotes }, author, author);
      }
      
      var result = verifierApprove(requestId, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Patch request approved by verifier', 'success');
      } else {
        showToast('Failed to approve patch request', 'error');
      }
    }
    
    function rejectPatchRequest(requestId) {
      var reason = prompt('Enter rejection reason:');
      if (!reason) return;
      
      var author = currentMode || 'Verifier';
      var result = markRejected(requestId, reason, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Patch request rejected', 'success');
      } else {
        showToast('Failed to reject patch request', 'error');
      }
    }
    
    function openClarificationModal(requestId) {
      var questions = prompt('Enter clarification questions:');
      if (!questions) return;
      
      var author = currentMode || 'Verifier';
      var result = requestClarification(requestId, [questions], author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Clarification requested', 'success');
      } else {
        showToast('Failed to request clarification', 'error');
      }
    }
    
    function openClarificationResponseModal(requestId) {
      var response = prompt('Enter your response to the clarification request:');
      if (!response) return;
      
      var author = currentMode || 'Analyst';
      var result = respondToClarification(requestId, response, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Clarification response submitted', 'success');
      } else {
        showToast('Failed to submit response', 'error');
      }
    }
    
    function adminApprovePatch(requestId) {
      var author = currentMode || 'Admin';

      if (!getChecklistConfirmation('admin', requestId)) {
        if (!confirm('Admin Review Checklist not yet completed for this patch.\n\nBy clicking OK, you confirm you have reviewed:\n- Verifier approval validity\n- Downstream risk\n- Versioning and changelog\n- Smoke (Strict) verification\n\nProceed with admin approval?')) {
          return;
        }
        saveChecklistConfirmation('admin', requestId);
      }

      var result = adminApprove(requestId, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Admin approval granted', 'success');
      } else {
        showToast('Failed to grant admin approval', 'error');
      }
    }
    
    function setAdminHoldPatch(requestId) {
      var reason = prompt('Enter reason for admin hold:') || 'Placed on hold for further review';
      var author = currentMode || 'Admin';
      var result = setAdminHold(requestId, reason, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Placed on admin hold', 'success');
      } else {
        showToast('Failed to set admin hold', 'error');
      }
    }
    
    function releaseAdminHoldPatch(requestId) {
      var author = currentMode || 'Admin';
      var result = releaseAdminHold(requestId, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Released from admin hold', 'success');
      } else {
        showToast('Failed to release admin hold', 'error');
      }
    }
    
    function exportToKiwi(requestId) {
      var author = currentMode || 'Admin';
      var exportJson = exportPatchRequestsForKiwi([requestId]);
      navigator.clipboard.writeText(exportJson).then(function() {
        markSentToKiwi([requestId], author, author);
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Exported to Kiwi and copied to clipboard', 'success');
      });
    }
    
    function openPasteKiwiReturnModal(requestId) {
      var payloadStr = prompt('Paste Kiwi return JSON payload:');
      if (!payloadStr) return;
      
      try {
        var payload = JSON.parse(payloadStr);
        var author = currentMode || 'Admin';
        var result = applyKiwiReturn(requestId, payload, author, author);
        if (result) {
          closePatchDetailDrawer();
          renderPatchConsoleTable();
          showToast('Kiwi return applied', 'success');
        } else {
          showToast('Failed to apply Kiwi return', 'error');
        }
      } catch (e) {
        showToast('Invalid JSON payload', 'error');
      }
    }
    
    // Initialize patch console when admin view loads
    function initPatchConsole() {
      renderPatchConsoleTable();
      updatePatchQueueCounts();
    }
    
    // ========== COMMENT UI FUNCTIONS ==========
    function openAddCommentModal(targetType, targetId) {
      document.getElementById('comment-target-type').value = targetType;
      document.getElementById('comment-target-id').value = targetId;
      document.getElementById('comment-target-display').textContent = targetType + ': ' + targetId;
      document.getElementById('comment-content-input').value = '';
      document.getElementById('add-comment-modal').style.display = 'flex';
    }
    
    function closeAddCommentModal() {
      document.getElementById('add-comment-modal').style.display = 'none';
    }
    
    function submitNewComment() {
      var targetType = document.getElementById('comment-target-type').value;
      var targetId = document.getElementById('comment-target-id').value;
      var content = document.getElementById('comment-content-input').value.trim();
      
      if (!content) {
        showToast('Please enter a comment', 'warning');
        return;
      }
      
      var author = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      createComment(targetType, targetId, content, author, author);
      closeAddCommentModal();
      showToast('Comment added', 'success');
      
      // Refresh the drawer if it's a record comment
      if (targetType === 'record') {
        renderRecordDrawer();
      }
      updatePatchQueueCounts();
    }
    
    function resolveCommentById(commentId) {
      var author = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      resolveComment(commentId, author, author);
      renderRecordDrawer();
      updatePatchQueueCounts();
      showToast('Comment resolved', 'success');
    }
    
    function elevateCommentToPatchRequest(commentId) {
      var comment = getComment(commentId);
      if (!comment) return;
      
      document.getElementById('elevate-comment-id').value = commentId;
      document.getElementById('elevate-comment-preview').innerHTML = 
        '<strong>Original Comment:</strong> ' + escapeHtml(comment.content) + 
        '<br><span style="font-size: 0.85em; color: #666;">Target: ' + comment.target_type + ' / ' + escapeHtml(comment.target_id) + '</span>';
      document.getElementById('elevate-intent-when').value = '';
      document.getElementById('elevate-intent-then').value = '';
      document.getElementById('elevate-intent-because').value = '';
      document.getElementById('elevate-to-patch-modal').style.display = 'flex';
    }
    
    function closeElevateToPatchModal() {
      document.getElementById('elevate-to-patch-modal').style.display = 'none';
    }
    
    function submitElevateToPatch() {
      var commentId = document.getElementById('elevate-comment-id').value;
      var comment = getComment(commentId);
      if (!comment) return;
      
      var intentWhen = document.getElementById('elevate-intent-when').value.trim();
      var intentThen = document.getElementById('elevate-intent-then').value.trim();
      var intentBecause = document.getElementById('elevate-intent-because').value.trim();
      
      if (!intentThen) {
        showToast('Please fill in the THEN (action) field', 'warning');
        return;
      }
      
      var author = getCurrentUserName();
      
      var patchRequest = createPatchRequest({
        target: comment.target_type,
        contract_key: comment.record_identity.contract_key,
        file_url: comment.record_identity.file_url,
        file_name: comment.record_identity.file_name,
        when: intentWhen || 'N/A',
        then: intentThen,
        because: intentBecause || comment.content,
        rationale: 'Elevated from comment: ' + comment.content,
        author: author,
        author_role: author,
        linked_comment_id: commentId
      });
      elevateToRequest(commentId, patchRequest.request_id, author, author);
      
      closeElevateToPatchModal();
      renderRecordDrawer();
      renderPatchConsoleTable();
      showToast('Created Patch Request from comment', 'success');
    }
    
    // ========== SCHEMA TREE EDITOR ==========
    var SchemaTreeEditor = {
      _sources: {},
      _tree: null,
      _changeBuffer: [],
      _draftKey: 'schema_editor_draft',
      _loaded: false,
      _renderedNodes: {},
      _expandedNodes: {},

      init: function() {
        var self = this;
        var files = [
          { key: 'field_meta', url: '/rules/rules_bundle/field_meta.json' },
          { key: 'sheet_order', url: '/rules/rules_bundle/sheet_order.json' },
          { key: 'hinge_groups', url: '/rules/rules_bundle/hinge_groups.json' },
          { key: 'qa_flags', url: '/rules/rules_bundle/qa_flags.json' },
          { key: 'column_aliases', url: '/rules/rules_bundle/column_aliases.json' },
          { key: 'sheet_aliases', url: '/rules/rules_bundle/sheet_aliases.json' }
        ];
        var promises = files.map(function(f) { return self._loadSource(f.key, f.url); });
        return Promise.all(promises).then(function() {
          self._loaded = true;
          self._buildTree();
          self._renderTree();
          self.loadDraft();
          self._updateStatusBar();
          console.log('[SchemaTreeEditor] Initialized with ' + Object.keys(self._sources).length + ' sources');
        }).catch(function(err) {
          console.error('[SchemaTreeEditor] Init failed:', err);
        });
      },

      _loadSource: function(key, url) {
        var self = this;
        return fetch(url).then(function(res) { return res.json(); }).then(function(data) {
          self._sources[key] = data;
        }).catch(function(err) {
          console.warn('[SchemaTreeEditor] Failed to load ' + key + ':', err);
          self._sources[key] = null;
        });
      },

      _buildTree: function() {
        var self = this;
        var tree = { id: 'root', label: 'Schema', children: [], type: 'root' };
        var sheetOrder = [];
        if (self._sources.sheet_order && self._sources.sheet_order.order) {
          sheetOrder = self._sources.sheet_order.order.sort(function(a, b) { return a.order - b.order; });
        }
        sheetOrder.forEach(function(so) {
          var sheetNode = {
            id: 'sheet_' + so.sheet,
            label: so.sheet,
            type: 'sheet',
            sheet: so.sheet,
            order: so.order,
            children: [],
            _childrenBuilt: false
          };
          tree.children.push(sheetNode);
        });
        var docTypes = [];
        try { docTypes = JSON.parse(JSON.stringify(self._sources.sheet_aliases || {})); } catch(e) {}
        tree.children.push({
          id: 'meta_doctypes',
          label: 'Document Types',
          type: 'meta',
          children: [],
          _childrenBuilt: false
        });
        tree.children.push({
          id: 'meta_aliases',
          label: 'Column Aliases (Global)',
          type: 'meta',
          children: [],
          _childrenBuilt: false
        });
        tree.children.push({
          id: 'meta_qa_flags',
          label: 'QA Flags (Global)',
          type: 'meta',
          children: [],
          _childrenBuilt: false
        });
        var unknownCols = {};
        try { unknownCols = JSON.parse(localStorage.getItem('unknown_columns') || '{}'); } catch(e) {}
        var hasUnknown = Object.keys(unknownCols).some(function(k) { return unknownCols[k] && unknownCols[k].length > 0; });
        if (hasUnknown) {
          tree.children.push({
            id: 'meta_unknown',
            label: 'Unassigned / Pending Columns',
            type: 'unknown_root',
            children: [],
            _childrenBuilt: false
          });
        }
        self._tree = tree;
      },

      _buildSheetChildren: function(sheetNode) {
        var self = this;
        var sheet = sheetNode.sheet;
        var children = [];
        if (self._sources.field_meta && self._sources.field_meta.fields) {
          var fields = self._sources.field_meta.fields.filter(function(f) { return f.sheet === sheet; });
          fields.forEach(function(f) {
            children.push({
              id: 'field_' + sheet + '_' + f.field_key,
              label: f.field_label || f.field_key,
              type: 'field',
              sheet: sheet,
              field_key: f.field_key,
              field_label: f.field_label,
              return_format: f.return_format || '',
              requiredness: f.requiredness || '',
              children: [],
              _childrenBuilt: true
            });
          });
        }
        if (self._sources.hinge_groups && self._sources.hinge_groups.hinges) {
          var hinges = self._sources.hinge_groups.hinges.filter(function(h) { return h.sheet === sheet; });
          if (hinges.length > 0) {
            var hingeGroup = {
              id: 'hinge_group_' + sheet,
              label: 'Hinge Groups (' + hinges.length + ')',
              type: 'hinge_group',
              sheet: sheet,
              children: [],
              _childrenBuilt: true
            };
            hinges.forEach(function(h) {
              hingeGroup.children.push({
                id: 'hinge_' + sheet + '_' + h.field_key,
                label: h.field_key + ' [' + h.hinge_level + ']',
                type: 'hinge',
                sheet: sheet,
                data: h,
                children: [],
                _childrenBuilt: true
              });
            });
            children.push(hingeGroup);
          }
        }
        if (self._sources.column_aliases && self._sources.column_aliases.aliases) {
          var aliases = self._sources.column_aliases.aliases.filter(function(a) { return a.sheet === sheet; });
          if (aliases.length > 0) {
            var aliasGroup = {
              id: 'alias_group_' + sheet,
              label: 'Column Aliases (' + aliases.length + ')',
              type: 'alias_group',
              sheet: sheet,
              children: [],
              _childrenBuilt: true
            };
            aliases.forEach(function(a) {
              aliasGroup.children.push({
                id: 'alias_' + sheet + '_' + a.canonical_key,
                label: a.canonical_key,
                type: 'alias',
                sheet: sheet,
                canonical_key: a.canonical_key,
                aliases: a.aliases || [],
                children: [],
                _childrenBuilt: true
              });
            });
            children.push(aliasGroup);
          }
        }
        var unknownCols = {};
        try { unknownCols = JSON.parse(localStorage.getItem('unknown_columns') || '{}'); } catch(e) {}
        var pending = unknownCols[sheet] || [];
        if (pending.length > 0) {
          pending.forEach(function(col) {
            children.push({
              id: 'pending_' + sheet + '_' + (col.column || col),
              label: typeof col === 'string' ? col : col.column,
              type: 'pending',
              sheet: sheet,
              children: [],
              _childrenBuilt: true
            });
          });
        }
        sheetNode.children = children;
        sheetNode._childrenBuilt = true;
      },

      _buildMetaChildren: function(node) {
        var self = this;
        if (node.id === 'meta_doctypes') {
          var types = [];
          try { types = JSON.parse(JSON.stringify(require || [])); } catch(e) {}
          try {
            fetch('/config/document_types.json').then(function(r) { return r.json(); }).then(function(d) {
              if (Array.isArray(d)) {
                node.children = d.map(function(dt, i) {
                  return { id: 'doctype_' + i, label: dt, type: 'document_type', children: [], _childrenBuilt: true };
                });
                node._childrenBuilt = true;
                self._renderNodeChildren(node);
              }
            });
          } catch(e) {}
          node._childrenBuilt = true;
        } else if (node.id === 'meta_aliases') {
          if (self._sources.column_aliases && self._sources.column_aliases.aliases) {
            node.children = self._sources.column_aliases.aliases.map(function(a) {
              return {
                id: 'galias_' + a.canonical_key + '_' + a.sheet,
                label: a.canonical_key + ' (' + a.sheet + ')',
                type: 'alias',
                sheet: a.sheet,
                canonical_key: a.canonical_key,
                aliases: a.aliases || [],
                children: [],
                _childrenBuilt: true
              };
            });
          }
          node._childrenBuilt = true;
        } else if (node.id === 'meta_qa_flags') {
          if (self._sources.qa_flags && self._sources.qa_flags.flags) {
            node.children = self._sources.qa_flags.flags.map(function(f) {
              return {
                id: 'qaflag_' + f.flag_id,
                label: f.flag_id + ' [' + f.flag_level + ']',
                type: 'qa_flag',
                data: f,
                children: [],
                _childrenBuilt: true
              };
            });
          }
          node._childrenBuilt = true;
        } else if (node.id === 'meta_unknown') {
          var unknownCols = {};
          try { unknownCols = JSON.parse(localStorage.getItem('unknown_columns') || '{}'); } catch(e) {}
          var children = [];
          Object.keys(unknownCols).forEach(function(sheetKey) {
            (unknownCols[sheetKey] || []).forEach(function(col) {
              var colName = typeof col === 'string' ? col : col.column;
              children.push({
                id: 'unk_' + sheetKey + '_' + colName,
                label: colName + ' (from: ' + sheetKey + ')',
                type: 'pending',
                sheet: sheetKey,
                children: [],
                _childrenBuilt: true
              });
            });
          });
          node.children = children;
          node._childrenBuilt = true;
        }
      },

      _renderTree: function() {
        var self = this;
        var container = document.getElementById('schema-tree-container');
        if (!container || !self._tree) return;
        container.innerHTML = '';
        self._renderedNodes = {};
        self._tree.children.forEach(function(child) {
          self._renderNode(child, 0, container);
        });
      },

      _renderNode: function(node, depth, parentEl) {
        var self = this;
        var row = document.createElement('div');
        row.id = 'stnode_' + node.id;
        row.setAttribute('data-node-id', node.id);
        row.setAttribute('data-depth', depth);
        var isPending = node.type === 'pending';
        var baseStyle = 'display:flex; align-items:center; padding:4px 0; cursor:pointer; border-bottom:1px solid #f0f0f0; padding-left:' + (depth * 20) + 'px;';
        if (isPending) baseStyle += ' background:#fff8e1; border-left:3px solid #ffa000;';
        row.style.cssText = baseStyle;
        var hasChildren = node.children && node.children.length > 0 || !node._childrenBuilt;
        var arrowSpan = document.createElement('span');
        arrowSpan.style.cssText = 'width:20px; text-align:center; color:#999; font-size:0.9em; flex-shrink:0;';
        arrowSpan.className = 'schema-tree-arrow';
        if (hasChildren) {
          arrowSpan.textContent = self._expandedNodes[node.id] ? '\u25BC' : '\u25B6';
          arrowSpan.onclick = function(e) {
            e.stopPropagation();
            if (self._expandedNodes[node.id]) {
              self._collapseNode(node.id);
            } else {
              self._expandNode(node.id, node, depth, parentEl);
            }
          };
        } else {
          arrowSpan.textContent = ' ';
        }
        row.appendChild(arrowSpan);
        var iconSpan = document.createElement('span');
        iconSpan.style.cssText = 'margin-right:6px; font-size:0.9em;';
        var icons = { sheet: '\uD83D\uDCC4', field: '\uD83D\uDD11', alias: '\uD83C\uDFF7\uFE0F', alias_group: '\uD83C\uDFF7\uFE0F', qa_flag: '\u26A0\uFE0F', document_type: '\uD83D\uDCCB', hinge: '\uD83D\uDD17', hinge_group: '\uD83D\uDD17', pending: '\u2753', meta: '\uD83D\uDCC2', unknown_root: '\uD83D\uDCC2', root: '' };
        iconSpan.textContent = icons[node.type] || '';
        row.appendChild(iconSpan);
        var labelSpan = document.createElement('span');
        labelSpan.style.cssText = 'flex:1; font-size:0.88em; color:#333;';
        labelSpan.textContent = node.label;
        row.appendChild(labelSpan);
        if (node.type === 'field') {
          var chipArea = document.createElement('span');
          chipArea.style.cssText = 'display:flex; gap:2px; align-items:center; flex-shrink:0;';
          if (node.field_key) {
            var ck = document.createElement('span');
            ck.style.cssText = 'display:inline-block; padding:1px 6px; border-radius:10px; font-size:0.75em; margin-left:4px; background:#e3f2fd; color:#1565c0;';
            ck.textContent = node.field_key;
            chipArea.appendChild(ck);
          }
          if (node.return_format) {
            var rf = document.createElement('span');
            rf.style.cssText = 'display:inline-block; padding:1px 6px; border-radius:10px; font-size:0.75em; margin-left:4px; background:#f3e5f5; color:#7b1fa2;';
            rf.textContent = node.return_format;
            chipArea.appendChild(rf);
          }
          if (node.requiredness) {
            var rq = document.createElement('span');
            var reqColors = { required: 'background:#ffebee; color:#c62828;', optional: 'background:#fff8e1; color:#f57f17;', not_needed: 'background:#eceff1; color:#546e7a;' };
            rq.style.cssText = 'display:inline-block; padding:1px 6px; border-radius:10px; font-size:0.75em; margin-left:4px;' + (reqColors[node.requiredness] || 'background:#eceff1; color:#546e7a;');
            rq.textContent = node.requiredness;
            chipArea.appendChild(rq);
          }
          row.appendChild(chipArea);
        }
        if (node.type === 'alias') {
          var aliasList = document.createElement('span');
          aliasList.style.cssText = 'font-size:0.75em; color:#888; margin-left:8px;';
          aliasList.textContent = '\u2192 ' + (node.aliases || []).join(', ');
          row.appendChild(aliasList);
        }
        if (node.type === 'pending') {
          var actions = document.createElement('span');
          actions.style.cssText = 'display:flex; gap:4px; margin-left:8px; flex-shrink:0;';
          actions.innerHTML = '<button onclick="schemaTreeMapAlias(\'' + self._escAttr(node.id) + '\')" style="font-size:0.7em; padding:2px 6px; border:1px solid #1976d2; background:white; color:#1976d2; border-radius:4px; cursor:pointer;">Map to Existing</button>' +
            '<button onclick="schemaTreeAddField(\'' + self._escAttr(node.id) + '\')" style="font-size:0.7em; padding:2px 6px; border:1px solid #388e3c; background:white; color:#388e3c; border-radius:4px; cursor:pointer;">Add as New Field</button>' +
            '<button onclick="schemaTreeAddTenantRule(\'' + self._escAttr(node.id) + '\')" style="font-size:0.7em; padding:2px 6px; border:1px solid #f57c00; background:white; color:#f57c00; border-radius:4px; cursor:pointer;">Create Tenant Rule</button>' +
            '<button onclick="schemaTreeIgnore(\'' + self._escAttr(node.id) + '\')" style="font-size:0.7em; padding:2px 6px; border:1px solid #999; background:white; color:#999; border-radius:4px; cursor:pointer;">Ignore</button>';
          row.appendChild(actions);
        }
        if (node.type === 'field' || node.type === 'alias') {
          var editBtn = document.createElement('span');
          editBtn.style.cssText = 'cursor:pointer; font-size:0.8em; margin-left:6px; color:#999;';
          editBtn.textContent = '\u270E';
          editBtn.title = 'Edit';
          editBtn.onclick = function(e) { e.stopPropagation(); schemaTreeEditNode(node.id); };
          row.appendChild(editBtn);
        }
        parentEl.appendChild(row);
        self._renderedNodes[node.id] = { node: node, element: row, depth: depth, parentEl: parentEl };
        if (self._expandedNodes[node.id]) {
          self._expandNode(node.id, node, depth, parentEl);
        }
      },

      _escAttr: function(s) { return String(s).replace(/'/g, "\\'").replace(/"/g, '&quot;'); },

      _expandNode: function(nodeId, node, depth, parentEl) {
        var self = this;
        if (!node) {
          var info = self._renderedNodes[nodeId];
          if (!info) return;
          node = info.node;
          depth = info.depth;
          parentEl = info.parentEl;
        }
        if (!node._childrenBuilt) {
          if (node.type === 'sheet') {
            self._buildSheetChildren(node);
          } else {
            self._buildMetaChildren(node);
          }
        }
        self._expandedNodes[nodeId] = true;
        var arrow = document.querySelector('#stnode_' + CSS.escape(nodeId) + ' .schema-tree-arrow');
        if (arrow) arrow.textContent = '\u25BC';
        var childContainerId = 'stchildren_' + nodeId;
        var existing = document.getElementById(childContainerId);
        if (existing) {
          existing.style.display = '';
          return;
        }
        var childContainer = document.createElement('div');
        childContainer.id = childContainerId;
        var nodeRow = document.getElementById('stnode_' + CSS.escape(nodeId));
        if (nodeRow && nodeRow.nextSibling) {
          parentEl.insertBefore(childContainer, nodeRow.nextSibling);
        } else {
          parentEl.appendChild(childContainer);
        }
        (node.children || []).forEach(function(child) {
          self._renderNode(child, depth + 1, childContainer);
        });
      },

      _collapseNode: function(nodeId) {
        var self = this;
        self._expandedNodes[nodeId] = false;
        var arrow = document.querySelector('#stnode_' + CSS.escape(nodeId) + ' .schema-tree-arrow');
        if (arrow) arrow.textContent = '\u25B6';
        var childContainer = document.getElementById('stchildren_' + nodeId);
        if (childContainer) childContainer.style.display = 'none';
      },

      _renderNodeChildren: function(node) {
        var self = this;
        if (!self._expandedNodes[node.id]) return;
        var childContainer = document.getElementById('stchildren_' + node.id);
        if (!childContainer) return;
        var info = self._renderedNodes[node.id];
        if (!info) return;
        childContainer.innerHTML = '';
        (node.children || []).forEach(function(child) {
          self._renderNode(child, info.depth + 1, childContainer);
        });
      },

      _findNode: function(nodeId, parent) {
        var self = this;
        parent = parent || self._tree;
        if (parent.id === nodeId) return parent;
        if (parent.children) {
          for (var i = 0; i < parent.children.length; i++) {
            var found = self._findNode(nodeId, parent.children[i]);
            if (found) return found;
          }
        }
        return null;
      },

      _emitChange: function(subtype, path, action, oldVal, newVal) {
        var self = this;
        var change = {
          id: 'chg_' + Date.now(),
          path: path,
          action: action,
          oldVal: oldVal,
          newVal: newVal,
          timestamp: new Date().toISOString()
        };
        self._changeBuffer.push(change);
        self._updateStatusBar();
        try {
          var actor = typeof getCurrentUserName === 'function' ? getCurrentUserName() : 'unknown';
          AuditTimeline.emit('SCHEMA_CHANGE', {
            dataset_id: IDENTITY_CONTEXT.dataset_id || '',
            metadata: {
              subtype: subtype,
              path: path,
              action: action,
              actor: actor
            }
          });
        } catch(e) { console.warn('[SchemaTreeEditor] AuditTimeline emit failed:', e); }
        return change;
      },

      addAlias: function(canonicalKey, sheet, newAlias) {
        var path = 'column_aliases/' + sheet + '/' + canonicalKey;
        this._emitChange('alias_patch', path, 'add_alias', null, newAlias);
        if (typeof showToast === 'function') showToast('Alias "' + newAlias + '" added to ' + canonicalKey, 'success');
      },

      addCanonicalField: function(sheet, fieldKey, fieldLabel) {
        var path = 'field_meta/' + sheet + '/' + fieldKey;
        this._emitChange('schema_patch', path, 'add_field', null, { field_key: fieldKey, field_label: fieldLabel, sheet: sheet });
        if (typeof showToast === 'function') showToast('Field "' + fieldKey + '" added to section ' + sheet, 'success');
      },

      addTenantRule: function(sheet, fieldKey, rule) {
        var path = 'tenant_rules/' + sheet + '/' + fieldKey;
        this._emitChange('tenant_rule_patch', path, 'add_tenant_rule', null, rule);
        if (typeof showToast === 'function') showToast('Tenant rule added for ' + fieldKey, 'success');
      },

      suppressColumn: function(sheet, columnName) {
        var path = 'suppressions/' + sheet + '/' + columnName;
        this._emitChange('suppression_patch', path, 'suppress', null, columnName);
        if (typeof showToast === 'function') showToast('Column "' + columnName + '" suppressed', 'info');
      },

      undo: function() {
        if (this._changeBuffer.length === 0) {
          if (typeof showToast === 'function') showToast('Nothing to undo', 'info');
          return;
        }
        var removed = this._changeBuffer.pop();
        this._updateStatusBar();
        if (typeof showToast === 'function') showToast('Undid: ' + removed.action + ' on ' + removed.path, 'info');
      },

      getChanges: function() { return this._changeBuffer.slice(); },

      getDiffPreview: function() {
        if (this._changeBuffer.length === 0) return '<p style="color:#888; font-size:0.9em;">No pending changes.</p>';
        var html = '<table style="width:100%; border-collapse:collapse; font-size:0.82em;">';
        html += '<thead><tr style="background:#f5f5f5;"><th style="padding:4px 8px; text-align:left; border-bottom:1px solid #ddd;">Action</th><th style="padding:4px 8px; text-align:left; border-bottom:1px solid #ddd;">Path</th><th style="padding:4px 8px; text-align:left; border-bottom:1px solid #ddd;">Old</th><th style="padding:4px 8px; text-align:left; border-bottom:1px solid #ddd;">New</th><th style="padding:4px 8px; text-align:left; border-bottom:1px solid #ddd;">Time</th></tr></thead><tbody>';
        this._changeBuffer.forEach(function(c) {
          var color = '#e8f5e9';
          if (c.action.indexOf('suppress') >= 0 || c.action.indexOf('remove') >= 0) color = '#ffebee';
          else if (c.action.indexOf('modify') >= 0) color = '#fff8e1';
          html += '<tr style="background:' + color + ';">';
          html += '<td style="padding:4px 8px; border-bottom:1px solid #eee;">' + c.action + '</td>';
          html += '<td style="padding:4px 8px; border-bottom:1px solid #eee; font-family:monospace; font-size:0.9em;">' + c.path + '</td>';
          html += '<td style="padding:4px 8px; border-bottom:1px solid #eee;">' + (c.oldVal ? JSON.stringify(c.oldVal) : '-') + '</td>';
          html += '<td style="padding:4px 8px; border-bottom:1px solid #eee;">' + (c.newVal ? JSON.stringify(c.newVal) : '-') + '</td>';
          html += '<td style="padding:4px 8px; border-bottom:1px solid #eee; font-size:0.85em;">' + (c.timestamp || '') + '</td>';
          html += '</tr>';
        });
        html += '</tbody></table>';
        return html;
      },

      saveDraft: function() {
        var self = this;
        try {
          SessionDB._put(SessionDB.WORKBOOK_STORE, {
            id: 'schema_editor_draft',
            changes: self._changeBuffer,
            saved_at: new Date().toISOString()
          }).then(function() {
            if (typeof showToast === 'function') showToast('Schema draft saved (' + self._changeBuffer.length + ' changes)', 'success');
          }).catch(function(err) {
            console.error('[SchemaTreeEditor] saveDraft failed:', err);
            if (typeof showToast === 'function') showToast('Failed to save draft', 'error');
          });
        } catch(e) {
          console.error('[SchemaTreeEditor] saveDraft error:', e);
        }
      },

      loadDraft: function() {
        var self = this;
        try {
          SessionDB._get(SessionDB.WORKBOOK_STORE, 'schema_editor_draft').then(function(draft) {
            if (draft && draft.changes && Array.isArray(draft.changes)) {
              self._changeBuffer = draft.changes;
              self._updateStatusBar();
              console.log('[SchemaTreeEditor] Loaded draft with ' + draft.changes.length + ' changes from ' + (draft.saved_at || 'unknown'));
            }
          }).catch(function(err) {
            console.warn('[SchemaTreeEditor] loadDraft failed:', err);
          });
        } catch(e) { console.warn('[SchemaTreeEditor] loadDraft error:', e); }
      },

      exportPatch: function() {
        var self = this;
        var patch = {
          type: 'schema_patch',
          version: 'v1',
          exported_at: new Date().toISOString(),
          changes: self._changeBuffer
        };
        var json = JSON.stringify(patch, null, 2);
        try {
          navigator.clipboard.writeText(json).then(function() {
            if (typeof showToast === 'function') showToast('Patch JSON copied to clipboard (' + self._changeBuffer.length + ' changes)', 'success');
          });
        } catch(e) {
          console.log('[SchemaTreeEditor] Patch export:', json);
          if (typeof showToast === 'function') showToast('Patch exported to console (clipboard unavailable)', 'info');
        }
      },

      applyLocally: function() {
        var self = this;
        self._changeBuffer.forEach(function(c) {
          if (c.action === 'add_alias' && c.newVal) {
            var norm = String(c.newVal).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
            var parts = c.path.split('/');
            var sheet = parts[1] || '';
            var canonical = parts[2] || '';
            if (norm && canonical) {
              if (!COLUMN_ALIAS_MAP[norm]) COLUMN_ALIAS_MAP[norm] = [];
              COLUMN_ALIAS_MAP[norm].push({ canonical_key: canonical, sheet: sheet });
            }
          }
        });
        if (typeof showToast === 'function') showToast('Changes applied to runtime', 'success');
      },

      _updateStatusBar: function() {
        var loadedEl = document.getElementById('schema-loaded-count');
        var pendingEl = document.getElementById('schema-pending-count');
        if (loadedEl) loadedEl.textContent = 'Sources: ' + Object.keys(this._sources).length + ' loaded';
        if (pendingEl) pendingEl.textContent = 'Pending changes: ' + this._changeBuffer.length;
      }
    };

    function schemaTreeExpandAll() {
      if (!SchemaTreeEditor._tree) return;
      SchemaTreeEditor._tree.children.forEach(function(child) {
        SchemaTreeEditor._expandNode(child.id, child, 0, document.getElementById('schema-tree-container'));
        if (child.children) {
          child.children.forEach(function(gc) {
            SchemaTreeEditor._expandNode(gc.id);
          });
        }
      });
    }
    function schemaTreeCollapseAll() {
      if (!SchemaTreeEditor._tree) return;
      Object.keys(SchemaTreeEditor._expandedNodes).forEach(function(id) {
        SchemaTreeEditor._collapseNode(id);
      });
    }
    function schemaTreePreviewDiff() {
      var panel = document.getElementById('schema-diff-panel');
      if (!panel) return;
      if (panel.style.display === 'none') {
        panel.style.display = '';
        panel.innerHTML = '<h4 style="margin:0 0 10px; font-size:0.95em;">Diff Preview</h4>' + SchemaTreeEditor.getDiffPreview();
      } else {
        panel.style.display = 'none';
      }
    }
    function schemaTreeMapAlias(nodeId) {
      var node = SchemaTreeEditor._findNode(nodeId);
      if (!node) return;
      var canonical = prompt('Enter the canonical field_key to map "' + node.label + '" to:');
      if (canonical) {
        SchemaTreeEditor.addAlias(canonical, node.sheet || '_default', node.label);
      }
    }
    function schemaTreeAddField(nodeId) {
      var node = SchemaTreeEditor._findNode(nodeId);
      if (!node) return;
      var fieldKey = prompt('Enter field_key for new field (e.g., my_field_c):');
      if (fieldKey) {
        SchemaTreeEditor.addCanonicalField(node.sheet || '_default', fieldKey, node.label);
      }
    }
    function schemaTreeAddTenantRule(nodeId) {
      var node = SchemaTreeEditor._findNode(nodeId);
      if (!node) return;
      var rule = prompt('Enter tenant rule description:');
      if (rule) {
        SchemaTreeEditor.addTenantRule(node.sheet || '_default', node.label, rule);
      }
    }
    function schemaTreeIgnore(nodeId) {
      var node = SchemaTreeEditor._findNode(nodeId);
      if (!node) return;
      SchemaTreeEditor.suppressColumn(node.sheet || '_default', node.label);
    }
    function schemaTreeEditNode(nodeId) {
      var node = SchemaTreeEditor._findNode(nodeId);
      if (!node) return;
      if (node.type === 'alias') {
        var newAlias = prompt('Add a new alias for "' + node.canonical_key + '":\nCurrent: ' + (node.aliases || []).join(', '));
        if (newAlias) {
          SchemaTreeEditor.addAlias(node.canonical_key, node.sheet || '', newAlias);
        }
      } else if (node.type === 'field') {
        var newLabel = prompt('Edit label for "' + node.field_key + '":', node.field_label || '');
        if (newLabel && newLabel !== node.field_label) {
          SchemaTreeEditor._emitChange('schema_patch', 'field_meta/' + node.sheet + '/' + node.field_key, 'modify_label', node.field_label, newLabel);
          if (typeof showToast === 'function') showToast('Label updated for ' + node.field_key, 'success');
        }
      }
    }

    // ========== STANDARDIZER (Legacy) ==========
    let standardizerResult = {
      mergedDataset: null,
      issues: [],
      changeLog: [],
      currentTab: 'summary'
    };
    
    // Infer CSV delimiter
    function inferDelimiter(csvText) {
      var firstLine = csvText.split('\n')[0] || '';
      var counts = { ',': 0, '\t': 0, ';': 0, '|': 0 };
      for (var i = 0; i < firstLine.length; i++) {
        if (counts.hasOwnProperty(firstLine[i])) counts[firstLine[i]]++;
      }
      var best = ',';
      var max = 0;
      Object.keys(counts).forEach(function(d) {
        if (counts[d] > max) { max = counts[d]; best = d; }
      });
      return best;
    }
    
    // Parse CSV to array of objects
    function parseCSV(csvText, delimiter) {
      delimiter = delimiter || inferDelimiter(csvText);
      var lines = csvText.trim().split('\n');
      if (lines.length < 2) return { headers: [], rows: [], delimiter: delimiter };
      
      var headers = lines[0].split(delimiter).map(function(h) { return h.trim().replace(/^"|"$/g, ''); });
      var rows = [];
      for (var i = 1; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) continue;
        var values = line.split(delimiter).map(function(v) { return v.trim().replace(/^"|"$/g, ''); });
        var row = {};
        headers.forEach(function(h, idx) {
          row[h] = values[idx] !== undefined ? values[idx] : null;
        });
        rows.push(row);
      }
      return { headers: headers, rows: rows, delimiter: delimiter };
    }
    
    // Normalize header name
    function normalizeHeader(header) {
      return header
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
    }
    
    // Standard canonical headers
    var CANONICAL_HEADERS = ['contract_key', 'file_url', 'file_name', 'sheet', 'field', 'value', 'status', 'subtype'];
    
    // Run the standardizer
    function runStandardizer() {
      var csvInput = document.getElementById('standardizer-csv-input');
      var csvText = csvInput.value.trim();
      
      if (!csvText) {
        showStandardizerStatus('Please enter or upload CSV data.', 'error');
        return;
      }
      
      var parsed = parseCSV(csvText);
      if (parsed.rows.length === 0) {
        showStandardizerStatus('No data rows found in CSV.', 'error');
        return;
      }
      
      var issues = [];
      var changeLog = [];
      var headerMap = {};
      var normalizedHeaders = [];
      var missingAnchors = [];
      
      // Normalize headers
      parsed.headers.forEach(function(original) {
        var normalized = normalizeHeader(original);
        if (normalized !== original.toLowerCase()) {
          changeLog.push({ type: 'header_renamed', original: original, normalized: normalized });
        }
        headerMap[original] = normalized;
        normalizedHeaders.push(normalized);
      });
      
      // Check for canonical headers
      CANONICAL_HEADERS.forEach(function(anchor) {
        var found = normalizedHeaders.some(function(h) { return h === anchor || h.includes(anchor); });
        if (!found && (anchor === 'contract_key' || anchor === 'file_url' || anchor === 'file_name')) {
          issues.push({
            type: 'missing_required_anchor',
            severity: 'blocking',
            anchor: anchor,
            message: 'Required anchor header "' + anchor + '" not found in input.'
          });
          missingAnchors.push(anchor);
        }
      });
      
      // Check for ambiguous columns
      var normalizedCounts = {};
      normalizedHeaders.forEach(function(h) {
        normalizedCounts[h] = (normalizedCounts[h] || 0) + 1;
      });
      Object.keys(normalizedCounts).forEach(function(h) {
        if (normalizedCounts[h] > 1) {
          issues.push({
            type: 'ambiguous_columns',
            severity: 'warning',
            header: h,
            count: normalizedCounts[h],
            message: 'Header "' + h + '" appears ' + normalizedCounts[h] + ' times after normalization.'
          });
        }
      });
      
      // Build normalized rows
      var normalizedRows = parsed.rows.map(function(row, idx) {
        var newRow = { _row_index: idx };
        parsed.headers.forEach(function(original) {
          var normalized = headerMap[original];
          newRow[normalized] = row[original] !== '' ? row[original] : null;
        });
        return newRow;
      });
      
      // Sort rows deterministically by canonical keys
      normalizedRows.sort(function(a, b) {
        var keys = ['contract_key', 'file_url', 'file_name', 'sheet', 'field'];
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var av = (a[k] || '').toString();
          var bv = (b[k] || '').toString();
          if (av < bv) return -1;
          if (av > bv) return 1;
        }
        return 0;
      });
      
      // Build merged dataset
      var mergedDataset = {
        version: '1.0.0',
        generated_at: new Date().toISOString(),
        source: 'standardizer',
        delimiter_detected: parsed.delimiter,
        schema: {
          original_headers: parsed.headers,
          normalized_headers: normalizedHeaders,
          header_mapping: headerMap
        },
        data: {
          rows: normalizedRows,
          row_count: normalizedRows.length
        }
      };
      
      standardizerResult.mergedDataset = mergedDataset;
      standardizerResult.issues = issues;
      standardizerResult.changeLog = changeLog;
      
      var hasBlocking = issues.some(function(i) { return i.severity === 'blocking'; });
      var status = hasBlocking ? 'Completed with blocking issues' : 'Completed successfully';
      var statusType = hasBlocking ? 'warning' : 'success';
      showStandardizerStatus(status + ': ' + normalizedRows.length + ' rows, ' + issues.length + ' issues.', statusType);
      
      document.getElementById('standardizer-output').style.display = 'block';
      showStandardizerTab('summary');
    }
    
    function showStandardizerStatus(message, type) {
      var el = document.getElementById('standardizer-status');
      el.textContent = message;
      el.style.display = 'block';
      el.style.background = type === 'error' ? '#ffebee' : type === 'warning' ? '#fff3e0' : '#e8f5e9';
      el.style.color = type === 'error' ? '#c62828' : type === 'warning' ? '#e65100' : '#2e7d32';
    }
    
    function showStandardizerTab(tab) {
      standardizerResult.currentTab = tab;
      document.querySelectorAll('[data-std-tab]').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.stdTab === tab);
      });
      
      var content = document.getElementById('standardizer-tab-content');
      var ds = standardizerResult.mergedDataset;
      var issues = standardizerResult.issues;
      var log = standardizerResult.changeLog;
      
      if (tab === 'summary') {
        content.innerHTML = '<div class="json-header">Summary</div>' +
          '<div>Rows: ' + (ds ? ds.data.row_count : 0) + '</div>' +
          '<div>Original Headers: ' + (ds ? ds.schema.original_headers.length : 0) + '</div>' +
          '<div>Issues: ' + issues.length + ' (' + issues.filter(function(i){return i.severity==='blocking';}).length + ' blocking)</div>' +
          '<div>Changes: ' + log.length + '</div>';
      } else if (tab === 'dataset') {
        content.innerHTML = '<div class="json-header">Internal JSON (advanced)</div><pre>' + 
          (ds ? escapeHtml(JSON.stringify(ds, null, 2)) : 'No data') + '</pre>';
      } else if (tab === 'issues') {
        content.innerHTML = '<div class="json-header">Standardization Issues</div><pre>' + 
          escapeHtml(JSON.stringify(issues, null, 2)) + '</pre>';
      } else if (tab === 'changelog') {
        content.innerHTML = '<div class="json-header">Change Log</div><pre>' + 
          escapeHtml(JSON.stringify(log, null, 2)) + '</pre>';
      }
    }
    
    function generateSampleCSV() {
      var sample = 'Contract Key,File Name,File URL,Sheet,Field,Value,Status\n' +
        'CK001,a.pdf,https://example.org/a.pdf,Sheet1,title,Sample Title,ready\n' +
        'CK002,b.pdf,https://example.org/b.pdf,Sheet1,title,Another Title,needs_review\n' +
        'CK003,c.xlsx,https://example.org/c.xlsx,Data,amount,1500.00,ready\n';
      document.getElementById('standardizer-csv-input').value = sample;
      showStandardizerStatus('Sample CSV generated. Click "Run Standardizer" to process.', 'success');
    }
    
    function clearStandardizer() {
      document.getElementById('standardizer-csv-input').value = '';
      document.getElementById('standardizer-status').style.display = 'none';
      document.getElementById('standardizer-output').style.display = 'none';
      document.getElementById('standardizer-drop-text').textContent = 'Drop CSV here or click to browse';
      standardizerResult = { mergedDataset: null, issues: [], changeLog: [], currentTab: 'summary' };
    }
    
    function copyStandardizerOutput(type) {
      var text = '';
      if (type === 'dataset' && standardizerResult.mergedDataset) {
        text = JSON.stringify(standardizerResult.mergedDataset, null, 2);
      } else if (type === 'issues') {
        text = JSON.stringify(standardizerResult.issues, null, 2);
      }
      navigator.clipboard.writeText(text).then(function() {
        showToast('Copied to clipboard!', 'success');
      });
    }
    
    // Setup standardizer drop zone
    function setupStandardizerDropZone() {
      var dropZone = document.getElementById('standardizer-drop-zone');
      var fileInput = document.getElementById('standardizer-file-input');
      if (!dropZone || !fileInput) return;
      
      dropZone.addEventListener('click', function() { fileInput.click(); });
      dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        dropZone.style.borderColor = '#1976d2';
        dropZone.style.background = '#e3f2fd';
      });
      dropZone.addEventListener('dragleave', function() {
        dropZone.style.borderColor = '#ccc';
        dropZone.style.background = '#fafafa';
      });
      dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        dropZone.style.borderColor = '#ccc';
        dropZone.style.background = '#fafafa';
        var file = e.dataTransfer.files[0];
        if (file) handleStandardizerFile(file);
      });
      fileInput.addEventListener('change', function(e) {
        var file = e.target.files[0];
        if (file) handleStandardizerFile(file);
      });
    }
    
    function handleStandardizerFile(file) {
      var reader = new FileReader();
      reader.onload = function(e) {
        document.getElementById('standardizer-csv-input').value = e.target.result;
        document.getElementById('standardizer-drop-text').textContent = file.name;
        showStandardizerStatus('File loaded: ' + file.name + '. Click "Run Standardizer" to process.', 'success');
      };
      reader.readAsText(file);
    }

    function renderWorkflowMap() {
      var container = document.getElementById('workflow-map');
      if (!container) return;
      
      var html = WORKFLOW_STAGES.map(function(stage, idx) {
        var artifactChips = stage.artifacts.map(function(artifactKey) {
          var binding = artifactRegistry.bindings[artifactKey];
          var status = binding ? binding.status : 'unknown';
          var statusClass = status === 'loaded' ? '' : status === 'missing' ? 'missing' : 'unknown';
          var label = ARTIFACT_LABELS[artifactKey] || artifactKey;
          var statusIcon = status === 'loaded' ? '✓' : status === 'missing' ? '✗' : '?';
          return '<span class="workflow-artifact ' + statusClass + '">' + statusIcon + ' ' + label + '</span>';
        }).join('');
        
        var connector = idx < WORKFLOW_STAGES.length - 1 ? '<div class="workflow-connector"></div>' : '';
        
        return '<div class="workflow-node" onclick="WORKFLOW_STAGES[' + idx + '].action()">' +
          '<div class="workflow-node-icon">' + stage.icon + '</div>' +
          '<div class="workflow-node-content">' +
            '<div class="workflow-node-title">' + stage.title + '</div>' +
            '<div class="workflow-node-desc">' + stage.desc + '</div>' +
            (artifactChips ? '<div class="workflow-node-artifacts">' + artifactChips + '</div>' : '') +
          '</div>' +
        '</div>' + connector;
      }).join('');
      
      container.innerHTML = html;
    }
    
    function updateSessionChip() {
      const chip = document.getElementById('session-chip');
      const chipText = document.getElementById('session-chip-text');
      const meta = document.getElementById('session-meta');
      const previewStatus = document.getElementById('preview-status');
      const triageInfo = document.getElementById('triage-session-info');
      
      // v1.5.5: chip may not exist after header cleanup
      if (!chip) return;
      chip.className = 'session-chip ' + sessionState.status;
      
      if (sessionState.status === 'loaded') {
        chipText.textContent = 'Loaded';
        const sourceLabel = sessionState.sourceType === 'paste' ? 'paste' : 
                           sessionState.sourceType === 'drop' ? sessionState.fileName || 'file' : 
                           sessionState.sourceType;
        meta.textContent = `via ${sourceLabel} at ${new Date(sessionState.loadedAt).toLocaleTimeString()}`;
        if (previewStatus) {
          previewStatus.textContent = 'Loaded';
          previewStatus.className = 'loader-section-status loaded';
        }
        if (triageInfo) {
          triageInfo.innerHTML = `<strong>Source:</strong> ${sourceLabel} (memory) | <strong>Loaded:</strong> ${new Date(sessionState.loadedAt).toLocaleString()}`;
        }
      } else if (sessionState.status === 'fallback') {
        chipText.textContent = 'Fallback';
        meta.textContent = 'using example data';
        if (previewStatus) {
          previewStatus.textContent = 'Example';
          previewStatus.className = 'loader-section-status loaded';
        }
        if (triageInfo) {
          triageInfo.innerHTML = `<strong>Source:</strong> example (fallback) | Using bundled sample data`;
        }
      } else {
        chipText.textContent = 'Not Loaded';
        meta.textContent = '';
        if (previewStatus) {
          previewStatus.textContent = 'Not Loaded';
          previewStatus.className = 'loader-section-status empty';
        }
        if (triageInfo) {
          triageInfo.innerHTML = `<strong>Source:</strong> none | Click <em>Data Source</em> to begin`;
        }
      }
    }

    // ========== SIDEBAR FUNCTIONS (v1.4.6) ==========
    var cacheState = { pdfCount: 0, storageKB: 0, totalBytes: 0 };
    
    // ========== PDF CACHE (v1.4.13) ==========
    // IndexedDB-based offline-first PDF cache with LRU eviction
    // v1.4.18: PDF Proxy configuration - unified server on same origin (port 5000)
    // Priority: Supabase proxy (if env set) > FastAPI proxy (same origin) > show warning
    var PDF_PROXY_CONFIG = (function() {
      var host = window.location.hostname;
      var protocol = window.location.protocol;
      var origin = window.location.origin;
      
      // Check for Supabase configuration (set via embedded config or env)
      var supabaseUrl = window.VITE_SUPABASE_URL || localStorage.getItem('SUPABASE_URL') || '';
      var supabaseKey = window.VITE_SUPABASE_ANON_KEY || localStorage.getItem('SUPABASE_ANON_KEY') || '';
      
      var proxyType = 'none';
      var baseUrl = '';
      var authHeader = null;
      
      // Priority 1: Supabase Edge Function (DataDash method)
      if (supabaseUrl && supabaseKey) {
        baseUrl = supabaseUrl.replace(/\/$/, '') + '/functions/v1/contract-proxy';
        authHeader = 'Bearer ' + supabaseKey;
        proxyType = 'supabase';
      } else {
        // Priority 2: FastAPI proxy on SAME origin (unified server on port 5000)
        // No port switching needed - proxy endpoint is at /proxy/pdf on same server
        baseUrl = origin + '/proxy/pdf';
        proxyType = 'fastapi';
      }
      
      // v1.4.18: Debug logging (guarded by localStorage pdfDebug flag)
      if (localStorage.getItem('pdfDebug') === '1') {
        console.log('[PDF_PROXY_DEBUG]', JSON.stringify({
          proxyType: proxyType,
          viewerOrigin: origin,
          viewerHost: host,
          proxyBaseUrl: baseUrl,
          hasSupabaseEnv: !!(supabaseUrl && supabaseKey),
          authHeaderSet: !!authHeader
        }));
      } else {
        console.log('[PDF_PROXY] Type:', proxyType, '| URL:', baseUrl.substring(0, 60) + (baseUrl.length > 60 ? '...' : ''));
      }
      
      return {
        BASE_URL: baseUrl,
        ENABLED: proxyType !== 'none',
        PROXY_TYPE: proxyType,
        AUTH_HEADER: authHeader,
        TIMEOUT_MS: 30000
      };
    })();
    
    var PDF_CACHE_CONFIG = {
      DB_NAME: 'orchestrate_pdf_cache',
      DB_VERSION: 1,
      STORE_NAME: 'pdfs',
      INDEX_STORE: 'index',
      MAX_FILE_BYTES: 25 * 1024 * 1024,  // 25MB per file
      MAX_TOTAL_BYTES: 250 * 1024 * 1024  // 250MB total
    };
    
    var pdfCacheDB = null;
    var pdfCacheIndex = []; // In-memory index: [{key, source_url, size_bytes, created_at, last_accessed_at}]
    
    function initPdfCache() {
      return new Promise(function(resolve, reject) {
        if (!window.indexedDB) {
          console.warn('[PDF_CACHE] IndexedDB not supported, using memory-only mode');
          resolve(null);
          return;
        }
        
        var request = indexedDB.open(PDF_CACHE_CONFIG.DB_NAME, PDF_CACHE_CONFIG.DB_VERSION);
        
        request.onerror = function(e) {
          console.error('[PDF_CACHE] Failed to open IndexedDB:', e);
          resolve(null);
        };
        
        request.onsuccess = function(e) {
          pdfCacheDB = e.target.result;
          console.log('[PDF_CACHE] IndexedDB opened successfully');
          loadCacheIndex().then(resolve).catch(function() { resolve(null); });
        };
        
        request.onupgradeneeded = function(e) {
          var db = e.target.result;
          if (!db.objectStoreNames.contains(PDF_CACHE_CONFIG.STORE_NAME)) {
            db.createObjectStore(PDF_CACHE_CONFIG.STORE_NAME, { keyPath: 'key' });
          }
          if (!db.objectStoreNames.contains(PDF_CACHE_CONFIG.INDEX_STORE)) {
            db.createObjectStore(PDF_CACHE_CONFIG.INDEX_STORE, { keyPath: 'id' });
          }
        };
      });
    }
    
    function loadCacheIndex() {
      return new Promise(function(resolve, reject) {
        if (!pdfCacheDB) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.INDEX_STORE], 'readonly');
          var store = tx.objectStore(PDF_CACHE_CONFIG.INDEX_STORE);
          var req = store.get('cache_index');
          req.onsuccess = function() {
            if (req.result && Array.isArray(req.result.entries)) {
              pdfCacheIndex = req.result.entries;
            } else {
              pdfCacheIndex = [];
            }
            updateCacheStatsFromIndex();
            console.log('[PDF_CACHE] Loaded index:', pdfCacheIndex.length, 'entries');
            resolve();
          };
          req.onerror = function() {
            pdfCacheIndex = [];
            updateCacheStatsFromIndex();
            resolve();
          };
        } catch (e) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
        }
      });
    }
    
    function saveCacheIndex() {
      if (!pdfCacheDB) return Promise.resolve();
      
      return new Promise(function(resolve) {
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.INDEX_STORE], 'readwrite');
          var store = tx.objectStore(PDF_CACHE_CONFIG.INDEX_STORE);
          store.put({ id: 'cache_index', entries: pdfCacheIndex });
          tx.oncomplete = resolve;
          tx.onerror = resolve;
        } catch (e) {
          resolve();
        }
      });
    }
    
    function updateCacheStatsFromIndex() {
      var totalBytes = 0;
      pdfCacheIndex.forEach(function(entry) {
        totalBytes += entry.size_bytes || 0;
      });
      cacheState.pdfCount = pdfCacheIndex.length;
      cacheState.totalBytes = totalBytes;
      cacheState.storageKB = Math.round(totalBytes / 1024);
      updateCacheDisplay();
    }
    
    function computePdfCacheKey(recordIdentity, sourceUrl) {
      var identity = recordIdentity || 'unknown';
      var url = sourceUrl || '';
      return 'pdf:' + identity + ':' + url.split('?')[0];
    }
    
    function getCachedPdf(cacheKey) {
      return new Promise(function(resolve) {
        if (!pdfCacheDB) {
          resolve(null);
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME], 'readonly');
          var store = tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME);
          var req = store.get(cacheKey);
          req.onsuccess = function() {
            if (req.result && req.result.blob) {
              // Update last_accessed_at
              updateCacheEntryAccess(cacheKey);
              resolve(req.result.blob);
            } else {
              resolve(null);
            }
          };
          req.onerror = function() { resolve(null); };
        } catch (e) {
          resolve(null);
        }
      });
    }
    
    function updateCacheEntryAccess(cacheKey) {
      var entry = pdfCacheIndex.find(function(e) { return e.key === cacheKey; });
      if (entry) {
        entry.last_accessed_at = Date.now();
        saveCacheIndex();
      }
    }
    
    function cachePdf(cacheKey, sourceUrl, blob) {
      return new Promise(function(resolve) {
        if (!pdfCacheDB || !blob) {
          resolve(false);
          return;
        }
        
        var sizeBytes = blob.size;
        
        // Check per-file cap
        if (sizeBytes > PDF_CACHE_CONFIG.MAX_FILE_BYTES) {
          console.log('[PDF_CACHE] File too large to cache:', (sizeBytes / 1024 / 1024).toFixed(2), 'MB (max 25MB)');
          resolve(false);
          return;
        }
        
        // LRU eviction if needed
        evictLRUIfNeeded(sizeBytes).then(function() {
          try {
            var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME], 'readwrite');
            var store = tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME);
            
            var entry = {
              key: cacheKey,
              source_url: sourceUrl,
              size_bytes: sizeBytes,
              created_at: Date.now(),
              last_accessed_at: Date.now(),
              blob: blob
            };
            
            store.put(entry);
            
            tx.oncomplete = function() {
              // Update index
              var existingIdx = pdfCacheIndex.findIndex(function(e) { return e.key === cacheKey; });
              var indexEntry = {
                key: cacheKey,
                source_url: sourceUrl,
                size_bytes: sizeBytes,
                created_at: entry.created_at,
                last_accessed_at: entry.last_accessed_at
              };
              
              if (existingIdx >= 0) {
                pdfCacheIndex[existingIdx] = indexEntry;
              } else {
                pdfCacheIndex.push(indexEntry);
              }
              
              updateCacheStatsFromIndex();
              saveCacheIndex();
              console.log('[PDF_CACHE] Cached:', cacheKey, (sizeBytes / 1024).toFixed(1), 'KB');
              resolve(true);
            };
            
            tx.onerror = function() { resolve(false); };
          } catch (e) {
            resolve(false);
          }
        });
      });
    }
    
    function evictLRUIfNeeded(newFileBytes) {
      return new Promise(function(resolve) {
        var currentTotal = cacheState.totalBytes;
        var wouldBe = currentTotal + newFileBytes;
        
        if (wouldBe <= PDF_CACHE_CONFIG.MAX_TOTAL_BYTES) {
          resolve();
          return;
        }
        
        // Sort by last_accessed_at (oldest first)
        var sorted = pdfCacheIndex.slice().sort(function(a, b) {
          return (a.last_accessed_at || 0) - (b.last_accessed_at || 0);
        });
        
        var toEvict = [];
        var freedBytes = 0;
        var needed = wouldBe - PDF_CACHE_CONFIG.MAX_TOTAL_BYTES;
        
        for (var i = 0; i < sorted.length && freedBytes < needed; i++) {
          toEvict.push(sorted[i].key);
          freedBytes += sorted[i].size_bytes || 0;
        }
        
        if (toEvict.length === 0) {
          resolve();
          return;
        }
        
        console.log('[PDF_CACHE] Evicting', toEvict.length, 'LRU entries to free', (freedBytes / 1024).toFixed(1), 'KB');
        
        // Delete from IndexedDB
        var pending = toEvict.length;
        toEvict.forEach(function(key) {
          deleteCachedPdf(key).then(function() {
            pending--;
            if (pending === 0) resolve();
          });
        });
      });
    }
    
    function deleteCachedPdf(cacheKey) {
      return new Promise(function(resolve) {
        if (!pdfCacheDB) {
          pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
          updateCacheStatsFromIndex();
          resolve();
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME], 'readwrite');
          var store = tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME);
          store.delete(cacheKey);
          tx.oncomplete = function() {
            pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
            updateCacheStatsFromIndex();
            resolve();
          };
          tx.onerror = function() {
            pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
            updateCacheStatsFromIndex();
            resolve();
          };
        } catch (e) {
          pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
          updateCacheStatsFromIndex();
          resolve();
        }
      });
    }
    
    function clearAllCachedPdfs() {
      return new Promise(function(resolve) {
        if (!pdfCacheDB) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME, PDF_CACHE_CONFIG.INDEX_STORE], 'readwrite');
          tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME).clear();
          tx.objectStore(PDF_CACHE_CONFIG.INDEX_STORE).clear();
          tx.oncomplete = function() {
            pdfCacheIndex = [];
            updateCacheStatsFromIndex();
            console.log('[PDF_CACHE] All cached PDFs cleared');
            resolve();
          };
          tx.onerror = function() {
            pdfCacheIndex = [];
            updateCacheStatsFromIndex();
            resolve();
          };
        } catch (e) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
        }
      });
    }
    
    function formatCacheSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1024 / 1024).toFixed(1) + ' MB';
    }

    function updateProgressBlock() {
      var todoEl = document.getElementById('progress-todo');
      var reviewEl = document.getElementById('progress-review');
      var doneEl = document.getElementById('progress-done');
      var barFill = document.getElementById('progress-bar-fill');

      if (!todoEl || !reviewEl || !doneEl) return;

      var todo = 0, review = 0, done = 0, total = 0;

      if (typeof TriageAnalytics !== 'undefined') {
        var cache = TriageAnalytics.getCache();
        if (cache && cache.batch_summary) {
          var bs = cache.batch_summary;
          todo = bs.pending || 0;
          review = bs.needs_review || 0;
          done = bs.completed || 0;
          total = bs.contracts_total || 0;
        }
      }

      var progressPct = total > 0 ? Math.round((done / total) * 100) : 0;

      todoEl.textContent = todo;
      reviewEl.textContent = review;
      doneEl.textContent = done;
      if (barFill) barFill.style.width = progressPct + '%';

      console.log('[Progress] Updated from batch_summary: To Do=' + todo + ', Review=' + review + ', Done=' + done + ', Total=' + total + ' (' + progressPct + '%)');
    }

    function updateActiveDataSourceBar(filename) {
      var nameEl = document.getElementById('active-data-source-name');
      var actionBtn = document.getElementById('active-data-source-action');
      if (nameEl) {
        nameEl.textContent = filename || 'No dataset loaded';
      }
      if (actionBtn) {
        actionBtn.textContent = filename ? 'Change' : 'Connect';
      }
    }

    // v1.6.4: Check if a sheet is a meta sheet (audit log, change log, etc.)
    function isMetaSheet(sheetName) {
      if (!sheetName) return false;
      return META_SHEET_PATTERNS.some(function(pattern) {
        return sheetName.includes(pattern);
      });
    }
    
    // v1.6.20: Check if sheet is a reference/glossary sheet (supporting data, not actionable)
    function isReferenceSheet(sheetName) {
      if (!sheetName) return false;
      var lowerName = sheetName.toLowerCase();
      return REFERENCE_SHEET_PATTERNS.some(function(pattern) {
        return lowerName.includes(pattern.toLowerCase());
      });
    }
    
    // v1.6.20: Filter out reference/glossary rows from issues/field_actions arrays
    function filterOutReferenceData(items) {
      if (!items || !Array.isArray(items)) return [];
      return items.filter(function(item) {
        var sheet = item.sheet || item.sheet_name || '';
        return !isReferenceSheet(sheet) && !isMetaSheet(sheet);
      });
    }
    
    // v1.6.4: Get all meta sheets from workbook
    function getMetaSheets() {
      if (!workbook || !workbook.order) return [];
      return workbook.order.filter(isMetaSheet);
    }
    
    // v1.6.4: Get data sheets (non-meta) from workbook
    function getDataSheets() {
      if (!workbook || !workbook.order) return [];
      return workbook.order.filter(function(s) { return !isMetaSheet(s); });
    }
    
    // v1.6.4: Set demo mode (original or modified)
    function setDemoMode(mode) {
      if (mode !== 'original' && mode !== 'modified') return;
      demoToggleState.mode = mode;
      localStorage.setItem(DEMO_TOGGLE_KEY, mode);
      updateDemoToggleUI();
      
      // Reload the appropriate dataset
      console.log('[DemoToggle] Switching to:', mode);
      loadSampleDataset({ autoRedirect: false });
      showToast('Switched to ' + (mode === 'modified' ? 'Modified (In-Progress)' : 'Original (Baseline)') + ' demo dataset', 'success');
    }
    
    // v1.6.4: Update demo toggle UI state
    function updateDemoToggleUI() {
      var isModified = demoToggleState.isModified();
      var originalBtn = document.getElementById('demo-toggle-original');
      var modifiedBtn = document.getElementById('demo-toggle-modified');
      var badge = document.getElementById('demo-mode-badge');
      var banner = document.getElementById('demo-partial-banner');
      var nameEl = document.getElementById('demo-dataset-name');
      var descEl = document.getElementById('demo-dataset-desc');
      
      if (originalBtn) {
        originalBtn.style.background = isModified ? '#f5f5f5' : '#1976d2';
        originalBtn.style.color = isModified ? '#333' : 'white';
      }
      if (modifiedBtn) {
        modifiedBtn.style.background = isModified ? '#ff9800' : '#f5f5f5';
        modifiedBtn.style.color = isModified ? 'white' : '#333';
      }
      if (badge) badge.style.display = isModified ? 'inline-block' : 'none';
      if (banner) banner.style.display = isModified ? 'block' : 'none';
      if (nameEl) nameEl.textContent = isModified ? 'ostereo_demo_v1.json' : 'ostereo_demo_original.json';
      if (descEl) descEl.textContent = isModified ? 'Modified dataset (in-progress)' : 'Baseline dataset (clean)';
    }

    function updateSidebarSheetSelector() {
      if (typeof _populateGridSections === 'function') _populateGridSections();
      var selector = document.getElementById('sidebar-sheet-selector');
      if (!selector) return;

      if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable()) {
        var allContracts = ContractIndex.listContracts().filter(function(c) {
          var fn = (c.file_name || c.contract_id || '').toLowerCase();
          if (fn.includes('_change_log') || fn === 'rfis & analyst notes' || fn.includes('glossary_reference') || fn.includes('_reference')) return false;
          var sheets = c.sheets ? Object.keys(c.sheets) : [];
          var allMeta = sheets.length > 0 && sheets.every(function(s) {
            return (typeof isMetaSheet === 'function' && isMetaSheet(s)) || (typeof isReferenceSheet === 'function' && isReferenceSheet(s));
          });
          return !allMeta;
        });
        var seen = {};
        allContracts = allContracts.filter(function(c) { if (seen[c.contract_id]) return false; seen[c.contract_id] = true; return true; });
        allContracts.sort(function(a, b) { return (a.file_name || '').localeCompare(b.file_name || ''); });

        selector.innerHTML = '<option value="all">All Contracts (' + allContracts.length + ')</option>';
        allContracts.forEach(function(c) {
          var opt = document.createElement('option');
          opt.value = c.contract_id;
          var label = (c.file_name || c.contract_id);
          if (label.length > 35) label = label.substring(0, 33) + '...';
          opt.textContent = label + ' (' + c.row_count + ')';
          selector.appendChild(opt);
        });
        if (_activeContractFilter) {
          selector.value = _activeContractFilter;
        } else {
          selector.value = 'all';
        }
      } else if (workbook && workbook.order) {
        selector.innerHTML = '<option value="all">All Records</option>';
        var dataSheets = getDataSheets();
        dataSheets.forEach(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          if (!sheet) return;
          var opt = document.createElement('option');
          opt.value = sheetName;
          opt.textContent = sheetName + ' (' + (sheet.rows ? sheet.rows.length : 0) + ')';
          selector.appendChild(opt);
        });
        if (gridState.sheet) {
          selector.value = gridState.sheet;
        } else {
          selector.value = 'all';
        }
      }
    }

    function handleSheetSelectorChange(value) {
      console.log('[Sidebar] Selector changed:', value);
      if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable()) {
        if (value === 'all') {
          _activeContractFilter = '';
        } else {
          _activeContractFilter = value;
        }
        var gridContractSelector = document.getElementById('grid-contract-selector');
        if (gridContractSelector) gridContractSelector.value = _activeContractFilter;
        renderGrid();
        updateProgressBlock();
        saveNavStateToCache(); scheduleAutosave();
      } else {
        if (value === 'all') {
          gridState.sheet = null;
        } else {
          gridState.sheet = value;
        }
        populateContractSelector();
        renderGrid();
        updateProgressBlock();
        saveNavStateToCache(); scheduleAutosave();
        var gridSelector = document.getElementById('grid-sheet-selector');
        if (gridSelector) gridSelector.value = gridState.sheet ? gridState.sheet : '';
      }
    }
    
    // v1.6.46: Grid sheet selector change handler - syncs both selectors
    function handleGridSheetSelectorChange(value) {
      console.log('[Grid] Sheet selector changed:', value);
      if (value === '' || value === 'all') {
        gridState.sheet = null;
      } else {
        gridState.sheet = value;
      }
      if (!(typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable())) {
        var sidebarSelector = document.getElementById('sidebar-sheet-selector');
        if (sidebarSelector) sidebarSelector.value = gridState.sheet ? gridState.sheet : 'all';
      }
      populateContractSelector();
      renderGrid();
      updateProgressBlock();
      saveNavStateToCache(); scheduleAutosave();
    }

    function _expandTriageSubnav() {
      var sn = document.getElementById('triage-subnav');
      var tp = document.querySelector('.nav-parent[data-page="triage"]');
      if (sn) sn.classList.add('expanded');
      if (tp) { tp.classList.add('expanded'); tp.classList.add('active'); }
      var ri = document.getElementById('nav-record-inspection');
      if (ri) ri.classList.add('active');
    }

    function _toggleTriageSubnav() {
      var sn = document.getElementById('triage-subnav');
      var tp = document.querySelector('.nav-parent[data-page="triage"]');
      if (!sn || !tp) return;
      if (sn.classList.contains('expanded')) {
        sn.classList.remove('expanded');
        tp.classList.remove('expanded');
      } else {
        sn.classList.add('expanded');
        tp.classList.add('expanded');
      }
    }

    function _populateGridSections() {
      var container = document.getElementById('grid-sections-nav');
      if (!container) return;
      var sections = [];
      if (typeof rulesBundleCache !== 'undefined' && rulesBundleCache.fieldMeta && rulesBundleCache.fieldMeta.meta && rulesBundleCache.fieldMeta.meta.sheet_mapping) {
        var keys = Object.keys(rulesBundleCache.fieldMeta.meta.sheet_mapping);
        var seen = {};
        for (var i = 0; i < keys.length; i++) {
          var cs = canonicalContractSection(keys[i]);
          if (!seen[cs.contract_section_label]) {
            seen[cs.contract_section_label] = true;
            sections.push(cs.contract_section_label);
          }
        }
      } else if (typeof workbook !== 'undefined' && workbook && workbook.order) {
        var ds = typeof getDataSheets === 'function' ? getDataSheets() : workbook.order;
        for (var j = 0; j < ds.length; j++) {
          sections.push(ds[j]);
        }
      }
      sections.sort();
      var html = '';
      for (var s = 0; s < sections.length; s++) {
        var sec = sections[s];
        var secKey = sec.toLowerCase().replace(/\s+/g, '_');
        html += '<a class="nav-section-link" data-section="' + secKey + '" href="#" onclick="_selectGridSection(\'' + sec.replace(/'/g, "\\'") + '\'); return false;">' + sec + '</a>';
      }
      container.innerHTML = html;
    }

    function _selectGridSection(sectionName) {
      gridState.sheet = sectionName;
      var gridSelector = document.getElementById('grid-sheet-selector');
      if (gridSelector) gridSelector.value = sectionName;
      navigateTo('grid');
      populateContractSelector();
      renderGrid();
      updateProgressBlock();
      saveNavStateToCache();
      document.querySelectorAll('#grid-sections-nav .nav-section-link').forEach(function(el) { el.classList.remove('active'); });
      var activeLink = document.querySelector('#grid-sections-nav .nav-section-link[data-section="' + sectionName.toLowerCase().replace(/\s+/g, '_') + '"]');
      if (activeLink) activeLink.classList.add('active');
    }

    function _expandGridSections() {
      var container = document.getElementById('grid-sections-nav');
      var parent = document.querySelector('.nav-subparent[data-page="grid"]');
      if (container) container.classList.add('expanded');
      if (parent) parent.classList.add('expanded');
    }

    function _collapseGridSections() {
      var container = document.getElementById('grid-sections-nav');
      var parent = document.querySelector('.nav-subparent[data-page="grid"]');
      if (container) container.classList.remove('expanded');
      if (parent) parent.classList.remove('expanded');
    }

    function openRecordInspectionFromNav() {
      if (typeof srrState !== 'undefined' && srrState.currentRowId !== null && srrState.currentSheetName) {
        openRowReviewDrawer(srrState.currentSheetName, srrState.currentRowId);
        _expandTriageSubnav();
        return;
      }
      var firstRow = null;
      if (gridState.filteredData && gridState.filteredData.length > 0) {
        firstRow = gridState.filteredData[0];
      } else if (typeof workbook !== 'undefined' && workbook && workbook.order) {
        var ds = typeof getDataSheets === 'function' ? getDataSheets() : workbook.order;
        for (var si = 0; si < ds.length; si++) {
          var sh = workbook.sheets[ds[si]];
          if (sh && sh.rows && sh.rows.length > 0) {
            firstRow = { _sheet_name: ds[si], _row_index: 0 };
            break;
          }
        }
      }
      if (firstRow) {
        if (firstRow._sheet_name && typeof firstRow._row_index !== 'undefined') {
          openRowReviewDrawer(firstRow._sheet_name, firstRow._row_index);
        } else if (firstRow._row_id) {
          openRowReviewDrawer(firstRow._row_id);
        }
        _expandTriageSubnav();
      } else if (!dataLoaded) {
        showToast('Load a dataset first', 'warning');
      } else {
        showToast('No records available to inspect', 'info');
      }
    }

    // v1.4.13: Wire clear cache to IndexedDB
    function clearCachedPDFs() {
      clearAllCachedPdfs().then(function() {
        try {
          localStorage.removeItem('orchestrate.pdf_attachments.v1');
        } catch (e) {}
        showToast('Cached PDFs cleared', 'success');
      });
    }

    // ========== EXPORT / SAVE FUNCTIONALITY (v1.6.33) ==========
    function handleExportSave() {
      if (typeof XLSX === 'undefined') {
        showToast('Excel library not loaded. Please refresh and try again.', 'error');
        return;
      }
      
      if (!workbook || !workbook.order || workbook.order.length === 0) {
        showToast('No data to export. Please load a dataset first.', 'warning');
        return;
      }
      
      showToast('Preparing export...', 'info');
      
      try {
        var wb = XLSX.utils.book_new();
        
        // v1.6.33: Export all data sheets with styling metadata
        var dataSheets = getDataSheets();
        dataSheets.forEach(function(sheetName) {
          var sheetData = workbook.sheets[sheetName];
          if (!sheetData || !sheetData.rows) return;
          // Build sheet array with headers + orchestrate columns
          var exportHeaders = sheetData.headers.slice();
          var extraCols = ['batch_id', 'contract_id', 'document_id', 'document_role', 'document_type', 'capabilities', 'merged_from', 'group_id'];
          extraCols.forEach(function(c) {
            if (exportHeaders.indexOf(c) < 0) exportHeaders.push(c);
          });
          var sheetArray = [exportHeaders];
          // Add rows
          sheetData.rows.forEach(function(row) {
            var rowArray = exportHeaders.map(function(h) {
              if (h === 'batch_id') return row._identity && row._identity.batch_id || IDENTITY_CONTEXT.batch_id || '';
              if (h === 'contract_id') return row._identity && row._identity.contract_id || row._contract_id || '';
              if (h === 'document_id') return row._identity && row._identity.document_id || row._document_id || '';
              if (h === 'document_role') return row._document_role || 'Unknown';
              if (h === 'document_type') return row._document_type || 'Unknown';
              if (h === 'capabilities') {
                var caps = row._capabilities;
                if (!caps || Object.keys(caps).length === 0) return '';
                return JSON.stringify(caps);
              }
              if (h === 'merged_from') return row._merged_from ? JSON.stringify(row._merged_from) : '';
              if (h === 'group_id') return (row._group && row._group.group_id) || '';
              var val = row[h];
              if (val === null || val === undefined) return '';
              if (typeof val === 'object') return JSON.stringify(val);
              return val;
            });
            sheetArray.push(rowArray);
          });
          var ws = XLSX.utils.aoa_to_sheet(sheetArray);
          // v1.6.33: Apply column widths
          var colWidths = sheetData.headers.map(function(h) {
            return { wch: Math.min(30, Math.max(10, h.length + 2)) };
          });
          ws['!cols'] = colWidths;
          XLSX.utils.book_append_sheet(wb, ws, sheetName.substring(0, 31));
        });
        
        // v1.6.33: Add _change_log sheet with all changes
        var changeLogWs = buildChangeLogSheet();
        if (changeLogWs) {
          XLSX.utils.book_append_sheet(wb, changeLogWs, '_change_log');
        }
        
        // v1.6.33: Add RFIs & Analyst Notes sheet
        var rfiWs = buildRFISheet();
        if (rfiWs) {
          XLSX.utils.book_append_sheet(wb, rfiWs, 'RFIs & Analyst Notes');
        }
        
        // v1.6.33: Add Signals Summary sheet
        var signalsWs = buildSignalsSummarySheet();
        if (signalsWs) {
          XLSX.utils.book_append_sheet(wb, signalsWs, '_signals_summary');
        }
        
        // v1.6.33: Add Orchestrate OS Metadata sheet
        var metaWs = buildMetadataSheet();
        XLSX.utils.book_append_sheet(wb, metaWs, '_orchestrate_meta');
        
        // v1.6.59: Add Audit_Log sheet
        var auditWs = buildAuditLogSheet();
        if (auditWs) {
          XLSX.utils.book_append_sheet(wb, auditWs, 'Audit_Log');
        }

        // Generate filename with timestamp
        var datasetName = IDENTITY_CONTEXT.dataset_id || 'dataset';
        var timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        var filename = 'orchestrate_' + datasetName + '_' + timestamp + '.xlsx';
        
        // Download file
        XLSX.writeFile(wb, filename);
        
        showToast('Exported: ' + filename, 'success');
        console.log('[Export] Generated:', filename, 'sheets:', wb.SheetNames.length);
        
      } catch (err) {
        console.error('[Export] Error:', err);
        showToast('Export failed: ' + err.message, 'error');
      }
    }
    
    // v1.6.33: Build _change_log sheet from patch requests and changeMap
    function buildChangeLogSheet() {
      var headers = [
        'record_id', 'sheet', 'field', 'change_type', 'old_value', 'new_value',
        'reason', 'analyst', 'timestamp', 'status', 'request_id'
      ];
      var rows = [headers];
      
      // Get all patch requests
      var patchRequests = PATCH_REQUEST_STORE.list();
      patchRequests.forEach(function(pr) {
        var row = [
          pr.record_id || '',
          pr.sheet || '',
          pr.field || '',
          pr.type || 'correction',
          pr.old_value || '',
          pr.new_value || '',
          pr.justification || pr.comment || '',
          pr.analyst || getCurrentUserName(),
          pr.created_at_utc || '',
          pr.status || 'Draft',
          pr.request_id || ''
        ];
        rows.push(row);
      });
      
      // Also include changeMap entries if available
      if (typeof changeMap !== 'undefined' && changeMap.changes) {
        Object.keys(changeMap.changes).forEach(function(recordId) {
          var recordChanges = changeMap.changes[recordId];
          Object.keys(recordChanges).forEach(function(field) {
            var change = recordChanges[field];
            var row = [
              recordId,
              change.sheet || '',
              field,
              change.type || 'correction',
              change.old_value || '',
              change.new_value || '',
              change.notes || '',
              change.analyst || '',
              change.timestamp || '',
              'Applied',
              ''
            ];
            rows.push(row);
          });
        });
      }
      
      if (rows.length <= 1) return null;
      
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(25, Math.max(12, h.length + 2)) };
      });
      return ws;
    }
    
    // v1.6.33: Build RFIs & Analyst Notes sheet (includes all escalations)
    function buildRFISheet() {
      var headers = [
        'record_id', 'sheet', 'field', 'type', 'comment_or_question', 'current_value',
        'submitted_by', 'submitted_at', 'escalated_to', 'escalation_status',
        'response', 'resolved_by', 'resolved_at'
      ];
      var rows = [headers];
      
      // v1.6.33: Include ALL patch requests that have been promoted/escalated
      // This tracks the full escalation trail through the role hierarchy
      var patchRequests = PATCH_REQUEST_STORE.list();
      
      patchRequests.forEach(function(pr) {
        // Determine escalation status based on patch request status
        var escalationStatus = 'Draft';
        var escalatedTo = '';
        
        // Map status to escalation level
        if (pr.status === 'Submitted' || pr.status === 'Pending_Review') {
          escalationStatus = 'Analyst -> Verifier';
          escalatedTo = 'Verifier';
        } else if (pr.status === 'Needs_Clarification') {
          escalationStatus = 'Verifier -> Analyst (Returned)';
          escalatedTo = 'Analyst';
        } else if (pr.status === 'Verifier_Approved' || pr.status === 'Sent_to_Admin') {
          escalationStatus = 'Verifier -> Admin';
          escalatedTo = 'Admin';
        } else if (pr.status === 'Admin_Approved' || pr.status === 'Promoted') {
          escalationStatus = 'Approved & Promoted';
          escalatedTo = 'Baseline';
        } else if (pr.status === 'Admin_Rejected' || pr.status === 'Rejected') {
          escalationStatus = 'Rejected';
          escalatedTo = 'Closed';
        } else if (pr.status === 'Admin_Hold') {
          escalationStatus = 'On Hold (Admin)';
          escalatedTo = 'Admin';
        } else if (pr.status === 'Draft') {
          escalationStatus = 'Draft (Not Submitted)';
          escalatedTo = '';
        }
        
        var row = [
          pr.record_id || '',
          pr.sheet || '',
          pr.field || '',
          pr.type || 'correction',
          pr.comment || pr.justification || pr.question || '',
          pr.current_value || pr.old_value || '',
          pr.analyst || pr.submitted_by || getCurrentUserName(),
          pr.created_at_utc || '',
          escalatedTo,
          escalationStatus,
          pr.response || pr.verifier_notes || '',
          pr.resolved_by || pr.approved_by || '',
          pr.resolved_at || pr.updated_at_utc || ''
        ];
        rows.push(row);
      });
      
      if (rows.length <= 1) return null;
      
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(30, Math.max(12, h.length + 2)) };
      });
      return ws;
    }
    
    // v1.6.33: Build Signals Summary sheet
    function buildSignalsSummarySheet() {
      var headers = [
        'record_id', 'sheet', 'field', 'signal_type', 'severity', 'message', 'value'
      ];
      var rows = [headers];
      
      if (typeof signalStore !== 'undefined' && signalStore.signals_by_cell) {
        Object.keys(signalStore.signals_by_cell).forEach(function(recordId) {
          var recordSignals = signalStore.signals_by_cell[recordId];
          Object.keys(recordSignals).forEach(function(field) {
            var signals = recordSignals[field];
            signals.forEach(function(sig) {
              var row = [
                recordId,
                sig.sheet || '',
                field,
                sig.signal_type || '',
                sig.severity || 'info',
                sig.message || '',
                sig.value || ''
              ];
              rows.push(row);
            });
          });
        });
      }
      
      if (rows.length <= 1) return null;
      
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(25, Math.max(12, h.length + 2)) };
      });
      return ws;
    }
    
    // v1.6.33: Build Orchestrate OS Metadata sheet
    function buildMetadataSheet() {
      var metadata = [
        ['Orchestrate OS Export Metadata'],
        [''],
        ['Property', 'Value'],
        ['Export Date', new Date().toISOString()],
        ['Export Version', 'v2.2-P2'],
        ['Dataset ID', IDENTITY_CONTEXT.dataset_id || ''],
        ['Tenant ID', IDENTITY_CONTEXT.tenant_id || ''],
        ['Division ID', IDENTITY_CONTEXT.division_id || ''],
        ['Total Sections', workbook.order.length],
        ['Data Sections', getDataSheets().length],
        ['Meta Sections', getMetaSheets().length],
        ['Total Records', getTotalRecordCount()],
        ['Signal Count', signalStore && signalStore.stats ? signalStore.stats.total : 0],
        ['Patch Requests', PATCH_REQUEST_STORE.list().length],
        [''],
        ['Section Order'],
        ...workbook.order.map(function(s, i) { return [(i + 1), s]; }),
        [''],
        ['Signal Types'],
        ...Object.entries(signalStore && signalStore.stats && signalStore.stats.by_type ? signalStore.stats.by_type : {}).map(function(e) { return [e[0], e[1]]; }),
        [''],
        ['Nomenclature'],
        ['System Name', 'Orchestrate OS'],
        ['Purpose', 'Semantic Control Board'],
        ['Mode', 'Governance-only control plane'],
        ['Join Strategy', 'contract_key -> file_url -> file_name']
      ];
      
      var ws = XLSX.utils.aoa_to_sheet(metadata);
      ws['!cols'] = [{ wch: 25 }, { wch: 50 }];
      return ws;
    }
    
    // v1.6.59: Build Audit_Log sheet from AuditTimeline store
    function buildAuditLogSheet() {
      var events = AuditTimeline._memCache.filter(function(ev) {
        return !IDENTITY_CONTEXT.dataset_id || ev.dataset_id === IDENTITY_CONTEXT.dataset_id || ev.dataset_id === '';
      });
      if (events.length === 0) return null;

      events.sort(function(a, b) { return a.timestamp_iso < b.timestamp_iso ? -1 : 1; });

      var headers = ['event_id', 'event_type', 'actor_id', 'actor_role', 'timestamp_iso',
        'dataset_id', 'file_id', 'record_id', 'field_key', 'patch_request_id',
        'before_value', 'after_value', 'metadata'];
      var rows = [headers];
      events.forEach(function(ev) {
        rows.push(headers.map(function(h) {
          var v = ev[h];
          if (v === null || v === undefined) return '';
          if (typeof v === 'object') return JSON.stringify(v);
          return String(v);
        }));
      });

      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(35, Math.max(12, h.length + 4)) };
      });
      return ws;
    }

    // v1.6.33: Get total record count across all sheets
    function getTotalRecordCount() {
      var count = 0;
      if (workbook && workbook.sheets) {
        Object.keys(workbook.sheets).forEach(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          if (sheet && sheet.rows) {
            count += sheet.rows.length;
          }
        });
      }
      return count;
    }

    // v1.4.13: Update cache display with formatted size
    function updateCacheDisplay() {
      var countEl = document.getElementById('cache-pdf-count');
      var sizeEl = document.getElementById('cache-storage-used');
      if (countEl) countEl.textContent = cacheState.pdfCount;
      if (sizeEl) sizeEl.textContent = formatCacheSize(cacheState.totalBytes);
    }
    
    function loadFromData(data, sourceType, fileName) {
      // Start staged loader for this path
      stagedLoader.start();
      stagedLoader.setStage('loading');
      
      if (!data || (!data.sf_summary && !data.sf_contract_results && !data.sf_issues && !data.sf_field_actions)) {
        stagedLoader.finish();
        throw new Error('Invalid data format - expected Preview Packet structure');
      }
      
      stagedLoader.setStage('standardizing');
      
      sessionState.status = 'loaded';
      sessionState.sourceType = sourceType;
      sessionState.loadedAt = Date.now();
      sessionState.previewData = data;
      sessionState.fileName = fileName || null;
      
      allData.contractResults = sortByJoinTriplet(data.sf_contract_results || []);
      // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
      allData.issues = filterOutReferenceData(sortBySeverityFirst(data.sf_issues || [], ['sheet', 'field', 'issue_type']));
      allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(data.sf_field_actions || [], ['sheet', 'field', 'action']));
      allData.changeLog = sortBySeverityFirst(data.sf_change_log || [], ['sheet', 'field', 'notes']);
      allData.summary = data.sf_summary || {};
      
      renderSummary(data.sf_summary || {});
      populateSubtypeDropdown();
      
      // Rendering stage
      stagedLoader.setStage('rendering');
      renderAllTables();
      
      dataLoaded = true;
      currentArtifactPath = fileName || sourceType;
      updateUIForDataState();
      updateSessionChip();
      
      // v1.5.3: Persist all records to canonical store
      persistAllRecordsToStore();
      
      // v1.6.0: Generate signals for dataset
      generateSignalsForDataset();
      
      // v1.6.33: Seed patch requests from RFI meta sheet (if present in modified dataset)
      seedPatchRequestsFromMetaSheet();

      // v2.3.5-P1F: Batch PDF scan
      if (typeof _p1fBatchPdfScan === 'function') _p1fBatchPdfScan();
      
      // Finish staged loader
      stagedLoader.finish();
      
      // Detect unknown columns for Admin (uses current dataset with sheet awareness)
      if (typeof detectUnknownColumns === 'function') {
        detectUnknownColumns();
      }
      
      // Persist to localStorage if enabled
      const rememberChecked = (document.getElementById('remember-session') || {}).checked;
      if (rememberChecked) {
        try {
          localStorage.setItem(STORAGE_KEY_SESSION, JSON.stringify({
            status: sessionState.status,
            sourceType: sessionState.sourceType,
            loadedAt: sessionState.loadedAt,
            fileName: sessionState.fileName,
            previewData: data,
            rememberEnabled: true
          }));
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
      } else {
        // Clear any existing session if user unchecked remember
        try {
          localStorage.removeItem(STORAGE_KEY_SESSION);
        } catch (e) {}
      }
      
      closeDataSourceDrawer();
      showWizardStatus('data-source-status', 'Data loaded successfully!', 'success');
    }
    
    function resetSession() {
      sessionState.status = 'not-loaded';
      sessionState.sourceType = null;
      sessionState.loadedAt = null;
      sessionState.previewData = null;
      sessionState.expectedData = null;
      sessionState.fileName = null;
      
      dataLoaded = false;
      currentArtifactPath = '';
      currentDataset = null;
      
      // Reset workbook (v1.4.3)
      resetWorkbook();
      
      allData.contractResults = [];
      allData.issues = [];
      allData.fieldActions = [];
      allData.changeLog = [];
      allData.summary = {};
      
      // Clear only app-namespaced localStorage keys (keep patch draft)
      try {
        localStorage.removeItem(STORAGE_KEY_SESSION);
        localStorage.removeItem('orchestrate.dataset.v1');
        localStorage.removeItem('orchestrate.pdf_attachments.v1');
      } catch (e) {}
      
      updateUIForDataState();
      updateSessionChip();
      updateProgressBlock();
      renderAllTables();
      
      // Reset modal fields (if they exist)
      const previewPaste = document.getElementById('preview-paste-area');
      const expectedPaste = document.getElementById('expected-paste-area');
      const previewDropFile = document.getElementById('preview-drop-file');
      const expectedDropFile = document.getElementById('expected-drop-file');
      const previewDropLoad = document.getElementById('preview-drop-load');
      const expectedDropLoad = document.getElementById('expected-drop-load');
      const previewStatus = document.getElementById('preview-status');
      const expectedStatus = document.getElementById('expected-status');
      
      if (previewPaste) previewPaste.value = '';
      if (expectedPaste) expectedPaste.value = '';
      if (previewDropFile) previewDropFile.textContent = '';
      if (expectedDropFile) expectedDropFile.textContent = '';
      if (previewDropLoad) previewDropLoad.disabled = true;
      if (expectedDropLoad) expectedDropLoad.disabled = true;
      if (previewStatus) {
        previewStatus.textContent = 'Not Loaded';
        previewStatus.className = 'loader-section-status empty';
      }
      if (expectedStatus) {
        expectedStatus.textContent = 'Not Loaded';
        expectedStatus.className = 'loader-section-status empty';
      }
      
      // Navigate to loader after reset
      navigateTo('loader');
      showWizardStatus('data-source-status', 'Session reset. Patch draft preserved.', 'info');
    }
    
    function restoreSessionFromStorage() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY_SESSION);
        if (stored) {
          const session = JSON.parse(stored);
          // Only restore if rememberEnabled was true when saved (opt-in check)
          if (session.previewData && session.rememberEnabled) {
            // Set checkbox to match saved preference
            const rememberCheckbox = document.getElementById('remember-session');
            if (rememberCheckbox) rememberCheckbox.checked = true;
            
            // Load data without re-saving to localStorage
            sessionState.status = 'loaded';
            sessionState.sourceType = session.sourceType;
            sessionState.loadedAt = session.loadedAt;
            sessionState.previewData = session.previewData;
            sessionState.fileName = session.fileName;
            
            const data = session.previewData;
            allData.contractResults = sortByJoinTriplet(data.sf_contract_results || []);
            // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
            allData.issues = filterOutReferenceData(sortBySeverityFirst(data.sf_issues || [], ['sheet', 'field', 'issue_type']));
            allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(data.sf_field_actions || [], ['sheet', 'field', 'action']));
            allData.changeLog = sortBySeverityFirst(data.sf_change_log || [], ['sheet', 'field', 'notes']);
            allData.summary = data.sf_summary || {};
            
            renderSummary(data.sf_summary || {});
            populateSubtypeDropdown();
            renderAllTables();
            
            dataLoaded = true;
            currentArtifactPath = session.fileName || session.sourceType;
            updateUIForDataState();
            updateSessionChip();
            
            // v1.5.3: Persist all records to canonical store
            persistAllRecordsToStore();
            
            // v1.6.0: Generate signals for dataset
            generateSignalsForDataset();
            
            // v1.6.33: Seed patch requests from RFI meta sheet
            seedPatchRequestsFromMetaSheet();

            // v2.3.5-P1F: Batch PDF scan on session restore
            if (typeof _p1fBatchPdfScan === 'function') _p1fBatchPdfScan();
            
            return true;
          }
        }
      } catch (e) {
        console.warn('Could not restore session:', e);
      }
      return false;
    }
    
    function setupLoaderHandlers() {
      // Tab switching within loader sections
      document.querySelectorAll('.loader-tabs').forEach(tabContainer => {
        tabContainer.addEventListener('click', e => {
          const tab = e.target.closest('.loader-tab');
          if (!tab) return;
          const panelId = tab.dataset.panel;
          tabContainer.querySelectorAll('.loader-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const section = tabContainer.closest('.loader-section');
          if (section) {
            section.querySelectorAll('.loader-panel').forEach(p => p.classList.remove('active'));
          }
          var _panelEl = document.getElementById(panelId); if (_panelEl) _panelEl.classList.add('active');
        });
      });
      
      // Preview paste load (guard with null check - may not exist)
      var previewPasteBtn = document.getElementById('preview-paste-load');
      if (previewPasteBtn) {
        previewPasteBtn.addEventListener('click', function() {
          var text = document.getElementById('preview-paste-area').value.trim();
          if (!text) {
            showWizardStatus('data-source-status', 'Please paste JSON first', 'error');
            return;
          }
          try {
            var data = JSON.parse(text);
            loadFromData(data, 'paste', null);
          } catch (e) {
            showWizardStatus('data-source-status', 'Invalid JSON: ' + e.message, 'error');
          }
        });
      }
      
      // Preview drop zone (guard with null check - may not exist)
      var previewDropZone = document.getElementById('preview-drop-zone');
      var previewFileInput = document.getElementById('preview-file-input');
      var previewFileData = null;
      
      if (previewDropZone && previewFileInput) {
        var previewFileData = null;
        
        previewDropZone.addEventListener('click', function() { previewFileInput.click(); });
        previewDropZone.addEventListener('dragover', function(e) {
          e.preventDefault();
          previewDropZone.classList.add('drag-over');
        });
        previewDropZone.addEventListener('dragleave', function() {
          previewDropZone.classList.remove('drag-over');
        });
        previewDropZone.addEventListener('drop', function(e) {
          e.preventDefault();
          previewDropZone.classList.remove('drag-over');
          var file = e.dataTransfer.files[0];
          if (file) handlePreviewFile(file);
        });
        previewFileInput.addEventListener('change', function(e) {
          var file = e.target.files[0];
          if (file) handlePreviewFile(file);
        });
        
        function handlePreviewFile(file) {
          var reader = new FileReader();
          reader.onload = function(e) {
            try {
              previewFileData = JSON.parse(e.target.result);
              var fileEl = document.getElementById('preview-drop-file');
              if (fileEl) fileEl.textContent = file.name;
              previewDropZone.classList.add('has-file');
              var loadBtn = document.getElementById('preview-drop-load');
              if (loadBtn) loadBtn.disabled = false;
              sessionState.fileName = file.name;
            } catch (err) {
              showWizardStatus('data-source-status', 'Invalid JSON file: ' + err.message, 'error');
            }
          };
          reader.readAsText(file);
        }
        
        var previewLoadBtn = document.getElementById('preview-drop-load');
        if (previewLoadBtn) {
          previewLoadBtn.addEventListener('click', function() {
            if (previewFileData) {
              loadFromData(previewFileData, 'drop', sessionState.fileName);
            }
          });
        }
      }
      
      // Expected paste load (guard all with null checks)
      var expectedPasteBtn = document.getElementById('expected-paste-load');
      if (expectedPasteBtn) {
        expectedPasteBtn.addEventListener('click', function() {
          var textarea = document.getElementById('expected-paste-area');
          var text = textarea ? textarea.value.trim() : '';
          if (!text) {
            showWizardStatus('data-source-status', 'Please paste expected JSON first', 'error');
            return;
          }
          try {
            var data = JSON.parse(text);
            sessionState.expectedData = data;
            var statusEl = document.getElementById('expected-status');
            if (statusEl) {
              statusEl.textContent = 'Loaded';
              statusEl.className = 'loader-section-status loaded';
            }
            showWizardStatus('data-source-status', 'Expected data loaded for comparison', 'success');
          } catch (e) {
            showWizardStatus('data-source-status', 'Invalid JSON: ' + e.message, 'error');
          }
        });
      }
      
      // Expected drop zone (guard all with null checks)
      var expectedDropZone = document.getElementById('expected-drop-zone');
      var expectedFileInput = document.getElementById('expected-file-input');
      
      if (expectedDropZone && expectedFileInput) {
        var expectedFileData = null;
        
        expectedDropZone.addEventListener('click', function() { expectedFileInput.click(); });
        expectedDropZone.addEventListener('dragover', function(e) {
          e.preventDefault();
          expectedDropZone.classList.add('drag-over');
        });
        expectedDropZone.addEventListener('dragleave', function() {
          expectedDropZone.classList.remove('drag-over');
        });
        expectedDropZone.addEventListener('drop', function(e) {
          e.preventDefault();
          expectedDropZone.classList.remove('drag-over');
          var file = e.dataTransfer.files[0];
          if (file) handleExpectedFile(file);
        });
        expectedFileInput.addEventListener('change', function(e) {
          var file = e.target.files[0];
          if (file) handleExpectedFile(file);
        });
        
        function handleExpectedFile(file) {
          var reader = new FileReader();
          reader.onload = function(e) {
            try {
              expectedFileData = JSON.parse(e.target.result);
              var fileEl = document.getElementById('expected-drop-file');
              if (fileEl) fileEl.textContent = file.name;
              expectedDropZone.classList.add('has-file');
              var loadBtn = document.getElementById('expected-drop-load');
              if (loadBtn) loadBtn.disabled = false;
            } catch (err) {
              showWizardStatus('data-source-status', 'Invalid JSON file: ' + err.message, 'error');
            }
          };
          reader.readAsText(file);
        }
        
        var expectedLoadBtn = document.getElementById('expected-drop-load');
        if (expectedLoadBtn) {
          expectedLoadBtn.addEventListener('click', function() {
            if (expectedFileData) {
              sessionState.expectedData = expectedFileData;
              var statusEl = document.getElementById('expected-status');
              if (statusEl) {
                statusEl.textContent = 'Loaded';
                statusEl.className = 'loader-section-status loaded';
              }
              showWizardStatus('data-source-status', 'Expected data loaded for comparison', 'success');
            }
          });
        }
      }
      
      // Path hint preset buttons
      document.querySelectorAll('#preview-path .wizard-preset-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var input = document.getElementById('preview-path-input');
          if (input) input.value = btn.dataset.path;
        });
      });
      
      // Reset session button (guard with null check)
      var resetBtn = document.getElementById('reset-session-btn');
      if (resetBtn) {
        resetBtn.addEventListener('click', function() {
          if (confirm('Reset session? This clears loaded artifacts but keeps your patch draft.')) {
            resetSession();
          }
        });
      }
    }

    // ========== APP SESSION STATE MACHINE (V1.2.8) ==========
    var currentPage = 'loader';
    
    function getAppSessionState() {
      // Returns current session state for route guard checks
      // Use dataLoaded as primary check - simpler and more reliable than bundle check
      return {
        active_dataset_id: localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET) || null,
        data_loaded: dataLoaded,
        current_page: currentPage,
        current_mode: currentMode
      };
    }
    
    function checkRouteRequirements(page) {
      // Check if route requirements are met
      // Use dataLoaded instead of bundle presence (more reliable)
      var requirements = {
        'triage': { needsData: true },
        'patch': { needsData: true },
        'review': { needsData: true },
        'admin': { needsData: false },
        'loader': { needsData: false }
      };
      
      var pageReqs = requirements[page] || { needsData: false };
      
      if (pageReqs.needsData && !dataLoaded) {
        return { valid: false, missing: 'data_loaded' };
      }
      return { valid: true };
    }
    
    function updateDebugHUD() {
      var hud = document.getElementById('debug-hud');
      if (!hud) return;
      var state = getAppSessionState();
      hud.innerHTML = 'Route: ' + currentPage + ' | Data: ' + (dataLoaded ? 'Yes' : 'No') + ' | Mode: ' + currentMode;
    }
    
    function pageRequiresDataset(page) {
      return ['triage', 'patch', 'review'].includes(page);
    }

    function navigateTo(page, options) {
      options = options || {};
      // Loader is now a drawer, not a page - redirect loader requests to triage
      if (page === 'loader') page = 'triage';
      var pages = ['triage', 'grid', 'patch', 'review', 'verifier-review', 'admin-review', 'admin-approval', 'admin', 'row', 'restricted'];
      
      // v1.5.3: Reset verifier SRR mode when navigating away from row page
      if (!page.startsWith('row') && srrState.verifierMode) {
        resetVerifierSRRMode();
      }
      
      // Handle row/:id routes
      // v1.4.16: Validate rowId - reject undefined/NaN/empty
      if (page.startsWith('row/')) {
        var rowId = page.split('/')[1];
        if (!rowId || rowId === 'undefined' || rowId === 'null' || rowId === 'NaN') {
          console.warn('[Navigate] Invalid row route ignored:', page);
          navigateTo('triage');
          return;
        }
        // v1.4.16: If SRR already open with same row, skip re-open (prevents hashchange loop failures)
        if (srrState.currentRowId !== null && String(srrState.currentRowId) === String(rowId) && srrState.currentSheetName) {
          console.log('[Navigate] SRR already open for row:', rowId, 'sheet:', srrState.currentSheetName);
          return;
        }
        // v1.4.16: If srrState has sheetName from prior open, use it for resolution
        if (srrState.currentSheetName && typeof rowId === 'string') {
          var idx = parseInt(rowId, 10);
          if (!isNaN(idx)) {
            openRowReviewDrawer(srrState.currentSheetName, idx);
            _expandTriageSubnav();
            return;
          }
        }
        openRowReviewDrawer(rowId);
        _expandTriageSubnav();
        return;
      }
      if (!pages.includes(page)) page = dataLoaded ? 'grid' : 'triage';
      
      console.log('[Navigate] Attempting navigation to: ' + page + ', dataLoaded: ' + dataLoaded);
      
      // For pages needing data, we still show the page but with empty state
      // No hard redirect - triage handles its own empty state with "Load Data" CTA
      
      // Parse admin tab from route (e.g., admin/standardizer -> tab=standardizer)
      var adminTab = null;
      if (page.startsWith('admin/')) {
        var parts = page.split('/');
        page = 'admin';
        adminTab = parts[1] || 'governance';
      }
      
      // v1.4.22: RBAC route guards - show Access Restricted page with specific message
      var restrictedReason = null;
      if (page === 'admin' && currentMode !== 'admin' && currentMode !== 'architect') {
        console.log('[Navigate] Admin page requires admin mode');
        restrictedReason = 'The Admin Panel is only available to users with the Admin role.';
        adminTab = null;
      }
      if (page === 'review' && currentMode !== 'verifier' && currentMode !== 'admin') {
        console.log('[Navigate] Review page requires verifier/admin mode');
        restrictedReason = 'Config Inspector is only available to Verifiers and Admins.';
      }
      if (page === 'verifier-review' && currentMode !== 'verifier' && currentMode !== 'admin') {
        console.log('[Navigate] Verifier Review page requires verifier/admin mode');
        restrictedReason = 'Verifier Review is only available to Verifiers and Admins.';
      }
      if (page === 'admin-approval' && currentMode !== 'admin') {
        console.log('[Navigate] Admin Approval page requires admin mode');
        restrictedReason = 'Admin Approval is only available to users with the Admin role.';
      }
      if (page === 'patch' && currentMode !== 'analyst') {
        console.log('[Navigate] Patch Studio requires analyst mode');
        restrictedReason = 'Patch Studio is only available to Analysts. Verifiers and Admins review patches submitted by Analysts.';
      }
      
      // If restricted, show access restricted page
      if (restrictedReason) {
        page = 'restricted';
        var msgEl = document.getElementById('restricted-message');
        if (msgEl) msgEl.textContent = restrictedReason;
      }
      // v1.5.1: Admin Review route (reuses verifier-review page with admin label)
      if (page.startsWith('admin-review/') || page === 'admin-review') {
        if (currentMode !== 'admin') {
          console.log('[Navigate] Admin Review page requires admin mode');
          page = 'restricted';
          var msgEl2 = document.getElementById('restricted-message');
          if (msgEl2) msgEl2.textContent = 'Admin Review is only available to users with the Admin role.';
        } else {
          // Extract artifact ID and load for admin review
          var artifactId = page.split('/')[1];
          if (artifactId) {
            loadAdminReviewData(artifactId);
          }
          // Use verifier-review page but with admin context
          page = 'verifier-review';
        }
      }
      
      // Update current page tracking
      currentPage = page;
      
      saveNavStateToCache(); scheduleAutosave();
      // Clear all pages first - MUST reset both class AND inline style
      document.querySelectorAll('.page').forEach(function(p) { 
        p.classList.remove('active'); 
        p.style.display = 'none';  // Reset inline style to ensure CSS takes over
      });
      document.querySelectorAll('.page-content').forEach(function(p) { p.style.display = 'none'; });
      document.querySelectorAll('.nav-item').forEach(function(n) { n.classList.remove('active'); });
      
      var pageEl = document.getElementById('page-' + page);
      var navEl = document.querySelector('.nav-item[data-page="' + page + '"]');
      
      console.log('[Navigate] Showing page element: page-' + page + ', found: ' + (pageEl ? 'yes' : 'no'));
      
      if (pageEl) {
        pageEl.classList.add('active');
        pageEl.style.display = 'block';
      }
      if (navEl) navEl.classList.add('active');

      var triageSubnav = document.getElementById('triage-subnav');
      var triageParent = document.querySelector('.nav-parent[data-page="triage"]');
      if (triageSubnav && triageParent) {
        if (page === 'grid') {
          triageSubnav.classList.add('expanded');
          triageParent.classList.add('expanded');
          triageParent.classList.add('active');
        } else if (page !== 'triage') {
          triageSubnav.classList.remove('expanded');
          triageParent.classList.remove('expanded');
        }
      }
      if (page === 'grid') {
        _populateGridSections();
        _expandGridSections();
        if (!gridState.sheet) {
          document.querySelectorAll('#grid-sections-nav .nav-section-link').forEach(function(el) { el.classList.remove('active'); });
        }
      } else {
        _collapseGridSections();
      }
      
      // Show empty queue message on triage if no data loaded
      var emptyMsg = document.getElementById('empty-queue-message');
      if (emptyMsg) {
        if (page === 'triage' && !dataLoaded) {
          emptyMsg.classList.remove('hidden');
        } else {
          emptyMsg.classList.add('hidden');
        }
      }
      
      // Update debug HUD
      updateDebugHUD();
      
      // DEV-ONLY: Assert no admin sections render inside triage
      if (page === 'triage') {
        var triageEl = document.getElementById('page-triage');
        if (triageEl) {
          var adminSectionsInTriage = triageEl.querySelectorAll('[data-admin-section="true"]');
          if (adminSectionsInTriage.length > 0) {
            console.error('[DEV ASSERTION FAILED] Found ' + adminSectionsInTriage.length + ' admin sections inside triage page!');
          }
        }
      }
      
      // If navigating to admin with a specific tab, switch to it
      if (page === 'admin') {
        // Update admin queue count
        updatePatchQueueCount();
        if (adminTab) {
          switchAdminTab(adminTab);
        }
      }
      
      // v1.5.1: Show/hide Patch Tester tab based on role when entering SSR
      if (page === 'row') {
        srrShowPatchTesterTabs();
      }
      
      // If navigating to grid, initialize grid
      if (page === 'grid') {
        setTimeout(function() { 
          initGrid(); 
          // v1.5.2: Initialize verifier grid mode
          if (currentMode === 'verifier') {
            initVerifierGridFilters();
            renderVerifierGrid();
          }
        }, 0);
      }
      
      // If navigating to verifier-review, load data (only if we have a payload or haven't loaded yet)
      if (page === 'verifier-review') {
        // v1.5.1: Reset header/buttons if not in admin review mode
        if (!vrState.isAdminReview) {
          var headerEl = document.querySelector('#page-verifier-review h2');
          if (headerEl) headerEl.textContent = 'Verifier Review';
          var descEl = document.querySelector('#page-verifier-review .page-desc');
          if (descEl) descEl.textContent = 'Review submitted Patch Requests, request clarification, approve or reject.';
          resetVerifierReviewButtons();
        }
        
        setTimeout(function() {
          // Skip re-loading if we already have a loaded payload and no new selection
          if (!vrState.selectedPayloadId && vrState.currentPayload) {
            console.log('[VR_LOAD] Skipping reload - already have payload:', vrState.currentPayload.id || vrState.currentPatchId);
            return;
          }
          loadVerifierReviewData(vrState.selectedPayloadId);
          vrState.selectedPayloadId = null;  // Clear after use
        }, 0);
      }
      
      // If navigating to admin-approval, load sample data
      if (page === 'admin-approval') {
        setTimeout(function() { loadAdminApprovalData(); }, 0);
      }
      
      // Update hash (include tab for admin deep-links, preserve grid query params)
      if (page === 'admin' && adminTab && adminTab !== 'governance') {
        window.location.hash = '#/admin/' + adminTab;
      } else if (page === 'grid' && options.queryParams) {
        window.location.hash = '#/grid?' + options.queryParams;
      } else {
        window.location.hash = '#/' + page;
      }
    }
    
    // Navigate to grid with filter (for Triage alert lens)
    function navigateToGridFiltered(filter, sheet) {
      var params = [];
      if (filter && filter !== 'all') params.push('f=' + encodeURIComponent(filter));
      if (sheet) params.push('sheet=' + encodeURIComponent(sheet));
      navigateTo('grid', { queryParams: params.join('&') });
    }
    
    function recoverNavigation() {
      var currentHash = window.location.hash.replace('#/', '') || 'grid';
      // Loader is now a drawer, redirect appropriately
      if (currentHash === 'loader') currentHash = 'grid';
      // Handle grid query params
      if (currentHash.startsWith('grid?')) {
        var queryPart = currentHash.split('?')[1];
        gridState.filter = 'all';
        gridState.sheet = '';
        gridState.search = '';
        if (queryPart) {
          var params = new URLSearchParams(queryPart);
          gridState.filter = params.get('f') || 'all';
          gridState.sheet = params.get('sheet') || '';
          gridState.search = params.get('q') || '';
        }
        currentHash = 'grid';
      }
      console.log('[RecoverNav] Recovering to: ' + currentHash);
      navigateTo(currentHash);
      return true;
    }

    // v1.6.22: Get the logged-in user's actual role (from landing page login)
    // Priority: demoUser.role (from login) > currentRole (from session) > fallback
    function getLoggedInUserRole() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        if (demoUser.role) {
          return demoUser.role.toLowerCase();
        }
      } catch (e) {}
      
      // Fallback to currentRole if demoUser is missing
      var currentRole = localStorage.getItem('currentRole');
      if (currentRole) {
        return currentRole.toLowerCase();
      }
      
      return '';
    }
    
    // v1.6.22: Apply role-based restrictions to mode switcher
    // Analyst/Verifier: locked to their role, cannot switch
    // Admin: full "God mode" - can switch between all roles (when Playground enabled)
    var roleRestrictionsApplied = false;
    
    // v1.6.25: Check if user is in demo session (came from /ui/demo/)
    function isDemoSession() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        return demoUser.isDemo === true;
      } catch (e) {
        return false;
      }
    }
    
    function isLocalSession() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        return demoUser.isLocal === true;
      } catch (e) {
        return false;
      }
    }
    
    // v1.6.25: Handle sign out - redirect to appropriate landing page
    function handleSignOut(event) {
      event.preventDefault();
      var isDemo = isDemoSession();
      var isLocal = isLocalSession();
      localStorage.removeItem('currentRole');
      localStorage.removeItem('demoUser');
      localStorage.removeItem('ingestion_folder_name');
      localStorage.removeItem('orchestrate_nav_state');
      localStorage.removeItem('viewer_mode_v10');
      localStorage.removeItem('orchestrate_srr_state');
      localStorage.removeItem('orchestrate_group_collapsed');
      var keysToRemove = [];
      for (var i = 0; i < localStorage.length; i++) {
        var k = localStorage.key(i);
        if (k && (k.indexOf('workbook_session_') === 0 || k.indexOf('orchestrate_artifact_') === 0)) {
          keysToRemove.push(k);
        }
      }
      keysToRemove.forEach(function(k) { localStorage.removeItem(k); });
      try {
        if (typeof SessionDB !== 'undefined' && SessionDB.clearWorkbookCache) SessionDB.clearWorkbookCache().catch(function(){});
        if (typeof workbook !== 'undefined') { workbook = { sheets: {}, order: [] }; }
        if (typeof dataLoaded !== 'undefined') dataLoaded = false;
        if (typeof ContractIndex !== 'undefined' && ContractIndex.clear) ContractIndex.clear();
      } catch(e) { console.warn('[SignOut] cleanup error:', e); }
      window.location.href = isDemo ? '/ui/demo/' : '/ui/landing/';
    }
    
    // v1.6.24: Check if playground mode is enabled for admin
    function isPlaygroundEnabled() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        // In demo mode, only Admin gets playground (role switching)
        if (demoUser.isDemo === true) return demoUser.role === 'admin';
        return demoUser.playgroundEnabled === true;
      } catch (e) {
        return false;
      }
    }
    
    // v1.6.24: Set playground mode for admin
    function setPlaygroundEnabledFlag(enabled) {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        demoUser.playgroundEnabled = enabled;
        localStorage.setItem('demoUser', JSON.stringify(demoUser));
      } catch (e) {
        console.error('[Playground] Failed to save state:', e);
      }
    }
    
    // v1.6.33: Get current user's display name for audit/export attribution
    function getCurrentUserName() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        // Priority: name > email prefix > role-based default
        if (demoUser.name && demoUser.name.trim()) {
          return demoUser.name.trim();
        }
        if (demoUser.email) {
          // Extract name from email (e.g., "john.doe@company.com" -> "John Doe")
          var emailPrefix = demoUser.email.split('@')[0];
          return emailPrefix.replace(/[._]/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
        }
        // Fallback to role-based name
        var role = getCurrentRole();
        return role.charAt(0).toUpperCase() + role.slice(1);
      } catch (e) {
        return 'Analyst';
      }
    }
    
    function updateSidebarUserProfile() {
      var nameEl = document.getElementById('sidebar-user-name');
      var roleEl = document.getElementById('sidebar-user-role');
      var avatarEl = document.getElementById('sidebar-user-avatar');
      if (!nameEl) return;
      var name = getCurrentUserName();
      var role = currentMode || 'analyst';
      nameEl.textContent = name;
      roleEl.textContent = role;
      if (avatarEl) {
        var initials = name.split(' ').map(function(w) { return w.charAt(0); }).join('').toUpperCase().substr(0, 2);
        avatarEl.textContent = initials || '?';
        var colors = { analyst: '#1565c0', verifier: '#2e7d32', admin: '#6a1b9a' };
        avatarEl.style.background = colors[role] || '#1565c0';
      }
    }
    
    function applyRoleBasedModeRestrictions() {
      var loggedInRole = getLoggedInUserRole();
      var modeToggle = document.getElementById('mode-toggle-container');
      var lockedDisplayBottom = document.getElementById('locked-role-display');
      var lockedDisplayTop = document.getElementById('locked-role-display-top');
      var modeSectionBottom = document.querySelector('.nav-mode-section');
      var signOutLink = document.getElementById('sign-out-link');
      
      // Style the sign out link hover (only once)
      if (signOutLink && !roleRestrictionsApplied) {
        signOutLink.addEventListener('mouseenter', function() {
          this.style.color = '#fff';
        });
        signOutLink.addEventListener('mouseleave', function() {
          this.style.color = '#888';
        });
      }
      roleRestrictionsApplied = true;
      
      // v1.6.24: Admin with Playground enabled has full role switching access
      if (loggedInRole === 'admin' && isPlaygroundEnabled()) {
        if (modeToggle) modeToggle.style.display = 'flex';
        if (lockedDisplayBottom) lockedDisplayBottom.style.display = 'none';
        if (lockedDisplayTop) lockedDisplayTop.style.display = 'none';
        if (modeSectionBottom) modeSectionBottom.style.display = 'block';
        return;
      }
      
      // v1.6.24: Admin without Playground is locked to admin mode
      if (loggedInRole === 'admin') {
        if (modeSectionBottom) modeSectionBottom.style.display = 'none';
        if (lockedDisplayTop) {
          lockedDisplayTop.innerHTML = '<span style="opacity: 0.7;">Mode:</span> Admin';
          lockedDisplayTop.style.display = 'block';
        }
        if (currentMode !== 'admin') {
          setMode('admin');
        }
        return;
      }
      
      // Analyst and Verifier are locked to their respective modes
      if (loggedInRole === 'analyst' || loggedInRole === 'verifier') {
        // Hide the entire mode section at bottom (toggle buttons + bottom indicator)
        if (modeSectionBottom) modeSectionBottom.style.display = 'none';
        
        // Show locked role indicator at TOP (above navigation)
        if (lockedDisplayTop) {
          var roleLabel = loggedInRole.charAt(0).toUpperCase() + loggedInRole.slice(1);
          lockedDisplayTop.innerHTML = '<span style="opacity: 0.7;">Mode:</span> ' + roleLabel;
          lockedDisplayTop.style.display = 'block';
        }
        
        // Only force setMode if current mode doesn't match (avoid redundant reload)
        if (currentMode !== loggedInRole) {
          setMode(loggedInRole);
        }
        return;
      }
      
      // No logged-in user or unrecognized role - locked to analyst mode
      if (modeSectionBottom) modeSectionBottom.style.display = 'none';
      if (lockedDisplayTop) {
        lockedDisplayTop.innerHTML = '<span style="opacity: 0.7;">Mode:</span> Analyst';
        lockedDisplayTop.style.display = 'block';
      }
    }
    
    function setMode(mode) {
      var modes = ['analyst', 'verifier', 'admin'];
      if (modes.indexOf(mode) === -1) mode = 'analyst';
      currentMode = mode;
      updateSidebarUserProfile();
      
      // Update triage page titles with role
      var roleLabel = mode === 'analyst' ? 'Analyst' : mode === 'verifier' ? 'Verifier' : 'Admin';
      var triageTitle = document.getElementById('triage-page-title');
      var verifierTitle = document.getElementById('verifier-triage-title');
      if (triageTitle) triageTitle.textContent = 'Triage - ' + roleLabel;
      if (verifierTitle) verifierTitle.textContent = 'Triage - ' + roleLabel;
      
      document.querySelectorAll('.mode-btn').forEach(function(b) { b.classList.remove('active'); });
      var modeBtn = document.querySelector('.mode-btn[data-mode="' + mode + '"]');
      if (modeBtn) modeBtn.classList.add('active');
      
      // Toggle nav visibility based on mode using CSS classes
      var appLayout = document.querySelector('.app-layout');
      if (appLayout) {
        appLayout.classList.remove('mode-analyst', 'mode-verifier', 'mode-admin');
        appLayout.classList.add('mode-' + mode);
      }

      // v1.5.3 Fix: Toggle Triage view visibility + ALWAYS reload queues from canonical store
      var analystContent = document.getElementById('analyst-triage-content');
      var verifierContent = document.getElementById('verifier-triage-content');
      if (analystContent && verifierContent) {
        if (mode === 'verifier' || mode === 'admin') {
          analystContent.style.display = 'none';
          verifierContent.style.display = 'block';
          // v1.5.3 Fix: Always reload verifier queue from canonical stores (not dependent on analyst SRR state)
          reloadVerifierQueuesFromStore();
          initVerifierFilters();
          renderVerifierTriage();
        } else {
          analystContent.style.display = 'block';
          verifierContent.style.display = 'none';
          // v1.5.4: Render analyst triage from PatchRequest store
          renderAnalystTriage();
        }
      }
      
      // v1.5.2: Toggle Grid verifier mode
      var verifierGridBar = document.getElementById('verifier-grid-filter-bar');
      var analystGridBar = document.getElementById('analyst-grid-controls');
      if (verifierGridBar) {
        verifierGridBar.style.display = mode === 'verifier' ? 'flex' : 'none';
      }
      if (analystGridBar) {
        // Keep analyst controls visible but disable inline editing for verifiers
      }
      
      // If downgrading from admin mode, teardown admin state
      if (mode !== 'admin') {
        teardownAdminState();
      }
      
      // v1.5.3 Fix: Reset SRR state when switching roles to prevent stale isReadOnly
      if (mode === 'analyst' || mode === 'admin') {
        srrState.isReadOnly = false;
        srrState.verifierMode = false;
        if (srrState.currentRecord) {
          resetVerifierSRRMode();
          renderSrrFields(srrState.currentRecord);
        }
      } else if (mode === 'verifier') {
        srrState.isReadOnly = true;
        if (srrState.currentRecord) {
          srrState.verifierMode = true;
          initVerifierSRRMode();
          renderSrrFields(srrState.currentRecord);
        }
      }
      
      // Always route to Triage (home) on any role change
      navigateToRoleDefault();
      
      applyModeVisibility(mode);
      localStorage.setItem('viewer_mode_v10', mode);
      if (typeof applyDemoControlsVisibility === 'function') applyDemoControlsVisibility();
    }

    // v1.4.22: Navigate to role-specific default landing page
    // v1.6.37: Default to All Data Grid (Accounts sheet) instead of Triage
    function navigateToRoleDefault() {
      console.log('[P0.9-CLEANUP] route_default_triage: role=' + currentMode);
      navigateTo('triage');
    }
    
    function applyModeVisibility(mode) {
      // P0.6: Architect inherits admin visibility
      var effectiveMode = (mode === 'architect') ? 'admin' : mode;
      const revElements = document.querySelectorAll('[data-mode-verifier]');
      const anlElements = document.querySelectorAll('[data-mode-analyst]');
      const admElements = document.querySelectorAll('[data-mode-admin]');
      
      revElements.forEach(function(el) {
        el.classList.toggle('mode-hidden', effectiveMode !== 'verifier' && effectiveMode !== 'admin');
      });
      anlElements.forEach(function(el) {
        el.classList.toggle('mode-hidden', effectiveMode !== 'analyst');
      });
      admElements.forEach(function(el) {
        el.classList.toggle('mode-hidden', effectiveMode !== 'admin');
      });
    }

    // =========================================================================
    // ADMIN USER PANEL (v1.4.21) - Demo role assignment
    // =========================================================================
    
    var DEMO_USERS_KEY = 'orchestrate_demo_users';
    // v1.6.27: Reduced to 6 users, blank defaults for editing
    var DEFAULT_DEMO_USERS = [
      { id: 'user_001', name: '', email: '', role: 'analyst', status: 'active' },
      { id: 'user_002', name: '', email: '', role: 'analyst', status: 'active' },
      { id: 'user_003', name: '', email: '', role: 'verifier', status: 'active' },
      { id: 'user_004', name: '', email: '', role: 'verifier', status: 'active' },
      { id: 'user_005', name: 'Zachary Holwerda', email: 'zachary.holwerda@createmusicgroup.com', role: 'admin', status: 'active' },
      { id: 'user_006', name: '', email: '', role: 'admin', status: 'active' }
    ];
    
    function getDemoUsers() {
      try {
        var stored = localStorage.getItem(DEMO_USERS_KEY);
        if (stored) {
          return JSON.parse(stored);
        }
      } catch (e) {
        console.log('[Users] Error loading demo users:', e);
      }
      return JSON.parse(JSON.stringify(DEFAULT_DEMO_USERS));
    }
    
    function saveDemoUsers(users) {
      try {
        localStorage.setItem(DEMO_USERS_KEY, JSON.stringify(users));
        localStorage.setItem(DEMO_USERS_KEY + '_updated', new Date().toISOString());
        return true;
      } catch (e) {
        console.log('[Users] Error saving demo users:', e);
        return false;
      }
    }
    
    function renderUsersTable() {
      var tbody = document.getElementById('users-table-body');
      if (!tbody) return;
      
      var users = getDemoUsers();
      var isPlayground = isDemoMode();
      var currentUserEmail = null;
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        currentUserEmail = demoUser.email;
      } catch (e) {}
      
      // v1.6.27: All fields are editable inputs
      var html = '';
      users.forEach(function(user, idx) {
        var isCurrentUser = currentUserEmail && user.email && currentUserEmail.toLowerCase() === user.email.toLowerCase();
        var inputStyle = 'padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; width: 100%; box-sizing: border-box;';
        html += '<tr style="' + (isCurrentUser ? 'background: #fffde7;' : '') + '">';
        
        // Name column - editable input
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0;">';
        html += '<div style="display: flex; align-items: center; gap: 8px;">';
        var displayName = user.name || 'User ' + (idx + 1);
        html += '<div style="width: 32px; height: 32px; border-radius: 50%; background: ' + getUserColor(displayName) + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.85em;">' + getInitials(displayName) + '</div>';
        html += '<input type="text" id="user-name-' + idx + '" value="' + (user.name || '') + '" placeholder="Enter name" style="' + inputStyle + ' width: 140px;">';
        html += '</div></td>';
        
        // Email column - editable input
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0;">';
        html += '<input type="email" id="user-email-' + idx + '" value="' + (user.email || '') + '" placeholder="user@domain.com" style="' + inputStyle + '">';
        html += '</td>';
        
        // Role column - dropdown
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0;">';
        html += '<select id="user-role-' + idx + '" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; cursor: pointer;">';
        html += '<option value="analyst"' + (user.role === 'analyst' ? ' selected' : '') + '>Analyst</option>';
        html += '<option value="verifier"' + (user.role === 'verifier' ? ' selected' : '') + '>Verifier</option>';
        html += '<option value="admin"' + (user.role === 'admin' ? ' selected' : '') + '>Admin</option>';
        html += '</select>';
        html += '</td>';
        
        // Status column - dropdown
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0; text-align: center;">';
        html += '<select id="user-status-' + idx + '" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; cursor: pointer;">';
        html += '<option value="active"' + (user.status === 'active' ? ' selected' : '') + '>Active</option>';
        html += '<option value="pending"' + (user.status === 'pending' ? ' selected' : '') + '>Pending</option>';
        html += '<option value="disabled"' + (user.status === 'disabled' ? ' selected' : '') + '>Disabled</option>';
        html += '</select>';
        html += '</td>';
        
        // Actions column - Save button
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0; text-align: center;">';
        html += '<button onclick="saveUserRow(' + idx + ')" class="toolbar-btn" style="padding: 6px 14px; font-size: 0.85em;">Save</button>';
        html += '</td>';
        html += '</tr>';
      });
      
      tbody.innerHTML = html;
      
      var lastUpdated = localStorage.getItem(DEMO_USERS_KEY + '_updated');
      var updatedEl = document.getElementById('users-last-updated');
      if (updatedEl) {
        updatedEl.textContent = lastUpdated ? new Date(lastUpdated).toLocaleString() : 'Never';
      }
    }
    
    function getUserColor(name) {
      var colors = ['#1976d2', '#388e3c', '#7b1fa2', '#d32f2f', '#f57c00', '#0288d1', '#689f38', '#512da8'];
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    }
    
    function getInitials(name) {
      // v1.6.27: Handle empty names gracefully
      if (!name || name.trim() === '') return '??';
      return name.split(' ').filter(function(n) { return n.length > 0; }).map(function(n) { return n[0]; }).join('').substring(0, 2).toUpperCase() || '??';
    }
    
    // v1.6.27: Save all user fields (name, email, role, status)
    function saveUserRow(idx) {
      var users = getDemoUsers();
      if (!users[idx]) return;
      
      // Get all field values
      var nameInput = document.getElementById('user-name-' + idx);
      var emailInput = document.getElementById('user-email-' + idx);
      var roleSelect = document.getElementById('user-role-' + idx);
      var statusSelect = document.getElementById('user-status-' + idx);
      
      var newName = nameInput ? nameInput.value.trim() : users[idx].name;
      var newEmail = emailInput ? emailInput.value.trim().toLowerCase() : users[idx].email;
      var newRole = roleSelect ? roleSelect.value : users[idx].role;
      var newStatus = statusSelect ? statusSelect.value : users[idx].status;
      
      // Check for changes
      var hasChanges = newName !== users[idx].name ||
                       newEmail !== users[idx].email ||
                       newRole !== users[idx].role ||
                       newStatus !== users[idx].status;
      
      if (!hasChanges) {
        showToast('No changes to save', 'info');
        return;
      }
      
      // Update user data
      var oldEmail = users[idx].email;
      users[idx].name = newName;
      users[idx].email = newEmail;
      users[idx].role = newRole;
      users[idx].status = newStatus;
      
      saveDemoUsers(users);
      
      // Re-render to update avatar initials
      renderUsersTable();
      
      // Check if this affects the currently logged-in user
      var currentUserEmail = null;
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        currentUserEmail = demoUser.email;
      } catch (e) {}
      
      if (currentUserEmail && (currentUserEmail.toLowerCase() === oldEmail.toLowerCase() || currentUserEmail.toLowerCase() === newEmail.toLowerCase())) {
        localStorage.setItem('currentRole', newRole);
        showToast('Your user updated. Reload to apply changes.', 'warning');
      } else {
        var displayName = newName || 'User ' + (idx + 1);
        showToast(displayName + ' saved successfully', 'success');
      }
      
      select.dataset.originalRole = newRole;
      renderUsersTable();
    }
    
    function resetDemoUsers() {
      if (!confirm('Reset all demo users to default roles?')) return;
      localStorage.removeItem(DEMO_USERS_KEY);
      localStorage.removeItem(DEMO_USERS_KEY + '_updated');
      renderUsersTable();
      showToast('Demo users reset to defaults', 'info');
    }
    
    // v1.6.16: Add User Modal Functions
    function isUserEditingAllowed() {
      // Only allow user creation/editing in Demo/Playground mode
      return isDemoMode();
    }
    
    function openAddUserModal() {
      if (!isUserEditingAllowed()) {
        showToast('User management is only available in Demo mode', 'error');
        return;
      }
      var modal = document.getElementById('add-user-modal');
      if (modal) {
        modal.classList.add('active');
        document.getElementById('add-user-name').value = '';
        document.getElementById('add-user-email').value = '';
        document.getElementById('add-user-role').value = 'analyst';
        document.getElementById('add-user-status').value = 'active';
        document.getElementById('add-user-division').value = '';
        document.getElementById('add-user-error').style.display = 'none';
        document.getElementById('add-user-name').focus();
      }
    }
    
    function closeAddUserModal() {
      var modal = document.getElementById('add-user-modal');
      if (modal) modal.classList.remove('active');
    }
    
    function validateEmail(email) {
      var re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return re.test(String(email).toLowerCase());
    }
    
    function submitAddUser() {
      var name = (document.getElementById('add-user-name').value || '').trim();
      var email = (document.getElementById('add-user-email').value || '').trim();
      var role = document.getElementById('add-user-role').value || 'analyst';
      var status = document.getElementById('add-user-status').value || 'active';
      var division = (document.getElementById('add-user-division').value || '').trim();
      var errorEl = document.getElementById('add-user-error');
      
      // Validation
      if (!name) {
        errorEl.textContent = 'Please enter a full name.';
        errorEl.style.display = 'block';
        return;
      }
      
      if (!email) {
        errorEl.textContent = 'Please enter an email address.';
        errorEl.style.display = 'block';
        return;
      }
      
      if (!validateEmail(email)) {
        errorEl.textContent = 'Please enter a valid email address.';
        errorEl.style.display = 'block';
        return;
      }
      
      // Duplicate check
      var users = getDemoUsers();
      var emailLower = email.toLowerCase();
      var duplicate = users.some(function(u) {
        return u.email.toLowerCase() === emailLower;
      });
      
      if (duplicate) {
        errorEl.textContent = 'User with this email already exists.';
        errorEl.style.display = 'block';
        return;
      }
      
      // Create new user with pre-provisioned flag
      var newUser = {
        id: 'user_' + Date.now(),
        name: name,
        email: email,
        role: role,
        status: status,
        division: division || null,
        preProvisioned: true,
        createdAt: new Date().toISOString()
      };
      
      users.push(newUser);
      saveDemoUsers(users);
      
      closeAddUserModal();
      renderUsersTable();
      showToast('User "' + name + '" added successfully', 'success');
      console.log('[Users] Added pre-provisioned user:', newUser.email, 'role:', newUser.role);
    }
    
    function deleteUser(idx) {
      if (!isUserEditingAllowed()) {
        showToast('User management is only available in Demo mode', 'error');
        return;
      }
      var users = getDemoUsers();
      if (!users[idx]) return;
      
      var user = users[idx];
      if (!user.preProvisioned) {
        showToast('Cannot delete default demo users', 'error');
        return;
      }
      
      if (!confirm('Delete user "' + user.name + '"?')) return;
      
      users.splice(idx, 1);
      saveDemoUsers(users);
      renderUsersTable();
      showToast('User deleted', 'info');
      console.log('[Users] Deleted user:', user.email);
    }
    
    // Admin Console Tab Switching
    var currentAdminTab = 'governance';
    function switchAdminTab(tabName) {
      // P0.6: Show architect controls if admin/architect
      var archSection = document.getElementById('truth-pack-admin-section');
      if (archSection) {
        var _mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        archSection.style.display = (_mode === 'admin' || _mode === 'architect') ? '' : 'none';
        var _toggle = document.getElementById('architect-mode-toggle');
        if (_toggle) _toggle.checked = (_mode === 'architect' || localStorage.getItem('truth_pack_architect_enabled') === 'true');
        if (typeof TruthPack !== 'undefined') TruthPack._renderControls();
      }
      var tabs = ['governance', 'users', 'patch-queue', 'config', 'inspector', 'standardizer', 'patch-console', 'evidence', 'unknown-cols', 'people', 'qa-runner'];
      if (tabs.indexOf(tabName) === -1) tabName = 'governance';
      
      // Render users table and update env mode UI when switching to users tab
      if (tabName === 'users') {
        renderUsersTable();
        updateEnvModeUI();
      }
      if (tabName === 'people') {
        var savedPTab = localStorage.getItem('people_active_tab') || 'members';
        switchPeopleTab(savedPTab);
      }
      if (typeof TruthConfig !== 'undefined') TruthConfig._renderUI();
      currentAdminTab = tabName;
      
      // Hide all tab panels
      var _panels = document.querySelectorAll('.admin-tab-panel');
      for (var _pi = 0; _pi < _panels.length; _pi++) {
        _panels[_pi].style.display = 'none';
      }
      
      // Show selected tab panel
      var targetPanel = document.getElementById('admin-tab-' + tabName);
      if (targetPanel) {
        targetPanel.style.display = 'block';
      }
      
      // Update tab button styles
      var _tabBtns = document.querySelectorAll('.admin-tab');
      for (var _tbi = 0; _tbi < _tabBtns.length; _tbi++) { var btn = _tabBtns[_tbi];
        if (btn.getAttribute('data-admin-tab') === tabName) {
          btn.style.background = '#1976d2';
          btn.style.color = 'white';
          btn.style.fontWeight = '600';
        } else {
          btn.style.background = '#f5f5f5';
          btn.style.color = '#666';
          btn.style.fontWeight = 'normal';
        }
      }
      
      // Render admin queue when tab is shown
      if (tabName === 'patch-queue') {
        renderAdminQueue();
      }
      
      // v1.6.48: Render batch add toggles when governance tab is shown
      if (tabName === 'governance') {
        if (typeof renderBatchAddAdminToggles === 'function') renderBatchAddAdminToggles();
        if (typeof BatchMerge !== 'undefined') { BatchMerge.refreshSourceList(); BatchMerge.renderMergedBatchPanel(); }
      }
      
      console.log('[Admin] Switched to tab:', tabName);
      if (tabName === 'qa-runner') {
        QARunner._onTabOpen();
      }
      if (tabName === 'config' && typeof renderGlossarySummary === 'function') renderGlossarySummary();
    }

    function renderBatchAddAdminToggles() {
      var container = document.getElementById('admin-batch-add-toggles');
      if (!container) return;
      
      var sheets = getDataSheets();
      if (sheets.length === 0) {
        container.innerHTML = '<div style="color: #999; font-size: 0.85em; font-style: italic;">Load a dataset to see available contract sections.</div>';
        return;
      }
      
      var html = '';
      sheets.forEach(function(sheetName) {
        var enabled = isBatchAddEnabled(sheetName);
        html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: ' + (enabled ? '#e8f5e9' : '#f5f5f5') + '; border-radius: 6px;">' +
          '<span style="font-size: 0.9em; font-weight: 500;">' + escapeHtml(sheetName) + '</span>' +
          '<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">' +
            '<span style="font-size: 0.8em; color: ' + (enabled ? '#2e7d32' : '#999') + ';">' + (enabled ? 'Enabled' : 'Disabled') + '</span>' +
            '<input type="checkbox" ' + (enabled ? 'checked' : '') + ' onchange="toggleBatchAddForSheet(\'' + escapeHtml(sheetName.replace(/'/g, "\\'")) + '\', this.checked)" style="width: 18px; height: 18px; cursor: pointer;">' +
          '</label>' +
        '</div>';
      });
      container.innerHTML = html;
    }

    function toggleBatchAddForSheet(sheetName, enabled) {
      setBatchAddEnabled(sheetName, enabled);
      renderBatchAddAdminToggles();
      showToast('Batch Add ' + (enabled ? 'enabled' : 'disabled') + ' for ' + sheetName, 'success');
    }
    
    // ========== ADMIN QUEUE RENDERING (v1.5.1) ==========
    function renderAdminQueue() {
      var items = getPatchQueue();
      var tbody = document.getElementById('patch-queue-tbody');
      if (!tbody) return;
      
      // Update count badge
      var countEl = document.getElementById('patch-queue-count');
      if (countEl) {
        countEl.textContent = items.length;
        countEl.style.display = items.length > 0 ? 'inline' : 'none';
      }
      
      if (items.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="padding: 20px; text-align: center; color: #888;">No patch requests pending Admin approval. Items appear here after Verifier approval.</td></tr>';
        return;
      }
      
      // Also check legacy verifierQueueState for additional data
      var legacyPayloads = {};
      if (typeof verifierQueueState !== 'undefined' && verifierQueueState.payloads) {
        verifierQueueState.payloads.forEach(function(p) {
          legacyPayloads[p.id] = p;
        });
      }
      
      tbody.innerHTML = items.map(function(item) {
        var legacy = legacyPayloads[item.id] || {};
        var typeLabel = item.artifact_type === 'blacklist' ? 'Blacklist' : 'Correction';
        var typeColor = item.artifact_type === 'blacklist' ? '#9c27b0' : '#2e7d32';
        var oldVal = item.old_value || legacy.old_value || '—';
        var newVal = item.new_value || legacy.new_value || '—';
        var comment = item.comment || legacy.comment || '';
        var time = item.created_at ? new Date(item.created_at).toLocaleString() : '—';
        
        return '<tr style="border-bottom: 1px solid #eee; cursor: pointer;" onclick="openAdminReviewDetail(\'' + item.id + '\')" onmouseover="this.style.background=\'#f5f8ff\'" onmouseout="this.style.background=\'transparent\'">' +
          '<td style="padding:12px;"><span style="background:' + typeColor + '; color:white; padding:2px 6px; border-radius:10px; font-size:0.8em;">' + typeLabel + '</span></td>' +
          '<td style="padding:12px; font-weight:600;">' + (item.record_id || '—') + '</td>' +
          '<td style="padding:12px; font-family:monospace;">' + (item.field_key || legacy.field || '—') + '</td>' +
          '<td style="padding:12px;"><span style="color:#888; text-decoration:line-through;">' + oldVal + '</span> → <span style="color:#2e7d32; font-weight:600;">' + newVal + '</span></td>' +
          '<td style="padding:12px; color:#666; max-width:200px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="' + comment + '">' + comment + '</td>' +
          '<td style="padding:12px; color:#888;">' + time + '</td>' +
          '<td style="padding:12px; display:flex; gap:6px;">' +
            '<button onclick="event.stopPropagation(); adminApproveItem(\'' + item.id + '\')" style="background:#2e7d32; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Finalize</button>' +
            '<button onclick="event.stopPropagation(); adminRejectItem(\'' + item.id + '\')" style="background:#d32f2f; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Reject</button>' +
          '</td>' +
        '</tr>';
      }).join('');
    }
    
    function openAdminReviewDetail(artifactId) {
      // Load the artifact and open Admin Review page (reuses verifier review layout)
      var artifact = getArtifact(artifactId);
      if (!artifact) {
        // Try legacy payload
        var payload = verifierQueueState.payloads.find(function(p) { return p.id === artifactId; });
        if (!payload) {
          showToast('Item not found', 'warning');
          return;
        }
        // Convert legacy to artifact-like object
        artifact = {
          id: payload.id,
          artifact_type: payload.type === 'blacklist' ? 'blacklist' : 'patch_request',
          record_id: payload.record_id,
          field_key: payload.field,
          old_value: payload.old_value,
          new_value: payload.new_value,
          comment: payload.comment,
          status: payload.status
        };
      }
      
      // Set state for admin review (reuse verifier review state)
      vrState.currentPatchId = artifactId;
      vrState.reviewState = 'Verifier_Approved';
      vrState.loadedPayload = artifact;
      
      navigateTo('admin-review/' + artifactId);
    }
    
    function adminApproveItem(artifactId) {
      updatePayloadStatus(artifactId, 'resolved');
      renderAdminQueue();
      showToast('Item finalized and resolved', 'success');
    }
    
    function adminRejectItem(artifactId) {
      updatePayloadStatus(artifactId, 'rejected');
      renderAdminQueue();
      showToast('Item rejected', 'warning');
    }
    
    function updatePatchQueueCount() {
      // v1.5.1: Badge count = only patch_request with status=sent_to_admin
      var patchRequests = listArtifacts({ artifact_type: 'patch_request', status: 'sent_to_admin' });
      var countEl = document.getElementById('patch-queue-count');
      if (countEl) {
        countEl.textContent = patchRequests.length;
        countEl.style.display = patchRequests.length > 0 ? 'inline' : 'none';
      }
    }

    // Teardown admin state when leaving admin mode
    function teardownAdminState() {
      // Reset admin tab to default
      currentAdminTab = 'governance';
      // Clear any admin-specific temp state
      console.log('[Admin] Tearing down admin state');
    }

    function updateUIForDataState() {
      const emptyQueueMsg = document.getElementById('empty-queue-message');
      const topToolbar = document.getElementById('top-toolbar');
      
      if (dataLoaded) {
        if (emptyQueueMsg) emptyQueueMsg.classList.add('hidden');
        if (topToolbar) topToolbar.style.display = 'flex';
      } else {
        if (emptyQueueMsg) emptyQueueMsg.classList.remove('hidden');
        if (topToolbar) topToolbar.style.display = 'none';
      }
      
      // Update session chip (handles status display)
      updateSessionChip();
      // Update queue counts
      updateQueueCounts();
      
      // Update data status chip in sidebar (v1.4.5)
      var dataStatusChip = document.getElementById('data-status-chip');
      if (dataStatusChip) {
        if (dataLoaded && allData.contractResults && allData.contractResults.length > 0) {
          dataStatusChip.textContent = allData.contractResults.length;
          dataStatusChip.classList.add('has-items');
        } else {
          dataStatusChip.textContent = '--';
          dataStatusChip.classList.remove('has-items');
        }
      }
    }

    function updateQueueCounts() {
      const results = allData.contractResults || [];
      const counts = {
        todo: 0,
        needs_review: 0,
        flagged: 0,
        blocked: 0,
        finalized: 0
      };
      
      results.forEach(r => {
        const status = (r.sf_contract_status || '').toLowerCase();
        if (status === 'needs_review') counts.needs_review++;
        else if (status === 'blocked') counts.blocked++;
        else if (status === 'ready') counts.finalized++;
        else counts.todo++;
      });
      
      // Total unfinished = todo + needs_review (the main work queue)
      counts.todo = results.length - counts.finalized;
      
      // Update count badges
      Object.entries(counts).forEach(([queue, count]) => {
        const el = document.getElementById(`queue-count-${queue}`);
        if (el) {
          el.textContent = count;
          el.classList.toggle('has-items', count > 0);
          el.classList.toggle('blocking', queue === 'blocked' && count > 0);
        }
      });
      
      // Update progress block in sidebar
      if (typeof updateProgressBlock === 'function') updateProgressBlock();
    }

    // Feature Flags (V1 defaults)
    var FEATURE_FLAGS = {
      connectors_enabled: false  // V1: offline-first, no connectors
    };
    
    // Data Source Panel - unified entry point (v1.5.0)
    // Always opens right-side panel (never modal) - per spec
    function openDataSourcePanel() {
      openDataSourceDrawer();
    }
    
    // Data Sources Drawer functions (now Upload Library)
    function openDataSourceDrawer() {
      document.getElementById('data-source-drawer').classList.add('active');
      renderSavedSessionsList();
      renderUploadLibrary();
      updateDataSourceDrawerState();
    }
    
    function closeDataSourceDrawer() {
      document.getElementById('data-source-drawer').classList.remove('active');
    }
    
    // Stub for updateSessionUI (v1.5.7 - noop for now, could update session indicators)
    function updateSessionUI() {
      // Placeholder for session UI updates (e.g., user avatar, session indicators)
    }
    
    // Update Data Source drawer to show current state (v1.4.23 folder-based)
    function updateDataSourceDrawerState() {
      var drawer = document.getElementById('data-source-drawer');
      if (!drawer) return;
      
      var headerEl = drawer.querySelector('.drawer-header h3');
      var folderSection = document.getElementById('data-source-folder-section');
      var emptySection = document.getElementById('data-source-empty-section');
      var activeSection = document.getElementById('data-source-active-section');
      var uploadSection = document.getElementById('data-source-upload-section');
      var searchSection = document.getElementById('data-source-search-section');
      var libraryHeader = document.getElementById('data-source-library-header');
      var uploadLibrary = getUploadLibrary();
      // v1.4.23: Filter out sample dataset from library count
      var realLibrary = uploadLibrary.filter(function(e) { return e.dataset_id !== 'ds-sample' && e.source !== 'sample'; });
      var count = realLibrary.length;
      var hasData = dataLoaded && sessionState.status === 'loaded';
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      
      // Update header
      if (headerEl) {
        headerEl.textContent = 'Data Source';
      }
      
      // v1.4.23: Show folder section if folder is mapped
      if (folderSection) {
        if (mappedFolder) {
          folderSection.style.display = 'block';
          var folderNameEl = document.getElementById('connected-folder-name');
          var syncTimeEl = document.getElementById('folder-sync-time');
          if (folderNameEl) folderNameEl.textContent = mappedFolder;
          if (syncTimeEl) {
            var syncTime = localStorage.getItem('ingestion_folder_sync_time');
            syncTimeEl.textContent = 'Last sync: ' + (syncTime ? new Date(syncTime).toLocaleString() : 'Not synced yet');
          }
        } else {
          folderSection.style.display = 'none';
        }
      }
      
      // Show empty section when no folder mapped
      if (emptySection) {
        emptySection.style.display = mappedFolder ? 'none' : 'block';
      }
      
      // Show active dataset section when data loaded
      if (activeSection) {
        if (hasData) {
          activeSection.style.display = 'block';
          var nameEl = document.getElementById('active-dataset-name');
          var metaEl = document.getElementById('active-dataset-meta');
          if (nameEl) {
            nameEl.textContent = sessionState.fileName || sessionState.sourceType || 'Loaded Dataset';
          }
          if (metaEl) {
            var rowCount = allData.contractResults ? allData.contractResults.length : 0;
            var loadedAt = sessionState.loadedAt ? new Date(sessionState.loadedAt).toLocaleString() : '—';
            metaEl.innerHTML = '<strong>' + rowCount + '</strong> records | Loaded: ' + loadedAt;
          }
        } else {
          activeSection.style.display = 'none';
        }
      }
      
      // Hide upload section (v1.4.23 - folder-based workflow)
      if (uploadSection) {
        uploadSection.style.display = 'none';
      }
      
      // Show search section when folder mapped (disabled)
      if (searchSection) {
        searchSection.style.display = mappedFolder ? 'block' : 'none';
      }
      
      // v1.4.24: Always show Drive Files header (static stub content in HTML)
      if (libraryHeader) {
        libraryHeader.style.display = mappedFolder ? 'block' : 'none';
      }
      
      // Close disconnect menu
      var disconnectMenu = document.getElementById('disconnect-menu');
      if (disconnectMenu) disconnectMenu.style.display = 'none';
    }
    
    // ========== FOLDER SELECTION (v1.4.24 - auto-mapped, no modal) ==========
    // Legacy no-op functions (folder is now auto-mapped from email)
    function openFolderSelectionModal() { /* Removed in v1.4.24 */ }
    function closeFolderSelectionModal() { /* Removed in v1.4.24 */ }
    function confirmFolderSelection() { /* Removed in v1.4.24 */ }
    
    function updateActiveDataSourceBar() {
      var nameEl = document.getElementById('active-data-source-name');
      var actionBtn = document.getElementById('active-data-source-action');
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      
      if (nameEl) {
        if (mappedFolder) {
          nameEl.textContent = 'Connected: ' + mappedFolder;
        } else if (dataLoaded && sessionState.fileName) {
          nameEl.textContent = sessionState.fileName;
        } else {
          nameEl.textContent = 'No folder connected';
        }
      }
      if (actionBtn) {
        actionBtn.textContent = mappedFolder ? 'Change' : 'Connect';
        actionBtn.onclick = mappedFolder ? openDataSourcePanel : openFolderSelectionModal;
      }
    }
    
    function updateLoaderFolderState() {
      var folderInfo = document.getElementById('loader-folder-info');
      var noFolder = document.getElementById('loader-no-folder');
      var folderName = document.getElementById('loader-folder-name');
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      
      if (mappedFolder) {
        if (folderInfo) folderInfo.style.display = 'block';
        if (noFolder) noFolder.style.display = 'none';
        if (folderName) folderName.textContent = mappedFolder;
      } else {
        if (folderInfo) folderInfo.style.display = 'none';
        if (noFolder) noFolder.style.display = 'block';
      }
    }
    
    // Toggle disconnect menu on ACTIVE badge click
    function toggleDisconnectMenu(event) {
      event.stopPropagation();
      var menu = document.getElementById('disconnect-menu');
      if (menu) {
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      }
    }
    
    // Data Source panel search stub - show "coming soon" toast
    var dataSourceSearchDebounce = null;
    function showDataSourceSearchToast() {
      if (dataSourceSearchDebounce) return;
      dataSourceSearchDebounce = setTimeout(function() {
        dataSourceSearchDebounce = null;
      }, 1500);
      showToast('Search coming soon (V2)', 'info');
    }
    
    // Disconnect active dataset (move to Saved)
    function disconnectActiveDataset() {
      var menu = document.getElementById('disconnect-menu');
      if (menu) menu.style.display = 'none';
      
      // Save current dataset to library before clearing
      if (dataLoaded && sessionState.status === 'loaded') {
        saveCurrentDatasetToLibrary();
      }
      
      // Clear active dataset
      dataLoaded = false;
      sessionState.status = 'not_loaded';
      sessionState.fileName = null;
      sessionState.loadedAt = null;
      sessionState.sourceType = null;
      allData = { contractResults: [], fieldActions: [], issues: [], summary: {} };
      workbook = { sheets: {}, order: [] };
      localStorage.removeItem('activeDatasetId');
      
      // Update UI
      updateDataSourceDrawerState();
      renderUploadLibrary();
      updateSessionUI();
      updateQueueCounts();
      showToast('Dataset disconnected', 'info');
    }
    
    // Save current dataset to upload library
    function saveCurrentDatasetToLibrary() {
      var library = getUploadLibrary();
      var entry = {
        id: 'ds_' + Date.now(),
        name: sessionState.fileName || 'Dataset',
        type: sessionState.sourceType || 'unknown',
        recordCount: allData.contractResults ? allData.contractResults.length : 0,
        savedAt: new Date().toISOString(),
        data: JSON.stringify(allData)
      };
      library.push(entry);
      localStorage.setItem('upload_library_v1', JSON.stringify(library));
    }
    
    // Handle file upload from drawer
    function handleDrawerFileUpload(input) {
      var file = input.files[0];
      if (!file) return;
      
      var ext = file.name.split('.').pop().toLowerCase();
      if (ext !== 'csv' && ext !== 'xlsx') {
        showToast('Unsupported file type. Use CSV or XLSX.', 'error');
        return;
      }
      
      // If active dataset exists, rotate it to Saved
      if (dataLoaded && sessionState.status === 'loaded') {
        saveCurrentDatasetToLibrary();
        showToast('Previous dataset moved to Saved', 'info');
      }
      
      // Process the file
      if (ext === 'csv') {
        processCSVFile(file);
      } else if (ext === 'xlsx') {
        processXLSXFile(file);
      }
      
      input.value = ''; // Reset input
    }
    
    // Process CSV file from drawer upload
    function processCSVFile(file) {
      var reader = new FileReader();
      reader.onload = function(e) {
        var text = e.target.result;
        var parsed = parseCSV(text);
        
        // parseCSV returns { headers: [], rows: [], delimiter: '' }
        if (!parsed || !parsed.rows || parsed.rows.length === 0) {
          showToast('Failed to parse CSV file or no data rows found', 'error');
          return;
        }
        
        var headers = parsed.headers;
        var records = parsed.rows; // Already in object format
        
        // Create a workbook-compatible structure
        var sheetName = file.name.replace(/\.(csv|xlsx)$/i, '');
        
        // v1.5.3 Fix: Set IDENTITY_CONTEXT.dataset_id before persisting
        if (!IDENTITY_CONTEXT.dataset_id) {
          IDENTITY_CONTEXT.dataset_id = file.name;
        }
          if (typeof p08PurgeStaleTriageItems === 'function') p08PurgeStaleTriageItems(file.name);
        
        // Clear any cached version of this sheet to treat re-import as fresh
        clearCachedDataset(sheetName);
        
        // Load into workbook (the correct global variable that getGridDataset reads from)
        workbook.sheets[sheetName] = {
          name: sheetName,
          headers: headers,
          rows: records
        };
        if (workbook.order.indexOf(sheetName) < 0) {
          workbook.order.push(sheetName);
        }
        workbook.activeSheet = sheetName;
        
        console.log('[Loader] CSV file loaded: ' + sheetName + ', ' + records.length + ' rows');
        
        // Update state
        dataLoaded = true;
        datasetRevision++; // v1.6.18: Bump revision for cache invalidation
        sessionState.status = 'loaded';
        sessionState.loadedAt = new Date().toISOString();
        sessionState.source = 'file:' + file.name;
        
        updateUIForDataState();
        closeDataSourceDrawer();
        
        // v1.5.3: Persist all records to canonical store
        persistAllRecordsToStore();
        
        // v1.6.0: Generate signals for dataset
        generateSignalsForDataset();
        
        showToast('CSV loaded: ' + records.length + ' records', 'success');
        navigateTo('grid');
      };
      reader.onerror = function() {
        showToast('Failed to read file', 'error');
      };
      reader.readAsText(file);
    }
    
    // Clear cached dataset by name to ensure fresh import
    function clearCachedDataset(sheetName) {
      // Remove from workbook if exists
      if (workbook && workbook.sheets && workbook.sheets[sheetName]) {
        delete workbook.sheets[sheetName];
        var idx = workbook.order.indexOf(sheetName);
        if (idx >= 0) workbook.order.splice(idx, 1);
        console.log('[Loader] Cleared cached dataset: ' + sheetName);
      }
      
      // Remove from upload library localStorage
      try {
        var library = JSON.parse(localStorage.getItem('upload_library_v1') || '[]');
        var filtered = library.filter(function(ds) { return ds.name !== sheetName; });
        if (filtered.length !== library.length) {
          localStorage.setItem('upload_library_v1', JSON.stringify(filtered));
          console.log('[Loader] Removed from upload library: ' + sheetName);
        }
      } catch (err) {
        console.warn('[Loader] Could not clear upload library cache', err);
      }
    }
    
    // Placeholder XLSX processing (V2 full implementation)
    function processXLSXFile(file) {
      showToast('XLSX support coming soon. Use CSV for now.', 'info');
    }
    
    // Close disconnect menu when clicking elsewhere
    document.addEventListener('click', function(e) {
      var menu = document.getElementById('disconnect-menu');
      if (menu && menu.style.display !== 'none') {
        var badge = document.getElementById('active-badge');
        if (!badge || !badge.contains(e.target)) {
          menu.style.display = 'none';
        }
      }
    });
    
    // Get stored datasets from localStorage
    function getUploadLibrary() {
      try {
        var stored = localStorage.getItem('upload_library_v1');
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        return [];
      }
    }
    
    // Loader Modal functions
    var loaderModalTriggerEl = null;
    
    function openLoaderModal() {
      loaderModalTriggerEl = document.activeElement;
      hideLoaderError(); // Clear any previous errors
      document.getElementById('loader-modal-overlay').classList.add('active');
      document.body.style.overflow = 'hidden';
      document.addEventListener('keydown', loaderModalKeyHandler);
      var closeBtn = document.getElementById('loader-modal-close-btn');
      if (closeBtn) closeBtn.focus();
    }
    
    function closeLoaderModal(event) {
      if (event && event.target && event.target.id !== 'loader-modal-overlay') return;
      document.getElementById('loader-modal-overlay').classList.remove('active');
      document.body.style.overflow = '';
      document.removeEventListener('keydown', loaderModalKeyHandler);
      if (loaderModalTriggerEl && loaderModalTriggerEl.focus) {
        loaderModalTriggerEl.focus();
      }
      loaderModalTriggerEl = null;
    }
    
    function loaderModalKeyHandler(e) {
      if (e.key === 'Escape') {
        closeLoaderModal();
      }
      if (e.key === 'Tab') {
        var modal = document.getElementById('loader-modal');
        var focusables = modal.querySelectorAll('button, input, select, textarea, a[href]');
        if (focusables.length === 0) return;
        var first = focusables[0];
        var last = focusables[focusables.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    }
    
    // v1.4.5: Legacy alias removed - use openLoaderModal() directly
    function openLoaderDrawer() { openLoaderModal(); }
    
    // v1.4.5: Stub admin functions to prevent console errors
    function inspectJSON(type) {
      console.log('[Admin] inspectJSON called for:', type);
      showToast('Inspector: ' + type + ' (not yet implemented)', 'info');
    }
    

    // ===== CANONICAL GLOSSARY MANAGEMENT =====
    var _glossaryDefault = null;

    function renderGlossarySummary() {
      var summaryEl = document.getElementById('glossary-summary');
      var mapEl = document.getElementById('glossary-sheet-map');
      if (!summaryEl) return;
      if (!rulesBundleCache.loaded || !rulesBundleCache.fieldMeta || !rulesBundleCache.fieldMeta.fields) {
        summaryEl.innerHTML = '<span style="color: #f57c00;">No glossary loaded. Upload a glossary JSON to enable schema coverage.</span>';
        summaryEl.style.background = '#fff3e0';
        if (mapEl) mapEl.innerHTML = '';
        return;
      }
      var fields = rulesBundleCache.fieldMeta.fields;
      var meta = rulesBundleCache.fieldMeta.meta || {};
      var sheetMap = meta.sheet_mapping || {};
      var version = meta.schema_version || '1.0';
      var updatedAt = meta.updated_at || 'unknown';
      var sheetCounts = {};
      for (var i = 0; i < fields.length; i++) {
        var s = fields[i].sheet || 'Unknown';
        sheetCounts[s] = (sheetCounts[s] || 0) + 1;
      }
      var required = fields.filter(function(f) { return f.requiredness === 'required'; }).length;
      var picklists = fields.filter(function(f) { return f.picklist; }).length;
      summaryEl.style.background = '#e8f5e9';
      summaryEl.innerHTML = '<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">' +
        '<div><strong>' + fields.length + ' fields</strong> across <strong>' + Object.keys(sheetCounts).length + ' sections</strong></div>' +
        '<div style="display: flex; gap: 12px; font-size: 0.9em; color: #555;">' +
        '<span>Required: ' + required + '</span>' +
        '<span>Picklists: ' + picklists + '</span>' +
        '<span>v' + version + '</span>' +
        '</div></div>';
      if (mapEl) {
        var mapHtml = '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em; margin-top: 8px;">';
        mapHtml += '<thead><tr style="background: #f5f5f5;"><th style="padding: 6px 10px; text-align: left; border-bottom: 1px solid #ddd;">Data Section</th><th style="padding: 6px 10px; text-align: left; border-bottom: 1px solid #ddd;">Definitions Source</th><th style="padding: 6px 10px; text-align: right; border-bottom: 1px solid #ddd;">Fields</th></tr></thead><tbody>';
        var sortedSheets = Object.keys(sheetCounts).sort();
        for (var si = 0; si < sortedSheets.length; si++) {
          var sn = sortedSheets[si];
          var defSheet = sheetMap[sn] || '<span style="color: #999;">unmapped</span>';
          mapHtml += '<tr><td style="padding: 5px 10px; border-bottom: 1px solid #eee;">' + sn + '</td><td style="padding: 5px 10px; border-bottom: 1px solid #eee;">' + defSheet + '</td><td style="padding: 5px 10px; text-align: right; border-bottom: 1px solid #eee;">' + sheetCounts[sn] + '</td></tr>';
        }
        mapHtml += '</tbody></table>';
        mapEl.innerHTML = mapHtml;
      }
    }

    function handleGlossaryUpload(input) {
      var statusEl = document.getElementById('glossary-upload-status');
      if (!input.files || !input.files[0]) return;
      var file = input.files[0];
      if (!file.name.endsWith('.json')) {
        if (statusEl) { statusEl.style.display = 'block'; statusEl.style.background = '#ffebee'; statusEl.style.color = '#c62828'; statusEl.textContent = 'Please select a .json file.'; }
        return;
      }
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var glossary = JSON.parse(e.target.result);
          var errors = validateGlossarySchema(glossary);
          if (errors.length > 0) {
            if (statusEl) { statusEl.style.display = 'block'; statusEl.style.background = '#ffebee'; statusEl.style.color = '#c62828'; statusEl.innerHTML = '<strong>Validation errors:</strong><ul style="margin: 4px 0 0 16px; padding: 0;">' + errors.map(function(err) { return '<li>' + err + '</li>'; }).join('') + '</ul>'; }
            return;
          }
          rulesBundleCache.fieldMeta = glossary;
          try { localStorage.setItem('orchestrate_glossary_override', JSON.stringify(glossary)); } catch(se) { console.warn('[Glossary] Storage save failed:', se); }
          renderGlossarySummary();
          if (typeof TriageAnalytics !== 'undefined') {
            try { TriageAnalytics.refresh(); TriageAnalytics.renderHeader(); } catch(ae) {}
          }
          if (statusEl) { statusEl.style.display = 'block'; statusEl.style.background = '#e8f5e9'; statusEl.style.color = '#2e7d32'; statusEl.textContent = 'Glossary uploaded: ' + glossary.fields.length + ' fields across ' + Object.keys(glossary.meta.sheet_mapping || {}).length + ' section mappings. Schema coverage will update on next triage refresh.'; }
          showToast('Glossary updated: ' + glossary.fields.length + ' fields loaded', 'success');
          console.log('[Glossary] Uploaded: ' + glossary.fields.length + ' fields, version=' + (glossary.meta && glossary.meta.schema_version || '?'));
        } catch(parseErr) {
          if (statusEl) { statusEl.style.display = 'block'; statusEl.style.background = '#ffebee'; statusEl.style.color = '#c62828'; statusEl.textContent = 'Invalid JSON: ' + parseErr.message; }
        }
      };
      reader.readAsText(file);
      input.value = '';
    }

    function validateGlossarySchema(glossary) {
      var errors = [];
      if (!glossary || typeof glossary !== 'object') { errors.push('Root must be a JSON object'); return errors; }
      if (!glossary.fields || !Array.isArray(glossary.fields)) { errors.push('Missing or invalid "fields" array'); return errors; }
      if (glossary.fields.length === 0) { errors.push('"fields" array is empty'); return errors; }
      var sample = glossary.fields[0];
      if (!sample.field_key) errors.push('Fields must have "field_key" property');
      if (!sample.sheet) errors.push('Fields must have "sheet" property (data sheet name)');
      if (!glossary.meta) errors.push('Missing "meta" object (should contain sheet_mapping)');
      else if (!glossary.meta.sheet_mapping) errors.push('Missing "meta.sheet_mapping" object (data sheet -> definition sheet mapping)');
      var sheetsInFields = {};
      for (var i = 0; i < glossary.fields.length; i++) {
        var f = glossary.fields[i];
        if (!f.field_key) { errors.push('Field at index ' + i + ' missing field_key'); break; }
        sheetsInFields[f.sheet || 'Unknown'] = true;
      }
      if (glossary.meta && glossary.meta.sheet_mapping) {
        var mapped = Object.keys(glossary.meta.sheet_mapping);
        var unmapped = Object.keys(sheetsInFields).filter(function(s) { return !glossary.meta.sheet_mapping[s]; });
        if (unmapped.length > 0) errors.push('Unmapped sections in fields: ' + unmapped.join(', '));
      }
      return errors;
    }

    function downloadCurrentGlossary() {
      if (!rulesBundleCache.loaded || !rulesBundleCache.fieldMeta) {
        showToast('No glossary loaded', 'warning');
        return;
      }
      var blob = new Blob([JSON.stringify(rulesBundleCache.fieldMeta, null, 2)], { type: 'application/json' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'field_meta_glossary.json';
      a.click();
      URL.revokeObjectURL(url);
      showToast('Glossary downloaded', 'info');
    }

    function resetGlossaryToDefault() {
      if (!_glossaryDefault) {
        showToast('Default glossary not available. Reload the page.', 'warning');
        return;
      }
      rulesBundleCache.fieldMeta = JSON.parse(JSON.stringify(_glossaryDefault));
      try { localStorage.removeItem('orchestrate_glossary_override'); } catch(se) {}
      renderGlossarySummary();
      if (typeof TriageAnalytics !== 'undefined') {
        try { TriageAnalytics.refresh(); TriageAnalytics.renderHeader(); } catch(ae) {}
      }
      showToast('Glossary reset to default', 'info');
      console.log('[Glossary] Reset to default: ' + _glossaryDefault.fields.length + ' fields');
    }

    function loadAdminConfig() {
      console.log('[Admin] loadAdminConfig called');
      showToast('Load Config (not yet implemented)', 'info');
    }
    
    function copyInspectorJSON() {
      console.log('[Admin] copyInspectorJSON called');
      showToast('Copy JSON (not yet implemented)', 'info');
    }
    function closeLoaderDrawer() { closeLoaderModal(); }
    
    // ============================================================
    // GRID FUNCTIONS (v1.4.3)
    // ============================================================
    var currentDataset = null;
    var gridState = {
      filter: 'all',
      sheet: '',
      search: '',
      visibleColumns: [],
      allColumns: [],
      // v1.6.46: Column ordering and display preferences
      columnOrder: null,  // User-defined column order (null = use default)
      hiddenColumns: ['file_url', 'File_URL_c', '_row_index', '_originalIdx', '_sheetRowIndex', 'sheet']  // Columns hidden by default
    };
    
    // v1.6.46: Get Excel-style column letter (A, B, C, ... Z, AA, AB, etc.)
    function getColumnLetter(index) {
      var letter = '';
      while (index >= 0) {
        letter = String.fromCharCode(65 + (index % 26)) + letter;
        index = Math.floor(index / 26) - 1;
      }
      return letter;
    }
    
    // v1.6.46: Get preferred column order for display
    function getPreferredColumnOrder(columns) {
      // Priority columns to show first (account/identity fields)
      var priorityFields = [
        'File_Name_c', 'file_name', 
        'Account_Name_c', 'account_name',
        'Artist_Name_pka_or_dba_c', 'artist_name',
        'contract_key'
      ];
      
      var ordered = [];
      var remaining = columns.slice();
      
      // Add priority fields first (in order)
      priorityFields.forEach(function(field) {
        var idx = remaining.findIndex(function(c) { 
          return c.toLowerCase() === field.toLowerCase(); 
        });
        if (idx !== -1) {
          ordered.push(remaining.splice(idx, 1)[0]);
        }
      });
      
      // Add remaining fields
      ordered = ordered.concat(remaining);
      
      // Filter out hidden columns for display
      return ordered.filter(function(col) {
        return !gridState.hiddenColumns.includes(col);
      });
    }
    
    // v1.6.46: Column drag and drop handlers
    var draggedColumnIdx = null;
    
    function handleColumnDragStart(event) {
      draggedColumnIdx = parseInt(event.target.closest('th').dataset.colIdx);
      event.target.closest('th').style.opacity = '0.5';
      event.dataTransfer.effectAllowed = 'move';
    }
    
    function handleColumnDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
      var th = event.target.closest('th');
      if (th && th.dataset.colIdx !== undefined) {
        th.style.borderLeft = '3px solid #1976d2';
      }
    }
    
    function handleColumnDrop(event) {
      event.preventDefault();
      var targetTh = event.target.closest('th');
      if (!targetTh || draggedColumnIdx === null) return;
      
      var targetIdx = parseInt(targetTh.dataset.colIdx);
      if (targetIdx === draggedColumnIdx) return;
      
      // Reorder columns
      var cols = gridState.visibleColumns.slice();
      var draggedCol = cols.splice(draggedColumnIdx, 1)[0];
      cols.splice(targetIdx, 0, draggedCol);
      
      // Save new order
      gridState.visibleColumns = cols;
      gridState.columnOrder = cols.slice();
      
      // Re-render grid with new column order
      renderGrid();
      showToast('Column order updated', 'success');
    }
    
    function handleColumnDragEnd(event) {
      // Reset styling on all headers
      var headers = document.querySelectorAll('#grid-header-row th');
      headers.forEach(function(th) {
        th.style.opacity = '1';
        th.style.borderLeft = '';
      });
      draggedColumnIdx = null;
    }
    
    function getGridDataset() {
      // Priority: workbook > allData > localStorage cache
      if (workbook.order.length > 0) {
        // Build dataset from workbook
        // v1.4.15: Store _sheetRowIndex for stable click handler identity
        var records = [];
        workbook.order.forEach(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          if (sheet && sheet.rows) {
            sheet.rows.forEach(function(row, sheetRowIndex) {
              var r = Object.assign({}, row);
              r.sheet = sheetName;
              r._sheetRowIndex = sheetRowIndex;
              records.push(r);
            });
          }
        });
        currentDataset = { sf_contract_results: records };
        console.log('[Grid] Dataset from workbook:', workbook.order.length, 'sheets,', records.length, 'records');
        return currentDataset;
      }
      
      if (currentDataset) return currentDataset;
      
      if (!currentDataset && window.allData && window.allData.contractResults) {
        currentDataset = { sf_contract_results: window.allData.contractResults };
      }
      return currentDataset;
    }

    function initGrid() {
      // Parse query params from URL
      var hash = window.location.hash;
      var queryMatch = hash.match(/\?(.+)$/);
      if (queryMatch) {
        var params = new URLSearchParams(queryMatch[1]);
        gridState.filter = params.get('f') || 'all';
        gridState.sheet = params.get('sheet') || '';
        gridState.search = params.get('q') || '';
      }
      
      // Apply state to UI
      var searchInput = document.getElementById('grid-search');
      if (searchInput) searchInput.value = gridState.search;
      
      var sheetSelector = document.getElementById('grid-sheet-selector');
      if (sheetSelector) sheetSelector.value = gridState.sheet;
      
      updateGridFilterChips();
      populateGridSheetSelector();
      renderGrid();
    }

    function populateGridSheetSelector() {
      var selector = document.getElementById('grid-sheet-selector');
      if (!selector) return;
      
      selector.innerHTML = '<option value="">All Records</option>';
      var sheets = [];
      
      // Priority: workbook.order > dataset extraction
      if (workbook.order.length > 0) {
        sheets = workbook.order.slice();
      } else {
        var ds = getGridDataset();
        if (ds && ds.sf_contract_results) {
          var sheetSet = new Set();
          ds.sf_contract_results.forEach(function(r) {
            if (r.sheet) sheetSet.add(r.sheet);
          });
          sheets = Array.from(sheetSet).sort();
        }
      }
      
      // v1.6.4: Filter out meta sheets (change_log, RFIs, etc.)
      sheets = sheets.filter(function(s) { return !isMetaSheet(s); });
      
      // Sort deterministically
      sheets.sort();
      
      // v1.6.33: Keep "All Records" as default; only set first sheet if explicitly needed
      
      sheets.forEach(function(sheet) {
        var opt = document.createElement('option');
        opt.value = sheet;
        opt.textContent = sheet;
        if (sheet === gridState.sheet) opt.selected = true;
        selector.appendChild(opt);
      });
      updateSidebarSheetSelector();
      
      // Attach change handler
      selector.onchange = function() {
        gridState.sheet = selector.value || null;
        updateGridURL();
        renderGrid();
        updateProgressBlock();
        
        // v1.6.39: Update field dropdown when sheet changes (for Patch Studio)
        if (typeof populateTargetFieldDropdown === 'function') {
          populateTargetFieldDropdown();
        }
      };
    }

    function setGridFilter(filter) {
      gridState.filter = filter;
      updateGridFilterChips();
      updateGridURL();
      renderGrid();
        updateProgressBlock();
    }

    function updateGridFilterChips() {
      var chips = document.querySelectorAll('#grid-status-chips .filter-chip');
      chips.forEach(function(chip) {
        if (chip.dataset.filter === gridState.filter) {
          chip.classList.add('active');
        } else {
          chip.classList.remove('active');
        }
      });
    }

    function updateGridURL() {
      var params = [];
      if (gridState.filter && gridState.filter !== 'all') params.push('f=' + encodeURIComponent(gridState.filter));
      if (gridState.sheet) params.push('sheet=' + encodeURIComponent(gridState.sheet));
      if (gridState.search) params.push('q=' + encodeURIComponent(gridState.search));
      
      var newHash = '#/grid' + (params.length > 0 ? '?' + params.join('&') : '');
      if (window.location.hash !== newHash) {
        history.replaceState(null, '', newHash);
      }
    }

    function renderGrid() {
        console.log('[T0:GUARD] renderGrid called, sheet:', gridState.sheet, 'filter:', gridState.filter);
      var perfT = perfStart();
      // v1.6.11: Show/hide change legend based on whether change map is active
      var legendEl = document.getElementById('grid-change-legend');
      if (legendEl) {
        legendEl.style.display = changeMapStore.enabled ? 'block' : 'none';
      }
      
      // v1.4.4: Improved empty state handling
      if (!dataLoaded) {
        document.getElementById('grid-tbody').innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 40px; color: #666;">' +
          '<div style="margin-bottom: 10px;">No data loaded</div>' +
          '<button class="top-toolbar-btn" onclick="openDataSourcePanel()">Add Data Source</button>' +
          '</td></tr>';
        document.getElementById('grid-row-count').textContent = '0 records';
        return;
      }
      
      var ds = getGridDataset();
      if (!ds) {
        // Workbook exists but getGridDataset returned null
        var sheetName = workbook.activeSheet || 'unknown';
        document.getElementById('grid-tbody').innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 40px; color: #666;">' +
          '<div style="font-weight: 600; margin-bottom: 5px;">0 rows in sheet: ' + escapeHtml(sheetName) + '</div>' +
          '<div style="font-size: 0.85em; color: #888;">The selected section has no data rows.</div>' +
          '</td></tr>';
        document.getElementById('grid-row-count').textContent = '0 records in ' + sheetName;
        return;
      }
      var records = ds.sf_contract_results || [];
      
      // Apply filters: sheet -> status -> search
      var filtered = records;
      
      // Sheet filter
      if (gridState.sheet) {
        filtered = filtered.filter(function(r) { return r.sheet === gridState.sheet; });
      }
      
      // Status filter
      if (gridState.filter && gridState.filter !== 'all') {
        filtered = filtered.filter(function(r) {
          var status = (r.status || '').toLowerCase().replace(/\s+/g, '_');
          return status === gridState.filter;
        });
      }
      
      // Search filter
      if (gridState.search) {
        var searchLower = gridState.search.toLowerCase();
        filtered = filtered.filter(function(r) {
          return Object.values(r).some(function(v) {
            return String(v).toLowerCase().includes(searchLower);
          });
        });
      }

      // v2.2 P2: Merged batch filter
      if (_activeMergedBatchFilter) {
        var _mbatch = BatchMerge.getMergedBatch(_activeMergedBatchFilter);
        if (_mbatch && _mbatch.contract_refs) {
          var _mbCids = _mbatch.contract_refs;
          filtered = filtered.filter(function(r) {
            var cid = ContractIndex.isAvailable() ? ContractIndex.deriveContractId(r) : null;
            return cid && _mbCids[cid];
          });
        }
      }

      // v2.2: Contract filter
      if (_activeContractFilter && ContractIndex.isAvailable()) {
        filtered = filtered.filter(function(r) {
          return ContractIndex.deriveContractId(r) === _activeContractFilter;
        });
      }
      
      // v1.5.2: Verifier mode - apply division/status filters from verifierFilterState
      if (currentMode === 'verifier') {
        // Refresh prStatusMap for accurate filtering
        renderVerifierGrid();
        
        // Filter by division if set (uses matchesDivisionFilter for Unassigned support)
        if (verifierFilterState.division) {
          filtered = filtered.filter(function(r) {
            return matchesDivisionFilter(r);
          });
        }
        
        // Filter by PR status if set - only show records with matching PatchRequest status
        // Guard: only apply if prStatusMap is populated (PR data loaded)
        if (verifierFilterState.status && window.verifierPrStatusMap && Object.keys(window.verifierPrStatusMap).length > 0) {
          filtered = filtered.filter(function(r) {
            var recordId = r.record_id || r.contract_key || '';
            var prInfo = window.verifierPrStatusMap[recordId];
            if (!prInfo) return false; // No PatchRequest = not shown when status filter active
            return prInfo.status === verifierFilterState.status;
          });
        } else if (verifierFilterState.status && (!window.verifierPrStatusMap || Object.keys(window.verifierPrStatusMap).length === 0)) {
          // PR data not yet loaded - skip status filter and show toast
          console.log('[Verifier] Status filter skipped - no PatchRequest data loaded yet');
        }
      }
      
      // Deterministic sorting: severity -> identity triplet -> original index
      // v1.6.18: Seed _originalIdx in O(n) upfront on full records array (not on filtered)
      // This avoids O(n^2) indexOf calls in the loop
      var perfT2 = perfStart();
      for (var i = 0; i < records.length; i++) {
        if (records[i]._originalIdx === undefined) {
          records[i]._originalIdx = i;
        }
      }
      perfLog('Seed _originalIdx', perfT2);
      
      filtered.sort(function(a, b) {
        // Severity order: blocking > warning > info
        var sevOrder = { blocking: 0, warning: 1, info: 2 };
        var sevA = sevOrder[(a.severity || 'info').toLowerCase()] || 2;
        var sevB = sevOrder[(b.severity || 'info').toLowerCase()] || 2;
        if (sevA !== sevB) return sevA - sevB;
        
        // Identity triplet
        var ckA = String(a.contract_key || '');
        var ckB = String(b.contract_key || '');
        if (ckA !== ckB) return ckA.localeCompare(ckB);
        
        var fuA = String(a.file_url || '');
        var fuB = String(b.file_url || '');
        if (fuA !== fuB) return fuA.localeCompare(fuB);
        
        var fnA = String(a.file_name || '');
        var fnB = String(b.file_name || '');
        if (fnA !== fnB) return fnA.localeCompare(fnB);
        
        // Fallback to stable original row index
        return (a._originalIdx || 0) - (b._originalIdx || 0);
      });
      

      // ── P1C: Contract Composite Grid ──
      if (_p1cIsCompositeMode()) {
        _p1cRenderComposite(filtered, records);
        perfLog('renderGrid(composite)', perfT);
        if (typeof hideUploadLoading === 'function') hideUploadLoading();
        return;
      }
      // P1C cleanup: remove composite view when not in composite mode
      var _p1cOldRoot = document.getElementById('p1c-composite-root');
      if (_p1cOldRoot) { _p1cOldRoot.parentNode.removeChild(_p1cOldRoot); console.log('[GRID-COMPOSITE][P1C] mode_disabled'); }
      var _p1cCtrl = document.getElementById('p1c-composite-controls');
      if (_p1cCtrl) _p1cCtrl.style.display = 'none';
      var _p1cOrigTable = document.getElementById('grid-table');
      if (_p1cOrigTable) _p1cOrigTable.style.display = '';

      // Determine columns from workbook sheet or fallback to defaults (v1.4.3 GRID-01)
      var columns = ['contract_key', 'file_name', 'file_url', 'status', 'subtype'];
      var activeSheetName = gridState.sheet || workbook.activeSheet;
      
      if (activeSheetName && workbook.sheets[activeSheetName]) {
        // Use headers from the active sheet
        columns = workbook.sheets[activeSheetName].headers.filter(function(h) {
          return h && h !== '_row_index';
        });
        console.log('[Grid] Using columns from sheet:', activeSheetName, columns.length, 'columns');
      } else if (filtered.length > 0) {
        // Extract columns from first record
        var sampleRow = filtered[0];
        columns = Object.keys(sampleRow).filter(function(k) {
          return k !== '_row_index' && k !== '_originalIdx' && k !== 'sheet';
        });
      }
      
      // v1.6.46: Apply preferred column order for display
      gridState.allColumns = columns.slice();
      gridState.visibleColumns = getPreferredColumnOrder(columns);
      
      // Render header with Excel-style column letters (A, B, C...)
      var headerRow = document.getElementById('grid-header-row');
      var headerHtml = '<th class="row-index" style="background: #f0f0f0; font-weight: 600;">#</th>';
      gridState.visibleColumns.forEach(function(col, idx) {
        var colLetter = getColumnLetter(idx);
        var displayName = col.replace(/_c$/i, '').replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
        if (displayName.length > 20) displayName = displayName.substring(0, 18) + '...';
        headerHtml += '<th draggable="true" data-col-idx="' + idx + '" data-col-name="' + col + '" ' +
          'ondragstart="handleColumnDragStart(event)" ondragover="handleColumnDragOver(event)" ' +
          'ondrop="handleColumnDrop(event)" ondragend="handleColumnDragEnd(event)" ' +
          'style="cursor: grab; user-select: none; min-width: 80px;">' +
          '<div style="font-size: 0.7em; color: #888; margin-bottom: 2px; font-weight: 600;">' + colLetter + '</div>' +
          '<div title="' + col + '" style="font-size: 0.85em;">' + displayName + '</div></th>';
      });
      headerRow.innerHTML = headerHtml;
      
      // Render body with virtualization for large datasets
      var tbody = document.getElementById('grid-tbody');
      var VIRTUALIZE_THRESHOLD = 2000;
      var BATCH_SIZE = 100;
      
      if (filtered.length === 0) {
        cleanupGridVirtualization();
        tbody.innerHTML = '<tr><td colspan="' + (gridState.visibleColumns.length + 1) + '" style="text-align: center; padding: 40px; color: #666;">No records match filters</td></tr>';
      } else if (filtered.length > VIRTUALIZE_THRESHOLD) {
        // Virtualized rendering: render first batch and add scroll listener
        renderGridBatch(filtered, 0, BATCH_SIZE, gridState.visibleColumns, true);
        console.log('[Grid] Virtualized render enabled for ' + filtered.length + ' rows');
      } else {
        // Cleanup virtualization when not needed
        cleanupGridVirtualization();
        // v1.5.2: Pass sheet name and original row index to click handler
        // Also apply verifier highlighting if in verifier mode
        var isVerifierMode = currentMode === 'verifier';
        // v1.6.18: Status key normalization
        var STATUS_KEYS = ['status', 'Status', 'sf_contract_status', 'review_state', 'Review_State'];
        
        tbody.innerHTML = filtered.map(function(r, idx) {
          // v1.6.18: Normalize status field lookup
          var statusVal = '';
          for (var si = 0; si < STATUS_KEYS.length; si++) {
            if (r[STATUS_KEYS[si]]) { statusVal = r[STATUS_KEYS[si]]; break; }
          }
          var statusClass = 'status-' + (statusVal || '').toLowerCase().replace(/\s+/g, '_');
          var sheetName = escapeHtml(r.sheet || '');
          var sheetRowIdx = r._sheetRowIndex !== undefined ? r._sheetRowIndex : idx;
          // v1.5.3 Fix: Check _identity.record_id as well for newly loaded rows
          // v1.6.2 Fix: Match signalStore recordId derivation (sheetName:idx fallback)
          var recordId = r.record_id || (r._identity && r._identity.record_id) || r.contract_key || '';
          if (!recordId) {
            recordId = sheetName + ':' + sheetRowIdx;
          }
          // v1.6.18: Build row classes with change highlighting
          var rowClasses = ['clickable'];
          var changeSummary = getRecordChangeSummary(recordId);
          if (changeSummary && changeSummary.total > 0) {
            if (changeSummary.by_type.added) rowClasses.push('row-added');
            else if (changeSummary.by_type.blacklist) rowClasses.push('row-removed');
            else if (changeSummary.by_type.removed) rowClasses.push('row-removed');
            else rowClasses.push('row-changed'); // correction, rfi, system_change
          }
          // v1.5.2: Verifier mode - apply PR status highlighting
          var rowStyle = '';
          var clickHandler = 'openRowReviewDrawer(\'' + sheetName + '\',' + sheetRowIdx + ')';
          if (isVerifierMode) {
            var highlight = getVerifierRowHighlight(recordId);
            if (highlight) {
              rowStyle = 'background: ' + highlight.bg + '; border-left: 3px solid ' + highlight.border + ';';
            }
            // Route verifier clicks through handleVerifierRowClick
            clickHandler = 'handleVerifierRowClick(\'' + escapeHtml(recordId) + '\', \'' + sheetName + '\', ' + sheetRowIdx + ')';
          }
          // v1.6.2: Add row badges for signal counts
          var rowBadgesHtml = renderRowBadges(recordId);
          return '<tr class="' + rowClasses.join(' ') + '" style="' + rowStyle + '" data-sheet-name="' + sheetName + '" data-record-index="' + sheetRowIdx + '" data-record-id="' + escapeHtml(recordId) + '" onclick="' + clickHandler + '">' +
            '<td class="row-index">' + (idx + 1) + rowBadgesHtml + '</td>' +
            gridState.visibleColumns.map(function(col) {
              var val = r[col];
              if (val === null || val === undefined) val = '';
              if (typeof val === 'object') val = JSON.stringify(val);
              
              // v1.6.46: Make File_Name a clickable link using file_url
              var isFileNameCol = col.toLowerCase().includes('file_name');
              var cellContent = String(val);
              if (isFileNameCol && val) {
                var fileUrl = r.file_url || r.File_URL_c || '';
                if (fileUrl) {
                  var shortName = val.length > 40 ? val.substring(0, 38) + '...' : val;
                  cellContent = '<a href="' + fileUrl + '" target="_blank" onclick="event.stopPropagation();" style="color: #1976d2; text-decoration: none; display: inline-flex; align-items: center; gap: 4px;"><span style="font-size: 0.9em;">&#128279;</span>' + shortName + '</a>';
                }
              }
              
              // v1.6.18: Apply status class for any status-variant column
              var isStatusCol = STATUS_KEYS.indexOf(col) >= 0 || col.toLowerCase() === 'status';
              var cellClass = isStatusCol ? statusClass : '';
              // v1.6.2: Apply signal-based cell coloring (v1.6.18: pass record)
              var cellStyle = getGridCellStyle(recordId, col, r);
              var changeInfo = getCellChangeInfo(recordId, col, r); var titlePrefix = changeInfo && CHANGE_TYPE_STYLES[changeInfo.type] ? '[' + CHANGE_TYPE_STYLES[changeInfo.type].label + '] ' : ''; return '<td class="' + cellClass + ' truncated" style="' + cellStyle + '" title="' + titlePrefix + String(val).replace(/"/g, '&quot;') + '">' + cellContent + '</td>';
            }).join('') +
            '</tr>';
        }).join('');
      }
      
      // Update footer
      document.getElementById('grid-row-count').textContent = filtered.length + ' of ' + records.length + ' records';
      gridState.filteredData = filtered;
      
      var filterInfo = [];
      if (gridState.sheet) filterInfo.push('Sheet: ' + gridState.sheet);
      if (gridState.filter !== 'all') filterInfo.push('Status: ' + gridState.filter);
      if (gridState.search) filterInfo.push('Search: "' + gridState.search + '"');
      document.getElementById('grid-filter-info').textContent = filterInfo.join(' | ');
      
      // Update per-sheet mini stats
      updateGridSheetStats(records, filtered);
      perfLog('renderGrid', perfT);
      
      // v1.6.46: Always hide upload loading after grid renders (catches non-virtualized path)
      if (typeof hideUploadLoading === 'function') {
        hideUploadLoading();
      }
    }
    
    function updateGridSheetStats(allRecords, filtered) {
      // Compute stats for visible/filtered records
      var rowCount = filtered.length;
      var readyCount = 0, reviewCount = 0, blockedCount = 0;
      
      // Use filtered set for counts to match current view
      filtered.forEach(function(r) {
        var status = (r.status || '').toLowerCase().replace(/\s+/g, '_');
        if (status === 'ready') readyCount++;
        else if (status === 'needs_review') reviewCount++;
        else if (status === 'blocked') blockedCount++;
      });
      
      // For total context, also compute from sheet-level (unfiltered by status/search)
      var sheetTotal = gridState.sheet ? 
        allRecords.filter(function(r) { return r.sheet === gridState.sheet; }).length : 
        allRecords.length;
      
      document.querySelector('#grid-stat-rows .stat-value').textContent = rowCount + ' / ' + sheetTotal;
      document.querySelector('#grid-stat-ready .stat-value').textContent = readyCount;
      document.querySelector('#grid-stat-review .stat-value').textContent = reviewCount;
      document.querySelector('#grid-stat-blocked .stat-value').textContent = blockedCount;
      
      // Unknown columns count (admin only - already gated by CSS admin-only-content)
      var unknownCount = getUnknownColumnsCount(gridState.sheet);
      document.querySelector('#grid-stat-unknown .stat-value').textContent = unknownCount;
    }
    
    function getUnknownColumnsCount(sheetName) {
      var unknownCols = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
      if (sheetName && unknownCols[sheetName]) {
        return unknownCols[sheetName].length;
      }
      var total = 0;
      Object.keys(unknownCols).forEach(function(sheet) {
        total += (unknownCols[sheet] || []).length;
      });
      return total;
    }

    function toggleColumnMenu() {
      var menu = document.getElementById('grid-column-menu');
      if (menu.style.display === 'none') {
        // Build checkboxes
        var container = document.getElementById('grid-column-checkboxes');
        container.innerHTML = gridState.allColumns.map(function(col) {
          var checked = gridState.visibleColumns.includes(col) ? 'checked' : '';
          return '<label style="display: block; margin: 4px 0; cursor: pointer;"><input type="checkbox" ' + checked + ' onchange="toggleGridColumn(\'' + col + '\', this.checked)"> ' + 
            col.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }) + '</label>';
        }).join('');
        menu.style.display = 'block';
      } else {
        menu.style.display = 'none';
      }
    }

    function toggleGridColumn(col, visible) {
      if (visible && !gridState.visibleColumns.includes(col)) {
        gridState.visibleColumns.push(col);
      } else if (!visible) {
        gridState.visibleColumns = gridState.visibleColumns.filter(function(c) { return c !== col; });
      }
      renderGrid();
    }



    // ═══ P1D: Contract-Centric Pre-Flight Grouping ═══
    var _p1dGroupState = {};
    var _p1dAccordionLocked = false;

    function _p1dToggleGroup(groupId) {
      if (_p1dAccordionLocked) {
        console.log('[PREFLIGHT-LIVE][OCR] accordion_locked_during_scan: ' + groupId);
        return;
      }
      console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] group_toggled: ' + groupId);
      var children = document.querySelectorAll('.p1d1-child-row[data-parent="' + groupId + '"]');
      var caretEl = document.querySelector('[data-caret="' + groupId + '"]');
      if (!children.length) return;
      var isCurrentlyHidden = children[0].style.display === 'none';
      for (var i = 0; i < children.length; i++) {
        children[i].style.display = isCurrentlyHidden ? '' : 'none';
      }
      if (caretEl) caretEl.textContent = isCurrentlyHidden ? '▼' : '▶';
      _p1dGroupState[groupId] = !isCurrentlyHidden;
    }

    // v2.3.5-P1D.1: Resolve account name from workbook data fields for a given contract key
    function _p1d1ResolveAccountName(contractKey, fileName) {
      var ACCT_FIELDS = [
        'Account_Name_c', 'Account_Name', 'account_name', 'account_name_c',
        'Artist_Name_pka_or_dba_c', 'Artist_Name_c', 'artist_name',
        'Legal_Name_c', 'legal_name',
        'Payee_c', 'Name'
      ];
      if (typeof workbook === 'undefined' || !workbook.sheets) return '';
      var sheets = Object.keys(workbook.sheets);
      for (var si = 0; si < sheets.length; si++) {
        var sn = sheets[si];
        if (sn.indexOf('_change_log') >= 0 || sn === 'RFIs & Analyst Notes') continue;
        var rows = (workbook.sheets[sn] && workbook.sheets[sn].rows) || [];
        for (var ri = 0; ri < rows.length; ri++) {
          var r = rows[ri];
          var rck = r.contract_key || '';
          var rfn = r.File_Name_c || r.File_Name || r.file_name || '';
          var matched = false;
          if (contractKey && rck && rck === contractKey) matched = true;
          if (!matched && fileName && rfn && rfn === fileName) matched = true;
          if (!matched) continue;
          for (var fi = 0; fi < ACCT_FIELDS.length; fi++) {
            var val = r[ACCT_FIELDS[fi]];
            if (val && typeof val === 'string' && val.trim() && val !== 'N/A' && val !== '-' && val.trim().length > 1) {
              return val.trim();
            }
          }
        }
      }
      return '';
    }

    // v2.3.5-P1D.1: Get human-readable batch name from IDENTITY_CONTEXT or session
    function _p1d1GetBatchName() {
      var dsId = (typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.dataset_id) || '';
      if (dsId) {
        var clean = dsId.replace(/\.(xlsx|csv|xls)$/i, '').replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
        return clean;
      }
      return '';
    }

    function resolvePreflightContractKey(item) {
      var result = { contract_group_id: '_batch_level', contract_display_name: 'Batch-level Issues', source_url: '', domain: '', confidence: 'none', source: 'none' };

      var cid = item.contract_id || '';
      if (cid && cid.indexOf('ctr_') === 0) {
        result.contract_group_id = cid;
        result.confidence = 'high';
        result.source = 'contract_id';
        result.contract_display_name = _p1d1ResolveAccountName(cid, item.file_name) || cid;
        result.source_url = item.file_url || '';
        result.domain = _p1dExtractDomain(item);
        return result;
      }

      var ck = item.contract_key || '';
      if (ck) {
        var rid = item.record_id || '';
        if (rid && typeof workbook !== 'undefined' && workbook.sheets) {
          var sheets = Object.keys(workbook.sheets);
          for (var si = 0; si < sheets.length; si++) {
            var rows = (workbook.sheets[sheets[si]] && workbook.sheets[sheets[si]].rows) || [];
            for (var ri = 0; ri < rows.length; ri++) {
              var r = rows[ri];
              if ((r._identity && r._identity.record_id === rid) || r.record_id === rid) {
                var derivedCid = (r._identity && r._identity.contract_id) || '';
                if (derivedCid) {
                  result.contract_group_id = derivedCid;
                  result.confidence = 'high';
                  result.source = 'row_lookup';
                  result.contract_display_name = _p1d1ResolveAccountName(derivedCid, item.file_name) || derivedCid;
                  result.source_url = item.file_url || r.file_url || r.File_URL_c || '';
                  result.domain = _p1dExtractDomain(item);
                  return result;
                }
              }
            }
          }
        }

        var fu = item.file_url || '';
        if (fu && typeof ContractIndex !== 'undefined') {
          var canonUrl = ContractIndex._canonicalizeUrl(fu);
          var fileId = ContractIndex._extractFileIdentifier(canonUrl);
          if (fileId && !ContractIndex._isHeaderLike(fileId)) {
            result.contract_group_id = 'ctr_' + simpleHash(fileId);
            result.confidence = 'medium';
            result.source = 'url_hash';
          } else if (canonUrl) {
            result.contract_group_id = 'ctr_' + simpleHash(canonUrl);
            result.confidence = 'medium';
            result.source = 'url_hash';
          }
          result.source_url = fu;
          result.domain = _p1dExtractDomain(item);
          result.contract_display_name = _p1d1ResolveAccountName(result.contract_group_id, item.file_name) || ck;
          return result;
        }

        var fn = item.file_name || ck;
        if (fn) {
          result.contract_group_id = 'ctr_' + simpleHash(fn.replace(/\s+/g, '_').trim());
          result.confidence = 'low';
          result.source = 'slug_fallback';
          result.contract_display_name = fn.replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
          result.source_url = item.file_url || '';
          result.domain = _p1dExtractDomain(item);
          console.log('[P1D-DEDUPE][FALLBACK] item used fallback source=slug_fallback key=' + result.contract_group_id);
          return result;
        }
      }

      if (item.file_url || item.file_name) {
        var _fu2 = item.file_url || '';
        var _fn2 = item.file_name || '';
        if (_fu2 && typeof ContractIndex !== 'undefined') {
          var _canon = ContractIndex._canonicalizeUrl(_fu2);
          var _fid = ContractIndex._extractFileIdentifier(_canon);
          if (_fid && !ContractIndex._isHeaderLike(_fid)) {
            result.contract_group_id = 'ctr_' + simpleHash(_fid);
          } else {
            result.contract_group_id = 'ctr_' + simpleHash(_canon);
          }
          result.confidence = 'medium';
          result.source = 'url_hash_no_ck';
        } else if (_fn2) {
          result.contract_group_id = 'ctr_' + simpleHash(_fn2.replace(/\s+/g, '_').trim());
          result.confidence = 'low';
          result.source = 'filename_hash';
        }
        result.contract_display_name = (_fn2 || _fu2).replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
        result.source_url = _fu2;
        result.domain = _p1dExtractDomain(item);
        if (result.confidence === 'low') {
          console.log('[P1D-DEDUPE][FALLBACK] item used fallback source=' + result.source + ' key=' + result.contract_group_id);
        }
        return result;
      }

      return result;
    }

    function _p1dExtractDomain(item) {
      var u = item.file_url || '';
      if (u) {
        try { var m = u.match(/^https?:\/\/([^\/]+)/); if (m) return m[1]; } catch(e) {}
      }
      return '';
    }

    function _p1dGetGroupKey(item) {
      if (!item._contract_resolved) {
        var resolved = resolvePreflightContractKey(item);
        item._contract_group_id = resolved.contract_group_id;
        item._contract_display_name = resolved.contract_display_name;
        item._contract_source_url = resolved.source_url;
        item._contract_domain = resolved.domain;
        item._contract_confidence = resolved.confidence;
        item._contract_source = resolved.source;
        item._contract_resolved = true;
      }
      return item._contract_group_id;
    }

    function _p1dGetDisplayName(groupKey, items) {
      if (groupKey === '_batch_level') return 'Batch-level Issues';
      var batchName = _p1d1GetBatchName();
      var itemFileName = '';
      for (var fi = 0; fi < items.length; fi++) {
        if (items[fi].file_name) { itemFileName = items[fi].file_name; break; }
      }
      for (var i = 0; i < items.length; i++) {
        if (items[i]._contract_display_name) {
          var dn = items[i]._contract_display_name;
          var isRawKey = (dn.indexOf('ctr_') === 0) || (/^ROW_\d+/.test(dn)) || (/^[a-z_]+:ROW_\d+/.test(dn));
          if (!isRawKey) {
            return batchName ? dn + ' : ' + batchName : dn;
          }
        }
      }
      var itemContractKey = '';
      for (var _cki = 0; _cki < items.length; _cki++) {
        if (items[_cki].contract_key) { itemContractKey = items[_cki].contract_key; break; }
      }
      var acctName = _p1d1ResolveAccountName(itemContractKey, itemFileName);
      if (acctName) return batchName ? acctName + ' : ' + batchName : acctName;
      if (itemFileName) {
        var fnClean = itemFileName.replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
        if (fnClean.length > 50) fnClean = fnClean.substring(0, 48) + '\u2026';
        return batchName ? fnClean + ' : ' + batchName : fnClean;
      }
      var gkClean = groupKey.replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
      if (gkClean && gkClean !== '_batch_level') return batchName ? gkClean + ' : ' + batchName : gkClean;
      return batchName || groupKey;
    }

    function _p1dGetDomainHint(items) {
      for (var i = 0; i < items.length; i++) {
        if (items[i]._contract_domain) return items[i]._contract_domain;
        var u = items[i].file_url || '';
        if (u) {
          try {
            var m = u.match(/^https?:\/\/([^\/]+)/);
            if (m) return m[1];
          } catch(e) {}
        }
      }
      return '';
    }

    function _p1d1ViewContract(contractKey) {
      console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] view_contract: ' + contractKey);
      var _openedRecord = false;
      if (contractKey && typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && ContractIndex._index && ContractIndex._index.contracts[contractKey]) {
        var _ci = ContractIndex._index.contracts[contractKey];
        if (_ci.sheets) {
          var _sheetKeys = Object.keys(_ci.sheets);
          for (var _ski = 0; _ski < _sheetKeys.length; _ski++) {
            var _sn = _sheetKeys[_ski];
            var _rows = _ci.sheets[_sn];
            if (_rows && _rows.length > 0 && typeof workbook !== 'undefined' && workbook.sheets && workbook.sheets[_sn] && workbook.sheets[_sn].rows) {
              var _ri = _rows[0].row_index !== undefined ? _rows[0].row_index : _rows[0];
              if (_ri < workbook.sheets[_sn].rows.length) {
                openRowReviewDrawer(_sn, _ri);
                _openedRecord = true;
                break;
              }
            }
          }
        }
      }
      if (!_openedRecord) {
        if (typeof handleContractFilterChange === 'function') {
          handleContractFilterChange(contractKey);
        }
        var gridSelector = document.getElementById('contract-filter-selector') || document.getElementById('sidebar-sheet-selector');
        if (gridSelector) gridSelector.value = contractKey;
        window.location.hash = '#/grid';
        if (typeof renderGrid === 'function') renderGrid();
      }
    }




    // P1X-ref: Resolve a meaningful business reference for a pre-flight item
    function _p1xGetReference(item) {
      var REF_FIELDS = [
        'Account_Name_c', 'Account_Name', 'Artist_Name_pka_or_dba_c',
        'Opportunity_Name', 'Opportunity_Name_c',
        'Legal_Name_c', 'Legal_First_Name_c',
        'Album_Name_c', 'Artist_Name_c', 'Name',
        'Payee_c', 'Description', 'Title',
        'Writer_Name__c', 'Writer_Name_c',
        'Add_Ons_c', 'Type_c'
      ];
      var ck = item.contract_key || item.contract_id || '';
      var sn = item.sheet_name || '';
      // Try to find the first row in workbook matching this contract
      if (typeof workbook !== 'undefined' && workbook.sheets && sn && workbook.sheets[sn]) {
        var rows = workbook.sheets[sn].rows || [];
        for (var ri = 0; ri < rows.length; ri++) {
          var r = rows[ri];
          var rck = r.contract_key || r.File_Name_c || r.File_Name || '';
          if (rck === ck) {
            for (var fi = 0; fi < REF_FIELDS.length; fi++) {
              var val = r[REF_FIELDS[fi]];
              if (val && typeof val === 'string' && val.trim() && val !== 'N/A' && val !== '-') {
                var ref = val.trim();
                return ref.length > 40 ? ref.substring(0, 38) + '...' : ref;
              }
            }
            break;
          }
        }
      }
      // Fallback: clean up file_name or contract_key
      var fn = item.file_name || ck || '';
      if (fn) {
        fn = fn.replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ');
        fn = fn.replace(/\s+/g, ' ').trim();
        return fn.length > 40 ? fn.substring(0, 38) + '...' : fn;
      }
      return sn || '-';
    }

    // ═══ PREFLIGHT-TERMS: Contract Section + Glossary Term Mapping ═══
    var _SECTION_CANON = {
      'accounts': 'Accounts',
      'account': 'Accounts',
      'opportunity': 'Opportunities',
      'opportunities': 'Opportunities',
      'financials': 'Financials',
      'financial': 'Financials',
      'catalog': 'Catalog',
      'schedule': 'Schedule',
      'schedule_catalog': 'Schedule Catalog',
      'schedule catalog': 'Schedule Catalog',
      'schedulecatalog': 'Schedule Catalog',
      'v2_add_ons': 'V2 Add Ons',
      'v2 add ons': 'V2 Add Ons',
      'v2addons': 'V2 Add Ons',
      'add_ons': 'V2 Add Ons',
      'add ons': 'V2 Add Ons',
      'contacts': 'Contacts',
      'contact': 'Contacts'
    };

    function canonicalContractSection(rawName) {
      if (!rawName) return { contract_section_key: 'unknown', contract_section_label: 'Unknown' };
      var trimmed = rawName.trim();
      var lower = trimmed.toLowerCase().replace(/[\s_]+/g, '_');
      if (_SECTION_CANON[lower]) {
        var label = _SECTION_CANON[lower];
        return { contract_section_key: label.toLowerCase().replace(/\s+/g, '_'), contract_section_label: label };
      }
      var lowerSpace = trimmed.toLowerCase().replace(/[_]+/g, ' ').trim();
      if (_SECTION_CANON[lowerSpace]) {
        var label2 = _SECTION_CANON[lowerSpace];
        return { contract_section_key: label2.toLowerCase().replace(/\s+/g, '_'), contract_section_label: label2 };
      }
      if (_SECTION_CANON[trimmed.toLowerCase()]) {
        var label3 = _SECTION_CANON[trimmed.toLowerCase()];
        return { contract_section_key: label3.toLowerCase().replace(/\s+/g, '_'), contract_section_label: label3 };
      }
      var titleCase = trimmed.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      return { contract_section_key: trimmed.toLowerCase().replace(/\s+/g, '_'), contract_section_label: titleCase };
    }

    var _pfTermCache = null;
    function _buildPfTermCache() {
      if (_pfTermCache) return _pfTermCache;
      _pfTermCache = { bySection: {}, global: {} };
      if (typeof rulesBundleCache !== 'undefined' && rulesBundleCache.fieldMeta && rulesBundleCache.fieldMeta.fields) {
        var fields = rulesBundleCache.fieldMeta.fields;
        for (var i = 0; i < fields.length; i++) {
          var f = fields[i];
          var fk = (f.field_key || '').toLowerCase();
          var sheet = (f.sheet || '').toLowerCase().replace(/\s+/g, '_');
          if (!fk) continue;
          var entry = { field_label: f.field_label || '', field_key: f.field_key || '', definition: f.definition || '' };
          if (sheet) {
            if (!_pfTermCache.bySection[sheet]) _pfTermCache.bySection[sheet] = {};
            _pfTermCache.bySection[sheet][fk] = entry;
          }
          if (!_pfTermCache.global[fk]) _pfTermCache.global[fk] = entry;
        }
      }
      return _pfTermCache;
    }

    function resolvePreflightFieldTerm(item) {
      var cache = _buildPfTermCache();
      var sectionKey = (item.contract_section_key || '').toLowerCase();
      var rawFieldKey = item.field_key || item.field_name || '';
      var fkLower = rawFieldKey.toLowerCase();
      if (sectionKey && cache.bySection[sectionKey] && cache.bySection[sectionKey][fkLower]) {
        var exact = cache.bySection[sectionKey][fkLower];
        return { field_label: exact.field_label, field_key: rawFieldKey, field_definition: exact.definition, _resolution: 'exact' };
      }
      if (cache.global[fkLower]) {
        var glob = cache.global[fkLower];
        return { field_label: glob.field_label, field_key: rawFieldKey, field_definition: glob.definition, _resolution: 'global' };
      }
      var humanized = rawFieldKey.replace(/_c$/i, '').replace(/__c$/i, '').replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }).trim();
      if (humanized && humanized !== rawFieldKey) {
        return { field_label: humanized, field_key: rawFieldKey, field_definition: '', _resolution: 'humanized' };
      }
      return { field_label: rawFieldKey || 'Unknown Term', field_key: rawFieldKey, field_definition: '', _resolution: 'unknown' };
    }

    var _REASON_LABELS = {
      'OCR_UNREADABLE': 'Unreadable Content (OCR)',
      'OCR_MOJIBAKE': 'Encoding Artifacts (Mojibake)',
      'MISSING_REQUIRED': 'Missing Required Field',
      'PICKLIST_INVALID': 'Invalid Picklist Value',
      'UNKNOWN_COLUMN': 'Unknown Column',
      'HEADER_ECHO': 'Header Echo Row',
      'LOW_CONFIDENCE': 'Low Confidence Extraction',
      'UNATTACHED_SCHEDULE': 'Unattached Schedule',
      'TEXT_NOT_SEARCHABLE': 'Non-Searchable PDF',
      'PDF_VERIFIED_CLEAN': 'PDF Verified Clean',
      'MANUAL_REVIEW': 'Manual Review Required',
      'QA_FLAG': 'QA Validation Flag',
      'SYSTEM_CHANGE': 'System Change Applied'
    };

    var _pfTermStats = { exact: 0, global: 0, humanized: 0, unknown: 0 };

    function enrichPreflightItem(item) {
      var rawSheet = item.sheet_name || item.sheet || '';
      var section = canonicalContractSection(rawSheet);
      item.contract_section_key = section.contract_section_key;
      item.contract_section_label = section.contract_section_label;
      if (!item.sheet_name) item.sheet_name = section.contract_section_label;
      var term = resolvePreflightFieldTerm(item);
      item.field_label = term.field_label;
      if (!item.field_key) item.field_key = term.field_key;
      if (term.field_definition) item.field_definition = term.field_definition;
      _pfTermStats[term._resolution] = (_pfTermStats[term._resolution] || 0) + 1;
      var rc = item.blocker_type || item.signal_type || item.reason_code || '';
      item.reason_code = rc;
      item.reason_label = _REASON_LABELS[rc] || rc.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      return item;
    }

    function _logPfTermStats(context) {
      console.log('[PREFLIGHT-TERMS][MAP] ' + context + ': exact=' + _pfTermStats.exact + ', global=' + _pfTermStats.global + ', humanized=' + _pfTermStats.humanized + ', unknown=' + _pfTermStats.unknown);
      _pfTermStats = { exact: 0, global: 0, humanized: 0, unknown: 0 };
    }
    // ═══ END PREFLIGHT-TERMS ═══

    function _p1dRenderGrouped(items, containerId) {
      var container = document.getElementById(containerId);
      if (!container) return;

      if (items.length === 0) {
        container.innerHTML = '<div class="p1d-empty-state">No pre-flight items</div>';
        return;
      }

      var groups = {};
      var groupOrder = [];
      for (var i = 0; i < items.length; i++) {
        var key = _p1dGetGroupKey(items[i]);
        if (!groups[key]) {
          groups[key] = { items: [], blockers: 0, warnings: 0 };
          groupOrder.push(key);
        }
        groups[key].items.push(items[i]);
        if (items[i].severity === 'blocker') groups[key].blockers++;
        else groups[key].warnings++;
      }

      groupOrder.sort(function(a, b) {
        if (a === '_batch_level') return 1;
        if (b === '_batch_level') return -1;
        var ga = groups[a], gb = groups[b];
        if (gb.blockers !== ga.blockers) return gb.blockers - ga.blockers;
        if (gb.items.length !== ga.items.length) return gb.items.length - ga.items.length;
        var na = _p1dGetDisplayName(a, ga.items);
        var nb = _p1dGetDisplayName(b, gb.items);
        return na < nb ? -1 : (na > nb ? 1 : 0);
      });

      console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] model_built: groups=' + groupOrder.length + ', total_items=' + items.length);

      var _uniqueContracts = {};
      var _uniqueRecords = {};
      for (var ui = 0; ui < items.length; ui++) {
        var itm = items[ui];
        _p1dGetGroupKey(itm);
        var cgid = itm._contract_group_id || itm.contract_key || itm.contract_id || '';
        if (cgid && cgid !== '_batch_level') _uniqueContracts[cgid] = true;
        var rid = itm.record_id || '';
        if (rid && rid.indexOf('ROW_') !== 0) _uniqueRecords[rid] = true;
        else if (rid) _uniqueRecords[rid] = true;
      }
      var totalContracts = (typeof _p1fScanState !== 'undefined' && _p1fScanState.total > 0) ? _p1fScanState.total : Object.keys(_uniqueContracts).length;
      var affectedCount = Math.min(Object.keys(_uniqueContracts).length, totalContracts);
      var impactedCount = Object.keys(_uniqueRecords).length;
      console.log('[P1D-DEDUPE][COUNTS] affected_contracts=' + affectedCount + ' records_impacted=' + impactedCount);
      console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] metrics_recomputed: affected_contracts=' + affectedCount + '/' + totalContracts + ', records_impacted=' + impactedCount + ', total_issues=' + items.length);

      var html = '<table class="p1d1-health-table">';
      html += '<thead><tr>';
      html += '<th style="width:30px;"></th>';
      html += '<th>Contract</th>';
      html += '<th>ID</th>';
      html += '<th>Source</th>';
      html += '<th>Issues</th>';
      html += '<th>Severity</th>';
      html += '<th>Contract Sections</th>';
      html += '<th>Actions</th>';
      html += '<th>Health</th>';
      html += '</tr></thead><tbody>';

      var childrenRendered = 0;
      for (var gi = 0; gi < groupOrder.length; gi++) {
        var gk = groupOrder[gi];
        var g = groups[gk];
        var gItems = g.items;
        var groupId = 'p1d1-g-' + gi;
        var defaultCollapsed = true;
        var isCollapsed = _p1dGroupState[groupId] !== undefined ? _p1dGroupState[groupId] : defaultCollapsed;

        var displayName = _p1dGetDisplayName(gk, gItems);
        var _rawFn = ""; for (var _fni = 0; _fni < gItems.length; _fni++) { if (gItems[_fni].file_name) { _rawFn = gItems[_fni].file_name; break; } } var tooltipText = _rawFn ? _rawFn : gk;
        var compactId = 'batch';
        if (gk !== '_batch_level') {
          var _idFn = '';
          for (var _idi = 0; _idi < gItems.length; _idi++) {
            if (gItems[_idi].file_name) { _idFn = gItems[_idi].file_name; break; }
          }
          if (_idFn) {
            compactId = _idFn.replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ').replace(/\s+/g, ' ').trim();
            if (compactId.length > 28) compactId = compactId.substring(0, 26) + '\u2026';
          } else {
            var rawId = gk.indexOf('file:') === 0 ? gk.substring(5) : gk;
            if (rawId.indexOf('ctr_') === 0) {
              rawId = rawId.substring(0, 10);
            } else {
              rawId = rawId.replace(/_/g, ' ').trim();
            }
            compactId = rawId.length > 22 ? rawId.substring(0, 20) + '\u2026' : (rawId || gk);
          }
        }
        var domainHint = _p1dGetDomainHint(gItems);

        var _childDedupeMap = {};
        var _childDedupeOrder = [];
        var _dedupedBlockers = 0;
        var _dedupedWarnings = 0;
        for (var _cdi = 0; _cdi < gItems.length; _cdi++) {
          var _cdItem = gItems[_cdi];
          var _cdKey = (_cdItem._contract_group_id || _cdItem.contract_id || _cdItem.contract_key || '') + '|' + (_cdItem.contract_section_key || _cdItem.sheet_name || '') + '|' + (_cdItem.reason_code || _cdItem.blocker_type || _cdItem.signal_type || '') + '|' + (_cdItem.field_key || _cdItem.field_name || '') + '|' + (_cdItem.severity || '');
          if (_childDedupeMap[_cdKey]) {
            _childDedupeMap[_cdKey].count++;
          } else {
            _childDedupeMap[_cdKey] = { item: _cdItem, count: 1 };
            _childDedupeOrder.push(_cdKey);
            if (_cdItem.severity === 'blocker') _dedupedBlockers++;
            else _dedupedWarnings++;
          }
        }
        var _dedupedIssueCount = _childDedupeOrder.length;

        var sheetCounts = {};
        for (var _sci = 0; _sci < _childDedupeOrder.length; _sci++) {
          var _scItem = _childDedupeMap[_childDedupeOrder[_sci]].item;
          var sn = _scItem.contract_section_label || _scItem.sheet_name || 'Unknown';
          sheetCounts[sn] = (sheetCounts[sn] || 0) + 1;
        }
        var sectionChips = '';
        var sheetNames = Object.keys(sheetCounts).sort();
        for (var sc = 0; sc < sheetNames.length; sc++) {
          sectionChips += '<span class="p1d1-section-chip">' + escapeHtml(sheetNames[sc]) + ' (' + sheetCounts[sheetNames[sc]] + ')</span>';
        }

        var sevSummary = '';
        if (_dedupedBlockers > 0) sevSummary += '<span class="p1d1-sev-badge blocker">' + _dedupedBlockers + ' blocker' + (_dedupedBlockers > 1 ? 's' : '') + '</span>';
        if (_dedupedWarnings > 0) sevSummary += '<span class="p1d1-sev-badge warning">' + _dedupedWarnings + ' warning' + (_dedupedWarnings > 1 ? 's' : '') + '</span>';

        console.log('[P1D-DEDUPE][GROUP] contract_group_id=' + gk + ' raw_items=' + gItems.length + ' deduped_items=' + _dedupedIssueCount);

        var caretChar = isCollapsed ? '\u25B6' : '\u25BC';
        var parentClass = 'p1d1-parent-row';

        var _origCk = gk;
        for (var _oki = 0; _oki < gItems.length; _oki++) {
          if (gItems[_oki].contract_key) { _origCk = gItems[_oki].contract_key; break; }
          if (gItems[_oki].contract_id) { _origCk = gItems[_oki].contract_id; break; }
        }
        var viewContractAction = '';
        if (gk !== '_batch_level') {
          viewContractAction = '<button class="p1d1-view-btn" onclick="event.stopPropagation(); _p1d1ViewContract(\'' + escapeHtml(_origCk.replace(/'/g, "\\'")) + '\')">View Contract</button>';
        }

        html += '<tr class="' + parentClass + '" data-group-id="' + groupId + '" onclick="_p1dToggleGroup(\'' + groupId + '\')">';
        html += '<td class="p1d1-caret" data-caret="' + groupId + '">' + caretChar + '</td>';
        html += '<td class="p1d1-contract-name" title="' + escapeHtml(tooltipText) + '">' + escapeHtml(displayName) + '</td>';
        html += '<td class="p1d1-contract-id" title="' + escapeHtml(gk) + '"><code>' + escapeHtml(compactId) + '</code></td>';
        var _srcUrl = '';
        var _srcLabel = '';
        for (var _si = 0; _si < gItems.length; _si++) {
          if (gItems[_si]._contract_source_url) { _srcUrl = gItems[_si]._contract_source_url; break; }
          if (gItems[_si].file_url) { _srcUrl = gItems[_si].file_url; break; }
        }
        for (var _sli = 0; _sli < gItems.length; _sli++) {
          if (gItems[_sli].file_name) { _srcLabel = gItems[_sli].file_name.replace(/\.pdf$/i, '').replace(/_/g, ' ').replace(/-/g, ' ').replace(/\s+/g, ' ').trim(); break; }
        }
        if (!_srcLabel) _srcLabel = domainHint || 'Source';
        if (_srcLabel.length > 30) _srcLabel = _srcLabel.substring(0, 28) + '\u2026';
        if (_srcUrl) {
          html += '<td class="p1d1-domain"><a href="' + escapeHtml(_srcUrl) + '" target="_blank" rel="noopener" title="' + escapeHtml(_srcUrl) + '" style="color:#1565c0;text-decoration:none;font-size:0.9em;" onclick="event.stopPropagation();">' + escapeHtml(_srcLabel) + '</a></td>';
        } else {
          html += '<td class="p1d1-domain">' + escapeHtml(_srcLabel) + '</td>';
        }
        html += '<td class="p1d1-issue-count">' + _dedupedIssueCount + '</td>';
        html += '<td>' + sevSummary + '</td>';
        html += '<td class="p1d1-sections">' + sectionChips + '</td>';
        html += '<td>' + viewContractAction + '</td>';
        var healthHtml = '';
        var _hsKey = ContractHealthScore && ContractHealthScore._scores ? (ContractHealthScore._scores[gk] ? gk : ContractHealthScore._scores[_origCk] ? _origCk : null) : null;
        if (typeof ContractHealthScore !== 'undefined' && _hsKey && ContractHealthScore._scores[_hsKey]) {
          var hs = ContractHealthScore._scores[_hsKey];
          var band = hs.band;
          var tooltipLines = ['Score: ' + hs.score + '/100 (' + band.label + ')'];
          if (hs.penalties.length > 0) {
            tooltipLines.push('---');
            hs.penalties.forEach(function(p) { tooltipLines.push('-' + p.value + ' ' + p.reason + ' (' + p.detail + ')'); });
          }
          var tt = tooltipLines.join('\n').replace(/"/g, '&quot;');
          healthHtml = '<span style="display:inline-flex;align-items:center;padding:2px 8px;border-radius:10px;font-size:0.85em;background:' + band.bg + ';color:' + band.color + ';font-weight:600;cursor:help;" title="' + tt + '">' + hs.score + '</span>';
        } else {
          healthHtml = '<span style="color:#ccc;">-</span>';
        }
        html += '<td style="padding:8px 6px;text-align:center;">' + healthHtml + '</td>';
        html += '</tr>';

        var childDisplay = isCollapsed ? 'none' : '';
        for (var di = 0; di < _childDedupeOrder.length; di++) {
          var _cdEntry = _childDedupeMap[_childDedupeOrder[di]];
          var item = _cdEntry.item;
          var _dupCount = _cdEntry.count;
          var sName = escapeHtml(item.contract_section_label || item.sheet_name || 'Unknown');
          var fLabel;
          if (item._batch_scan && item.file_name) {
            fLabel = item.file_name;
            if (fLabel.length > 45) fLabel = fLabel.substring(0, 43) + '...';
          } else {
            fLabel = item.field_label || _p1xGetReference(item);
          }
          var fName = escapeHtml(fLabel);
          if (!item._batch_scan && item.field_key && item.field_key !== fLabel) {
            fName += ' <span style="color:#999;font-size:0.82em;">' + escapeHtml(item.field_key) + '</span>';
          }
          if (item.field_definition) {
            fName = '<span title="' + escapeHtml(item.field_definition) + '">' + fName + '</span>';
          }

          var reasonHtml = '-';
          if (item.blocker_type && typeof _preflightBlockerTypes !== 'undefined') {
            var bt = _preflightBlockerTypes[item.blocker_type] || {};
            var rLabel = bt.label || (item.blocker_type || '').replace(/_/g, ' ');
            var rTip = (bt.desc || item.message || '').replace(/"/g, '&quot;');
            reasonHtml = '<span class="p1d1-reason-chip" title="' + rTip + '">' + escapeHtml(rLabel) + '</span>';
          } else if (item.reason_summary || item.signal_type) {
            reasonHtml = escapeHtml(item.reason_summary || item.signal_type || '-');
          }

          var sevColor = item.severity === 'blocker' ? '#bf360c' : (item.severity === 'warning' ? '#f57c00' : '#666');
          var sevLabel = item.severity ? item.severity.charAt(0).toUpperCase() + item.severity.slice(1) : '-';
          var sevHtml = '<span style="color:' + sevColor + '; font-weight:500; font-size:0.85em;">' + sevLabel + '</span>';
          if (_dupCount > 1) {
            sevHtml += ' <span style="display:inline-block;background:#e0e0e0;color:#333;border-radius:8px;padding:1px 6px;font-size:0.75em;font-weight:600;margin-left:4px;">x' + _dupCount + '</span>';
          }

          var stBadge = '<span class="p1d1-status-badge" style="background:' + (item.status_color || '#9e9e9e') + '15; color:' + (item.status_color || '#9e9e9e') + ';">' + (item.status_label || item.status || 'open') + '</span>';

          var _q = String.fromCharCode(39);
          var _esc = function(v) { return (v || '').replace(/'/g, String.fromCharCode(92) + String.fromCharCode(39)); };
          var viewHandler = 'openPreflightItem(' + _q + _esc(item.request_id) + _q + ', ' + _q + _esc(item.record_id) + _q + ', ' + _q + _esc(item.contract_id || item.contract_key) + _q + ', ' + _q + _esc(item.field_name || item.field_key) + _q + ')';
          var patchBtn = '';
          if (item.can_create_patch && item.status === 'open') {
            patchBtn = ' <button class="p1d1-patch-btn" onclick="event.stopPropagation(); createPatchFromBlocker(' + _q + _esc(item.request_id) + _q + ', ' + _q + _esc(item.record_id) + _q + ', ' + _q + _esc(item.field_name) + _q + ', ' + _q + _esc(item.blocker_type) + _q + ')">Patch</button>';
          }

          html += '<tr class="p1d1-child-row" data-parent="' + groupId + '" style="display:' + childDisplay + ';" onclick="event.stopPropagation(); ' + viewHandler + '">';
          html += '<td></td>';
          html += '<td class="p1d1-child-section">' + sName + '</td>';
          html += '<td class="p1d1-child-ref">' + fName + '</td>';
          html += '<td>' + reasonHtml + '</td>';
          html += '<td>' + sevHtml + '</td>';
          html += '<td>' + stBadge + '</td>';
          html += '<td></td>';
          html += '<td><button class="p1d1-view-btn small" onclick="event.stopPropagation(); ' + viewHandler + '">View</button>' + patchBtn + '</td>';
          html += '<td></td>';
          html += '</tr>';
          childrenRendered++;
        }
      }

      html += '</tbody></table>';
      container.innerHTML = html;
      console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] parent_rows_rendered: ' + groupOrder.length);
      console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] child_rows_rendered: ' + childrenRendered);
      console.log('[TRIAGE-CANONICAL][P1X] grouping_rendered: groups=' + groupOrder.length + ', items=' + items.length);
    }



    // ═══ P1E: PDF Reliability Spike — Helpers ═══
    var _p1eDiagState = { sourceUrl: '', cacheKey: '', lastLoaded: null, textStatus: '', pageCount: 0, matchAttempts: [] };

    function _p1eLog(event, detail) {
      var msg = '[PDF-RELIABILITY][P1E] ' + event;
      if (detail) msg += ': ' + (typeof detail === 'object' ? JSON.stringify(detail) : String(detail));
      console.log(msg);
    }

    function _p1eNormalizeForSearch(text) {
      if (!text) return '';
      var s = String(text);
      s = s.replace(/[\u2018\u2019\u201A\u201B]/g, String.fromCharCode(39));
      s = s.replace(/[\u201C\u201D\u201E\u201F]/g, '"');
      s = s.replace(/[\u2013\u2014]/g, '-');
      s = s.replace(/[\u00A0\u2000-\u200B\u202F\u205F\u3000]/g, ' ');
      s = s.replace(/\s+/g, ' ').trim();
      return s;
    }

    function _p1eAsciiNormalize(text) {
      if (!text) return '';
      var s = _p1eNormalizeForSearch(text);
      s = s.replace(/[^\x20-\x7E]/g, '');
      return s.trim();
    }

    function _p1eDetectMojibake(text) {
      if (!text || typeof text !== 'string') return { isMojibake: false, reason: '', impact: '' };
      var controlCount = 0;
      var replacementCount = 0;
      var highNonLatinCount = 0;
      var totalChars = text.length;
      if (totalChars < 5) return { isMojibake: false, reason: '', impact: '' };
      for (var i = 0; i < totalChars; i++) {
        var code = text.charCodeAt(i);
        if (code === 0xFFFD) replacementCount++;
        else if (code < 32 && code !== 10 && code !== 13 && code !== 9) controlCount++;
        else if (code > 0x00FF && code < 0x3000) highNonLatinCount++;
      }
      var replacementRatio = replacementCount / totalChars;
      var controlRatio = controlCount / totalChars;
      var highRatio = highNonLatinCount / totalChars;
      var reason = '';
      var ratio = 0;
      if (replacementRatio >= controlRatio && replacementRatio >= highRatio) { reason = 'HIGH_REPLACEMENT_CHARS'; ratio = replacementRatio; }
      else if (controlRatio >= highRatio) { reason = 'CONTROL_CHAR_EXCESS'; ratio = controlRatio; }
      else { reason = 'ENCODING_MISMATCH'; ratio = highRatio; }
      if (replacementRatio > 0.15 || controlRatio > 0.08 || (highRatio > 0.4 && totalChars > 20)) {
        return { isMojibake: true, reason: reason, ratio: ratio, impact: 'high' };
      }
      if (replacementRatio > 0.05 || controlRatio > 0.03) {
        return { isMojibake: true, reason: reason, ratio: ratio, impact: 'medium' };
      }
      if (replacementRatio > 0.01 || controlRatio > 0.005) {
        return { isMojibake: true, reason: reason, ratio: ratio, impact: 'low' };
      }
      return { isMojibake: false, reason: '', ratio: 0, impact: '' };
    }

    function _p1eDetectNonSearchable(pages) {
      if (!pages || pages.length === 0) return { nonSearchable: true, reason: 'NO_PAGES' };
      var emptyPages = 0;
      var tinyPages = 0;
      for (var i = 0; i < pages.length; i++) {
        var t = (pages[i].text || '').trim();
        if (t.length === 0) emptyPages++;
        else if (t.length < 10) tinyPages++;
      }
      var emptyRatio = emptyPages / pages.length;
      if (emptyRatio > 0.8) return { nonSearchable: true, reason: 'MOSTLY_EMPTY_TEXT', emptyRatio: emptyRatio };
      if (emptyPages === pages.length) return { nonSearchable: true, reason: 'ALL_PAGES_EMPTY' };
      return { nonSearchable: false, reason: '' };
    }

    function _p1eRouteToPreFlight(record, condition, reason) {
      if (!record) return;
      var contractKey = record.contract_key || record.contract_id || '';
      var fileUrl = srrResolveFieldValue(record, 'file_url');
      var fileName = srrResolveFieldValue(record, 'file_name');
      var item = {
        request_id: 'p1e_' + condition.toLowerCase() + '_' + contractKey + '_' + Date.now(),
        type: 'preflight_blocker',
        signal_type: condition,
        record_id: contractKey,
        contract_id: contractKey,
        contract_key: contractKey,
        field_name: 'file_url',
        field_key: 'file_url',
        sheet_name: srrState.currentSheetName || '',
        severity: overrideSeverity || (condition === 'OCR_UNREADABLE' ? 'blocker' : 'warning'),
        _impact: impact || '',
        message: reason,
        status: 'open',
        status_label: 'Open',
        status_color: '#f57c00',
        updated_at: new Date().toISOString(),
        source: 'preflight',
        blocker_type: condition,
        can_create_patch: false,
        file_name: fileName,
        file_url: fileUrl
      };
      var isDup = analystTriageState.manualItems.some(function(m) {
        return m.signal_type === condition && m.contract_key === contractKey && m.field_name === 'file_url';
      });
      if (!isDup) {
        analystTriageState.manualItems.push(item);
        _p1eLog('preflight_routed', { condition: condition, contract: contractKey, reason: reason });
      }
    }


    /* ── P1F: Batch PDF Scan Engine ── */
    // ═══ P1F.1: Real-Time Pre-Flight Intake ═══
    var preflightLiveState = {
      entries: {},
      order: [],
      totals: { queued: 0, scanning: 0, flagged: 0, clean: 0, error: 0, processed: 0, total: 0 },
      active: false,
      _renderTimer: null,
      _lastRenderAt: 0
    };

    function _p1f1Log(event, detail) {
      var msg = '[PREFLIGHT-LIVE][OCR] ' + event;
      if (detail) {
        var parts = [];
        for (var k in detail) {
          if (detail.hasOwnProperty(k)) parts.push(k + '=' + detail[k]);
        }
        if (parts.length > 0) msg += ' | ' + parts.join(', ');
      }
      console.log(msg);
    }

    function _p1f1TimeStr(d) {
      if (!d) return '';
      var h = d.getHours(), m = d.getMinutes(), s = d.getSeconds();
      return (h < 10 ? '0' : '') + h + ':' + (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
    }

    function _p1f1Enqueue(contract) {
      var ck = contract.contract_key || '';
      if (!ck) return;
      var label = '';
      try { label = typeof _p1dGetDisplayName === 'function' ? _p1dGetDisplayName(ck, [contract]) : ck; } catch(e) { label = ck; }
      preflightLiveState.entries[ck] = {
        contract_id: ck,
        contract_label: label,
        file_name: contract.file_name || '',
        source_url: contract.file_url || '',
        status: 'queued',
        reason_codes: [],
        started_at: null,
        finished_at: null
      };
      preflightLiveState.order.push(ck);
      preflightLiveState.totals.queued++;
      preflightLiveState.totals.total++;
      _p1f1Log('enqueue', { contract_id: ck, file_name: contract.file_name || '' });
    }

    function _p1f1Start(contractKey) {
      var e = preflightLiveState.entries[contractKey];
      if (!e) return;
      if (e.status === 'queued') preflightLiveState.totals.queued--;
      e.status = 'scanning';
      e.started_at = new Date();
      preflightLiveState.totals.scanning++;
      _p1f1Log('start', { contract_id: contractKey, file_name: e.file_name });
      _p1f1ScheduleRender();
    }

    function _p1f1Flagged(contractKey, reasonCodes) {
      var e = preflightLiveState.entries[contractKey];
      if (!e) return;
      if (e.status === 'scanning') preflightLiveState.totals.scanning--;
      e.status = 'flagged';
      e.reason_codes = reasonCodes || [];
      e.finished_at = new Date();
      preflightLiveState.totals.flagged++;
      preflightLiveState.totals.processed++;
      _p1f1Log('flagged', { contract_id: contractKey, file_name: e.file_name, reason: reasonCodes.join(';') });
      _p1f1ScheduleRender();
    }

    function _p1f1Clean(contractKey) {
      var e = preflightLiveState.entries[contractKey];
      if (!e) return;
      if (e.status === 'scanning') preflightLiveState.totals.scanning--;
      e.status = 'clean';
      e.finished_at = new Date();
      preflightLiveState.totals.clean++;
      preflightLiveState.totals.processed++;
      _p1f1Log('clean', { contract_id: contractKey, file_name: e.file_name });
      _p1f1ScheduleRender();
    }

    function _p1f1Error(contractKey, reason) {
      var e = preflightLiveState.entries[contractKey];
      if (!e) return;
      if (e.status === 'scanning') preflightLiveState.totals.scanning--;
      e.status = 'error';
      e.reason_codes = [reason || 'unknown'];
      e.finished_at = new Date();
      preflightLiveState.totals.error++;
      preflightLiveState.totals.processed++;
      _p1f1Log('error', { contract_id: contractKey, file_name: e.file_name, reason: reason || 'unknown' });
      _p1f1ScheduleRender();
    }

    function _p1f1Complete() {
      preflightLiveState.active = false;
      _p1f1Log('complete', {
        total: preflightLiveState.totals.total,
        flagged: preflightLiveState.totals.flagged,
        clean: preflightLiveState.totals.clean,
        error: preflightLiveState.totals.error
      });
      _p1f1Render();
      _p1f1RestoreAccordion();
      var scanLabel = document.getElementById('p1f1-scan-active-label');
      if (scanLabel) scanLabel.style.display = 'none';

      var t = preflightLiveState.totals;

      var summaryBar = document.getElementById('p1f1-summary-bar');
      if (summaryBar) {
        summaryBar.style.display = '';
        var flaggedLabel = t.flagged > 0
          ? '<span style="color:#c62828;font-weight:600;">' + t.flagged + ' flagged</span>'
          : '<span style="color:#2e7d32;">0 flagged</span>';
        summaryBar.innerHTML = '<span style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">'
          + '<span style="font-weight:600;color:#333;">Batch Scan Complete</span>'
          + '<span style="color:#546e7a;">' + t.total + ' contracts scanned</span>'
          + '<span style="color:#546e7a;">·</span>'
          + flaggedLabel
          + '<span style="color:#546e7a;">·</span>'
          + '<span style="color:#2e7d32;">' + t.clean + ' clean</span>'
          + (t.error > 0 ? '<span style="color:#546e7a;">·</span><span style="color:#e65100;">' + t.error + ' errors</span>' : '')
          
          + '</span>';
        console.log('[TRIAGE-CONTRACT-HEALTH][P1F.2] summary_intake_attached | total=' + t.total + ', flagged=' + t.flagged + ', clean=' + t.clean + ', errors=' + t.error);
      }
    }

    function _p1f1Reset() {
      preflightLiveState.entries = {};
      preflightLiveState.order = [];
      preflightLiveState.totals = { queued: 0, scanning: 0, flagged: 0, clean: 0, error: 0, processed: 0, total: 0 };
      preflightLiveState.active = false;
      if (preflightLiveState._renderTimer) { clearTimeout(preflightLiveState._renderTimer); preflightLiveState._renderTimer = null; }
    }

    function _p1f1ScheduleRender() {
      var now = Date.now();
      var elapsed = now - preflightLiveState._lastRenderAt;
      if (preflightLiveState._renderTimer) clearTimeout(preflightLiveState._renderTimer);
      if (elapsed > 400) {
        _p1f1Render();
      } else {
        preflightLiveState._renderTimer = setTimeout(function() { _p1f1Render(); }, 400 - elapsed);
      }
    }

    function _p1f1Render() {
      preflightLiveState._lastRenderAt = Date.now();
      var wrapper = document.getElementById('p1f1-live-intake-wrapper');
      if (!wrapper) return;
      var t = preflightLiveState.totals;
      if (t.total === 0) { wrapper.style.display = 'none'; return; }
      wrapper.style.display = '';
      var summaryBar = document.getElementById('p1f1-summary-bar');
      if (summaryBar) {
        summaryBar.style.display = '';
        summaryBar.innerHTML = '<span class="p1f1-stat">Processed ' + t.processed + ' / ' + t.total + '</span>'
          + '<span class="p1f1-stat p1f1-stat-flagged">Flagged ' + t.flagged + '</span>'
          + '<span class="p1f1-stat p1f1-stat-clean">Clean ' + t.clean + '</span>'
          + '<span class="p1f1-stat p1f1-stat-error">Errors ' + t.error + '</span>'
          + (preflightLiveState.active ? '<span class="p1f1-scan-active-label" id="p1f1-scan-active-label">Scanning\u2026</span>' : '');
      }
    }

    function _p1f1ForceExpandAll() {
      var children = document.querySelectorAll('.p1d1-child-row');
      for (var i = 0; i < children.length; i++) {
        children[i].style.display = '';
      }
      var carets = document.querySelectorAll('[data-caret]');
      for (var j = 0; j < carets.length; j++) {
        carets[j].textContent = '\u25BC';
      }
      _p1dGroupState = {};
    }

    function _p1f1RestoreAccordion() {
      _p1dAccordionLocked = false;
      _p1dGroupState = {};
      var allChildren = document.querySelectorAll('.p1d1-child-row');
      for (var i = 0; i < allChildren.length; i++) {
        allChildren[i].style.display = 'none';
      }
      var carets = document.querySelectorAll('[data-caret]');
      for (var j = 0; j < carets.length; j++) {
        carets[j].textContent = '\u25B6';
      }
      console.log('[PREFLIGHT-LIVE] accordion_restored: all groups collapsed');
    }

    function _p1f1LockAccordion() {
      _p1dAccordionLocked = true;
      console.log('[PREFLIGHT-LIVE] accordion_locked');
    }

    function _p1f1UnlockAccordion() {
      _p1dAccordionLocked = false;
      console.log('[PREFLIGHT-LIVE] accordion_unlocked');
    }


    var _p1fScanState = {
      running: false,
      total: 0,
      scanned: 0,
      clean: 0,
      mojibake: 0,
      mojibakeLow: 0,
      mojibakeMedium: 0,
      mojibakeHigh: 0,
      nonSearchable: 0,
      errors: 0,
      skipped: 0,
      results: {}
    };
    var _p1fBatchScanItems = [];

    function _p1fMergeBatchItems() {
      if (!_p1fBatchScanItems || _p1fBatchScanItems.length === 0) return;
      var _existKeys = {};
      analystTriageState.manualItems.forEach(function(m) {
        if (m.contract_key && m.field_name) _existKeys[m.signal_type + ':' + m.contract_key + ':' + m.field_name] = true;
      });
      _p1fBatchScanItems.forEach(function(item) {
        var key = item.signal_type + ':' + item.contract_key + ':' + item.field_name;
        if (!_existKeys[key]) {
          analystTriageState.manualItems.push(item);
          _existKeys[key] = true;
        }
      });
    }

    var _missingValuePreflightItems = [];

    function _buildMissingValuePreflightItems() {
      _missingValuePreflightItems = [];
      if (typeof TriageAnalytics === 'undefined' || !TriageAnalytics._cache || !TriageAnalytics._cache.schema) return;
      var items = TriageAnalytics._cache.schema._missing_values_items;
      if (!items || items.length === 0) return;
      var ciAvail = typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && typeof ContractIndex.deriveContractId === 'function';
      var wb = (typeof workbook !== 'undefined') ? workbook : null;
      for (var i = 0; i < items.length; i++) {
        var mv = items[i];
        var condition = mv.reason === 'invalid_picklist' ? 'PICKLIST_INVALID' : 'MISSING_REQUIRED';
        var perContract = {};
        var batchCount = 0;
        var totalRows = 0;
        var isPicklist = mv.reason === 'invalid_picklist';
        var optionsLower = [];
        if (isPicklist) {
          var fMeta = (typeof getFieldMeta === 'function') ? getFieldMeta(mv.section, mv.field_key) : null;
          if (fMeta && fMeta.options && fMeta.options.length > 0) {
            for (var oi = 0; oi < fMeta.options.length; oi++) { optionsLower.push(String(fMeta.options[oi]).toLowerCase().trim()); }
          }
        }
        if (wb && wb.sheets && wb.sheets[mv.section] && wb.sheets[mv.section].rows) {
          var rows = wb.sheets[mv.section].rows;
          totalRows = rows.length;
          for (var ri = 0; ri < rows.length; ri++) {
            var row = rows[ri];
            if (!row) continue;
            var val = row[mv.header];
            var hit = false;
            if (!isPicklist) {
              hit = (typeof isBlankValue === 'function') && isBlankValue(val);
            } else {
              var blank = (typeof isBlankValue === 'function') && isBlankValue(val);
              if (!blank && val !== null && val !== undefined) {
                hit = optionsLower.indexOf(String(val).toLowerCase().trim()) === -1;
              }
            }
            if (!hit) continue;
            var cid = '';
            if (ciAvail) {
              var derived = ContractIndex.deriveContractId(row);
              if (derived) cid = derived;
            }
            if (cid) {
              if (!perContract[cid]) perContract[cid] = { count: 0, file_name: '' };
              perContract[cid].count++;
              if (!perContract[cid].file_name) {
                var _fn = row.file_name || row.File_Name_c || row.File_Name || row.contract_key || '';
                if (_fn) perContract[cid].file_name = _fn;
              }
            } else {
              batchCount++;
            }
          }
        } else {
          batchCount = mv.blank_count;
          totalRows = mv.total_rows;
        }
        var contractKeys = Object.keys(perContract);
        for (var ci = 0; ci < contractKeys.length; ci++) {
          var ck = contractKeys[ci];
          var cnt = perContract[ck].count;
          var _ckFileName = perContract[ck].file_name || '';
          var pct = totalRows > 0 ? Math.round((cnt / totalRows) * 100) : 0;
          var msg = isPicklist
            ? cnt + ' of ' + totalRows + ' rows (' + pct + '%) have invalid picklist values'
            : cnt + ' of ' + totalRows + ' rows (' + pct + '%) are blank or missing';
          var item = {
            request_id: 'mv_' + condition.toLowerCase() + '_' + ck + '_' + mv.section + '_' + mv.field_key + '_' + mv.reason,
            type: 'preflight_blocker',
            signal_type: condition,
            record_id: ck,
            contract_id: ck,
            contract_key: ck,
            field_name: mv.field_key,
            field_key: mv.field_key,
            sheet_name: mv.section,
            severity: isPicklist ? 'warning' : 'blocker',
            message: msg,
            status: 'open',
            status_label: 'Open',
            status_color: '#f57c00',
            updated_at: new Date().toISOString(),
            source: 'preflight',
            blocker_type: condition,
            can_create_patch: false,
            _missing_value: true,
            file_name: _ckFileName
          };
          enrichPreflightItem(item);
          _missingValuePreflightItems.push(item);
        }
        if (batchCount > 0) {
          var bPct = totalRows > 0 ? Math.round((batchCount / totalRows) * 100) : 0;
          var bMsg = isPicklist
            ? batchCount + ' of ' + totalRows + ' rows (' + bPct + '%) have invalid picklist values'
            : batchCount + ' of ' + totalRows + ' rows (' + bPct + '%) are blank or missing';
          var bItem = {
            request_id: 'mv_' + condition.toLowerCase() + '_batch_' + mv.section + '_' + mv.field_key + '_' + mv.reason,
            type: 'preflight_blocker',
            signal_type: condition,
            record_id: mv.section,
            contract_id: '',
            contract_key: '',
            field_name: mv.field_key,
            field_key: mv.field_key,
            sheet_name: mv.section,
            severity: isPicklist ? 'warning' : 'blocker',
            message: bMsg,
            status: 'open',
            status_label: 'Open',
            status_color: '#f57c00',
            updated_at: new Date().toISOString(),
            source: 'preflight',
            blocker_type: condition,
            can_create_patch: false,
            _missing_value: true
          };
          enrichPreflightItem(bItem);
          _missingValuePreflightItems.push(bItem);
        }
      }
    }

    function _mergeMissingValuePreflightItems() {
      if (!_missingValuePreflightItems || _missingValuePreflightItems.length === 0) return;
      var _existKeys = {};
      analystTriageState.manualItems.forEach(function(m) {
        var k = (m.signal_type || '') + ':' + (m.contract_key || m.record_id || '') + ':' + (m.sheet_name || '') + ':' + (m.field_name || '') + ':' + (m.blocker_type || '');
        _existKeys[k] = true;
      });
      var added = 0;
      _missingValuePreflightItems.forEach(function(item) {
        var k = item.signal_type + ':' + (item.contract_key || item.record_id || '') + ':' + (item.sheet_name || '') + ':' + (item.field_name || '') + ':' + (item.blocker_type || '');
        if (!_existKeys[k]) {
          analystTriageState.manualItems.push(item);
          _existKeys[k] = true;
          added++;
        }
      });
      if (added > 0) console.log('[PREFLIGHT-MV] merged ' + added + ' missing-value items into Pre-Flight');
    }

    var _p1f2CleanItems = [];
    var _p1f2RunId = '';

    function _p1f2RouteCleanToSystemPass(contract) {
      var contractKey = contract.contract_key || '';
      var isDup = _p1f2CleanItems.some(function(m) { return m.contract_key === contractKey; });
      if (isDup) return;
      var item = {
        request_id: 'p1f2_clean_' + contractKey + '_' + Date.now(),
        type: 'system_change',
        signal_type: 'PDF_VERIFIED_CLEAN',
        record_id: contractKey,
        contract_id: contractKey,
        contract_key: contractKey,
        field_name: 'file_url',
        field_key: 'file_url',
        sheet_name: contract.sheet_name || '',
        severity: 'info',
        message: 'PDF verified clean — no OCR or encoding issues detected',
        status: 'system_pass_ready',
        status_label: 'System Pass Ready',
        status_color: '#2e7d32',
        updated_at: new Date().toISOString(),
        source: 'batch_pdf_scan',
        file_name: contract.file_name || '',
        file_url: contract.file_url || '',
        preflight_pdf_status: 'clean',
        preflight_pdf_clean_at: new Date().toISOString(),
        preflight_pdf_run_id: _p1f2RunId,
        preflight_pdf_reason_codes: [],
        _batch_scan: true,
        _p1f2_clean: true
      };
      _p1f2CleanItems.push(item);
      console.log('[TRIAGE-CONTRACT-HEALTH][P1F.2] clean_routed_to_system_pass | contract=' + contractKey);
    }

    function _p1f2MergeCleanToSystemPass() {
      if (!_p1f2CleanItems || _p1f2CleanItems.length === 0) return;
      var existKeys = {};
      analystTriageState.systemItems.forEach(function(m) {
        if (m.contract_key) existKeys[m.signal_type + ':' + m.contract_key] = true;
      });
      var added = 0;
      _p1f2CleanItems.forEach(function(item) {
        var key = item.signal_type + ':' + item.contract_key;
        if (!existKeys[key]) {
          analystTriageState.systemItems.push(item);
          existKeys[key] = true;
          added++;
        }
      });
      if (added > 0) {
        console.log('[TRIAGE-CONTRACT-HEALTH][P1F.2] dedupe_applied | clean_added=' + added + ', dupes_skipped=' + (_p1f2CleanItems.length - added));
      }
    }

    function _p1fRenderContractHealth() {
      if (typeof TriageAnalytics !== 'undefined') {
        try { TriageAnalytics.refresh(); TriageAnalytics.renderHeader(); } catch(e) { console.warn('[P1F] Contract health analytics refresh error:', e); }
      }
    }

    function _p1fLog(event, detail) {
      var msg = '[PDF-BATCH-SCAN][P1F] ' + event;
      if (detail) {
        var parts = [];
        for (var k in detail) {
          if (detail.hasOwnProperty(k)) parts.push(k + '=' + detail[k]);
        }
        if (parts.length > 0) msg += ' | ' + parts.join(', ');
      }
      console.log(msg);
    }

    function _p1fCreateBanner() {
      var existing = document.getElementById('p1f-scan-banner');
      if (existing) return existing;
      var banner = document.createElement('div');
      banner.id = 'p1f-scan-banner';
      banner.className = 'p1f-scan-banner';
      banner.innerHTML = '<span id="p1f-scan-label">Scanning PDFs...</span>'
        + '<div class="p1f-scan-progress"><div class="p1f-scan-progress-bar" id="p1f-progress-bar"></div></div>'
        + '<div class="p1f-scan-stats">'
        + '<span id="p1f-stat-count">0/0</span>'
        + '<span class="p1f-scan-stat-ok" id="p1f-stat-ok"></span>'
        + '<span class="p1f-scan-stat-bad" id="p1f-stat-bad"></span>'
        + '<span id="p1f-stat-scope" style="opacity:0.7;font-size:0.85em;margin-left:4px;"></span>'
        + '</div>';
      document.body.appendChild(banner);
      return banner;
    }

    function _p1fUpdateBanner() {
      var s = _p1fScanState;
      var bar = document.getElementById('p1f-progress-bar');
      var label = document.getElementById('p1f-scan-label');
      var count = document.getElementById('p1f-stat-count');
      var ok = document.getElementById('p1f-stat-ok');
      var bad = document.getElementById('p1f-stat-bad');
      if (!bar) return;
      var pct = s.total > 0 ? Math.round((s.scanned / s.total) * 100) : 0;
      bar.style.width = pct + '%';
      count.textContent = s.scanned + '/' + s.total + ' contracts';
      if (s.running) {
        label.textContent = 'Scanning PDFs for text quality...';
      }
      var scopeEl = document.getElementById('p1f-stat-scope');
      if (scopeEl && !scopeEl._filled) {
        var scope = _p1fGetDatasetScope();
        if (scope) {
          scopeEl.textContent = '(' + scope + ')';
          scopeEl._filled = true;
        }
      }
      ok.textContent = s.clean > 0 ? (s.clean + ' clean') : '';
      var badCount = s.mojibake + s.nonSearchable;
      var badParts = [];
      if (s.mojibakeHigh > 0) badParts.push(s.mojibakeHigh + ' high');
      if (s.mojibakeMedium > 0) badParts.push(s.mojibakeMedium + ' med');
      if (s.mojibakeLow > 0) badParts.push(s.mojibakeLow + ' low');
      if (s.nonSearchable > 0) badParts.push(s.nonSearchable + ' no-text');
      bad.textContent = badCount > 0 ? (badCount + ' flagged' + (badParts.length > 0 ? ' (' + badParts.join(', ') + ')' : '')) : '';
    }

    function _p1fShowComplete() {
      var s = _p1fScanState;
      var banner = document.getElementById('p1f-scan-banner');
      var label = document.getElementById('p1f-scan-label');
      var count = document.getElementById('p1f-stat-count');
      var bar = document.getElementById('p1f-progress-bar');
      if (!banner || !label) return;
      bar.style.width = '100%';
      count.textContent = s.total + ' contracts';
      var badCount = s.mojibake + s.nonSearchable;
      if (badCount > 0) {
        banner.classList.add('has-issues');
        label.textContent = 'PDF scan complete: ' + badCount + ' contract' + (badCount !== 1 ? 's' : '') + ' flagged in Pre-Flight';
      } else {
        banner.classList.add('p1f-scan-done');
        label.textContent = 'PDF scan complete: all ' + s.total + ' contracts clean';
      }
      console.log('[PDF-RELIABILITY][P1E-FOLLOWUP] scan_complete: total=' + s.total + ', clean=' + s.clean + ', flagged=' + badCount);
      try { localStorage.setItem('_p1f_scan_fingerprint', (typeof _p1fComputeFingerprint === 'function') ? _p1fComputeFingerprint() : ''); } catch(e) {}
      if (typeof showToast === 'function') {
        showToast('PDF text quality scan complete: ' + s.clean + ' clean, ' + badCount + ' flagged', badCount > 0 ? 'warning' : 'success');
      }
      var _bannerHovered = false;
      var _fadeTimer = null;
      var _startFade = function() {
        _fadeTimer = setTimeout(function() {
          if (!_bannerHovered) {
            banner.style.transition = 'transform 0.5s ease, opacity 0.5s ease';
            banner.style.opacity = '0';
            setTimeout(function() { banner.classList.remove('visible'); banner.style.opacity = ''; banner.style.transition = ''; }, 500);
          }
        }, 3000);
      };
      banner.addEventListener('mouseenter', function() {
        _bannerHovered = true;
        if (_fadeTimer) clearTimeout(_fadeTimer);
        console.log('[PDF-RELIABILITY][P1E-FOLLOWUP] banner_hover_hold');
      });
      banner.addEventListener('mouseleave', function() {
        _bannerHovered = false;
        _startFade();
        console.log('[PDF-RELIABILITY][P1E-FOLLOWUP] banner_hover_release');
      });
      _startFade();
    }

    function _p1fComputeFingerprint() {
      var parts = [];
      if (typeof _p1fBatchScanItems !== 'undefined') {
        for (var i = 0; i < _p1fBatchScanItems.length; i++) {
          var it = _p1fBatchScanItems[i];
          parts.push((it.contract_key || it.contract_id || '') + ':' + (it.signal_type || '') + ':' + (it.severity || ''));
        }
      }
      if (typeof analystTriageState !== 'undefined' && analystTriageState.manualItems) {
        for (var j = 0; j < analystTriageState.manualItems.length; j++) {
          var mi = analystTriageState.manualItems[j];
          parts.push((mi.contract_key || mi.contract_id || '') + ':' + (mi.blocker_type || mi.signal_type || '') + ':' + (mi.severity || ''));
        }
      }
      parts.sort();
      var hash = 0;
      var str = parts.join('|');
      for (var k = 0; k < str.length; k++) {
        var ch = str.charCodeAt(k);
        hash = ((hash << 5) - hash) + ch;
        hash = hash & hash;
      }
      return 'fp_' + Math.abs(hash) + '_' + parts.length;
    }

    function _p1fCheckSessionDiff() {
      var currentFp = _p1fComputeFingerprint();
      var storedFp = '';
      try { storedFp = localStorage.getItem('_p1f_scan_fingerprint') || ''; } catch(e) {}
      if (!storedFp) {
        try { localStorage.setItem('_p1f_scan_fingerprint', currentFp); } catch(e) {}
        console.log('[PDF-RELIABILITY][P1E-FOLLOWUP] session_diff_none (first session)');
        return;
      }
      if (storedFp === currentFp) {
        console.log('[PDF-RELIABILITY][P1E-FOLLOWUP] session_diff_none');
        return;
      }
      var oldParts = storedFp.split('_');
      var newParts = currentFp.split('_');
      var oldCount = parseInt(oldParts[2]) || 0;
      var newCount = parseInt(newParts[2]) || 0;
      var added = Math.max(0, newCount - oldCount);
      var removed = Math.max(0, oldCount - newCount);
      var contractSet = {};
      if (typeof _p1fBatchScanItems !== 'undefined') {
        for (var i = 0; i < _p1fBatchScanItems.length; i++) {
          contractSet[_p1fBatchScanItems[i].contract_key || _p1fBatchScanItems[i].contract_id || ''] = true;
        }
      }
      var contractCount = Object.keys(contractSet).length;
      console.log('[PDF-RELIABILITY][P1E-FOLLOWUP] session_diff_detected: added=' + added + ', removed=' + removed + ', contracts=' + contractCount);
      if (typeof showToast === 'function') {
        showToast('Pre-Flight changed since last session: +' + added + '/-' + removed + ' issues across ' + contractCount + ' contracts', 'info');
      }
      try { localStorage.setItem('_p1f_scan_fingerprint', currentFp); } catch(e) {}
    }

    function _p1fExtractUniqueContracts() {
      var contracts = {};
      if (!workbook || !workbook.sheets) return [];
      var sheetNames = Object.keys(workbook.sheets);
      for (var si = 0; si < sheetNames.length; si++) {
        var sheetName = sheetNames[si];
        if (sheetName.indexOf('_change_log') !== -1) continue;
        if (sheetName === 'RFIs & Analyst Notes') continue;
        if (typeof isReferenceSheet === 'function' && isReferenceSheet(sheetName)) continue;
        if (typeof isMetaSheet === 'function' && isMetaSheet(sheetName)) continue;
        var sheet = workbook.sheets[sheetName];
        if (!sheet || !sheet.rows) continue;
        for (var ri = 0; ri < sheet.rows.length; ri++) {
          var row = sheet.rows[ri];
          if (!row) continue;
          var url = row.file_url || row.File_URL_c || '';
          var fn = row.file_name || row.File_Name_c || row.File_Name || '';
          if (!url || !fn) continue;
          var canonicalId = (typeof ContractIndex !== 'undefined' && typeof ContractIndex.deriveContractId === 'function')
            ? ContractIndex.deriveContractId(row)
            : null;
          var groupKey = canonicalId || fn.trim().toLowerCase();
          if (contracts[groupKey]) {
            if (contracts[groupKey].sheet_names.indexOf(sheetName) === -1) {
              contracts[groupKey].sheet_names.push(sheetName);
            }
            continue;
          }
          var ck = canonicalId || row.contract_key || row.contract_id || fn;
          contracts[groupKey] = {
            contract_key: ck,
            file_url: url,
            file_name: fn,
            sheet_name: sheetName,
            sheet_names: [sheetName],
            record: row
          };
        }
      }
      var ciAvailable = typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable && ContractIndex.isAvailable();
      if (ciAvailable) {
        for (var gk in contracts) {
          if (!contracts.hasOwnProperty(gk)) continue;
          var entry = contracts[gk];
          var ciContract = ContractIndex.getContract(entry.contract_key);
          if (ciContract && ciContract.sheets) {
            var ciSheets = Object.keys(ciContract.sheets);
            for (var cs = 0; cs < ciSheets.length; cs++) {
              if (entry.sheet_names.indexOf(ciSheets[cs]) === -1) {
                entry.sheet_names.push(ciSheets[cs]);
              }
            }
          }
        }
      }
      var list = [];
      for (var k in contracts) {
        if (contracts.hasOwnProperty(k)) list.push(contracts[k]);
      }
      console.log('[P1F][P0-A] _p1fExtractUniqueContracts: ' + list.length + ' unique contracts (canonical), sheets collected per contract' + (ciAvailable ? ' (ContractIndex enriched)' : ' (row-scan only)'));
      return list;
    }

    function _p1fScanSinglePdf(contract, callback) {
      var proxyBase = window._pdfProxyBaseUrl || '';
      var apiUrl = proxyBase + '/api/pdf/text?url=' + encodeURIComponent(contract.file_url);

      _p1fLog('scan_start', { contract: contract.contract_key, url: contract.file_url.substring(0, 60) });
      _p1f1Start(contract.contract_key);

      fetch(apiUrl)
        .then(function(r) {
          if (!r.ok) throw new Error('HTTP ' + r.status);
          return r.json();
        })
        .then(function(data) {
          var pages = data.pages || [];
          if (pages.length === 0) {
            _p1fScanState.skipped++;
            _p1fLog('scan_skip_no_pages', { contract: contract.contract_key });
            _p1f1Clean(contract.contract_key);
            callback('skip');
            return;
          }

          var nonSearch = _p1eDetectNonSearchable(pages);
          if (nonSearch.nonSearchable) {
            _p1fScanState.nonSearchable++;
            _p1fLog('scan_non_searchable', { contract: contract.contract_key, reason: nonSearch.reason });
            var mockRecord = {
              contract_key: contract.contract_key,
              contract_id: contract.contract_key,
              file_url: contract.file_url,
              file_name: contract.file_name
            };
            var _sheetsToRoute = contract.sheet_names || [contract.sheet_name];
            for (var _si = 0; _si < _sheetsToRoute.length; _si++) {
              _p1fRouteToPreFlight(mockRecord, _sheetsToRoute[_si], 'TEXT_NOT_SEARCHABLE',
                'PDF has no searchable text: ' + nonSearch.reason);
            }
            _p1fScanState.results[contract.contract_key] = 'non_searchable';
            _p1f1Flagged(contract.contract_key, ['TEXT_NOT_SEARCHABLE']);
            try { if (preflightLiveState.active) { _p1fRenderContractHealth(); } } catch(e) {}
            callback('non_searchable');
            return;
          }

          var allText = pages.map(function(p) { return p.text || ''; }).join(' ');
          var mojibake = _p1eDetectMojibake(allText);
          if (mojibake.isMojibake) {
            _p1fScanState.mojibake++;
            var impact = mojibake.impact || 'medium';
            if (impact === 'low') _p1fScanState.mojibakeLow++;
            else if (impact === 'medium') _p1fScanState.mojibakeMedium++;
            else _p1fScanState.mojibakeHigh++;
            _p1fLog('scan_mojibake', { contract: contract.contract_key, reason: mojibake.reason, ratio: mojibake.ratio, impact: impact });
            var impactLabels = { low: 'Low Impact Mojibake', medium: 'Medium Impact Mojibake', high: 'High Impact — Unreadable' };
            var signalType = impact === 'high' ? 'OCR_UNREADABLE' : 'OCR_MOJIBAKE';
            var severity = impact === 'high' ? 'blocker' : (impact === 'medium' ? 'review' : 'warning');
            var mockRec = {
              contract_key: contract.contract_key,
              contract_id: contract.contract_key,
              file_url: contract.file_url,
              file_name: contract.file_name
            };
            var _sheetsToRouteMoji = contract.sheet_names || [contract.sheet_name];
            for (var _msi = 0; _msi < _sheetsToRouteMoji.length; _msi++) {
              _p1fRouteToPreFlight(mockRec, _sheetsToRouteMoji[_msi], signalType,
                (impactLabels[impact] || 'Mojibake') + ': ' + mojibake.reason + ' (' + Math.round(mojibake.ratio * 100) + '%)',
                severity, impact);
            }
            _p1fScanState.results[contract.contract_key] = 'mojibake_' + impact;
            _p1f1Flagged(contract.contract_key, [signalType, 'MOJIBAKE_ENCODING']);
            try { if (preflightLiveState.active) { _p1fRenderContractHealth(); } } catch(e) {}
            callback('mojibake');
            return;
          }

          _p1fScanState.clean++;
          _p1fScanState.results[contract.contract_key] = 'clean';
          _p1fLog('scan_clean', { contract: contract.contract_key, pages: pages.length });
          _p1f2RouteCleanToSystemPass(contract);
          _p1f1Clean(contract.contract_key);
          callback('clean');
        })
        .catch(function(err) {
          _p1fScanState.errors++;
          _p1fLog('scan_error', { contract: contract.contract_key, error: err.message });
          _p1fScanState.results[contract.contract_key] = 'error';
          _p1f1Error(contract.contract_key, err.message || 'unknown');
          callback('error');
        });
    }

    function _p1fRouteToPreFlight(record, sheetName, condition, reason, overrideSeverity, impact) {
      var contractKey = record.contract_key || record.contract_id || '';
      var item = {
        request_id: 'p1f_' + condition.toLowerCase() + '_' + contractKey + '_' + Date.now(),
        type: 'preflight_blocker',
        signal_type: condition,
        record_id: contractKey,
        contract_id: contractKey,
        contract_key: contractKey,
        field_name: 'file_url',
        field_key: 'file_url',
        sheet_name: sheetName || '',
        severity: condition === 'OCR_UNREADABLE' ? 'blocker' : 'warning',
        message: reason,
        status: 'open',
        status_label: 'Open',
        status_color: '#f57c00',
        updated_at: new Date().toISOString(),
        source: 'preflight',
        blocker_type: condition,
        can_create_patch: false,
        file_name: record.file_name || '',
        file_url: record.file_url || '',
        _batch_scan: true
      };
      enrichPreflightItem(item);
      var isDup = _p1fBatchScanItems.some(function(m) {
        return m.signal_type === condition && m.contract_key === contractKey && m.sheet_name === (sheetName || '') && m.field_name === 'file_url';
      });
      if (!isDup) {
        item.preflight_pdf_status = item.severity === 'blocker' ? 'blocker' : 'warning';
        item.preflight_pdf_clean_at = null;
        item.preflight_pdf_run_id = _p1f2RunId;
        item.preflight_pdf_reason_codes = [condition];
        _p1fBatchScanItems.push(item);
        _p1fLog('preflight_routed', { condition: condition, contract: contractKey, impact: impact || '' });
      } else {
        _p1fLog('preflight_dedup_skipped', { condition: condition, contract: contractKey });
      }
    }

    function _rerunResetBtn(btn) {
      if (btn) {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.className = 'triage-icon-btn';
        btn.style.cssText = 'background: linear-gradient(135deg, #e65100 0%, #bf360c 100%); color: white;';
        btn.innerHTML = '<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg><span class="btn-label">Rerun</span>';
      }
    }

    function rerunPreFlight() {
      if (!dataLoaded || !workbook || !workbook.order || workbook.order.length === 0) {
        showToast('No data loaded. Upload an Excel file first.', 'warning');
        return;
      }
      console.log('[RERUN-PREFLIGHT] Starting full pre-flight pipeline rerun');

      var btn = document.getElementById('btn-rerun-preflight');
      if (btn) {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="animation: spin 1s linear infinite;"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg> Running...';
      }

      console.log('[RERUN-PREFLIGHT] Clearing all triage state for clean restart');

      analystTriageState.manualItems = [];
      _p1fBatchScanItems = [];
      _p1f2CleanItems = [];
      _p1f2RunId = '';

      _p1fScanState.running = false;
      _p1fScanState.total = 0;
      _p1fScanState.scanned = 0;
      _p1fScanState.clean = 0;
      _p1fScanState.mojibake = 0;
      _p1fScanState.mojibakeLow = 0;
      _p1fScanState.mojibakeMedium = 0;
      _p1fScanState.mojibakeHigh = 0;
      _p1fScanState.nonSearchable = 0;
      _p1fScanState.errors = 0;
      _p1fScanState.skipped = 0;
      _p1fScanState.results = {};

      if (typeof _p1f1Reset === 'function') _p1f1Reset();
      if (typeof _p1f1UnlockAccordion === 'function') _p1f1UnlockAccordion();

      var _liveWrapper = document.getElementById('p1f1-live-intake-wrapper');
      if (_liveTbody) _liveTbody.innerHTML = '';
      var _summaryBar = document.getElementById('p1f1-summary-bar');
      if (_summaryBar) { _summaryBar.style.display = 'none'; _summaryBar.innerHTML = ''; }

      var _pfc = document.getElementById('p1d-preflight-container');
      if (_pfc) _pfc.innerHTML = '<div class="p1d-empty-state">Rerunning pre-flight…</div>';

      _p1dGroupState = {};

      try { renderAnalystTriage(); } catch(e) { console.warn('[RERUN-PREFLIGHT] Initial triage clear render error:', e); }
      try { if (typeof TriageAnalytics !== 'undefined' && typeof TriageAnalytics.refresh === 'function') { TriageAnalytics.refresh(); TriageAnalytics.renderHeader(); } } catch(e) {}

      console.log('[RERUN-PREFLIGHT] State cleared, regenerating signals');
      try { generateSignalsForDataset(); } catch(e) { console.warn('[RERUN-PREFLIGHT] Signal generation error:', e); }

      try { if (typeof detectUnknownColumns === 'function') { detectUnknownColumns(); } } catch(e) {}

      if (typeof _p1fBatchPdfScan === 'function') {
        var origShowComplete = typeof _p1fShowComplete === 'function' ? _p1fShowComplete : function() {};
        _p1fShowComplete = function() {
          try { origShowComplete(); } catch(e) { console.warn('[RERUN-PREFLIGHT] origShowComplete error:', e); }
          _p1fShowComplete = origShowComplete;
          console.log('[RERUN-PREFLIGHT] Batch PDF scan complete, refreshing triage');
          _rerunResetBtn(btn);
          showToast('Pre-Flight rerun complete. Check triage for OCR flags.', 'success');
        };
        try {
          _p1fBatchPdfScan();
        } catch(e) {
          console.warn('[RERUN-PREFLIGHT] Batch scan error:', e);
          _p1fShowComplete = origShowComplete;
          try { renderAnalystTriage(); } catch(e2) {}
          _rerunResetBtn(btn);
          showToast('Pre-Flight scan encountered an error. Signals refreshed.', 'warning');
        }
      } else {
        try { renderAnalystTriage(); } catch(e) {}
        _rerunResetBtn(btn);
        showToast('Pre-Flight signals refreshed (no PDF scan available).', 'info');
      }
    }

    function _p1fGetDatasetScope() {
      if (!workbook || !workbook.sheets) return '';
      var sheetContracts = {};
      var sheetNames = Object.keys(workbook.sheets);
      for (var i = 0; i < sheetNames.length; i++) {
        var name = sheetNames[i];
        if (name.indexOf('_change_log') !== -1) continue;
        if (name === 'RFIs & Analyst Notes') continue;
        if (typeof isReferenceSheet === 'function' && isReferenceSheet(name)) continue;
        if (typeof isMetaSheet === 'function' && isMetaSheet(name)) continue;
        var sheet = workbook.sheets[name];
        if (!sheet || !sheet.rows || sheet.rows.length === 0) continue;
        var seen = {};
        var uniqueCount = 0;
        for (var ri = 0; ri < sheet.rows.length; ri++) {
          var row = sheet.rows[ri];
          if (!row) continue;
          var ck = row.contract_key || row.contract_id || row.File_Name_c || row.File_Name || '';
          if (!ck || seen[ck]) continue;
          seen[ck] = true;
          uniqueCount++;
        }
        if (uniqueCount > 0) sheetContracts[name] = uniqueCount;
      }
      var parts = [];
      for (var sn in sheetContracts) {
        if (sheetContracts.hasOwnProperty(sn)) parts.push(sheetContracts[sn] + ' ' + sn);
      }
      return parts.length > 0 ? parts.join(', ') : '';
    }

    function _p1fBatchPdfScan() {
      if (_p1fScanState.running) {
        _p1fLog('scan_already_running');
        return;
      }
      var contracts = _p1fExtractUniqueContracts();
      if (contracts.length === 0) {
        _p1fLog('scan_no_contracts');
        return;
      }

      _p1fScanState.running = true;
      _p1fScanState.total = contracts.length;
      _p1fScanState.scanned = 0;
      _p1fScanState.clean = 0;
      _p1fScanState.mojibake = 0;
      _p1fScanState.mojibakeLow = 0;
      _p1fScanState.mojibakeMedium = 0;
      _p1fScanState.mojibakeHigh = 0;
      _p1fScanState.nonSearchable = 0;
      _p1fScanState.errors = 0;
      _p1fScanState.skipped = 0;
      _p1fScanState.results = {};

      _p1fLog('batch_scan_start', { total: contracts.length });

      _p1f2RunId = 'run_' + Date.now().toString(36);
      _p1f2CleanItems = [];

      _p1f1Reset();
      preflightLiveState.active = true;
      for (var _ei = 0; _ei < contracts.length; _ei++) { _p1f1Enqueue(contracts[_ei]); }
      _p1f1Render();
      _p1f1LockAccordion();

      var banner = _p1fCreateBanner();
      _p1fUpdateBanner();
      setTimeout(function() { banner.classList.add('visible'); }, 50);

      var concurrency = 3;
      var queue = contracts.slice();
      var active = 0;

      function processNext() {
        while (active < concurrency && queue.length > 0) {
          var contract = queue.shift();
          active++;
          _p1fScanSinglePdf(contract, function(result) {
            active--;
            _p1fScanState.scanned++;
            _p1fUpdateBanner();
            if (queue.length > 0 || active > 0) {
              processNext();
            } else {
              _p1fScanState.running = false;
              _p1f1Complete();
              _p1f1UnlockAccordion();
              _p1fLog('batch_scan_complete', {
                total: _p1fScanState.total,
                clean: _p1fScanState.clean,
                mojibake: _p1fScanState.mojibake,
                nonSearchable: _p1fScanState.nonSearchable,
                errors: _p1fScanState.errors,
                skipped: _p1fScanState.skipped
              });
              _p1fShowComplete();
              console.log('[TRIAGE-CONTRACT-HEALTH][P1F.2] metrics_recomputed | total_contracts=' + _p1fScanState.total + ', clean=' + _p1fScanState.clean + ', flagged=' + (_p1fScanState.mojibake + _p1fScanState.nonSearchable) + ', errors=' + _p1fScanState.errors);
              try { renderAnalystTriage(); } catch(e) { console.warn('[P1F] Post-scan triage render error:', e); }
              _p1f2MergeCleanToSystemPass();
              try {
                var sysCountEl = document.getElementById('system-queue-count');
                if (sysCountEl) sysCountEl.textContent = '(' + analystTriageState.systemItems.length + ')';
                renderTriageQueueTable(analystTriageState.systemItems, 'system-queue-list', 'No system changes');
              } catch(e) { console.warn('[P1F.2] System queue re-render error:', e); }
              try {
                var _csBody = document.getElementById('ta-contract-body');
                if (_csBody && _csBody.style.display === 'none') {
                  _csBody.style.display = '';
                  var _csToggle = document.getElementById('ta-contract-toggle');
                  if (_csToggle) _csToggle.style.transform = 'rotate(90deg)';
                }
              } catch(e) {}
            }
          });
        }
      }
      processNext();
    }

        function _p1eSearchVariants(query) {
      var variants = [];
      var trimmed = query.trim();
      if (trimmed) variants.push(trimmed);
      var norm = _p1eNormalizeForSearch(trimmed);
      if (norm && norm !== trimmed) variants.push(norm);
      var ascii = _p1eAsciiNormalize(trimmed);
      if (ascii && ascii !== norm && ascii !== trimmed) variants.push(ascii);
      if (trimmed.length > 30) {
        var sub = trimmed.substring(0, 25);
        variants.push(sub);
      }
      var noPunct = trimmed.replace(/[.,;:!?()\[\]{}'"]/g, '').trim();
      if (noPunct && noPunct !== trimmed && noPunct !== norm) variants.push(noPunct);
      return variants;
    }

    function _p1eMatchInPages(pages, query) {
      var variants = _p1eSearchVariants(query);
      var attempts = [];
      for (var vi = 0; vi < variants.length; vi++) {
        var variant = variants[vi];
        var variantLower = _p1eNormalizeForSearch(variant).toLowerCase();
        var matchPages = [];
        for (var pi = 0; pi < pages.length; pi++) {
          var pageText = _p1eNormalizeForSearch(pages[pi].text || '').toLowerCase();
          if (pageText.indexOf(variantLower) >= 0) {
            matchPages.push(pages[pi].page);
          }
        }
        attempts.push({ variant: variant.substring(0, 40), matched: matchPages.length > 0, pages: matchPages.length });
        if (matchPages.length > 0) {
          _p1eLog('anchor_match_found', { variant: variant.substring(0, 40), variantIndex: vi, pages: matchPages });
          return { matchPages: matchPages, variant: variant, attempts: attempts };
        }
      }
      _p1eLog('anchor_match_failed', { query: query.substring(0, 40), variantsTried: attempts.length, attempts: attempts });
      return { matchPages: [], variant: query, attempts: attempts };
    }

    function _p1eShowDiagPanel() {
      var panel = document.getElementById('p1e-diag-panel');
      if (!panel) return;
      var body = panel.querySelector('.p1e-diag-body');
      if (!body) return;
      var d = _p1eDiagState;
      var html = '';
      html += '<div class="p1e-diag-row"><span class="p1e-diag-label">Source URL</span><span class="p1e-diag-value" title="' + escapeHtml(d.sourceUrl) + '">' + escapeHtml(d.sourceUrl ? (d.sourceUrl.length > 50 ? d.sourceUrl.substring(0, 50) + '...' : d.sourceUrl) : 'none') + '</span></div>';
      html += '<div class="p1e-diag-row"><span class="p1e-diag-label">Cache Key</span><span class="p1e-diag-value">' + escapeHtml(d.cacheKey || 'none') + '</span></div>';
      html += '<div class="p1e-diag-row"><span class="p1e-diag-label">Last Loaded</span><span class="p1e-diag-value">' + (d.lastLoaded ? d.lastLoaded.toLocaleTimeString() : 'never') + '</span></div>';
      html += '<div class="p1e-diag-row"><span class="p1e-diag-label">Text Status</span><span class="p1e-diag-value ' + (d.textStatus === 'ok' ? 'ok' : (d.textStatus ? 'warn' : '')) + '">' + (d.textStatus || 'unknown') + '</span></div>';
      html += '<div class="p1e-diag-row"><span class="p1e-diag-label">Pages</span><span class="p1e-diag-value">' + d.pageCount + '</span></div>';
      html += '<div class="p1e-diag-row"><span class="p1e-diag-label">Cache Status</span><span class="p1e-diag-value ' + (srrState.cacheStatus === 'hit' ? 'ok' : (srrState.cacheStatus || '')) + '">' + (srrState.cacheStatus || 'none') + '</span></div>';
      if (d.matchAttempts.length > 0) {
        html += '<div style="margin-top: 8px; font-weight: 600; color: #666;">Recent Match Attempts</div>';
        for (var i = 0; i < d.matchAttempts.length && i < 5; i++) {
          var a = d.matchAttempts[i];
          html += '<div class="p1e-diag-row"><span class="p1e-diag-label">' + escapeHtml(a.variant) + '</span><span class="p1e-diag-value ' + (a.matched ? 'ok' : 'fail') + '">' + (a.matched ? a.pages + ' pages' : 'no match') + '</span></div>';
        }
      }
      body.innerHTML = html;
      panel.classList.add('visible');
    }

    function _p1eHideDiagPanel() {
      var panel = document.getElementById('p1e-diag-panel');
      if (panel) panel.classList.remove('visible');
    }

    function _p1eToggleDiagPanel() {
      var panel = document.getElementById('p1e-diag-panel');
      if (panel) panel.classList.toggle('visible');
    }

    // ═══ P1C: Contract Composite Grid — Helpers ═══
    var _p1cSectionState = {};

    function _p1cIsCompositeMode() {
      return (!gridState.sheet || gridState.sheet === '' || gridState.sheet === 'all');
    }

    function _p1cExpandAll() {
      console.log('[GRID-COMPOSITE][P1C] expand_all');
      var sections = document.querySelectorAll('.p1c-section');
      for (var i = 0; i < sections.length; i++) {
        var sid = sections[i].getAttribute('data-section-id');
        _p1cSectionState[sid] = false;
        var body = sections[i].querySelector('.p1c-section-body');
        if (body) body.classList.remove('collapsed');
        var caret = sections[i].querySelector('.p1c-section-caret');
        if (caret) caret.classList.remove('collapsed');
      }
    }

    function _p1cCollapseAll() {
      console.log('[GRID-COMPOSITE][P1C] collapse_all');
      var sections = document.querySelectorAll('.p1c-section');
      for (var i = 0; i < sections.length; i++) {
        var sid = sections[i].getAttribute('data-section-id');
        _p1cSectionState[sid] = true;
        var body = sections[i].querySelector('.p1c-section-body');
        if (body) body.classList.add('collapsed');
        var caret = sections[i].querySelector('.p1c-section-caret');
        if (caret) caret.classList.add('collapsed');
      }
    }

    function _p1cToggleSection(sectionId) {
      console.log('[GRID-COMPOSITE][P1C] section_toggled: ' + sectionId);
      var sec = document.querySelector('.p1c-section[data-section-id="' + sectionId + '"]');
      if (!sec) return;
      var body = sec.querySelector('.p1c-section-body');
      var caret = sec.querySelector('.p1c-section-caret');
      var isCollapsed = body.classList.contains('collapsed');
      if (isCollapsed) {
        body.classList.remove('collapsed');
        if (caret) caret.classList.remove('collapsed');
        _p1cSectionState[sectionId] = false;
      } else {
        body.classList.add('collapsed');
        if (caret) caret.classList.add('collapsed');
        _p1cSectionState[sectionId] = true;
      }
    }

    function _p1cRenderComposite(filtered, allRecords) {
      console.log('[GRID-COMPOSITE][P1C] mode_enabled');
      var STATUS_KEYS = ['status', 'Status', 'sf_contract_status', 'review_state', 'Review_State'];

      // Show controls
      var ctrl = document.getElementById('p1c-composite-controls');
      if (ctrl) ctrl.style.display = 'flex';

      // Group rows by sheet
      var sheetMap = {};
      var sheetOrder = [];
      for (var i = 0; i < filtered.length; i++) {
        var sn = filtered[i].sheet || 'Unknown';
        if (!sheetMap[sn]) {
          sheetMap[sn] = [];
          sheetOrder.push(sn);
        }
        sheetMap[sn].push(filtered[i]);
      }
      sheetOrder.sort();

      // Hide original table, use container for composite
      var origTable = document.getElementById('grid-table');
      if (origTable) origTable.style.display = 'none';

      var container = document.querySelector('.grid-table-container');
      if (!container) return;

      // Remove previous composite content
      var old = document.getElementById('p1c-composite-root');
      if (old) old.parentNode.removeChild(old);

      if (sheetOrder.length === 0) {
        var emptyDiv = document.createElement('div');
        emptyDiv.id = 'p1c-composite-root';
        emptyDiv.className = 'p1c-empty-state';
        emptyDiv.innerHTML = '<div style="font-weight: 600; margin-bottom: 5px;">No records match filters</div>' +
          '<div style="font-size: 0.85em; color: #888;">Try adjusting the search or status filters.</div>';
        container.appendChild(emptyDiv);
        console.log('[GRID-COMPOSITE][P1C] mode_disabled reason=no_matching_rows');
        document.getElementById('grid-row-count').textContent = '0 of ' + allRecords.length + ' records';
        return;
      }

      var root = document.createElement('div');
      root.id = 'p1c-composite-root';

      for (var si = 0; si < sheetOrder.length; si++) {
        var sheetName = sheetOrder[si];
        var rows = sheetMap[sheetName];
        var sectionId = 'p1c-sheet-' + si;
        var isCollapsed = _p1cSectionState[sectionId] === true;

        // Status counts
        var ready = 0, review = 0, blocked = 0;
        for (var ri = 0; ri < rows.length; ri++) {
          var st = '';
          for (var sk = 0; sk < STATUS_KEYS.length; sk++) {
            if (rows[ri][STATUS_KEYS[sk]]) { st = rows[ri][STATUS_KEYS[sk]]; break; }
          }
          st = (st || '').toLowerCase().replace(/\s+/g, '_');
          if (st === 'ready') ready++;
          else if (st === 'needs_review') review++;
          else if (st === 'blocked') blocked++;
        }

        // Build section
        var section = document.createElement('div');
        section.className = 'p1c-section';
        section.setAttribute('data-section-id', sectionId);
        section.setAttribute('data-sheet-name', sheetName);

        // Header
        var header = document.createElement('div');
        header.className = 'p1c-section-header';
        header.setAttribute('onclick', '_p1cToggleSection("' + sectionId + '")');
        var caretClass = 'p1c-section-caret' + (isCollapsed ? ' collapsed' : '');
        var chipsHtml = '';
        if (ready > 0) chipsHtml += '<span class="p1c-section-chip p1c-chip-ready">' + ready + ' Ready</span>';
        if (review > 0) chipsHtml += '<span class="p1c-section-chip p1c-chip-review">' + review + ' Review</span>';
        if (blocked > 0) chipsHtml += '<span class="p1c-section-chip p1c-chip-blocked">' + blocked + ' Blocked</span>';
        header.innerHTML = '<span class="' + caretClass + '">&#9660;</span>' +
          '<span class="p1c-section-title">' + escapeHtml(sheetName) + '</span>' +
          '<span class="p1c-section-count">' + rows.length + ' row' + (rows.length !== 1 ? 's' : '') + '</span>' +
          '<div class="p1c-section-chips">' + chipsHtml + '</div>';

        section.appendChild(header);

        // Body
        var bodyDiv = document.createElement('div');
        bodyDiv.className = 'p1c-section-body' + (isCollapsed ? ' collapsed' : '');

        // Determine columns for this sheet
        var columns = [];
        if (workbook.sheets[sheetName] && workbook.sheets[sheetName].headers) {
          columns = workbook.sheets[sheetName].headers.filter(function(h) {
            return h && h !== '_row_index';
          });
        } else if (rows.length > 0) {
          columns = Object.keys(rows[0]).filter(function(k) {
            return k !== '_row_index' && k !== '_originalIdx' && k !== 'sheet' && k !== '_sheetRowIndex';
          });
        }
        columns = getPreferredColumnOrder(columns);

        // Table
        var tbl = document.createElement('table');
        tbl.className = 'grid-table';

        // Thead
        var thead = document.createElement('thead');
        var headTr = document.createElement('tr');
        headTr.innerHTML = '<th style="background: #fafafa; font-weight: 600;">#</th>';
        for (var ci = 0; ci < columns.length; ci++) {
          var col = columns[ci];
          var colLetter = getColumnLetter(ci);
          var displayName = col.replace(/_c$/i, '').replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
          if (displayName.length > 20) displayName = displayName.substring(0, 18) + '...';
          headTr.innerHTML += '<th style="min-width: 80px;">' +
            '<div style="font-size: 0.7em; color: #888; margin-bottom: 2px; font-weight: 600;">' + colLetter + '</div>' +
            '<div title="' + col + '" style="font-size: 0.85em;">' + displayName + '</div></th>';
        }
        thead.appendChild(headTr);
        tbl.appendChild(thead);

        // Tbody
        var tbody = document.createElement('tbody');
        for (var ri2 = 0; ri2 < rows.length; ri2++) {
          var r = rows[ri2];
          var statusVal = '';
          for (var sk2 = 0; sk2 < STATUS_KEYS.length; sk2++) {
            if (r[STATUS_KEYS[sk2]]) { statusVal = r[STATUS_KEYS[sk2]]; break; }
          }
          var statusClass = 'status-' + (statusVal || '').toLowerCase().replace(/\s+/g, '_');
          var rSheetName = escapeHtml(r.sheet || sheetName);
          var sheetRowIdx = r._sheetRowIndex !== undefined ? r._sheetRowIndex : ri2;
          var recordId = r.record_id || (r._identity && r._identity.record_id) || r.contract_key || '';
          if (!recordId) recordId = rSheetName + ':' + sheetRowIdx;

          var changeSummary = getRecordChangeSummary(recordId);
          var rowClasses = ['clickable'];
          if (changeSummary && changeSummary.total > 0) {
            if (changeSummary.by_type.added) rowClasses.push('row-added');
            else if (changeSummary.by_type.blacklist || changeSummary.by_type.removed) rowClasses.push('row-removed');
            else rowClasses.push('row-changed');
          }

          var cellStyle = getGridCellStyle ? '' : '';
          var rowBadgesHtml = typeof renderRowBadges === 'function' ? renderRowBadges(recordId) : '';

          var tr = document.createElement('tr');
          tr.className = rowClasses.join(' ');
          tr.setAttribute('data-sheet-name', rSheetName);
          tr.setAttribute('data-record-index', '' + sheetRowIdx);
          tr.setAttribute('data-record-id', escapeHtml(recordId));
          tr.onclick = (function(sn, sri) { return function() { openRowReviewDrawer(sn, sri); }; })(r.sheet || sheetName, sheetRowIdx);

          var rowHtml = '<td class="row-index">' + (ri2 + 1) + rowBadgesHtml + '</td>';
          for (var ci2 = 0; ci2 < columns.length; ci2++) {
            var col2 = columns[ci2];
            var val = r[col2];
            if (val === null || val === undefined) val = '';
            if (typeof val === 'object') val = JSON.stringify(val);
            var isFileNameCol = col2.toLowerCase().indexOf('file_name') >= 0;
            var cellContent = String(val);
            if (isFileNameCol && val) {
              var fileUrl = r.file_url || r.File_URL_c || '';
              if (fileUrl) {
                var shortName = val.length > 40 ? val.substring(0, 38) + '...' : val;
                cellContent = '<a href="' + fileUrl + '" target="_blank" onclick="event.stopPropagation();" style="color: #1976d2; text-decoration: none; display: inline-flex; align-items: center; gap: 4px;"><span style="font-size: 0.9em;">&#128279;</span>' + shortName + '</a>';
              }
            }
            var isStatusCol = STATUS_KEYS.indexOf(col2) >= 0 || col2.toLowerCase() === 'status';
            var cellCls = isStatusCol ? statusClass : '';
            var cStyle = typeof getGridCellStyle === 'function' ? getGridCellStyle(recordId, col2, r) : '';
            var changeInfo = typeof getCellChangeInfo === 'function' ? getCellChangeInfo(recordId, col2, r) : null;
            var titlePfx = changeInfo && typeof CHANGE_TYPE_STYLES !== 'undefined' && CHANGE_TYPE_STYLES[changeInfo.type] ? '[' + CHANGE_TYPE_STYLES[changeInfo.type].label + '] ' : '';
            rowHtml += '<td class="' + cellCls + ' truncated" style="' + cStyle + '" title="' + titlePfx + String(val).replace(/"/g, '&quot;') + '">' + cellContent + '</td>';
          }
          tr.innerHTML = rowHtml;
          tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
        bodyDiv.appendChild(tbl);
        section.appendChild(bodyDiv);
        root.appendChild(section);
        console.log('[GRID-COMPOSITE][P1C] section_rendered: ' + sheetName + ' rows=' + rows.length);
      }

      container.appendChild(root);

      // Update footer
      document.getElementById('grid-row-count').textContent = filtered.length + ' of ' + allRecords.length + ' records (composite: ' + sheetOrder.length + ' sheets)';
      gridState.filteredData = filtered;

      var filterInfo = [];
      if (gridState.filter !== 'all') filterInfo.push('Status: ' + gridState.filter);
      if (gridState.search) filterInfo.push('Search: "' + gridState.search + '"');
      if (_activeContractFilter) filterInfo.push('Contract: ' + _activeContractFilter.substring(0, 20));
      document.getElementById('grid-filter-info').textContent = filterInfo.join(' | ');
      updateGridSheetStats(allRecords, filtered);
    }


    // Record Inspection state (v1.4.18 - Field Inspector patch flow)
    var srrState = {
      currentRecord: null,
      currentRowId: null,
      currentSheetName: null,
      currentArtifactId: null,  // v1.5.1: Artifact ID for Verifier/Admin review context
      currentDatasetId: null,   // v1.5.1: Dataset ID for record lookup
      isReadOnly: false,        // v1.5.1: Read-only mode for Verifier/Admin
      originalValues: {},
      editedValues: {},
      proposedChanges: {},
      lockedFields: {},  // v1.4.18: Fields locked after edit commit
      fieldStates: {},   // v1.4.20: Per-field states: todo, verified, rfi, patched
      rfiField: null,    // Field being questioned in RFI (key, label, value)
      activeFilter: 'all',
      activeGroup: 'all',
      searchQuery: '',   // v1.4.18: Search filter
      editingField: null,
      docPage: 1,
      docTotalPages: 1,
      zoom: 1,
      patchType: 'correction',  // v1.4.19: correction | blacklist | rfi (now auto-driven)
      overrideEnabled: false,   // v1.4.19: Override toggle state
      patchDraft: { 
        patch_type: 'correction',
        observation_type: '',
        expected_type: '',
        justification: '',
        repro_type: '', repro_file: null,
        rfi_target: '',
        blacklist_category: '',
        blacklist_subject: '',
        changes: [], 
        status: 'Draft' 
      },
      contextMode: 'contract',
      accountOptions: [],
      selectedAccountIdx: null
    };
    
    // v1.5.7: Rules Bundle Cache - loaded on app init
    var rulesBundleCache = {
      loaded: false,
      loading: false,
      fieldMeta: null,      // field_meta.json
      hingeGroups: null,    // hinge_groups.json
      sheetOrder: null      // sheet_order.json
    };
    
    // v1.5.7: Account Name field key aliases (match any of these)
    var ACCOUNT_NAME_ALIASES = ['Account_Name', 'Account_Name_c', 'account_name', 'account_name_c'];

    function _srrGetAccountName(record) {
      var keys = Object.keys(record);
      for (var i = 0; i < keys.length; i++) {
        if (isAccountNameField(keys[i])) {
          return record[keys[i]] || 'Unknown';
        }
      }
      return 'Unknown';
    }

    function srrBuildAccountSelector(record) {
      var bar = document.getElementById('srr-context-bar');
      if (!bar) return;
      var contractKey = record.contract_key || '';
      if (!contractKey || typeof ContractIndex === 'undefined' || !ContractIndex._index || !ContractIndex._index.contracts) {
        bar.style.display = 'none';
        return;
      }
      var contract = ContractIndex._index.contracts[contractKey];
      if (!contract || !contract.sheets) {
        bar.style.display = 'none';
        return;
      }
      var sheetRows = contract.sheets[srrState.currentSheetName];
      if (!sheetRows || sheetRows.length === 0) {
        bar.style.display = 'none';
        return;
      }
      var countEl = document.getElementById('srr-account-count');
      var selectorRow = document.getElementById('srr-account-selector-row');
      var selectEl = document.getElementById('srr-account-select');
      if (sheetRows.length === 1) {
        bar.style.display = 'block';
        if (selectorRow) selectorRow.style.display = 'none';
        if (countEl) countEl.textContent = '1 account';
        srrState.accountOptions = [];
        srrState.selectedAccountIdx = srrState.currentRowIndex;
        return;
      }
      var options = [];
      var wb = window.workbook || window._workbook;
      for (var i = 0; i < sheetRows.length; i++) {
        var ref = sheetRows[i];
        var rowIdx = ref.row_index !== undefined ? ref.row_index : ref;
        var rowRecord = null;
        if (wb && wb.sheets && wb.sheets[srrState.currentSheetName] && wb.sheets[srrState.currentSheetName].rows) {
          rowRecord = wb.sheets[srrState.currentSheetName].rows[rowIdx];
        }
        var label = rowRecord ? _srrGetAccountName(rowRecord) : ('Row ' + rowIdx);
        var recId = rowRecord ? (rowRecord.record_id || rowRecord.contract_key || '') : '';
        options.push({ value: rowIdx, label: label, recordId: recId });
      }
      srrState.accountOptions = options;
      srrState.selectedAccountIdx = srrState.currentRowIndex;
      if (selectEl) {
        var html = '';
        for (var j = 0; j < options.length; j++) {
          var sel = (options[j].value === srrState.currentRowIndex) ? ' selected' : '';
          html += '<option value="' + options[j].value + '"' + sel + '>' + options[j].label + '</option>';
        }
        selectEl.innerHTML = html;
      }
      bar.style.display = 'block';
      if (countEl) countEl.textContent = options.length + ' accounts';
      if (srrState.contextMode === 'account' && selectorRow) {
        selectorRow.style.display = 'block';
      }
    }

    function srrSetContextMode(mode) {
      srrState.contextMode = mode;
      var btnContract = document.getElementById('srr-ctx-contract');
      var btnAccount = document.getElementById('srr-ctx-account');
      var selectorRow = document.getElementById('srr-account-selector-row');
      if (btnContract) {
        if (mode === 'contract') { btnContract.className = 'srr-ctx-btn active'; } else { btnContract.className = 'srr-ctx-btn'; }
      }
      if (btnAccount) {
        if (mode === 'account') { btnAccount.className = 'srr-ctx-btn active'; } else { btnAccount.className = 'srr-ctx-btn'; }
      }
      if (selectorRow) {
        selectorRow.style.display = (mode === 'account') ? 'block' : 'none';
      }
      console.log('[SRR-CONTEXT] mode_changed: ' + mode);
    }

    function srrSwitchAccount(value) {
      var rowIdx = parseInt(value, 10);
      if (isNaN(rowIdx)) return;
      console.log('[SRR-CONTEXT] account_switched: rowIndex=' + rowIdx);
      openRowReviewDrawer(srrState.currentSheetName, rowIdx);
    }

    // v1.5.7: Load rules bundles from /rules/rules_bundle/
    async function loadRulesBundle() {
      if (rulesBundleCache.loaded || rulesBundleCache.loading) return;
      rulesBundleCache.loading = true;
      console.log('[RulesBundle] Loading bundles...');
      
      try {
        var [fieldMetaRes, hingeGroupsRes, sheetOrderRes, qaFlagsRes, docTypesRes] = await Promise.all([
          fetch('/rules/rules_bundle/field_meta.json'),
          fetch('/rules/rules_bundle/hinge_groups.json'),
          fetch('/rules/rules_bundle/sheet_order.json'),
          fetch('/rules/rules_bundle/qa_flags.json'),
          fetch('/config/document_types.json')
        ]);
        
        if (fieldMetaRes.ok) {
          rulesBundleCache.fieldMeta = await fieldMetaRes.json();
          _glossaryDefault = JSON.parse(JSON.stringify(rulesBundleCache.fieldMeta));
          try {
            var _gOverride = localStorage.getItem('orchestrate_glossary_override');
            if (_gOverride) {
              var _gParsed = JSON.parse(_gOverride);
              if (_gParsed && _gParsed.fields && _gParsed.fields.length > 0) {
                rulesBundleCache.fieldMeta = _gParsed;
                console.log('[Glossary] Override loaded from session: ' + _gParsed.fields.length + ' fields');
              }
            }
          } catch(_gErr) { console.warn('[Glossary] Override load failed:', _gErr); }
          console.log('[RulesBundle] field_meta loaded:', (rulesBundleCache.fieldMeta.fields && rulesBundleCache.fieldMeta.fields.length) || 0, 'fields');
        }
        if (hingeGroupsRes.ok) {
          rulesBundleCache.hingeGroups = await hingeGroupsRes.json();
          console.log('[RulesBundle] hinge_groups loaded:', rulesBundleCache.hingeGroups.hinges?.length || 0, 'hinges');
        }
        if (sheetOrderRes.ok) {
          rulesBundleCache.sheetOrder = await sheetOrderRes.json();
          console.log('[RulesBundle] sheet_order loaded:', rulesBundleCache.sheetOrder.order?.length || 0, 'sheets');
        }
        if (qaFlagsRes.ok) {
          rulesBundleCache.qaFlags = await qaFlagsRes.json();
          console.log('[RulesBundle] qa_flags loaded:', rulesBundleCache.qaFlags.flags?.length || 0, 'flags');
        }
        if (docTypesRes.ok) {
          rulesBundleCache.documentTypes = await docTypesRes.json();
          console.log('[RulesBundle] document_types loaded:', rulesBundleCache.documentTypes.length, 'types');
        } else {
          rulesBundleCache.documentTypes = ['Unknown'];
        }
        
        rulesBundleCache.loaded = true;
        if (_srrActiveLeftTab === 'glossary') { srrRenderGlossary(); }

        // V2.3b: Pre-load section guidance and knowledge link configs
        try { loadSectionGuidanceConfig(); loadKnowledgeLinksConfig(); } catch(e) { console.warn('[V2.3b] Config load error:', e); }

        console.log('[RulesBundle] All bundles loaded successfully');
      } catch (err) {
        console.warn('[RulesBundle] Failed to load bundles:', err);
      } finally {
        rulesBundleCache.loading = false;
      }
    }
    
    // v1.5.7: Normalize field key for comparison (lowercase, no underscores/special chars)
    var _SHEET_EQUIV_MAP = {
      'opportunity': 'opportunities',
      'opportunities': 'opportunities',
      'add_ons': 'add_ons',
      'v2_add_ons': 'add_ons',
      'schedule_catalog': 'schedule_catalog',
      'accounts': 'accounts',
      'catalog': 'catalog',
      'contacts': 'contacts',
      'financials': 'financials',
      'schedule': 'schedule'
    };

    function _normSheetName(s) {
      var n = String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
      n = n.replace(/^v\d+_/, '');
      if (n.length > 1 && n.charAt(n.length - 1) === 's') {
        var singular = n.replace(/ies$/, 'y').replace(/ses$/, 'se').replace(/s$/, '');
        if (_SHEET_EQUIV_MAP[singular]) return _SHEET_EQUIV_MAP[singular];
      }
      return _SHEET_EQUIV_MAP[n] || n;
    }

    function _sheetsEquivalent(a, b) {
      return _normSheetName(a) === _normSheetName(b);
    }

    function _stripSfSuffix(token) {
      return token.replace(/_{1,2}[cr]$/, '');
    }

    function _normFieldToken(s) {
      var n = String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
      return _stripSfSuffix(n);
    }

    function _fieldTokensEquivalent(a, b) {
      return _normFieldToken(a) === _normFieldToken(b);
    }

        function normalizeFieldKey(fieldKey) {
      return fieldKey.toLowerCase().replace(/[^a-z0-9]/g, '');
    }
    
    // v1.5.7: Check if field key matches Account Name aliases (use ACCOUNT_NAME_ALIASES)
    function isAccountNameField(fieldKey) {
      var normalized = normalizeFieldKey(fieldKey);
      for (var i = 0; i < ACCOUNT_NAME_ALIASES.length; i++) {
        if (normalizeFieldKey(ACCOUNT_NAME_ALIASES[i]) === normalized) return true;
      }
      return false;
    }
    
    // v1.5.7: Get hinge info for a field (sheet + field_key -> hinge_level)
    // Uses normalized comparison for case-insensitive matching
    function getHingeInfo(sheetName, fieldKey) {
      if (!rulesBundleCache.hingeGroups || !rulesBundleCache.hingeGroups.hinges) return null;
      var hinges = rulesBundleCache.hingeGroups.hinges;
      var normalizedKey = normalizeFieldKey(fieldKey);
      for (var i = 0; i < hinges.length; i++) {
        var h = hinges[i];
        if (h.sheet === sheetName && normalizeFieldKey(h.field_key) === normalizedKey) {
          return { level: h.hinge_level, why: h.why_it_hinges };
        }
      }
      return null;
    }
    
    // v1.5.7: Get all hinges for a sheet, grouped by level (stores normalized keys for lookup)
    function getSheetHinges(sheetName) {
      if (!rulesBundleCache.hingeGroups || !rulesBundleCache.hingeGroups.hinges) return { primary: [], secondary: [], primaryNorm: [], secondaryNorm: [] };
      var hinges = rulesBundleCache.hingeGroups.hinges.filter(function(h) { return h.sheet === sheetName; });
      var primary = hinges.filter(function(h) { return h.hinge_level === 'Primary'; }).map(function(h) { return h.field_key; });
      var secondary = hinges.filter(function(h) { return h.hinge_level === 'Secondary'; }).map(function(h) { return h.field_key; });
      return {
        primary: primary,
        secondary: secondary,
        primaryNorm: primary.map(normalizeFieldKey),
        secondaryNorm: secondary.map(normalizeFieldKey)
      };
    }
    
    // v1.5.7: Order fields for Field Inspector using rules_bundle
    // Returns: { groups: [{name, fields: [key]}], orderedKeys: [key] }
    function orderFieldsForInspector(record, sheetName) {
      var allKeys = Object.keys(record).filter(function(k) { return !k.startsWith('_'); });
      
      // Get hinge configuration for this sheet
      var hinges = getSheetHinges(sheetName);
      
      // Partition fields into groups using normalized comparison
      var accountNameKey = null;
      var primaryKeys = [];
      var secondaryKeys = [];
      var otherKeys = [];
      
      allKeys.forEach(function(k) {
        var normKey = normalizeFieldKey(k);
        if (isAccountNameField(k)) {
          // Use first match (deterministic - iterate in record order)
          if (!accountNameKey) accountNameKey = k;
        } else if (hinges.primaryNorm.indexOf(normKey) >= 0) {
          primaryKeys.push(k);
        } else if (hinges.secondaryNorm.indexOf(normKey) >= 0) {
          secondaryKeys.push(k);
        } else {
          otherKeys.push(k);
        }
      });
      
      // Sort each group: primary/secondary by hinge order (normalized), other alphabetically
      primaryKeys.sort(function(a, b) { 
        return hinges.primaryNorm.indexOf(normalizeFieldKey(a)) - hinges.primaryNorm.indexOf(normalizeFieldKey(b)); 
      });
      secondaryKeys.sort(function(a, b) { 
        return hinges.secondaryNorm.indexOf(normalizeFieldKey(a)) - hinges.secondaryNorm.indexOf(normalizeFieldKey(b)); 
      });
      otherKeys.sort();
      
      // Build groups array for rendering with headers
      var groups = [];
      
      // Account Name is always first (own group, no header)
      if (accountNameKey) {
        groups.push({ name: null, fields: [accountNameKey] });
      }
      
      // v1.6.7: Simplified group names (removed internal "Hinge" terminology)
      // Primary Fields
      if (primaryKeys.length > 0) {
        groups.push({ name: 'Primary Fields', type: 'primary', fields: primaryKeys });
      }
      
      // Secondary Fields
      if (secondaryKeys.length > 0) {
        groups.push({ name: 'Secondary Fields', type: 'secondary', fields: secondaryKeys });
      }
      
      // Other Fields
      if (otherKeys.length > 0) {
        groups.push({ name: 'Other Fields', type: 'other', fields: otherKeys });
      }
      
      // Build flat ordered keys for filtering/counting
      var orderedKeys = [];
      if (accountNameKey) orderedKeys.push(accountNameKey);
      orderedKeys = orderedKeys.concat(primaryKeys).concat(secondaryKeys).concat(otherKeys);
      
      return { groups: groups, orderedKeys: orderedKeys };
    }
    
    // Legacy fallback for schema order (used when bundle not loaded)
    var SRR_SCHEMA_ORDER = [
      'contract_key',
      'file_name',
      'file_url',
      'subtype',
      'status',
      'notes',
      'artist',
      'label'
    ];
    
    // ========================================================================
    // SIGNAL ENGINE v1 (v1.6.0)
    // Deterministic cell-level signal generation from rules_bundle
    // ========================================================================
    
    // Signal storage: dataset.signals_by_cell[record_id][field_key] = [signals]
    var signalStore = {
      signals_by_cell: {},
      stats: { total: 0, by_type: {} },
      _recordToSheet: {}
    };
    
    // Mojibake detection regex (replacement characters, common encoding issues)
    var MOJIBAKE_REGEX = /[\ufffd\u0000-\u001f\uffff]|Ã¢|Ã©|Ã¨|Ã |Ã¼|â€™|â€œ|â€|Â |Â©|Â®/;
    
    // Signal types
    var SIGNAL_TYPES = {
      MISSING_REQUIRED: { severity: 'error', source: 'field_meta' },
      PICKLIST_INVALID: { severity: 'warning', source: 'field_meta' },
      QA_FLAG: { severity: 'info', source: 'qa_flags' },
      OCR_UNREADABLE: { severity: 'warning', source: 'encoding_check' }
    };
    
    // v1.6.2: Central Signal Style Map - single source of truth for UI and export
    var SIGNAL_STYLE_MAP = {
      PATCH_REQUIRED: { 
        label: 'Patch Required', 
        bg: '#e3f2fd',  // soft blue
        text: '#1565c0',
        priority: 1
      },
      SALESFORCE_LOGIC: { 
        label: 'System Pass', 
        bg: '#fff3e0',  // soft orange
        text: '#e65100',
        priority: 2
      },
      MANUAL_REVIEW: { 
        label: 'Pre-Flight', 
        bg: '#fffde7',  // soft yellow
        text: '#f57f17',
        priority: 3
      },
      SYSTEM_CHANGE: { 
        label: 'System Change', 
        bg: '#f5f5f5',  // neutral gray
        text: '#616161',
        priority: 4
      },
      CLEAN: { 
        label: 'Validated', 
        bg: '#e8f5e9',  // very light green
        text: '#2e7d32',
        priority: 5
      }
    };
    
    // Cell styles metadata for export alignment
    var cellStylesStore = {};
    
    // ========================================================================
    // CHANGE MAP ENGINE v1.6.8
    // Parses meta sheets (change logs, RFIs) to build cell-level change map
    // ========================================================================
    
    // Change map storage: changeMapStore[record_id][field_key] = { type, actor, ... }
    var changeMapStore = {
      changes_by_cell: {},  // record_id -> field_key -> change info
      stats: { total: 0, by_type: {} },
      enabled: false  // Only enabled for modified dataset
    };
    
    // Change type colors for grid highlighting
    // v1.6.11: Strong DataDash-style cell colors for modified dataset
    // ========== V2.2 P0: DOCUMENT ROLE + TYPE ENUMS ==========
    var DOCUMENT_ROLE_ENUM = [
      'Root Agreement', 'Amendment', 'Addendum', 'Schedule', 'Exhibit',
      'Statement of Work (SOW)', 'Side Letter', 'Rider', 'Termination Notice', 'Other', 'Unknown'
    ];
    var DOCUMENT_TYPE_ENUM = [
      'distribution_agreement', 'amendment', 'termination', 'work_for_hire',
      'license', 'publishing_admin', 'joint_venture', 'catalog_schedule_only', 'unknown'
    ];
    var CHANGE_TYPE_STYLES = {
      correction: { bg: '#CFE8FF', border: '#1976d2', label: 'Correction', emoji: '✏️', priority: 3 },
      rfi: { bg: '#FFE7B3', border: '#ff9800', label: 'RFI', emoji: '❓', priority: 2 },
      system_change: { bg: '#EFEFEF', border: '#9e9e9e', label: 'System Change', emoji: '⚙️', priority: 4 },
      blacklist: { bg: '#FFD6D6', border: '#e53935', label: 'Blacklist', emoji: '🚫', priority: 1 },
      verified: { bg: '#DDF5DD', border: '#4caf50', label: 'Verified', emoji: '✓', priority: 5 }
    };
    
    // v1.6.39: Clear all cell-level stores to prevent stale highlights on new dataset load
    function clearAllCellStores() {
      console.log('[CellStores] Clearing all cell-level caches for new dataset');
      
      // Clear signal store
      signalStore.signals_by_cell = {};
      signalStore.stats = { total: 0, by_type: {} };
      signalStore._recordToSheet = {};
      
      // Clear change map store
      changeMapStore.changes_by_cell = {};
      changeMapStore.stats = { total: 0, by_type: {} };
      changeMapStore.enabled = false;
      
      // v1.6.39: Clear cell styles store (grid highlighting)
      if (typeof cellStylesStore !== 'undefined') {
        cellStylesStore = {};
      }
      
      // v1.6.39: Clear record patch summary store
      if (typeof recordPatchSummaryStore !== 'undefined') {
        recordPatchSummaryStore = {};
      }
      
      // v1.6.39: Clear grid virtual state to force full re-render
      if (typeof gridVirtualState !== 'undefined') {
        gridVirtualState = { data: [], rendered: 0, columns: [], active: false };
      }
      
      console.log('[CellStores] All cell stores cleared');
    }
    
    // v1.6.11: Priority order for overlapping changes (lower = higher priority)
    // Blacklist (1) > RFI (2) > Correction (3) > System Change (4) > Verified (5)
    
    // Build change map from meta sheets in workbook
    function buildChangeMapFromMetaSheets() {
      var perfT = perfStart();
      changeMapStore.changes_by_cell = {};
      changeMapStore.stats = { total: 0, by_type: {} };
      changeMapStore.enabled = false;
      
      // v1.6.39: Skip change map for 'original' demo variant (clean baseline)
      if (typeof activeDatasetVariant !== 'undefined' && activeDatasetVariant === 'original') {
        console.log('[ChangeMap] Skipping change map build for original (clean) dataset');
        return;
      }
      
      if (!workbook || !workbook.sheets) {
        console.log('[ChangeMap] No workbook data');
        return;
      }
      
      // Check if modified dataset (has meta sheets)
      var hasMetaSheets = Object.keys(workbook.sheets).some(function(name) {
        return name.endsWith('_change_log') || name === 'RFIs & Analyst Notes';
      });
      
      if (!hasMetaSheets) {
        console.log('[ChangeMap] No meta sheets found - baseline dataset');
        return;
      }
      
      changeMapStore.enabled = true;
      var changeCount = 0;
      
      // v1.6.14: Helper to infer field name by matching old_value against target row
      function inferFieldFromValue(targetSheet, rowIdx, oldValue, newValue) {
        if (!oldValue && !newValue) return null;
        
        var sheet = workbook.sheets[targetSheet];
        if (!sheet || !sheet.rows || !sheet.rows[rowIdx]) return null;
        
        var targetRow = sheet.rows[rowIdx];
        var oldValStr = String(oldValue || '').trim().toLowerCase();
        var newValStr = String(newValue || '').trim().toLowerCase();
        
        // Try to find a field whose value matches old_value or new_value
        for (var key in targetRow) {
          if (key === 'record_id' || key === 'sheet' || key === 'row_index') continue;
          var cellVal = String(targetRow[key] || '').trim().toLowerCase();
          // Match on old_value (before change) or new_value (current value after change)
          if (oldValStr && cellVal === oldValStr) return key;
          if (newValStr && cellVal === newValStr) return key;
        }
        return null;
      }
      
      // 1. Parse change log sheets (*_change_log)
      var inferredCount = 0;
      var rowLevelCount = 0;
      var changeLogSheets = Object.keys(workbook.sheets).filter(function(n) { return n.endsWith('_change_log'); });
      console.log('[ChangeMap] Found change_log sheets:', changeLogSheets);
      
      Object.keys(workbook.sheets).forEach(function(sheetName) {
        if (!sheetName.endsWith('_change_log')) return;
        
        var sheet = workbook.sheets[sheetName];
        var rows = sheet.rows || [];
        console.log('[ChangeMap] Processing', sheetName, 'with', rows.length, 'rows');
        
        rows.forEach(function(row) {
          if (!row) return;
          var targetSheet = row.sheet_name || '';
          var rowIndex = parseFloat(row.row_index);
          var fieldName = row.field_name || '';
          var category = (row.category || '').toUpperCase();
          var changedBy = (row.changed_by || '').toLowerCase();
          if (!targetSheet || isNaN(rowIndex)) return;
          var rowIdx = Math.floor(rowIndex);
          // v1.6.14: Try to infer field if not provided
          if (!fieldName) {
            fieldName = inferFieldFromValue(targetSheet, rowIdx, row.old_value, row.new_value);
            if (fieldName) inferredCount++;
          }
          // Determine change type
          var changeType = 'correction';  // default
          if (category === 'SYSTEM_CHANGE' || changedBy === 'system') {
            changeType = 'system_change';
          } else if (category === 'BLACKLIST' || row.blacklist_value) {
            changeType = 'blacklist';
          }
          // Build record ID (sheet:index)
          var recordId = targetSheet + ':' + rowIdx;
          // Store change
          if (!changeMapStore.changes_by_cell[recordId]) {
            changeMapStore.changes_by_cell[recordId] = {};
          }
          // v1.6.14: Use _row_level marker if no field could be determined
          var storeKey = fieldName || '_row_level';
          if (!fieldName) rowLevelCount++;
          // Don't overwrite more specific field entries with row-level
          if (storeKey === '_row_level' && Object.keys(changeMapStore.changes_by_cell[recordId]).length > 0) {
            // Already have field-level changes, skip row-level marker
            return;
          }
          changeMapStore.changes_by_cell[recordId][storeKey] = {
            type: changeType,
            actor: changedBy === 'system' ? 'System' : 'Analyst',
            old_value: row.old_value || '',
            new_value: row.new_value || '',
            reason: row.reason || '',
            timestamp: row.changed_at || '',
            source: 'change_log'
          };
          changeCount++;
          changeMapStore.stats.by_type[changeType] = (changeMapStore.stats.by_type[changeType] || 0) + 1;
        });
      });
      
      console.log('[ChangeMap] Field inference: inferred=' + inferredCount + ', row-level=' + rowLevelCount);
      
      // v1.6.14: Debug logging for first few records with changes
      var sampleRecords = Object.keys(changeMapStore.changes_by_cell).slice(0, 3);
      if (sampleRecords.length > 0) {
        console.log('[ChangeMap] Sample records:', sampleRecords);
        sampleRecords.forEach(function(recId) {
          var fields = Object.keys(changeMapStore.changes_by_cell[recId]);
          console.log('[ChangeMap]   ' + recId + ': fields=' + fields.join(', '));
        });
      }
      
      // 2. Parse RFIs & Analyst Notes
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      var rfiInferred = 0;
      var rfiRowLevel = 0;
      
      if (rfiSheet && rfiSheet.rows) {
        rfiSheet.rows.forEach(function(row) {
          if (!row) return;
          var targetSheet = row['Sheet'] || '';
          var rowNum = parseFloat(row['Row #']);
          var fieldName = row['Field Name'] || '';
          var noteType = (row['Note Type'] || '').toUpperCase();
          var detectedBy = (row['Detected By'] || '').toLowerCase();
          if (!targetSheet || isNaN(rowNum)) return;
          var rowIdx = Math.floor(rowNum);
          // v1.6.14: Try to infer field from Summary if not provided
          if (!fieldName && row['Summary']) {
            // Check if summary mentions a field name pattern
            var summaryLower = (row['Summary'] || '').toLowerCase();
            var sheet = workbook.sheets[targetSheet];
            if (sheet && sheet.rows && sheet.rows[rowIdx]) {
              var targetRow = sheet.rows[rowIdx];
              for (var key in targetRow) {
                if (key === 'record_id' || key === 'sheet' || key === 'row_index') continue;
                var keyLower = key.toLowerCase().replace(/_c$/, '').replace(/_/g, ' ');
                if (summaryLower.includes(keyLower) && keyLower.length > 3) {
                  fieldName = key;
                  rfiInferred++;
                  break;
                }
              }
            }
          }
          // Determine change type from RFI data
          var changeType = 'rfi';  // default for this sheet
          if (noteType === 'BLACKLIST') {
            changeType = 'blacklist';
          } else if (detectedBy === 'system' || (row['Category'] || '').includes('AUTO')) {
            changeType = 'system_change';
          }
          var recordId = targetSheet + ':' + rowIdx;
          if (!changeMapStore.changes_by_cell[recordId]) {
            changeMapStore.changes_by_cell[recordId] = {};
          }
          // v1.6.14: Use _row_level marker if no field could be determined
          var storeKey = fieldName || '_row_level';
          if (!fieldName) rfiRowLevel++;
          // Don't overwrite existing change log entries (they have more detail)
          if (!changeMapStore.changes_by_cell[recordId][storeKey]) {
            changeMapStore.changes_by_cell[recordId][storeKey] = {
              type: changeType,
              actor: detectedBy === 'system' ? 'System' : 'Analyst',
              summary: row['Summary'] || '',
              details: row['Details'] || '',
              timestamp: row['Timestamp'] || '',
              source: 'rfi_notes'
            };
            
            changeCount++;
            changeMapStore.stats.by_type[changeType] = (changeMapStore.stats.by_type[changeType] || 0) + 1;
          }
        });
      }
      
      console.log('[ChangeMap] RFI inference: inferred=' + rfiInferred + ', row-level=' + rfiRowLevel);
      
      changeMapStore.stats.total = changeCount;
      
      console.log('[ChangeMap] Built change map:', changeCount, 'changes across', 
        Object.keys(changeMapStore.changes_by_cell).length, 'records');
      console.log('[ChangeMap] By type:', JSON.stringify(changeMapStore.stats.by_type));
      perfLog('buildChangeMapFromMetaSheets', perfT);
    }
    
    // ========== v1.6.33: SEED PATCH REQUESTS FROM META SHEET ==========
    // Parse RFIs & Analyst Notes sheet and create patch requests for Analyst Patch Queue
    // v1.6.33: Track if already seeded for this dataset
    var _patchSeedDatasetId = null;
    
    function seedPatchRequestsFromMetaSheet() {
      if (!workbook || !workbook.sheets) {
        return { imported: 0, skipped: 0 };
      }
      
      // v1.6.33: Only seed once per dataset
      var currentDatasetId = ARTIFACT_STORE.current_dataset_id || IDENTITY_CONTEXT.dataset_id || 'ds_default';
      if (_patchSeedDatasetId === currentDatasetId) {
        console.log('[PatchSeed] Already seeded for dataset:', currentDatasetId);
        return { imported: 0, skipped: 0 };
      }
      
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      if (!rfiSheet || !rfiSheet.rows || rfiSheet.rows.length === 0) {
        console.log('[PatchSeed] Dataset missing RFIs & Analyst Notes sheet - skipping RFI seeding (this is normal for baseline datasets)');
        return { imported: 0, skipped: 0 };
      }
      
      var imported = 0;
      var skipped = 0;
      
      // Build a set of existing request keys for deduplication
      var existingKeys = new Set();
      PATCH_REQUEST_STORE.list().forEach(function(pr) {
        if (pr.source === 'meta_sheet_import') {
          var key = (pr.dataset_id || '') + '|' + (pr.record_id || '') + '|' + (pr.field_name || '') + '|' + (pr.summary || '');
          existingKeys.add(key);
        }
      });
      
      rfiSheet.rows.forEach(function(row, rowIdx) {
        if (!row) return;
        
        // Only process rows where Note Type == "RFI"
        var noteType = (row['Note Type'] || '').trim().toUpperCase();
        if (noteType !== 'RFI') return;
        
        var targetSheet = row['Sheet'] || '';
        var rowNum = parseFloat(row['Row #']);
        var fieldName = row['Field Name'] || '';
        var summary = row['Summary'] || '';
        var details = row['Details'] || '';
        var timestamp = row['Timestamp'] || new Date().toISOString();
        var category = row['Category'] || '';
        var detectedBy = row['Detected By'] || 'Analyst';
        var status = row['Status'] || 'Submitted';
        var response = row['Response'] || '';
        
        // v1.6.33: Field name may be empty for RFI comments - extract from summary if possible
        if (!fieldName && summary) {
          var match = summary.match(/on\s+([A-Za-z0-9_]+)$/);
          if (match) fieldName = match[1];
          else fieldName = '(general)';
        }
        if (!targetSheet || isNaN(rowNum)) return;
        
        // Build record_id (sheet + row mapping)
        var recordId = targetSheet + ':' + Math.floor(rowNum);
        var datasetId = ARTIFACT_STORE.current_dataset_id || IDENTITY_CONTEXT.dataset_id || 'ds_default';
        
        // Deduplication key
        var dupeKey = datasetId + '|' + recordId + '|' + fieldName + '|' + summary;
        if (existingKeys.has(dupeKey)) {
          skipped++;
          return;
        }
        existingKeys.add(dupeKey);
        
        // Map status from meta sheet to patch request status
        var prStatus = 'Submitted';
        var statusLower = (status || '').toLowerCase().trim();
        if (statusLower === 'pending' || statusLower === 'open') prStatus = 'Submitted';
        else if (statusLower === 'resolved' || statusLower === 'closed') prStatus = 'Approved';
        else if (statusLower === 'rejected') prStatus = 'Rejected';
        else if (statusLower === 'draft') prStatus = 'Draft';
        else if (statusLower.includes('review')) prStatus = 'Pending_Review';
        
        // Generate request ID
        var requestId = 'pr_rfi_' + targetSheet.toLowerCase().replace(/\s+/g, '_') + '_r' + Math.floor(rowNum) + '_' + rowIdx;
        
        // Build description from Summary + Details
        var description = summary;
        if (details && details !== summary) {
          description += ' — ' + details;
        }
        
        // Create the patch request directly
        var now = timestamp || new Date().toISOString();
        var request = {
          request_id: requestId,
          version: 1,
          status: prStatus,
          artifact_type: 'rfi',
          type: 'rfi',
          source: 'meta_sheet_import',
          dataset_id: datasetId,
          record_id: recordId,
          sheet: targetSheet,
          field_name: fieldName,
          summary: summary,
          description: description,
          category: category,
          target: 'field_clarification',
          when: 'Field requires clarification',
          then: summary,
          because: details || summary,
          rationale: details || summary,
          analyst: detectedBy,
          submitted_by: detectedBy,
          response: response,
          created_at_utc: now,
          submitted_at_utc: now,
          updated_at_utc: now,
          thread: [],
          history: [
            {
              at_utc: now,
              actor: detectedBy,
              role: 'Analyst',
              action: 'Created from RFI sheet',
              from_status: null,
              to_status: prStatus
            }
          ]
        };
        
        // Add response as a thread item if present
        if (response && response.trim()) {
          request.thread.push({
            id: requestId + '_resp_0',
            timestamp: now,
            author: 'Verifier',
            role: 'verifier',
            content: response,
            type: 'response'
          });
        }
        
        // Save to store
        PATCH_REQUEST_STORE.save(request);
        imported++;
      });
      
      console.log('[PatchSeed] Imported', imported, 'RFIs to Patch Request store (', skipped, 'duplicates skipped)');
      
      // v1.6.33: Mark as seeded for this dataset
      _patchSeedDatasetId = currentDatasetId;
      
      return { imported: imported, skipped: skipped };
    }

    // v1.6.35: Canonical store for meta-derived triage items (shared across roles)
    var META_TRIAGE_STORE = {
      manualReviewItems: [],
      systemChangesItems: [],
      datasetId: null,
      
      setManualReview: function(items, datasetId) {
        this.manualReviewItems = items || [];
        this.datasetId = datasetId;
        console.log('[MetaTriageStore] Stored', this.manualReviewItems.length, 'Manual Review items');
      },
      
      setSystemChanges: function(items, datasetId) {
        this.systemChangesItems = items || [];
        this.datasetId = datasetId;
        console.log('[MetaTriageStore] Stored', this.systemChangesItems.length, 'System Changes items');
      },
      
      getManualReview: function() {
        return this.manualReviewItems;
      },
      
      getSystemChanges: function() {
        return this.systemChangesItems;
      },
      
      reset: function() {
        this.manualReviewItems = [];
        this.systemChangesItems = [];
        this.datasetId = null;
      }
    };

    // v1.6.35: Seed Manual Review queue from RFI meta sheet (Note Type = "Manual Review")
    var _manualReviewSeedDatasetId = null;
    var _manualReviewItems = [];
    
    function seedManualReviewFromMetaSheet() {
      if (!workbook || !workbook.sheets) {
        return [];
      }
      
      var currentDatasetId = ARTIFACT_STORE.current_dataset_id || IDENTITY_CONTEXT.dataset_id || 'ds_default';
      if (_manualReviewSeedDatasetId === currentDatasetId && _manualReviewItems.length > 0) {
        console.log('[ManualReviewSeed] Already seeded for dataset:', currentDatasetId);
        return _manualReviewItems;
      }
      
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      if (!rfiSheet || !rfiSheet.rows || rfiSheet.rows.length === 0) {
        console.log('[ManualReviewSeed] Dataset missing RFIs & Analyst Notes sheet - skipping Manual Review seeding');
        return [];
      }
      
      var items = [];
      
      rfiSheet.rows.forEach(function(row, rowIdx) {
        if (!row) return;
        
        // Only process rows where Note Type == "Manual Review"
        var noteType = (row['Note Type'] || '').trim().toLowerCase();
        if (noteType !== 'manual review') return;
        
        var targetSheet = row['Sheet'] || '';
        var rowNum = parseFloat(row['Row #']);
        var fieldName = row['Field Name'] || '(general)';
        var summary = row['Summary'] || '';
        var status = row['Status'] || 'Open';
        var timestamp = row['Timestamp'] || new Date().toISOString();
        
        if (!targetSheet || isNaN(rowNum)) return;
        
        var recordId = targetSheet + ':' + Math.floor(rowNum);
        
        items.push({
          request_id: 'manual_review_' + rowIdx,
          type: 'manual_review',
          record_id: recordId,
          field_name: fieldName,
          signal_type: 'MANUAL_REVIEW',
          severity: 'warning',
          status: status,
          status_label: status,
          status_color: '#f57c00',
          message: summary || 'Manual review required',
          updated_at: timestamp,
          sheet: targetSheet,
          row_index: Math.floor(rowNum),
          source: 'meta_sheet'
        });
      });
      
      _manualReviewSeedDatasetId = currentDatasetId;
      _manualReviewItems = items;
      
      // v1.6.35: Store in canonical store for cross-role access
      META_TRIAGE_STORE.setManualReview(items, currentDatasetId);
      
      console.log('[ManualReviewSeed] Seeded', items.length, 'Manual Review items from meta sheet');
      return items;
    }
    
    // v1.6.35: Seed System Changes queue from *_change_log sheets
    var _systemChangesSeedDatasetId = null;
    var _systemChangesItems = [];
    
    function seedSystemChangesFromChangeLog() {
      if (!workbook || !workbook.sheets) {
        return [];
      }
      
      var currentDatasetId = ARTIFACT_STORE.current_dataset_id || IDENTITY_CONTEXT.dataset_id || 'ds_default';
      if (_systemChangesSeedDatasetId === currentDatasetId && _systemChangesItems.length > 0) {
        console.log('[SystemChangesSeed] Already seeded for dataset:', currentDatasetId);
        return _systemChangesItems;
      }
      
      // Find all *_change_log sheets
      var changeLogSheets = Object.keys(workbook.sheets).filter(function(name) {
        return name.endsWith('_change_log');
      });
      
      if (changeLogSheets.length === 0) {
        console.log('[SystemChangesSeed] Dataset missing *_change_log sheets - skipping System Changes seeding');
        return [];
      }
      
      var items = [];
      
      changeLogSheets.forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        if (!sheet || !sheet.rows) return;
        
        var targetSheet = sheetName.replace('_change_log', '');
        
        sheet.rows.forEach(function(row, rowIdx) {
          if (!row) return;
          var rowNum = parseFloat(row['Row #'] || row['row'] || row['Row'] || rowIdx);
          var fieldName = row['Field'] || row['field'] || row['Field Name'] || row['Changed_Field'] || '';
          var changeType = row['Change Type'] || row['change_type'] || row['Action'] || row['action'] || 'Update';
          var oldValue = row['Old Value'] || row['old_value'] || row['Previous'] || '';
          var newValue = row['New Value'] || row['new_value'] || row['Current'] || '';
          var notes = row['Notes'] || row['notes'] || row['Summary'] || row['Reason'] || '';
          var timestamp = row['Timestamp'] || row['timestamp'] || row['Date'] || new Date().toISOString();
          var ruleId = row['Rule ID'] || row['rule_id'] || row['Rule'] || '';
          if (!fieldName && !notes) return;
          var recordId = targetSheet + ':' + Math.floor(rowNum);
          // Determine change type label
          var typeLabel = changeType;
          var typeColor = '#4caf50';
          if (changeType.toLowerCase().includes('address') || changeType.toLowerCase().includes('standard')) {
            typeLabel = 'Address Standardization';
            typeColor = '#2196f3';
          } else if (changeType.toLowerCase().includes('format')) {
            typeLabel = 'Format Correction';
            typeColor = '#9c27b0';
          } else if (changeType.toLowerCase().includes('rule')) {
            typeLabel = 'Rule-Based Correction';
            typeColor = '#ff9800';
          }
          var message = notes || (changeType + ': ' + fieldName);
          if (oldValue && newValue) {
            message = '"' + oldValue + '" → "' + newValue + '"' + (notes ? ' (' + notes + ')' : '');
          }
          items.push({
            request_id: 'system_change_' + sheetName + '_' + rowIdx,
            type: 'system_change',
            record_id: recordId,
            field_name: fieldName || '(system)',
            signal_type: 'SYSTEM_CHANGE',
            severity: 'info',
            status: 'Applied',
            status_label: typeLabel,
            status_color: typeColor,
            message: message,
            updated_at: timestamp,
            sheet: targetSheet,
            row_index: Math.floor(rowNum),
            old_value: oldValue,
            new_value: newValue,
            rule_id: ruleId,
            source: 'change_log'
          });
        });
      });
      
      _systemChangesSeedDatasetId = currentDatasetId;
      _systemChangesItems = items;
      
      // v1.6.35: Store in canonical store for cross-role access
      META_TRIAGE_STORE.setSystemChanges(items, currentDatasetId);
      
      console.log('[SystemChangesSeed] Seeded', items.length, 'System Changes from', changeLogSheets.length, 'change_log sheets');
      return items;
    }
    
    // ========== v1.6.9: SEED VERIFIER RFI QUEUE FROM META SHEET ==========
    // Parse RFIs & Analyst Notes sheet and populate Verifier queue with RFI items
    function seedVerifierRFIQueueFromMetaSheet() {
      if (!workbook || !workbook.sheets) return;
      
      // Guard: verifierQueueState may not be initialized yet (defined later in file)
      if (typeof verifierQueueState === 'undefined' || !verifierQueueState) {
        console.log('[RFI Seed] Skipped - verifierQueueState not yet initialized');
        return;
      }
      
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      if (!rfiSheet || !rfiSheet.rows || rfiSheet.rows.length === 0) {
        console.log('[RFI Seed] No RFIs & Analyst Notes sheet found');
        return;
      }
      
      var rfiCount = 0;
      var skippedDupes = 0;
      var importedRFIs = [];
      
      // Build a set of existing RFI keys for deduplication
      var existingKeys = new Set();
      verifierQueueState.payloads.forEach(function(p) {
        if (p.type === 'rfi' && p.source === 'legacy_rfi_import') {
          var key = (p.dataset_id || '') + '|' + p.record_id + '|' + p.field + '|' + (p.summary || '');
          existingKeys.add(key);
        }
      });
      
      rfiSheet.rows.forEach(function(row, rowIdx) {
        if (!row) return;
        
        // Only process rows where Note Type == "RFI"
        var noteType = (row['Note Type'] || '').trim().toUpperCase();
        if (noteType !== 'RFI') return;
        
        var targetSheet = row['Sheet'] || '';
        var rowNum = parseFloat(row['Row #']);
        var fieldName = row['Field Name'] || '';
        var summary = row['Summary'] || '';
        var details = row['Details'] || '';
        var timestamp = row['Timestamp'] || new Date().toISOString();
        var category = row['Category'] || '';
        var detectedBy = row['Detected By'] || 'Analyst';
        var sourceUrl = row['Source URL'] || '';
        
        // v1.6.33: Field name may be empty for RFI comments - extract from summary if possible
        if (!fieldName && summary) {
          var match = summary.match(/on\s+([A-Za-z0-9_]+)$/);
          if (match) fieldName = match[1];
          else fieldName = '(general)';
        }
        if (!targetSheet || isNaN(rowNum)) return;
        
        // Build record_id (sheet + row mapping)
        var recordId = targetSheet + ':' + Math.floor(rowNum);
        var datasetId = ARTIFACT_STORE.current_dataset_id || 'ds_default';
        
        // Deduplication key: dataset_id + record_id + field_key + summary
        var dupeKey = datasetId + '|' + recordId + '|' + fieldName + '|' + summary;
        if (existingKeys.has(dupeKey)) {
          skippedDupes++;
          return;
        }
        existingKeys.add(dupeKey);
        
        // Generate artifact ID
        var artifactId = 'art_rfi_' + targetSheet.toLowerCase().replace(/\s+/g, '_') + '_' + Math.floor(rowNum) + '_' + Date.now() + '_' + rowIdx;
        
        // Build comment from Summary + Details
        var comment = summary;
        if (details && details !== summary) {
          comment += (comment ? ' — ' : '') + details;
        }
        
        // Create artifact
        var artifact = createArtifact({
          artifact_id: artifactId,
          dataset_id: datasetId,
          record_id: recordId,
          field_key: fieldName,
          artifact_type: 'rfi',
          status: 'pending_review',
          created_by_actor_id: 'user',
          created_by_role: 'analyst',
          sheet_name: targetSheet,
          body: {
            summary: summary,
            details: details,
            category: category,
            source_url: sourceUrl,
            detected_by: detectedBy,
            original_timestamp: timestamp
          }
        });
        
        // Create verifier queue payload
        var payload = {
          id: artifactId,
          artifact_id: artifactId,
          type: 'rfi',
          status: 'pending',
          record_id: recordId,
          dataset_id: datasetId,
          field: fieldName,
          old_value: '',
          new_value: '',
          comment: comment,
          summary: summary,
          details: details,
          timestamp: timestamp,
          source: 'legacy_rfi_import',
          sheet_name: targetSheet,
          row_number: Math.floor(rowNum),
          category: category,
          detected_by: detectedBy,
          source_url: sourceUrl
        };
        
        verifierQueueState.payloads.push(payload);
        importedRFIs.push(payload);
        rfiCount++;
        
        // Create audit log entry
        logArtifactEvent('RFI_IMPORTED', {
          artifact_id: artifactId,
          artifact_type: 'rfi',
          record_id: recordId,
          field_key: fieldName,
          action: 'RFI_IMPORTED',
          actor: 'user',
          source: 'legacy_rfi_import',
          summary: summary
        });
      });
      
      // Persist verifier queue to localStorage
      if (rfiCount > 0) {
        saveVerifierQueue();
      }
      
      console.log('[RFI Seed] Imported', rfiCount, 'RFIs to Verifier queue (', skippedDupes, 'duplicates skipped)');
      
      // Re-render verifier triage if visible
      if (typeof renderVerifierTriage === 'function') {
        renderVerifierTriage();
      }
      
      return { imported: rfiCount, skipped: skippedDupes, items: importedRFIs };
    }
    
    // Get change info for a specific cell
    // v1.6.14: Also check for row-level changes as fallback
    // v1.6.18: Helper to get record changes with key fallback
    function getRecordChangesWithFallback(recordId, record) {
      if (!changeMapStore.enabled) return null;
      
      // Try primary key first
      var recordChanges = changeMapStore.changes_by_cell[recordId];
      if (recordChanges) return recordChanges;
      
      // v1.6.18: Fallback 1 - try record_id if join triplet failed
      if (record && record.record_id && record.record_id !== recordId) {
        recordChanges = changeMapStore.changes_by_cell[record.record_id];
        if (recordChanges) return recordChanges;
      }
      
      // v1.6.18: Fallback 2 - try sheet:rowIndex format
      if (record && record.sheet && record._sheetRowIndex !== undefined) {
        var sheetRowKey = record.sheet + ':' + record._sheetRowIndex;
        if (sheetRowKey !== recordId) {
          recordChanges = changeMapStore.changes_by_cell[sheetRowKey];
          if (recordChanges) return recordChanges;
        }
      }
      
      return null;
    }
    
    function getCellChangeInfo(recordId, fieldKey, record) {
      if (!changeMapStore.enabled) return null;
      var recordChanges = getRecordChangesWithFallback(recordId, record);
      if (!recordChanges) return null;
      
      // Try exact match first
      if (recordChanges[fieldKey]) return recordChanges[fieldKey];
      
      // Try normalized match
      var normKey = normalizeFieldKey(fieldKey);
      for (var key in recordChanges) {
        if (key !== '_row_level' && normalizeFieldKey(key) === normKey) {
          return recordChanges[key];
        }
      }
      
      // v1.6.14: Fall back to row-level change if no field match found
      if (recordChanges['_row_level']) {
        return recordChanges['_row_level'];
      }
      
      return null;
    }
    
    // Get all changes for a record (for badge tooltips)
    // v1.6.18: Updated to use fallback key resolution
    function getRecordChanges(recordId, record) {
      if (!changeMapStore.enabled) return {};
      return getRecordChangesWithFallback(recordId, record) || {};
    }
    
    // Get change summary for a record (for badge display)
    function getRecordChangeSummary(recordId) {
      var changes = getRecordChanges(recordId);
      var fieldKeys = Object.keys(changes);
      if (fieldKeys.length === 0) return null;
      
      var byType = {};
      fieldKeys.forEach(function(key) {
        var type = changes[key].type || 'correction';
        byType[type] = (byType[type] || 0) + 1;
      });
      
      return {
        total: fieldKeys.length,
        by_type: byType,
        fields: fieldKeys
      };
    }
    
    // Build tooltip text from change summary
    function buildChangeTooltip(summary) {
      if (!summary || summary.total === 0) return '';
      
      var parts = [];
      var typeOrder = ['correction', 'rfi', 'system_change', 'blacklist'];
      typeOrder.forEach(function(type) {
        var count = summary.by_type[type];
        if (count) {
          var style = CHANGE_TYPE_STYLES[type];
          parts.push(style.label + ' (' + count + ')');
        }
      });
      
      return summary.total + ' change' + (summary.total > 1 ? 's' : '') + ': ' + parts.join(', ');
    }
    
    // Map raw signal types to style categories
    function mapSignalToStyleCategory(signalType, severity) {
      switch (signalType) {
        case 'MISSING_REQUIRED':
        case 'PICKLIST_INVALID':
          return 'PATCH_REQUIRED';
        case 'QA_FLAG':
          if (severity === 'error' || severity === 'warning') return 'SALESFORCE_LOGIC';
          return 'SYSTEM_CHANGE';
        case 'OCR_UNREADABLE':
          return 'MANUAL_REVIEW';
        default:
          return 'CLEAN';
      }
    }
    
    // Get highest priority style for a cell (priority: 1=highest)
    function getCellHighestPriorityStyle(recordId, fieldKey) {
      var signals = getSignalsForCell(recordId, fieldKey);
      if (!signals || signals.length === 0) {
        return SIGNAL_STYLE_MAP.CLEAN;
      }
      
      var bestCategory = 'CLEAN';
      var bestPriority = 99;
      
      for (var i = 0; i < signals.length; i++) {
        var sig = signals[i];
        var category = mapSignalToStyleCategory(sig.signal_type, sig.severity);
        var style = SIGNAL_STYLE_MAP[category];
        if (style && style.priority < bestPriority) {
          bestPriority = style.priority;
          bestCategory = category;
        }
      }
      
      return SIGNAL_STYLE_MAP[bestCategory];
    }
    
    // Get row signal counts for badge display
    function getRowSignalCounts(recordId) {
      var recordSignals = signalStore.signals_by_cell[recordId];
      if (!recordSignals) return null;
      
      var counts = {
        PATCH_REQUIRED: 0,
        SALESFORCE_LOGIC: 0,
        MANUAL_REVIEW: 0,
        SYSTEM_CHANGE: 0
      };
      
      var fieldKeys = Object.keys(recordSignals);
      for (var i = 0; i < fieldKeys.length; i++) {
        var signals = recordSignals[fieldKeys[i]];
        for (var j = 0; j < signals.length; j++) {
          var category = mapSignalToStyleCategory(signals[j].signal_type, signals[j].severity);
          if (counts[category] !== undefined) {
            counts[category]++;
          }
        }
      }
      
      var total = counts.PATCH_REQUIRED + counts.SALESFORCE_LOGIC + counts.MANUAL_REVIEW + counts.SYSTEM_CHANGE;
      return total > 0 ? counts : null;
    }
    
    // Populate cell_styles metadata for export alignment
    function populateCellStyles() {
      cellStylesStore = {};
      var recordIds = Object.keys(signalStore.signals_by_cell);
      
      for (var i = 0; i < recordIds.length; i++) {
        var recordId = recordIds[i];
        var recordSignals = signalStore.signals_by_cell[recordId];
        cellStylesStore[recordId] = {};
        
        var fieldKeys = Object.keys(recordSignals);
        for (var j = 0; j < fieldKeys.length; j++) {
          var fieldKey = fieldKeys[j];
          var style = getCellHighestPriorityStyle(recordId, fieldKey);
          var signals = recordSignals[fieldKey];
          var category = 'CLEAN';
          if (signals.length > 0) {
            category = mapSignalToStyleCategory(signals[0].signal_type, signals[0].severity);
          }
          cellStylesStore[recordId][fieldKey] = {
            status: category,
            color: style.bg,
            label: style.label
          };
        }
      }
      
      console.log('[CellStyles] Populated metadata for', recordIds.length, 'records');
      return cellStylesStore;
    }
    
    // Get field metadata from rules bundle (normalized lookup)
    // Falls back to sheet-agnostic match if sheet-specific lookup fails
    function getFieldMeta(sheetName, fieldKey) {
      if (!rulesBundleCache.fieldMeta || !rulesBundleCache.fieldMeta.fields) return null;
      var fields = rulesBundleCache.fieldMeta.fields;
      var normKey = normalizeFieldKey(fieldKey);
      var sheetMatch = null;
      var anyMatch = null;
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        if (normalizeFieldKey(f.field_key) === normKey) {
          if (f.sheet === sheetName) {
            sheetMatch = f;
            break;
          }
          if (!anyMatch) anyMatch = f;
        }
      }
      return sheetMatch || anyMatch || null;
    }
    
    // v1.6.36+: Build glossary icon with data attributes for portal tooltip
    function buildGlossaryTooltip(fieldMeta, fieldKey, sheetName) {
      var dataAttrs = 'data-field-key="' + escapeHtml(fieldKey) + '"';
      if (sheetName) dataAttrs += ' data-sheet="' + escapeHtml(sheetName) + '"';
      return '<span class="glossary-tooltip-wrapper">' +
             '<span class="glossary-icon" ' + dataAttrs + '>ⓘ</span>' +
             '</span>';
    }

    // v1.6.36+: Build tooltip HTML content for the portal from field metadata
    function buildGlossaryPortalContent(fieldKey, sheetName) {
      var fieldMeta = getFieldMeta(sheetName, fieldKey);
      
      if (!fieldMeta) {
        console.log('[Glossary] No metadata for field:', fieldKey, 'sheet:', sheetName || '(none)');
        return '<div class="gtt-no-data">No glossary data available.</div>';
      }

      var label = fieldMeta.field_label || fieldKey;
      var type = fieldMeta.return_format || 'Unknown';
      var required = fieldMeta.requiredness || 'not_needed';
      var requiredLabel = required === 'required' ? 'Required' : 
                         required === 'optional' ? 'Optional' : 'Not Required';
      var definition = fieldMeta.definition || '';
      var options = fieldMeta.options || [];
      var hingeGroup = '';
      if (rulesBundleCache.hingeGroups && rulesBundleCache.hingeGroups.hinges) {
        var normKey = normalizeFieldKey(fieldKey);
        for (var i = 0; i < rulesBundleCache.hingeGroups.hinges.length; i++) {
          var hinge = rulesBundleCache.hingeGroups.hinges[i];
          if (hinge.fields && hinge.fields.some(function(f) { return normalizeFieldKey(f) === normKey; })) {
            hingeGroup = hinge.hinge_group || hinge.name || '';
            break;
          }
        }
      }

      var html = '';
      html += '<div class="gtt-row"><span class="gtt-label">Field:</span> <span class="gtt-value">' + escapeHtml(label) + '</span></div>';
      html += '<div class="gtt-row"><span class="gtt-label">Type:</span> <span class="gtt-value">' + escapeHtml(type) + '</span></div>';
      html += '<div class="gtt-row"><span class="gtt-label">Status:</span> <span class="gtt-value">' + requiredLabel + '</span></div>';
      if (hingeGroup) {
        html += '<div class="gtt-row"><span class="gtt-label">Group:</span> <span class="gtt-value">' + escapeHtml(hingeGroup) + '</span></div>';
      }
      if (definition) {
        html += '<hr class="gtt-divider">';
        html += '<div class="gtt-definition">' + escapeHtml(definition) + '</div>';
      }
      if (options && options.length > 0) {
        html += '<hr class="gtt-divider">';
        var optionsDisplay = options.slice(0, 10).join(', ');
        if (options.length > 10) optionsDisplay += ', ... (' + options.length + ' total)';
        html += '<div class="gtt-row"><span class="gtt-label">Options:</span></div>';
        html += '<div class="gtt-options">' + escapeHtml(optionsDisplay) + '</div>';
      }
      return html;
    }
    
    // Check if value is blank (empty, null, undefined, whitespace only, or common null-like strings)
    // v1.6.8: Expanded to include N/A, NULL, — to avoid false positive picklist signals
    var BLANK_VALUE_STRINGS = ['', 'n/a', 'na', 'null', '—', '-', 'none', 'undefined'];
    function isBlankValue(value) {
      if (value === null || value === undefined) return true;
      if (typeof value === 'string') {
        var normalized = value.trim().toLowerCase();
        if (normalized === '' || BLANK_VALUE_STRINGS.indexOf(normalized) >= 0) return true;
      }
      return false;
    }
    
    // Generate signals for a single cell
    function generateCellSignals(record, fieldKey, sheetName, recordId) {
      var signals = [];
      var value = record[fieldKey];
      var meta = getFieldMeta(sheetName, fieldKey);
      
      // 1. MISSING_REQUIRED: Required field is blank
      if (meta && meta.requiredness === 'required' && isBlankValue(value)) {
        signals.push({
          signal_type: 'MISSING_REQUIRED',
          severity: 'error',
          message: 'Required field is blank',
          source: 'field_meta',
          field_label: meta.field_label || fieldKey
        });
      }
      
      // 2. PICKLIST_INVALID: Picklist field with value not in options
      // v1.6.8: Only validate if:
      //   a) Dataset has enable_picklist_validation = true
      //   b) Field is explicitly marked as picklist (meta.picklist === true)
      //   c) Field has defined options (meta.options.length > 0)
      //   d) Value is not blank/empty/null-like
      // v1.6.10: Only validate on primary data sheets, skip meta sheets
      var PRIMARY_DATA_SHEETS = ['Accounts', 'Opportunity', 'Financials', 'Catalog', 'Schedule', 'Schedule Catalog', 'V2 Add Ons', 'Contacts'];
      var isMetaSheet = sheetName && (sheetName.includes('_change_log') || sheetName === 'RFIs & Analyst Notes');
      var isPrimarySheet = PRIMARY_DATA_SHEETS.indexOf(sheetName) >= 0;
      
      if (meta && meta.picklist === true && meta.options && meta.options.length > 0 && !isBlankValue(value) && !isMetaSheet && isPrimarySheet) {
        // Check dataset-level toggle before validating
        if (isPicklistValidationEnabled()) {
          var valueStr = String(value).trim();
          // v1.6.10: Skip empty-like values (N/A, NULL, etc.)
          var emptyLikeValues = ['', 'n/a', 'null', 'none', '-'];
          if (emptyLikeValues.indexOf(valueStr.toLowerCase()) < 0) {
            var isValid = meta.options.some(function(opt) {
              return String(opt).trim().toLowerCase() === valueStr.toLowerCase();
            });
            if (!isValid) {
              signals.push({
                signal_type: 'PICKLIST_INVALID',
                severity: 'warning',
                message: 'Value "' + valueStr + '" not in picklist options',
                source: 'field_meta',
                field_label: meta.field_label || fieldKey,
                valid_options: meta.options.slice(0, 5) // Show first 5 options
              });
            }
          }
        }
      }
      
      // 3. OCR_UNREADABLE: Encoding issues (mojibake)
      if (!isBlankValue(value) && typeof value === 'string' && MOJIBAKE_REGEX.test(value)) {
        signals.push({
          signal_type: 'OCR_UNREADABLE',
          severity: 'warning',
          message: 'Possible encoding issue detected',
          source: 'encoding_check',
          field_label: meta ? meta.field_label : fieldKey
        });
      }
      
      // 4. QA_FLAG: Attach informational flags from qa_flags.json
      // For v1, attach as informational markers based on field metadata presence
      // v1.6.19: Disabled QA_FLAG generation for missing required (F-REQ-001) since
      // MISSING_REQUIRED signal already covers this case. This prevents duplicate
      // entries in triage queues (one in Patch Queue, one in SF Logic Flags).
      // QA_FLAG should only be used for flags that don't have a dedicated signal type.
      
      // Sort signals alphabetically by signal_type for determinism
      signals.sort(function(a, b) {
        return a.signal_type.localeCompare(b.signal_type);
      });
      
      return signals;
    }
    
    // v1.6.8: Check if picklist validation is enabled for current dataset
    function isPicklistValidationEnabled() {
      // v2.3 G6: No localStorage blob read. Check in-memory allData for picklist flag.
      try {
        if (typeof allData !== 'undefined' && allData) {
          if (allData.enable_picklist_validation === true) return true;
          if (allData.summary && allData.summary.enable_picklist_validation === true) return true;
        }
        // Also check upload library for active dataset
        var activeId = localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET);
        if (activeId) {
          var library = getUploadLibrary();
          if (library) {
            var entry = library.find(function(d) { return d.dataset_id === activeId; });
            if (entry && entry.enable_picklist_validation === true) return true;
          }
        }
      } catch (e) { /* ignore */ }
      return false;
    }
    
    // Generate signals for entire dataset
    function generateSignalsForDataset() {
      // Stage: Validating rules
      if (stagedLoader.startTime) stagedLoader.setStage('validating');
      
      if (!rulesBundleCache.loaded) {
        console.warn('[SignalEngine] Rules bundle not loaded, skipping signal generation');
        return;
      }
      
      // v1.6.8: Check dataset-level picklist validation toggle
      var picklistEnabled = isPicklistValidationEnabled();
      console.log('[SignalEngine] Picklist validation enabled:', picklistEnabled);
      
      // Reset signal store
      signalStore.signals_by_cell = {};
      signalStore.stats = { total: 0, by_type: {} };
      signalStore._recordToSheet = {};
      
      var recordCount = 0;
      var signalCount = 0;
      
      // Iterate over all sheets and records in workbook
      if (!workbook || !workbook.sheets) {
        console.warn('[SignalEngine] No workbook data to scan');
        return;
      }
      
      Object.keys(workbook.sheets).sort().forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        var rows = sheet ? sheet.rows : [];
        if (!rows || rows.length === 0) return;
        
        rows.forEach(function(row, idx) {
          if (!row) return;
          recordCount++;
          // Get record_id (from _identity or generate)
          var recordId = (row._identity && row._identity.record_id) 
            ? row._identity.record_id 
            : sheetName + ':' + idx;
          // Initialize cell map for this record
          if (!signalStore.signals_by_cell[recordId]) {
            signalStore.signals_by_cell[recordId] = {};
          }
          signalStore._recordToSheet[recordId] = sheetName;
          // Backfill document_type and capabilities
          if (!row._document_type) row._document_type = 'Unknown';
          if (!row._document_role) row._document_role = 'Unknown';
          if (!row._capabilities) row._capabilities = {};
          if (!row._document_role_suggestion) row._document_role_suggestion = null;

          // Get all field keys (excluding internal fields)
          var fieldKeys = Object.keys(row).filter(function(k) {
            return !k.startsWith('_');
          }).sort(); // Sort for determinism
          // Generate signals for each cell
          fieldKeys.forEach(function(fieldKey) {
            var signals = generateCellSignals(row, fieldKey, sheetName, recordId);
            if (signals.length > 0) {
              signalStore.signals_by_cell[recordId][fieldKey] = signals;
              signalCount += signals.length;
              
              // Update stats
              signals.forEach(function(s) {
                signalStore.stats.by_type[s.signal_type] = (signalStore.stats.by_type[s.signal_type] || 0) + 1;
              });
            }
          });
        });
      });
      
      signalStore.stats.total = signalCount;
      
      // v1.6.0: Set dataset load timestamp for triage display
      datasetLoadTimestamp = new Date().toISOString();
      
      // Debug console log
      console.log('[SignalEngine] Scan complete:');
      console.log('  - Records scanned:', recordCount);
      console.log('  - Signals generated:', signalCount);
      
      // Top 5 signal types
      var typeEntries = Object.entries(signalStore.stats.by_type)
        .sort(function(a, b) { return b[1] - a[1]; })
        .slice(0, 5);
      
      if (typeEntries.length > 0) {
        console.log('  - Top signal types:');
        typeEntries.forEach(function(entry) {
          console.log('      ' + entry[0] + ': ' + entry[1]);
        });
      }
      
      // v1.6.2: Populate cell_styles metadata for export alignment
      populateCellStyles();
      
      // Stage: Building change map
      if (stagedLoader.startTime) stagedLoader.setStage('changemap');
      
      // v1.6.8: Build change map from meta sheets (for modified dataset)
      buildChangeMapFromMetaSheets();
      
      // Note: v1.6.9 RFI seeding is done in loadAnalystTriageFromStore after verifierQueueState is ready
      
      // v1.6.33: Update progress block after signals generated
      if (typeof updateProgressBlock === 'function') {
        updateProgressBlock();
      }
      
      return signalStore;
    }
    
    // Get signals for a specific record
    function getSignalsForRecord(recordId) {
      return signalStore.signals_by_cell[recordId] || {};
    }
    
    // Get signals for a specific cell
    function getSignalsForCell(recordId, fieldKey) {
      var recordSignals = signalStore.signals_by_cell[recordId];
      if (!recordSignals) return [];
      return recordSignals[fieldKey] || [];
    }
    
    // Get signal stats
    function getSignalStats() {
      return signalStore.stats;
    }
    
    // v1.6.2: Render row badges HTML for grid (v1.6.6: with detailed tooltips)
    // v1.6.8: Enhanced with change map integration for modified dataset
    function renderRowBadges(recordId) {
      // v1.6.8: Check change map first for modified dataset
      var changeSummary = getRecordChangeSummary(recordId);
      if (changeSummary && changeSummary.total > 0) {
        var badges = [];
        var byType = changeSummary.by_type;
        var changes = getRecordChanges(recordId);
        
        var typeConfigs = [
          { key: 'correction', cls: 'badge-patch' },
          { key: 'rfi', cls: 'badge-sflogic' },
          { key: 'system_change', cls: 'badge-system' },
          { key: 'blacklist', cls: 'badge-blacklist' }
        ];
        
        typeConfigs.forEach(function(cfg) {
          if (!byType[cfg.key] || byType[cfg.key] <= 0) return;
          var fieldList = [];
          Object.keys(changes).forEach(function(fk) {
            if ((changes[fk].type || 'correction') === cfg.key) fieldList.push(fk);
          });
          var ttHtml = '<div class="patch-tooltip">';
          ttHtml += '<div class="patch-tooltip-title">' + byType[cfg.key] + ' ' + formatPatchKind(cfg.key) + (byType[cfg.key] !== 1 ? 's' : '') + '</div>';
          var displayFields = fieldList.slice(0, 5);
          displayFields.forEach(function(fk) {
            var chipClass = getPatchChipClass(cfg.key);
            ttHtml += '<div class="patch-tooltip-item"><span class="patch-tooltip-field">' + escapeHtml(fk) + '</span><span class="patch-chip ' + chipClass + '">' + formatPatchKind(cfg.key) + '</span></div>';
          });
          if (fieldList.length > 5) ttHtml += '<div class="patch-tooltip-item" style="color: #888; font-style: italic;">+' + (fieldList.length - 5) + ' more...</div>';
          ttHtml += '</div>';
          badges.push('<span class="row-badge ' + cfg.cls + '">' + byType[cfg.key] + ttHtml + '</span>');
        });
        
        return badges.length > 0 ? '<div class="row-badges">' + badges.join('') + '</div>' : '';
      }
      
      // Fallback to signal-based badges (for baseline dataset)
      var counts = getRowSignalCounts(recordId);
      if (!counts) return '';
      
      // v1.6.6: Build patch summary for tooltip
      var summary = getRecordPatchSummary(recordId);
      
      var badges = [];
      if (counts.PATCH_REQUIRED > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'correction');
        badges.push('<span class="row-badge badge-patch">' + counts.PATCH_REQUIRED + tooltip + '</span>');
      }
      if (counts.SALESFORCE_LOGIC > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'rfi');
        badges.push('<span class="row-badge badge-sflogic">' + counts.SALESFORCE_LOGIC + tooltip + '</span>');
      }
      if (counts.MANUAL_REVIEW > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'correction');
        badges.push('<span class="row-badge badge-manual">' + counts.MANUAL_REVIEW + tooltip + '</span>');
      }
      if (counts.SYSTEM_CHANGE > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'system_change');
        badges.push('<span class="row-badge badge-system">' + counts.SYSTEM_CHANGE + tooltip + '</span>');
      }
      
      return badges.length > 0 ? '<div class="row-badges">' + badges.join('') + '</div>' : '';
    }
    
    // v1.6.6: Build tooltip HTML for patch badge (filters by kind for specific badges)
    function buildPatchBadgeTooltip(summary, filterKind) {
      if (!summary || !summary.items || summary.items.length === 0) {
        return '<div class="patch-tooltip"><div class="patch-tooltip-title">No details</div></div>';
      }
      
      // Map signal categories to patch kinds for filtering
      var kindMatches = function(itemKind, targetKind) {
        if (targetKind === 'correction') return itemKind === 'correction';
        if (targetKind === 'rfi') return itemKind === 'rfi';
        if (targetKind === 'blacklist') return itemKind === 'blacklist';
        if (targetKind === 'system_change') return itemKind === 'system_change';
        return true; // show all if no filter
      };
      
      // Get unique fields for this badge type only
      var seenFields = {};
      var items = [];
      for (var i = 0; i < summary.items.length; i++) {
        var item = summary.items[i];
        // Filter by kind if specified
        if (filterKind && !kindMatches(item.patch_kind, filterKind)) continue;
        var fieldNorm = normalizeFieldKey(item.field_key);
        if (!seenFields[fieldNorm]) {
          seenFields[fieldNorm] = true;
          items.push(item);
        }
      }
      
      if (items.length === 0) {
        return '<div class="patch-tooltip"><div class="patch-tooltip-title">No details</div></div>';
      }
      
      // Limit to first 5 fields to keep tooltip readable
      var displayItems = items.slice(0, 5);
      var hasMore = items.length > 5;
      
      var html = '<div class="patch-tooltip">';
      html += '<div class="patch-tooltip-title">' + items.length + ' ' + formatPatchKind(filterKind || 'patch') + (items.length !== 1 ? 's' : '') + '</div>';
      
      for (var j = 0; j < displayItems.length; j++) {
        var item = displayItems[j];
        var chipClass = getPatchChipClass(item.patch_kind);
        var sourceLabel = item.source === 'legacy_diff_import' ? ' (legacy)' : '';
        html += '<div class="patch-tooltip-item">';
        html += '<span class="patch-tooltip-field">' + escapeHtml(item.field_key) + '</span>';
        html += '<span class="patch-chip ' + chipClass + '">' + formatPatchKind(item.patch_kind) + sourceLabel + '</span>';
        html += '</div>';
      }
      
      if (hasMore) {
        html += '<div class="patch-tooltip-item" style="color: #888; font-style: italic;">+' + (items.length - 5) + ' more...</div>';
      }
      
      html += '</div>';
      return html;
    }
    
    // v1.6.2: Get cell style for grid coloring
    // v1.6.8: Enhanced with change map highlighting for modified dataset
    // v1.6.18: Updated to pass record for key fallback
    function getGridCellStyle(recordId, fieldKey, record) {
      var normKey = normalizeFieldKey(fieldKey);
      
      // v1.6.8: Check change map first (for modified dataset)
      var changeInfo = getCellChangeInfo(recordId, fieldKey, record);
      if (changeInfo) {
        var changeStyle = CHANGE_TYPE_STYLES[changeInfo.type];
        if (changeStyle) {
          return 'background: ' + changeStyle.bg + '; border-left: 3px solid ' + changeStyle.border + ';';
        }
      }
      
      // Fallback to signal-based styling
      var style = getCellHighestPriorityStyle(recordId, normKey);
      if (!style || style.priority >= 5) return ''; // CLEAN cells get no extra coloring
      return 'background: ' + style.bg + ';';
    }
    
    // ========================================================================
    // END SIGNAL ENGINE
    // ========================================================================
    
    // ========================================================================
    // v1.6.6: PATCH SUMMARY ENGINE
    // ========================================================================
    
    // Store for per-record patch summaries
    var recordPatchSummaryStore = {};
    
    // Build patch summary for a record from signals
    function buildPatchSummaryForRecord(recordId) {
      var recordSignals = signalStore.signals_by_cell[recordId];
      if (!recordSignals) return null;
      
      var items = [];
      var fieldKeys = Object.keys(recordSignals);
      
      for (var i = 0; i < fieldKeys.length; i++) {
        var fieldKey = fieldKeys[i];
        var signals = recordSignals[fieldKey];
        
        for (var j = 0; j < signals.length; j++) {
          var sig = signals[j];
          var patchKind = 'correction';  // default
          var source = 'system_rule';
          var reasonCategory = sig.signal_type || 'unknown';
          // Determine patch_kind from signal type
          if (sig.signal_type === 'SYSTEM_CHANGE' || reasonCategory.indexOf('system') >= 0) {
            patchKind = 'system_change';
            source = 'system_rule';
          } else if (sig.signal_type === 'QA_FLAG' || reasonCategory.indexOf('qa') >= 0) {
            patchKind = 'rfi';
            source = 'qa_flag';
          } else if (sig.signal_type === 'BLACKLIST' || reasonCategory.indexOf('blacklist') >= 0) {
            patchKind = 'blacklist';
            source = 'system_rule';
          } else if (sig.signal_type === 'PICKLIST_INVALID' || sig.signal_type === 'MISSING_REQUIRED') {
            patchKind = 'correction';
            source = 'field_meta';
          } else if (sig.signal_type === 'LEGACY_DIFF' || reasonCategory.indexOf('legacy') >= 0) {
            patchKind = 'correction';
            source = 'legacy_diff_import';
          }
          items.push({
            field_key: fieldKey,
            patch_kind: patchKind,
            reason_category: reasonCategory,
            source: source,
            severity: sig.severity || 'info'
          });
        }
      }
      
      if (items.length === 0) return null;
      
      var summary = {
        record_id: recordId,
        total_count: items.length,
        items: items
      };
      
      recordPatchSummaryStore[recordId] = summary;
      return summary;
    }
    
    // Get or build patch summary for record
    function getRecordPatchSummary(recordId) {
      if (recordPatchSummaryStore[recordId]) {
        return recordPatchSummaryStore[recordId];
      }
      return buildPatchSummaryForRecord(recordId);
    }
    
    // Get patch summary item for a specific field
    // v1.6.8: Enhanced to use change map first (for modified dataset)
    function getFieldPatchInfo(recordId, fieldKey) {
      // v1.6.8: Check change map first (takes precedence for modified dataset)
      var changeInfo = getCellChangeInfo(recordId, fieldKey);
      if (changeInfo) {
        return {
          field_key: fieldKey,
          patch_kind: changeInfo.type,
          source: changeInfo.source,
          reason: changeInfo.reason || changeInfo.summary || '',
          actor: changeInfo.actor
        };
      }
      
      // Fallback to signal-based patch summary
      var summary = getRecordPatchSummary(recordId);
      if (!summary) return null;
      
      var normKey = normalizeFieldKey(fieldKey);
      for (var i = 0; i < summary.items.length; i++) {
        if (normalizeFieldKey(summary.items[i].field_key) === normKey) {
          return summary.items[i];
        }
      }
      return null;
    }
    
    // Format patch kind for display
    function formatPatchKind(kind) {
      var labels = {
        'correction': 'Correction',
        'rfi': 'RFI',
        'blacklist': 'Blacklist',
        'system_change': 'System Change'
      };
      return labels[kind] || kind;
    }
    
    // Get CSS class for patch chip
    function getPatchChipClass(kind) {
      var classes = {
        'correction': 'patch-chip-correction',
        'rfi': 'patch-chip-rfi',
        'blacklist': 'patch-chip-blacklist',
        'system_change': 'patch-chip-system'
      };
      return classes[kind] || 'patch-chip-correction';
    }
    
    // v1.6.6: Auto-scroll to first patch field in Field Inspector
    function srrScrollToFirstPatchField() {
      var container = document.getElementById('srr-field-list');
      if (!container) return;
      
      // Find first field card with has-patch class
      var firstPatchField = container.querySelector('.srr-field-card.has-patch');
      if (firstPatchField) {
        // Scroll smoothly into view
        firstPatchField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Briefly highlight with pulse
        firstPatchField.style.transition = 'box-shadow 0.3s ease';
        firstPatchField.style.boxShadow = '0 0 12px rgba(21, 101, 192, 0.5)';
        setTimeout(function() {
          firstPatchField.style.boxShadow = '';
        }, 1500);
        console.log('[SRR] Auto-scrolled to first patch field:', firstPatchField.dataset.field);
      }
    }
    
    // ========================================================================
    // END PATCH SUMMARY ENGINE
    // ========================================================================
    
    // Stub field groups (legacy - now derived from hinge_groups.json)
    var SRR_FIELD_GROUPS = {
      'identity': ['contract_key', 'file_name', 'file_url'],
      'metadata': ['artist', 'label', 'subtype'],
      'status': ['status', 'notes']
    };
    
    // Stub required fields (schema stub)
    var SRR_REQUIRED_FIELDS = ['contract_key', 'status'];
    
    // v1.6.60: Internal marker fields — single source of truth (normalized keys)
    var SRR_INTERNAL_FIELDS = [
      'contract_key', 'file_name', 'file_url', 'record_id', 'sheet', 'status',
      'dataset_id', 'group_id', 'document_role', 'document_type', 'capabilities'
    ];

    // v1.6.5: Hidden fields - not shown in Field Inspector (analyst view)
    var SRR_HIDDEN_FIELDS = [
      'File_Name_c', 'File_URL_c',
      'Change_Count', 'System_Change_Count', 'User_Change_Count',
      'Row_Complete', 'Row_Verified'
    ];
    
    // v1.6.5: Pattern-based hidden field matching (for variations)
    var SRR_HIDDEN_PATTERNS = [
      'change count', 'system change', 'user change', 
      'row complete', 'row verified'
    ];
    
    // v1.6.60: Check if a field is an internal marker (normalized comparison)
    function isInternalField(fieldKey) {
      if (!fieldKey) return false;
      var norm = fieldKey.toLowerCase().replace(/[^a-z0-9]/g, '');
      return SRR_INTERNAL_FIELDS.some(function(f) {
        return f.toLowerCase().replace(/[^a-z0-9]/g, '') === norm;
      });
    }

    // v1.6.5: Check if a field should be hidden from analyst view
    function isHiddenField(fieldKey) {
      if (!fieldKey) return false;
      if (isInternalField(fieldKey)) return true;
      if (SRR_HIDDEN_FIELDS.indexOf(fieldKey) >= 0) return true;
      var keyLower = fieldKey.toLowerCase().replace(/_/g, ' ');
      return SRR_HIDDEN_PATTERNS.some(function(pattern) {
        return keyLower.indexOf(pattern) >= 0;
      });
    }

    // v1.4.15: Get active sheet name from grid state or sidebar
    function getActiveSheetName() {
      // Priority: gridState.sheet (set by sheet selector) > workbook first sheet
      if (typeof gridState !== 'undefined' && gridState.sheet) {
        return gridState.sheet;
      }
      // Fallback to sidebar selector if available
      var sidebarSelector = document.getElementById('sidebar-sheet-selector');
      if (sidebarSelector && sidebarSelector.value) {
        return sidebarSelector.value;
      }
      // Last resort: first sheet in workbook
      if (workbook.order.length > 0) {
        return workbook.order[0];
      }
      return null;
    }

    // v1.4.15: Resolve record from workbook using explicit sheetName and recordIndex
    // Signature: openRowReviewDrawer(sheetName, recordIndex)
    // Backwards compat: openRowReviewDrawer(rowId) for legacy callers
    // v1.4.16: Fixed rowId/undefined bug - always define rowId consistently

    // ========================================================================
    // V2.3b: Section Guidance + Knowledge Rail
    // ========================================================================
    var _sectionGuidanceConfig = null;
    var _knowledgeLinksConfig = null;
    var _guidanceCardExpanded = null;

    function loadSectionGuidanceConfig() {
      if (_sectionGuidanceConfig) return Promise.resolve(_sectionGuidanceConfig);
      return fetch('/config/section_guidance.json')
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(data) { _sectionGuidanceConfig = data; return data; })
        .catch(function() { _sectionGuidanceConfig = null; return null; });
    }

    function loadKnowledgeLinksConfig() {
      if (_knowledgeLinksConfig) return Promise.resolve(_knowledgeLinksConfig);
      return fetch('/config/knowledge_links.json')
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(data) { _knowledgeLinksConfig = data; return data; })
        .catch(function() { _knowledgeLinksConfig = null; return null; });
    }

    function srrRefreshGuidanceAndRail(record) {
      Promise.all([
        typeof loadSectionGuidanceConfig === 'function' ? loadSectionGuidanceConfig() : Promise.resolve(null),
        typeof loadKnowledgeLinksConfig === 'function' ? loadKnowledgeLinksConfig() : Promise.resolve(null)
      ]).then(function() {
        var existingCard = document.getElementById('section-guidance-card');
        if (existingCard) existingCard.remove();
        var existingRail = document.querySelector('.knowledge-rail');
        if (existingRail) existingRail.remove();
        if (record && typeof renderSectionGuidanceCard === 'function') {
          var srrFieldList = document.getElementById('srr-field-list');
          if (srrFieldList) renderSectionGuidanceCard(record, srrFieldList);
        }
        if (typeof renderKnowledgeRail === 'function') {
          var rightPanel = document.querySelector('.srr-panel-right .srr-panel-body') || document.getElementById('srr-tab-fields');
          if (rightPanel) renderKnowledgeRail(rightPanel);
        }
      });
    }

        function getSectionGuidance(docRole, docType, sheetName) {
      if (!_sectionGuidanceConfig || !_sectionGuidanceConfig.guidance) return null;
      var g = _sectionGuidanceConfig.guidance;
      if (sheetName && g[sheetName]) {
        console.log('[P0.9-CLEANUP] guidance_section_resolved:' + sheetName);
        return g[sheetName];
      }
      var sheetNorm = sheetName ? sheetName.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '') : '';
      var gKeys = Object.keys(g);
      for (var gi = 0; gi < gKeys.length; gi++) {
        var gkNorm = gKeys[gi].toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
        if (sheetNorm && gkNorm === sheetNorm) {
          console.log('[P0.9-CLEANUP] guidance_section_resolved:' + gKeys[gi] + ' (normalized)');
          return g[gKeys[gi]];
        }
      }
      var key1 = (docRole || '') + '::' + (docType || '');
      var key2 = docRole || '';
      if (g[key1]) { console.log('[P0.9-CLEANUP] guidance_section_resolved:' + key1); return g[key1]; }
      if (g[key2]) { console.log('[P0.9-CLEANUP] guidance_section_resolved:' + key2); return g[key2]; }
      if (g['default']) { console.log('[P0.9-CLEANUP] guidance_fallback_used'); return g['default']; }
      console.log('[P0.9-CLEANUP] guidance_fallback_used (no match)');
      return null;
    }

    function renderSectionGuidanceCard(record, container) {
      if (!container || !_sectionGuidanceConfig) return;
      var docRole = record._document_role || record.document_role || '';
      var docType = record._document_type || record.document_type || '';
      var confidence = record._confidence || record.confidence || null;
      var _sheetName = (typeof srrState !== 'undefined' && srrState.currentSheetName) ? srrState.currentSheetName : '';
      var guidance = getSectionGuidance(docRole, docType, _sheetName);
      if (!guidance) return;

      if (_guidanceCardExpanded === null) {
        var pref = localStorage.getItem('guidance_card_expanded');
        _guidanceCardExpanded = pref === null ? true : pref === 'true';
      }

      var expanded = _guidanceCardExpanded;
      var html = '<div id="section-guidance-card" class="section-guidance-card" style="margin-bottom: 16px; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; background: #fafbff;">';
      var _sheetLabel = (typeof srrState !== 'undefined' && srrState.currentSheetName) ? srrState.currentSheetName.replace(/_/g, ' ') : '';
      var guidanceTitle = guidance._section_label || guidance.label || (_sheetLabel ? _sheetLabel + ' Guidance' : 'Section Guidance');
      html += '<div class="section-guidance-toggle" onclick="toggleGuidanceCard()" style="padding: 10px 14px; background: #f0f4ff; display: flex; justify-content: space-between; align-items: center; border-bottom: ' + (expanded ? '1px solid #e0e0e0' : 'none') + ';">';
      html += '<div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">';
      html += '<span style="font-size: 1.1em;">\u{1F4D6}</span>';
      html += '<span style="font-weight: 600; font-size: 0.85em; color: #333;">' + guidanceTitle + '</span>';
      var _safeRole = (docRole && docRole.toLowerCase() !== 'unknown') ? docRole : '';
      var _safeType = (docType && docType.toLowerCase() !== 'unknown') ? docType : '';
      if (!_safeRole && !_safeType && _sheetLabel) {
        _safeRole = _sheetLabel;
      }
      if (_safeRole) html += '<span style="padding: 2px 8px; background: #e8eaf6; color: #3949ab; border-radius: 10px; font-size: 0.75em;">' + _safeRole + '</span>';
      if (_safeType) html += '<span style="padding: 2px 8px; background: #e0f2f1; color: #00695c; border-radius: 10px; font-size: 0.75em;">' + _safeType + '</span>';
      console.log('[P0.9-CLEANUP] guidance_labels_resolved: role=' + _safeRole + ', type=' + _safeType + ', sheet=' + (_sheetLabel || ''));
      if (confidence) {
        var confColor = confidence >= 0.8 ? '#2e7d32' : confidence >= 0.6 ? '#e65100' : '#c62828';
        html += '<span style="padding: 2px 8px; background: ' + confColor + '18; color: ' + confColor + '; border-radius: 10px; font-size: 0.75em;">' + Math.round(confidence * 100) + '% conf</span>';
      }
      html += '</div>';
      html += '<span style="font-size: 0.8em; color: #999;" id="guidance-card-chevron">' + (expanded ? '\u25B2' : '\u25BC') + '</span>';
      html += '</div>';

      html += '<div id="guidance-card-body" style="' + (expanded ? '' : 'display: none;') + ' padding: 14px;">';
      html += '<div style="font-size: 0.9em; font-weight: 600; color: #333; margin-bottom: 10px;">' + (guidance.section_label || 'General Review') + '</div>';

      if (guidance.what_to_look_for && guidance.what_to_look_for.length > 0) {
        html += '<div style="margin-bottom: 10px;">';
        html += '<div style="font-size: 0.78em; font-weight: 600; color: #1565c0; margin-bottom: 4px;">What to look for:</div>';
        html += '<ul style="margin: 0; padding-left: 18px; font-size: 0.8em; color: #444; line-height: 1.7;">';
        guidance.what_to_look_for.forEach(function(item) { html += '<li>' + item + '</li>'; });
        html += '</ul></div>';
      }

      if (guidance.common_failure_modes && guidance.common_failure_modes.length > 0) {
        html += '<div>';
        html += '<div style="font-size: 0.78em; font-weight: 600; color: #c62828; margin-bottom: 4px;">Common failure modes:</div>';
        html += '<ul style="margin: 0; padding-left: 18px; font-size: 0.8em; color: #666; line-height: 1.7;">';
        guidance.common_failure_modes.forEach(function(item) { html += '<li>' + item + '</li>'; });
        html += '</ul></div>';
      }

      html += '</div></div>';
      container.insertAdjacentHTML('afterbegin', html);
    }

    function toggleGuidanceCard() {
      var body = document.getElementById('guidance-card-body');
      var chevron = document.getElementById('guidance-card-chevron');
      if (!body) return;
      var isVisible = body.style.display !== 'none';
      body.style.display = isVisible ? 'none' : 'block';
      if (chevron) chevron.textContent = isVisible ? '\u25BC' : '\u25B2';
      _guidanceCardExpanded = !isVisible;
      localStorage.setItem('guidance_card_expanded', String(_guidanceCardExpanded));
    }

    function renderKnowledgeRail(container) {
      if (!container || !_knowledgeLinksConfig || !_knowledgeLinksConfig.links) return;
      var links = (_knowledgeLinksConfig.links || []).filter(function(l) { return l && l.url && l.url.indexOf('http') === 0 && l.label; })
        .filter(function(l) { return l.enabled && l.roles_allowed && l.roles_allowed.indexOf(currentMode) >= 0; })
        .sort(function(a, b) { return (a.order || 99) - (b.order || 99); });
      if (links.length === 0) return;

      var categories = {};
      links.forEach(function(l) {
        var cat = l.category || 'General';
        if (!categories[cat]) categories[cat] = [];
        categories[cat].push(l);
      });

      var html = '<div class="knowledge-rail" style="margin-top: 16px; border-top: 1px solid #e0e0e0; padding-top: 12px;">';
      html += '<div style="display: flex; align-items: center; gap: 6px; margin-bottom: 10px;">';
      html += '<span style="font-size: 1em;">\u{1F4DA}</span>';
      html += '<span style="font-weight: 600; font-size: 0.85em; color: #333;">Knowledge</span>';
      html += '</div>';

      Object.keys(categories).forEach(function(cat) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<div style="font-size: 0.72em; font-weight: 600; color: #999; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">' + cat + '</div>';
        categories[cat].forEach(function(link) {
          html += '<a href="' + link.url + '" target="_blank" rel="noopener" onclick="emitKnowledgeLinkEvent(\'' + link.id + '\')" style="display: flex; align-items: center; gap: 6px; padding: 5px 8px; margin-bottom: 2px; font-size: 0.8em; color: #1565c0; text-decoration: none; border-radius: 4px; transition: background 0.15s;" onmouseover="this.style.background=\'#e3f2fd\'" onmouseout="this.style.background=\'transparent\'">';
          html += '<span>' + link.title + '</span>';
          html += '<svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; opacity: 0.5;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>';
          html += '</a>';
        });
        html += '</div>';
      });

      html += '</div>';
      container.insertAdjacentHTML('beforeend', html);
    }

    function emitKnowledgeLinkEvent(linkId) {
      if (typeof AuditTimeline !== 'undefined') {
        var context = {};
        if (typeof srrState !== 'undefined' && srrState.currentRowId !== null) context.record_id = srrState.currentRowId;
        if (typeof srrState !== 'undefined' && srrState.currentSheetName) context.sheet = srrState.currentSheetName;
        AuditTimeline.emit('knowledge_link_opened', {
          metadata: { link_id: linkId, actor_role: currentMode, page_context: context }
        });
      }
    }

    function openRowReviewDrawer(arg1, arg2) {
        console.log('[T0:GUARD] openRowReviewDrawer called, args:', typeof arg1, typeof arg2);
        var _t0_guard = { triggered_download: false, srr_opened: false };
      // v1.5.3 Fix: Determine read-only mode based on current role at render time
      // Analyst mode: always editable (isReadOnly = false)
      // Verifier/Admin mode WITH artifact context: read-only (isReadOnly = true)
      // Verifier/Admin mode WITHOUT artifact context (direct grid nav): still read-only for field inspector
      if (currentMode === 'analyst' || currentMode === 'admin') {
        srrState.isReadOnly = false;
        srrState.verifierMode = false;
      } else if (currentMode === 'verifier') {
        srrState.isReadOnly = true;
      } else {
        srrState.isReadOnly = false;
      }
      
      var record = null;
      var sheetName = null;
      var rowIndex = -1;
      var rowId = null;  // v1.4.16: Always define rowId
      
      // v1.4.15: New signature (sheetName, recordIndex) from grid click handlers
      if (typeof arg1 === 'string' && typeof arg2 === 'number') {
        sheetName = arg1;
        rowIndex = arg2;
        rowId = rowIndex;  // v1.4.16: Use rowIndex as rowId for new signature
        
        var sheet = workbook.sheets[sheetName];
        if (sheet && sheet.rows && rowIndex >= 0 && rowIndex < sheet.rows.length) {
          record = sheet.rows[rowIndex];
        }
        
        if (!record) {
          // Log failure with diagnostic context
          console.log('[SRR_OPEN_FAIL]', JSON.stringify({
            sheetName: sheetName,
            recordIndex: rowIndex,
            availableSheets: workbook.order,
            sheetRowCount: sheet ? (sheet.rows ? sheet.rows.length : 0) : 0
          }));
          showToast('Record not found: ' + sheetName + '[' + rowIndex + ']', 'warning');
          return;
        }
      } else {
        // Legacy signature: openRowReviewDrawer(rowId) - for backwards compatibility
        rowId = arg1;  // v1.4.16: Use existing rowId variable (no redeclaration)
        rowIndex = parseInt(rowId, 10);
        
        if (workbook.order.length > 0) {
          sheetName = getActiveSheetName();
          if (!sheetName) {
            showToast('No active section selected', 'warning');
            return;
          }
          var sheet = workbook.sheets[sheetName];
          if (sheet && sheet.rows) {
            var foundIdx = sheet.rows.findIndex(function(r) {
              return String(r.contract_key) === String(rowId);
            });
            
            if (foundIdx >= 0) {
              record = sheet.rows[foundIdx];
              rowIndex = foundIdx;
            } else if (!isNaN(rowIndex) && rowIndex >= 0 && rowIndex < sheet.rows.length) {
              record = sheet.rows[rowIndex];
            }
          }
        } else {
          var ds = getGridDataset();
          if (ds && ds.sf_contract_results) {
            record = ds.sf_contract_results.find(function(r) {
              return String(r.contract_key) === String(rowId);
            });
            if (!record && !isNaN(rowIndex) && rowIndex >= 0 && rowIndex < ds.sf_contract_results.length) {
              record = ds.sf_contract_results[rowIndex];
            }
            sheetName = record ? (record.sheet || 'unknown') : 'unknown';
          }
        }
      }
      
      if (!record) {
        console.log('[SRR_OPEN_FAIL] Record resolution failed:', { arg1: arg1, arg2: arg2, sheetName: sheetName, rowIndex: rowIndex });
        showToast('Record not found', 'warning');
        return;
      }
      
      // Build record identity for logging/caching
      var recordKey = record.contract_key || (sheetName + ':' + rowIndex);
      
      // Store in state with extended context
      srrState.currentRecord = record;
      srrState.currentRowId = rowId;
      srrState.currentSheetName = sheetName;
      srrState.currentRowIndex = rowIndex;
      srrState.currentRecordKey = recordKey;

      srrBuildAccountSelector(record);

      if (currentMode === 'analyst') {
        _srrCollapsePatchPanel();
      }

      updateInspectorActionsState();
      if (typeof updateSrrGroupBadge === 'function') updateSrrGroupBadge();
      
      // v1.4.15: Single structured log per SRR open (use field resolver for Salesforce-style columns)
      var fileUrl = srrResolveFieldValue(record, 'file_url');
      var fileName = srrResolveFieldValue(record, 'file_name');
      console.log('[SRR_OPEN]', JSON.stringify({
        sheetName: sheetName,
        rowIndex: rowIndex,
        recordKey: recordKey,
        file_name: fileName,
        file_url: fileUrl.length > 60 ? fileUrl.substring(0, 60) + '...' : fileUrl,
        availableKeys: Object.keys(record).slice(0, 8)
      }));
      
      // v1.4.16: Validate rowId before navigation (prevent row/undefined)
      if (rowId === null || rowId === undefined || (typeof rowId === 'number' && isNaN(rowId))) {
        console.warn('[SRR] Invalid rowId, using rowIndex:', rowIndex);
        rowId = rowIndex;
      }
      
      // Navigate to page and render
      navigateTo('row');
      renderSingleRowReview(record, rowId);
      
      // Update URL without triggering hashchange loop
      var hashTarget = '#/row/' + rowId;
      if (window.location.hash !== hashTarget) {
        history.pushState(null, '', hashTarget);
      }
    }
    
    function renderSingleRowReview(record, rowId) {
      // Update top bar
      var _recName = _srrResolveRecordName(record);
      document.getElementById('srr-record-id').textContent = _recName || '—';
      document.getElementById('srr-record-id').title = record.contract_key || rowId || '';
      var stateBadge = document.getElementById('srr-state-badge');
      var status = (record.status || 'unknown').toLowerCase().replace(/\s+/g, '_');
      stateBadge.textContent = record.status || 'Unknown';
      stateBadge.className = 'srr-state-badge ' + status;
      
      // Resolve file info for action bar
      var fileName = srrResolveFieldValue(record, 'file_name');
      var fileUrl = srrResolveFieldValue(record, 'file_url');
      
      // v1.6.55: Show record name in page title
      var titleRecordNameEl = document.getElementById('srr-title-record-name');
      if (titleRecordNameEl) {
        if (_recName && _recName.length > 0) {
          var displayName = _recName.length > 60 ? _recName.substring(0, 57) + '...' : _recName;
          titleRecordNameEl.textContent = ' — ' + displayName;
          titleRecordNameEl.title = _recName;
        } else {
          titleRecordNameEl.textContent = '';
          titleRecordNameEl.title = '';
        }
      }
      
      // v1.6.54: Update file action bar
      srrUpdateFileActionBar(fileName, fileUrl);
      
      // Store original values for edit tracking
      srrState.originalValues = {};
      Object.keys(record).forEach(function(k) {
        if (!k.startsWith('_')) {
          srrState.originalValues[k] = record[k];
        }
      });
      
      // Reset edit state for new record
      srrState.editedValues = {};
      srrState.proposedChanges = {};
      srrState.lockedFields = {};  // v1.4.18: Reset locked fields
      srrState.editingField = null;
      srrState.activeFilter = 'todo';  // Default to To Do queue
      srrUpdateNavButtons();
      srrPopulateDocTypeDropdown(record);

      // V2.3b: Render section guidance card and knowledge rail (deterministic)
      srrRefreshGuidanceAndRail(record);

      srrState.activeGroup = 'all';
      srrState.searchQuery = '';  // v1.4.18: Reset search
      
      // Reset filter chips - default to To Do
      document.querySelectorAll('.srr-filter-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.filter === 'todo') chip.classList.add('active');
      });
      
      // v1.4.18: Reset search input
      var searchInput = document.getElementById('srr-field-search');
      if (searchInput) searchInput.value = '';
      
      // Render Field Inspector
      renderSrrFields(record);
      
      // v1.6.6: Auto-scroll to first patch field if any
      setTimeout(function() {
        srrScrollToFirstPatchField();
      }, 100);
      
      // v1.4.19: Reset patch type and override state
      srrState.patchType = srrState.patchDraft.patch_type || 'correction';
      srrState.overrideEnabled = srrState.patchDraft.override_enabled || false;
      
      // Update patch type chips
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === srrState.patchType) chip.classList.add('active');
      });
      var overrideToggle = document.getElementById('srr-override-toggle');
      if (overrideToggle) overrideToggle.classList.toggle('active', srrState.overrideEnabled);
      
      // v1.4.19: Load Evidence Pack (simplified structure)
      document.getElementById('srr-observation-type').value = srrState.patchDraft.observation_type || '';
      document.getElementById('srr-expected-type').value = srrState.patchDraft.expected_type || '';
      document.getElementById('srr-justification').value = srrState.patchDraft.justification || '';
      document.getElementById('srr-repro-type').value = srrState.patchDraft.repro_type || '';
      if (document.getElementById('srr-replay-type')) document.getElementById('srr-replay-type').value = srrState.patchDraft.replay_type || '';
      if (document.getElementById('srr-replay-steps')) document.getElementById('srr-replay-steps').value = srrState.patchDraft.replay_steps || '';
      if (document.getElementById('srr-replay-expected-result')) document.getElementById('srr-replay-expected-result').value = srrState.patchDraft.replay_expected_result || '';
      // RFI target stub - no input to restore (coming soon)
      
      // v1.4.18: Render Fields panel
      srrRenderPatchEditor();
      
      // v1.4.19: Update form sections based on patch type
      srrUpdatePatchFormSections();
      
      // Load PDF for this record (v1.4.10)
      srrLoadPdfForRecord(record);
      
      // v1.5.3: Initialize Verifier SRR mode if applicable
      if (srrState.verifierMode) {
        initVerifierSRRMode();
      }
    }
    
    function renderSrrFields(record) {
      var container = document.getElementById('srr-field-list');
      if (!record) {
        container.innerHTML = '<div class="srr-empty-state">No fields loaded</div>';
        document.getElementById('srr-field-count').textContent = '0 fields';
        return;
      }
      
      // v1.5.7: Use rules_bundle for ordering if loaded, else fallback to legacy schema-based order
      var sheetName = srrState.currentSheetName || 'Accounts';
      var ordering;
      
      if (rulesBundleCache.loaded) {
        ordering = orderFieldsForInspector(record, sheetName);
      } else {
        // Legacy fallback: schema order first, then unknown fields alphabetically
        var allRecordKeys = Object.keys(record).filter(function(k) { return !k.startsWith('_'); });
        var schemaKeys = [];
        var unknownKeys = [];
        allRecordKeys.forEach(function(k) {
          if (SRR_SCHEMA_ORDER.indexOf(k) >= 0) {
            schemaKeys.push(k);
          } else {
            unknownKeys.push(k);
          }
        });
        schemaKeys.sort(function(a, b) {
          return SRR_SCHEMA_ORDER.indexOf(a) - SRR_SCHEMA_ORDER.indexOf(b);
        });
        unknownKeys.sort();
        var legacyKeys = schemaKeys.concat(unknownKeys);
        ordering = { groups: [{ name: null, fields: legacyKeys }], orderedKeys: legacyKeys };
      }
      
      // Get all keys from groups for filtering
      var allKeys = [];
      ordering.groups.forEach(function(g) { allKeys = allKeys.concat(g.fields); });
      
      // v1.6.5: Filter out hidden fields (File_Name_c shown in header, File_URL_c internal, metrics hidden)
      allKeys = allKeys.filter(function(k) { return !isHiddenField(k); });
      
      // v1.4.18: Apply search filter to orderedKeys
      var filteredKeys = allKeys;
      if (srrState.searchQuery) {
        var query = srrState.searchQuery.toLowerCase();
        filteredKeys = allKeys.filter(function(k) {
          var val = srrState.editedValues.hasOwnProperty(k) ? srrState.editedValues[k] : srrState.originalValues[k];
          var valStr = val ? String(val).toLowerCase() : '';
          return k.toLowerCase().indexOf(query) >= 0 || valStr.indexOf(query) >= 0;
        });
      }
      
      // Apply field state filter - verified/submitted hidden from To Do by default
      filteredKeys = filteredKeys.filter(function(k) {
        var state = srrState.fieldStates[k] || 'todo';
        
        if (srrState.activeFilter === 'all') return true;
        if (srrState.activeFilter === 'todo') {
          return state === 'todo' || state === 'modified' || state === 'rfi_pending';
        }
        if (srrState.activeFilter === 'verified') return state === 'verified';
        if (srrState.activeFilter === 'rfi') return state === 'rfi' || state === 'rfi_pending';
        if (srrState.activeFilter === 'patched') return state === 'patched' || state === 'submitted';
        if (srrState.activeFilter === 'blocked') return state === 'blocked';
        return true;
      });
      
      // Create a Set for O(1) lookup of filtered keys
      var filteredSet = {};
      filteredKeys.forEach(function(k) { filteredSet[k] = true; });
      
      // v1.4.20: Update filter chip counts
      srrUpdateFilterCounts();
      
      document.getElementById('srr-field-count').textContent = filteredKeys.length + ' fields';
      
      // v1.5.7: Build HTML with group headers using hinge-based ordering
      // Helper function to render a single field card
      function srrBuildInlineSelect(fieldKey, currentVal, options, isInvalid, isLocked) {
        var valStr = String(currentVal || '').trim();
        var valLower = valStr.toLowerCase();
        var foundCurrent = false;
        var html = '<select class="srr-inline-select' + (isInvalid ? ' invalid' : '') + '" ' +
          'data-field="' + fieldKey + '" ' +
          (isLocked ? 'disabled ' : '') +
          'onchange="srrInlineSelectChange(this)">';
        html += '<option value=""' + (!valStr ? ' selected' : '') + '>-- Select --</option>';
        options.forEach(function(opt) {
          var optStr = String(opt).trim();
          var sel = optStr.toLowerCase() === valLower;
          if (sel) foundCurrent = true;
          html += '<option value="' + optStr.replace(/"/g, '&quot;') + '"' + (sel ? ' selected' : '') + '>' + optStr + '</option>';
        });
        if (valStr && !foundCurrent) {
          html += '<option value="' + valStr.replace(/"/g, '&quot;') + '" selected class="invalid-opt">' + valStr + '</option>';
        }
        html += '</select>';
        return html;
      }

      function srrInlineSelectChange(selectEl) {
        var fieldKey = selectEl.getAttribute('data-field');
        if (!fieldKey) return;
        var newValue = selectEl.value;
        srrPeSelectField(fieldKey, fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }));
        srrCommitEdit(fieldKey, newValue);
      }

      function renderFieldCard(key) {
        var originalVal = srrState.originalValues[key];
        var currentVal = srrState.editedValues.hasOwnProperty(key) ? srrState.editedValues[key] : originalVal;
        if (currentVal === null || currentVal === undefined) currentVal = '';
        if (typeof currentVal === 'object') currentVal = JSON.stringify(currentVal);
        
        var isEdited = srrState.editedValues.hasOwnProperty(key);
        var isLocked = srrState.lockedFields.hasOwnProperty(key);  // v1.4.18: locked after commit
        var change = srrState.proposedChanges[key];
        var isRequired = SRR_REQUIRED_FIELDS.indexOf(key) >= 0;
        var fieldState = srrState.fieldStates[key] || 'todo';  // v1.4.20: field state
        
        // Build badges based on field state (exact labels per spec)
        var chips = '';
        if (fieldState === 'verified') {
          chips += '<span class="srr-chip srr-chip-verified">Verified</span>';
        } else if (fieldState === 'modified') {
          chips += '<span class="srr-chip srr-chip-modified">Modified</span>';
        } else if (fieldState === 'submitted') {
          chips += '<span class="srr-chip srr-chip-submitted">Patch Submitted</span>';
        } else if (fieldState === 'rfi' || fieldState === 'rfi_pending') {
          chips += '<span class="srr-chip srr-chip-rfi">RFI</span>';
        } else if (fieldState === 'blocked') {
          chips += '<span class="srr-chip srr-chip-blocked">Blocked</span>';
        }
        // No badge for 'todo' (default state)

        
        // v1.6.7: Human-friendly label (convert snake_case to Title Case, remove trailing _c suffix)
        var label = key
          .replace(/_c$/i, '')  // Remove trailing _c (Salesforce suffix)
          .replace(/_/g, ' ')   // Convert underscores to spaces
          .replace(/\b\w/g, function(l) { return l.toUpperCase(); })  // Title case
          .trim();
        
        // v1.6.10: Get picklist metadata for dropdown rendering
        var fieldMeta = getFieldMeta(srrState.currentSheet || 'Accounts', key);
        var isPicklistField = fieldMeta && fieldMeta.picklist === true && fieldMeta.options && fieldMeta.options.length > 0;
        var picklistOptions = isPicklistField ? fieldMeta.options : [];
        
        // v1.6.10: Check if current value is valid for picklist
        var isInvalidPicklistValue = false;
        if (isPicklistField && currentVal) {
          var valLower = String(currentVal).trim().toLowerCase();
          var emptyLikeValues = ['', 'n/a', 'null', 'none', '-'];
          if (emptyLikeValues.indexOf(valLower) < 0) {
            isInvalidPicklistValue = !picklistOptions.some(function(opt) {
              return String(opt).trim().toLowerCase() === valLower;
            });
          }
        }
        
        var labelSuffix = '';
        var fieldSignalLevel = '';

        var recordId = srrState.currentRecord ? ((srrState.currentRecord._identity && srrState.currentRecord._identity.record_id) || srrState.currentRecord.record_id || '') : '';
        var fieldSignals = (recordId && typeof signalStore !== 'undefined' && signalStore.signals_by_cell && signalStore.signals_by_cell[recordId] && signalStore.signals_by_cell[recordId][key]) ? signalStore.signals_by_cell[recordId][key] : [];
        var fieldSignalTips = [];
        for (var _si = 0; _si < fieldSignals.length; _si++) {
          var sig = fieldSignals[_si];
          if (sig.severity === 'error') fieldSignalLevel = 'error';
          else if (sig.severity === 'warning' && fieldSignalLevel !== 'error') fieldSignalLevel = 'warning';
          else if (!fieldSignalLevel) fieldSignalLevel = 'info';
          var sigTip = (sig.message || sig.signal_type.replace(/_/g, ' ')).replace(/"/g, '&quot;');
          fieldSignalTips.push(sigTip);
        }
        if (fieldSignals.length === 0 && isInvalidPicklistValue) {
          if (!fieldSignalLevel || fieldSignalLevel === 'info') fieldSignalLevel = 'warning';
          fieldSignalTips.push('Current value is not in the valid options list');
        }
        if (fieldMeta && fieldMeta.requiredness === 'required' && fieldState === 'todo' && !fieldSignalLevel) {
          var hasVal = currentVal && String(currentVal).trim() !== '';
          if (!hasVal) {
            fieldSignalLevel = 'error';
            fieldSignalTips.push('Required field is empty');
          }
        }
        
        // v1.6.36: Build glossary tooltip from field metadata
        var glossaryTooltipHtml = buildGlossaryTooltip(fieldMeta, key, srrState.currentSheet);
        
        // Add state-based classes (patched→submitted, rfi_pending→rfi for styling)
        var cardClass = 'srr-field-card';
        var displayState = fieldState === 'patched' ? 'submitted' : (fieldState === 'rfi_pending' ? 'rfi' : fieldState);
        if (displayState !== 'todo') cardClass += ' state-' + displayState;
        if (isLocked) cardClass += ' locked';
        if (srrState.selectedField === key) cardClass += ' active';
        if (isPicklistField) cardClass += ' is-picklist';
        if (isInvalidPicklistValue) cardClass += ' has-invalid-value';
        if (fieldSignalLevel && displayState === 'todo') cardClass += ' signal-' + fieldSignalLevel;
        
        // v1.6.6: Check for patch highlight
        var patchInfo = getFieldPatchInfo(srrState.currentRecordKey, key);
        var patchIndicatorHtml = '';
        if (patchInfo) {
          cardClass += ' has-patch';
          if (patchInfo.patch_kind === 'rfi') cardClass += ' patch-rfi';
          else if (patchInfo.patch_kind === 'blacklist') cardClass += ' patch-blacklist';
          else if (patchInfo.patch_kind === 'system_change') cardClass += ' patch-system';
          // Build inline patch chip
          var patchChipClass = patchInfo.patch_kind;
          var sourceLabel = patchInfo.source === 'legacy_diff_import' ? 'legacy' : '';
          patchIndicatorHtml = '<div class="field-patch-indicator">' +
            '<span class="field-patch-chip ' + patchChipClass + '">' + formatPatchKind(patchInfo.patch_kind) + '</span>' +
            (sourceLabel ? '<span class="field-patch-chip legacy">' + sourceLabel + '</span>' : '') +
          '</div>';
        }
        
        // v1.4.20: Build action buttons based on state
        // v1.4.20: Feather SVGs for field actions (order: Blacklist, RFI, Verify)
        var iconFlag = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" y1="22" x2="4" y2="15"/></svg>';
        var iconEdit = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/></svg>';
        var iconCheck = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
        var iconReset = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14l-4-4 4-4"/><path d="M5 10h11a4 4 0 110 8h-1"/></svg>';
        
        var actionsHtml = '<div class="srr-field-actions">';
        // v1.6.46: Analyst-only actions — Verifier/Admin see no SRR action buttons
        var isFieldActionable = !srrState.isReadOnly;
        
        if (isFieldActionable) {
          if (fieldState === 'todo') {
            actionsHtml += '<button class="srr-field-action blacklist" onclick="event.stopPropagation(); srrBlacklistField(\'' + key + '\')" title="Block this field">' + iconFlag + '</button>';
            actionsHtml += '<button class="srr-field-action rfi" onclick="event.stopPropagation(); srrRfiField(\'' + key + '\')" title="Request for Info">' + iconEdit + '</button>';
            actionsHtml += '<button class="srr-field-action verify" onclick="event.stopPropagation(); srrVerifyField(\'' + key + '\')" title="Verify (mark as correct)">' + iconCheck + '</button>';
          } else if (fieldState === 'modified') {
            // Modified: no action icons (user moved on after editing)
          } else if (fieldState === 'verified') {
            // Verified: read-only for verifiers, reset for analysts
            if (!srrState.isReadOnly) {
              actionsHtml += '<button class="srr-field-action reset" onclick="event.stopPropagation(); srrResetFieldState(\'' + key + '\')" title="Reset to TODO">' + iconReset + '</button>';
            }
          } else if (fieldState === 'submitted') {
            // Patch Submitted: no actions needed
          } else {
            // rfi, blocked, patched, rfi_pending: show reset
            actionsHtml += '<button class="srr-field-action reset" onclick="event.stopPropagation(); srrResetFieldState(\'' + key + '\')" title="Reset to TODO">' + iconReset + '</button>';
          }
        }
        actionsHtml += '</div>';
        
        var cardTitle = fieldSignalTips.length > 0 ? ' title="' + fieldSignalTips.join('; ').replace(/"/g, '&amp;quot;') + '"' : '';
        var cardHtml = '<div class="' + cardClass + '"' + cardTitle + ' data-field="' + key + '">' +
          '<div class="srr-field-card-header" onclick="srrSelectField(\'' + key + '\')">' +
            '<div style="flex:1;min-width:0;">' +
              '<div class="srr-field-card-label">' + label + labelSuffix + glossaryTooltipHtml + '</div>' +
              '<div class="srr-field-card-api">' + key + '</div>' +
              (chips || patchIndicatorHtml ? '<div class="srr-field-card-chips" style="margin-top:3px;">' + chips + patchIndicatorHtml + '</div>' : '') +
            '</div>' +
            actionsHtml +
          '</div>' +
          '<div class="srr-field-card-body">' +
            (isPicklistField ? srrBuildInlineSelect(key, currentVal, picklistOptions, isInvalidPicklistValue, isLocked) :
            '<div class="srr-field-value-display" onclick="srrStartEdit(\'' + key + '\')" title="Click to edit" data-is-picklist="false">' + 
              (String(currentVal) || '<span style="color:#999;font-style:italic;">Empty</span>') + 
            '</div>');
        
        // Show mini patch prompt if this field was just edited
        if (isEdited && srrState.editingField === key) {
          var existingJustification = change ? (change.justification || '') : '';
          var existingComment = change ? (change.comment || '') : '';
          var existingCategory = change ? (change.category || 'Correction') : 'Correction';
          cardHtml += '<div class="srr-mini-patch">' +
            '<div class="srr-mini-patch-label">Patch Details</div>' +
            '<select class="srr-patch-type" id="srr-patch-type-' + key + '" onchange="srrUpdateChangeCategory(\'' + key + '\', this.value)">' +
              '<option value="Correction"' + (existingCategory === 'Correction' ? ' selected' : '') + '>Correction</option>' +
              '<option value="Blacklist Flag"' + (existingCategory === 'Blacklist Flag' ? ' selected' : '') + '>Blacklist Flag</option>' +
              '<option value="RFI"' + (existingCategory === 'RFI' ? ' selected' : '') + '>RFI</option>' +
            '</select>' +
            '<input type="text" class="srr-mini-patch-input" id="srr-mini-just-' + key + '" placeholder="Justification (required)" value="' + existingJustification.replace(/"/g, '&quot;') + '">' +
            '<input type="text" class="srr-mini-patch-input" id="srr-mini-comment-' + key + '" placeholder="Comment (optional)" value="' + existingComment.replace(/"/g, '&quot;') + '">' +
            '<div class="srr-mini-patch-actions">' +
              '<button class="srr-mini-patch-btn undo" onclick="srrUndoChange(\'' + key + '\')">Undo Change</button>' +
              '<button class="srr-mini-patch-btn save" onclick="srrSaveMiniPatch(\'' + key + '\')">Save Patch Draft</button>' +
            '</div>' +
          '</div>';
        }
        
        cardHtml += '</div></div>';
        return cardHtml;
      }
      
      // v1.5.7: Build HTML with group headers
      var html = '';
      ordering.groups.forEach(function(group) {
        // Filter group fields to only include those that passed search/state filters
        var groupFields = group.fields.filter(function(k) { return filteredSet[k]; });
        
        if (groupFields.length === 0) return;  // Skip empty groups
        
        // Add group header if group has a name (Account Name has null name)
        if (group.name) {
          var groupTypeClass = group.type ? ' group-' + group.type : '';
          html += '<div class="srr-field-group-header' + groupTypeClass + '">' + group.name + ' <span class="srr-group-count">(' + groupFields.length + ')</span></div>';
        }
        
        // Render field cards in this group
        groupFields.forEach(function(key) {
          html += renderFieldCard(key);
        });
      });
      
      // v1.6.60: System Metadata section for Verifier/Admin (collapsed by default)
      if (currentMode !== 'analyst') {
        var internalKeys = Object.keys(record).filter(function(k) {
          return !k.startsWith('_') && isInternalField(k);
        });
        if (internalKeys.length > 0) {
          internalKeys.sort();
          html += '<details class="srr-system-metadata" style="margin-top: 12px; border-top: 1px solid #e0e0e0;">';
          html += '<summary style="padding: 10px 12px; font-size: 0.75em; font-weight: 600; color: #9e9e9e; cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px; user-select: none;">System Metadata (' + internalKeys.length + ')</summary>';
          html += '<div style="padding: 0 12px 8px;">';
          internalKeys.forEach(function(k) {
            var val = record[k];
            if (val === null || val === undefined) val = '';
            if (typeof val === 'object') val = JSON.stringify(val);
            var displayVal = String(val);
            if (displayVal.length > 80) displayVal = displayVal.substring(0, 77) + '...';
            html += '<div style="display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.8em; border-bottom: 1px solid #f5f5f5;">';
            html += '<span style="color: #9e9e9e; font-weight: 500;">' + k + '</span>';
            html += '<span style="color: #616161; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="' + String(val).replace(/"/g, '&quot;') + '">' + displayVal + '</span>';
            html += '</div>';
          });
          html += '</div></details>';
        }
      }

      container.innerHTML = html || '<div class="srr-empty-state">No fields match current filter</div>';

      // V2.3b: Re-render guidance card at top of field list after each rebuild
      if (record && typeof renderSectionGuidanceCard === 'function' && _sectionGuidanceConfig) {
        var existingCard = document.getElementById('section-guidance-card');
        if (existingCard) existingCard.remove();
        renderSectionGuidanceCard(record, container);
      }
    }
    
    // SRR Filter functions
    function srrSetFilter(filter) {
      srrState.activeFilter = filter;
      document.querySelectorAll('.srr-filter-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.filter === filter) chip.classList.add('active');
      });
      renderSrrFields(srrState.currentRecord);
    }
    
    // v1.4.20: Update filter chip counts
    function srrUpdateFilterCounts() {
      // v1.6.5: Exclude hidden fields from counts
      var allKeys = Object.keys(srrState.originalValues).filter(function(k) { return !isHiddenField(k); });
      var counts = { all: allKeys.length, todo: 0, verified: 0, modified: 0, submitted: 0, rfi: 0, blocked: 0, patched: 0 };
      allKeys.forEach(function(k) {
        var state = srrState.fieldStates[k] || 'todo';
        counts[state] = (counts[state] || 0) + 1;
      });
      // Todo count includes modified and rfi_pending (still in To Do queue)
      var todoCount = counts.todo + counts.modified + (counts.rfi_pending || 0);
      // Patched count includes submitted for backwards compat
      var patchedCount = counts.patched + counts.submitted;
      // RFI count includes both sent and pending
      var rfiCount = counts.rfi + (counts.rfi_pending || 0);
      
      var allEl = document.getElementById('srr-count-all');
      var todoEl = document.getElementById('srr-count-todo');
      var verifiedEl = document.getElementById('srr-count-verified');
      var rfiEl = document.getElementById('srr-count-rfi');
      var patchedEl = document.getElementById('srr-count-patched');
      if (allEl) allEl.textContent = '(' + counts.all + ')';
      if (todoEl) todoEl.textContent = '(' + todoCount + ')';
      if (verifiedEl) verifiedEl.textContent = '(' + counts.verified + ')';
      if (rfiEl) rfiEl.textContent = '(' + rfiCount + ')';
      if (patchedEl) patchedEl.textContent = '(' + patchedCount + ')';
    }
    
    // v1.4.20: Field action - Verify (mark as correct)
    function srrVerifyField(fieldKey) {
      srrState.fieldStates[fieldKey] = 'verified';
      console.log('[SRR] Field VERIFIED:', fieldKey);
      AuditTimeline.emit('FIELD_VERIFIED', {
        record_id: srrState.currentRecordKey || '',
        field_key: fieldKey,
        file_id: srrState.currentSheetName || '',
        metadata: { sheet: srrState.currentSheetName }
      });
      
      // Animate out the field card then remove from DOM
      var card = document.querySelector('.srr-field-card[data-field="' + fieldKey + '"]');
      if (card) {
        card.classList.add('removing');
        // Remove card from DOM after animation
        setTimeout(function() {
          if (card.parentNode) card.parentNode.removeChild(card);
        }, 250);
      }
      
      // Update filter counts immediately
      srrUpdateFilterCounts();
      
      // Check if all fields are now verified (record fully validated)
      var allVerified = true;
      var fieldKeys = Object.keys(srrState.originalValues || {}).filter(function(k) {
        return !k.startsWith('_') && !isHiddenField(k);
      });
      for (var i = 0; i < fieldKeys.length; i++) {
        var k = fieldKeys[i];
        var state = srrState.fieldStates[k] || 'todo';
        if (state === 'todo') {
          allVerified = false;
          break;
        }
      }
      
      if (allVerified && fieldKeys.length > 0) {
        setTimeout(function() {
          console.log('[SRR] All fields verified - record complete');
          var recordKey = srrState.currentRecordKey;
          if (recordKey && window.localState && window.localState.recordStatus) {
            window.localState.recordStatus[recordKey] = 'finalized';
          }
          updateTriageCounts();
          srrAutoAdvance('All fields verified');
        }, 300);
      }
    }
    
    // v1.4.20: Field action - Blacklist Flag
    function srrBlacklistField(fieldKey) {
      var currentVal = srrState.editedValues.hasOwnProperty(fieldKey) 
        ? srrState.editedValues[fieldKey] 
        : srrState.originalValues[fieldKey];
      var label = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      
      // v1.5.2: Select field for quick actions
      srrPeSelectField(fieldKey, label);
      
      // Set field state to blocked (red header + Blocked badge)
      srrState.fieldStates[fieldKey] = 'blocked';
      
      // Auto-set patch type to blacklist
      srrState.patchType = 'blacklist';
      srrState.patchDraft.patch_type = 'blacklist';
      
      // Auto-populate blacklist subject
      srrState.patchDraft.blacklist_subject = label + ': ' + (currentVal || '(empty)');
      
      console.log('[SRR] Field BLACKLIST:', fieldKey, 'subject:', srrState.patchDraft.blacklist_subject);
      AuditTimeline.emit('FIELD_BLACKLISTED', {
        record_id: srrState.currentRecordKey || '',
        field_key: fieldKey,
        file_id: srrState.currentSheetName || '',
        before_value: currentVal || '',
        metadata: { subject: srrState.patchDraft.blacklist_subject }
      });
      if (srrCheckAllFieldsCompleted()) {
        setTimeout(function() { srrAutoAdvance('All fields addressed'); }, 300);
      }
      srrUpdatePatchFormSections();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
      _srrExpandPatchPanel();
    }
    
    // v1.4.20: Field action - RFI (question)
    function srrRfiField(fieldKey) {
      // Store RFI field info for display
      var currentVal = srrState.editedValues.hasOwnProperty(fieldKey) 
        ? srrState.editedValues[fieldKey] 
        : srrState.originalValues[fieldKey];
      var label = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      
      // v1.5.2: Select field for quick actions
      srrPeSelectField(fieldKey, label);
      
      // Set to rfi_pending (stays in To Do until Send RFI)
      srrState.fieldStates[fieldKey] = 'rfi_pending';
      srrState.rfiField = {
        key: fieldKey,
        label: label,
        value: currentVal
      };
      
      // Auto-set patch type to RFI
      srrState.patchType = 'rfi';
      srrState.patchDraft.patch_type = 'rfi';
      
      console.log('[SRR] Field RFI (pending):', fieldKey);
      if (srrCheckAllFieldsCompleted()) {
        setTimeout(function() { srrAutoAdvance('All fields addressed'); }, 300);
      }
      srrUpdatePatchFormSections();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
      _srrExpandPatchPanel();
    }
    
    // v1.4.20: Reset field state to TODO
    function srrResetFieldState(fieldKey) {
      var prevState = srrState.fieldStates[fieldKey];
      delete srrState.fieldStates[fieldKey];
      
      // If was patched, also clear proposed change
      if (prevState === 'patched' && srrState.proposedChanges[fieldKey]) {
        delete srrState.proposedChanges[fieldKey];
        delete srrState.lockedFields[fieldKey];
        delete srrState.editedValues[fieldKey];
      }
      
      console.log('[SRR] Field reset to TODO:', fieldKey);
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
    }
    
    // v1.4.20: Check if there are unresolved PATCHED or RFI fields
    function srrHasUnresolvedFields() {
      for (var key in srrState.fieldStates) {
        var state = srrState.fieldStates[key];
        if (state === 'patched' || state === 'rfi') return true;
      }
      return false;
    }
    
    // v1.4.20: Get count of unresolved fields
    function srrGetUnresolvedCount() {
      var count = 0;
      for (var key in srrState.fieldStates) {
        var state = srrState.fieldStates[key];
        if (state === 'patched' || state === 'rfi') count++;
      }
      return count;
    }
    
    function srrFilterByGroup(group) {
      srrState.activeGroup = group;
      renderSrrFields(srrState.currentRecord);
    }
    
    // v1.4.18: Search filter function
    function srrFilterFields() {
      var searchInput = document.getElementById('srr-field-search');
      srrState.searchQuery = searchInput ? searchInput.value : '';
      renderSrrFields(srrState.currentRecord);
    }
    
    // SRR Inline Edit functions
    function srrStartEdit(fieldKey) {
      // v1.5.2: Get field label for selection tracking
      var fieldLabel = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      
      // v1.5.2: Select field for quick actions (works even in read-only mode)
      srrPeSelectField(fieldKey, fieldLabel);
      
      // v1.6.46: Verifier/Admin read-only — silently prevent editing (no toast)
      if (srrState.isReadOnly) {
        return;
      }
      
      // v1.4.18: Prevent editing locked fields
      if (srrState.lockedFields.hasOwnProperty(fieldKey)) {
        showToast('Field is locked after change. Use Fields panel to modify.', 'info');
        return;
      }
      
      var card = document.querySelector('.srr-field-card[data-field="' + fieldKey + '"]');
      if (!card) return;
      
      var valueDisplay = card.querySelector('.srr-field-value-display');
      var currentVal = srrState.editedValues.hasOwnProperty(fieldKey) 
        ? srrState.editedValues[fieldKey] 
        : (srrState.originalValues[fieldKey] || '');
      
      // v1.6.10: Check if this is a picklist field with options
      var isPicklist = valueDisplay.getAttribute('data-is-picklist') === 'true';
      var picklistOptionsStr = valueDisplay.getAttribute('data-picklist-options');
      var picklistOptions = [];
      if (isPicklist && picklistOptionsStr) {
        try {
          picklistOptions = JSON.parse(decodeURIComponent(picklistOptionsStr));
        } catch (e) {
          picklistOptions = [];
        }
      }
      
      // v1.6.10: Render dropdown for picklist fields, text input for others
      // v1.6.21: Fixed double-click issue - track editing state and prevent re-creation
      if (isPicklist && picklistOptions.length > 0) {
        // Check if we're already editing this field (prevent double-click recreation)
        if (srrState.editingField === fieldKey) {
          return; // Already editing, don't recreate
        }
        srrState.editingField = fieldKey;
        
        // Build dropdown HTML
        var selectHtml = '<select class="srr-field-value-select" id="srr-edit-input-' + fieldKey + '" onclick="event.stopPropagation();">';
        // Add empty option
        selectHtml += '<option value=""' + (!currentVal ? ' selected' : '') + '>-- Select --</option>';
        // Check if current value is in options (for invalid value handling)
        var currentValLower = String(currentVal).trim().toLowerCase();
        var foundCurrentVal = false;
        picklistOptions.forEach(function(opt) {
          var isSelected = String(opt).trim().toLowerCase() === currentValLower;
          if (isSelected) foundCurrentVal = true;
          selectHtml += '<option value="' + String(opt).replace(/"/g, '&quot;') + '"' + (isSelected ? ' selected' : '') + '>' + String(opt) + '</option>';
        });
        // If current value not in options, add it as an invalid option
        if (currentVal && !foundCurrentVal) {
          selectHtml += '<option value="' + String(currentVal).replace(/"/g, '&quot;') + '" selected style="color:#c62828;">' + String(currentVal) + ' (invalid)</option>';
        }
        selectHtml += '</select>';
        valueDisplay.innerHTML = selectHtml;
        
        var select = document.getElementById('srr-edit-input-' + fieldKey);
        if (!select) return;
        
        // v1.6.21: Open dropdown automatically on first click
        select.focus();
        // Try to programmatically open the dropdown (works in modern browsers)
        if (typeof select.showPicker === 'function') {
          try { select.showPicker(); } catch (e) {}
        }
        
        // Handle change and blur
        select.addEventListener('change', function() {
          srrCommitEdit(fieldKey, select.value);
        });
        select.addEventListener('blur', function() {
          // Small delay to allow change event to fire first
          setTimeout(function() {
            if (srrState.editingField === fieldKey) {
              srrCommitEdit(fieldKey, select.value);
            }
          }, 150);
        });
      } else {
        // Regular text input
        // v1.6.21: Track editing state for text inputs too
        if (srrState.editingField === fieldKey) {
          return; // Already editing, don't recreate
        }
        srrState.editingField = fieldKey;
        
        valueDisplay.innerHTML = '<input type="text" class="srr-field-value-input" id="srr-edit-input-' + fieldKey + '" value="' + String(currentVal).replace(/"/g, '&quot;') + '" onclick="event.stopPropagation();">';
        
        var input = document.getElementById('srr-edit-input-' + fieldKey);
        if (!input) return;
        
        input.focus();
        input.select();
        
        // Handle blur and Enter
        input.addEventListener('blur', function() {
          srrCommitEdit(fieldKey, input.value);
        });
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            srrCommitEdit(fieldKey, input.value);
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            srrState.editingField = null;
            renderSrrFields(srrState.currentRecord);
          }
        });
      }
    }
    
    function srrCommitEdit(fieldKey, newValue) {
      var originalVal = srrState.originalValues[fieldKey];
      if (originalVal === null || originalVal === undefined) originalVal = '';
      
      // Check if value actually changed
      if (String(newValue) !== String(originalVal)) {
        srrState.editedValues[fieldKey] = newValue;
        srrState.editingField = null;  // v1.4.18: Clear editing state
        
        // v1.4.18: Lock field after commit (AC-01)
        srrState.lockedFields[fieldKey] = true;
        
        // Set field state to modified (routes to Correction, not RFI)
        srrState.fieldStates[fieldKey] = 'modified';
        
        // Auto-set patch type to correction (via edit action)
        srrState.patchType = 'correction';
        srrState.patchDraft.patch_type = 'correction';
        srrUpdatePatchTypeDisplay();
        
        // Create or update proposed change
        if (!srrState.proposedChanges[fieldKey]) {
          srrState.proposedChanges[fieldKey] = {
            field: fieldKey,
            label: fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }),
            from: originalVal,
            to: newValue,
            category: 'Correction',
            justification: '',
            comment: ''
          };
        } else {
          srrState.proposedChanges[fieldKey].to = newValue;
        }
        
        // Update patch draft changes array
        srrSyncProposedChanges();
        
        console.log('[SRR] Field committed (locked):', fieldKey, 'from:', originalVal, 'to:', newValue);
        showToast('Field changed and locked: ' + fieldKey, 'success');
        scheduleAutosave();
      } else {
        srrState.editingField = null;
      }
      
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();  // v1.4.18: Update Fields panel
    }
    
    function srrUndoChange(fieldKey) {
      delete srrState.editedValues[fieldKey];
      delete srrState.proposedChanges[fieldKey];
      delete srrState.lockedFields[fieldKey];  // v1.4.18: Unlock field
      srrState.editingField = null;
      
      srrSyncProposedChanges();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();  // v1.4.18: Update Fields panel
      srrStudioEnsureLoaded((srrState.currentRecord && srrState.currentRecord._identity && srrState.currentRecord._identity.record_id) || srrState.currentRecordKey || '', srrState.currentSheetName || '');
      srrStudioOnRecordScopeChanged();
      
      showToast('Change reverted: ' + fieldKey, 'info');
      console.log('[SRR] Undo change:', fieldKey);
    }
    
    // v1.4.18: Fields panel rendering (AC-02)
    function srrRenderPatchEditor() {
      var container = document.getElementById('srr-patch-editor-fields');
      var countEl = document.getElementById('srr-change-count');
      var changes = Object.values(srrState.proposedChanges);
      var patchType = srrState.patchType;
      
      if (!container) return;
      
      // For RFI, show the RFI field info instead of changes
      if (patchType === 'rfi' && srrState.rfiField) {
        var rfi = srrState.rfiField;
        var valDisplay = rfi.value === null || rfi.value === undefined || rfi.value === '' ? '(empty)' : String(rfi.value);
        countEl.textContent = '1 field';
        container.innerHTML = '<div class="srr-patch-editor-field">' +
          '<div class="srr-patch-editor-label" style="font-weight: 600; margin-bottom: 6px;">' + rfi.label + '</div>' +
          '<div class="srr-patch-editor-row">' +
            '<label style="color: #666;">Value:</label>' +
            '<div class="srr-patch-editor-old" style="background: #fff3e0; border-color: #ffe0b2;" title="' + valDisplay.replace(/"/g, '&quot;') + '">' + valDisplay + '</div>' +
          '</div>' +
        '</div>';
        return;
      }
      
      countEl.textContent = changes.length + ' change' + (changes.length !== 1 ? 's' : '');
      
      if (changes.length === 0) {
        // Show appropriate helper based on patch type
        var helperText = patchType === 'blacklist' 
          ? 'Click the Block icon on a field to flag it for blacklist.'
          : 'Click a field value to edit. Changed fields appear here.';
        container.innerHTML = '<div class="srr-patch-editor-empty" id="srr-action-box-helper">' + helperText + '</div>';
        return;
      }
      
      var html = changes.map(function(change) {
        var oldVal = change.from === null || change.from === undefined || change.from === '' ? '(empty)' : String(change.from);
        var newVal = change.to === null || change.to === undefined ? '' : String(change.to);
        
        // v1.5.2: Make field clickable to select for quick actions
        return '<div class="srr-patch-editor-field" data-field="' + change.field + '" onclick="srrPeSelectField(\'' + change.field + '\', \'' + change.label.replace(/'/g, "\\'") + '\')" style="cursor: pointer;">' +
          '<div class="srr-patch-editor-label">' + change.label + 
            '<button class="srr-patch-remove-btn" onclick="event.stopPropagation(); srrUndoChange(\'' + change.field + '\')" title="Remove change">✕</button>' +
          '</div>' +
          '<div class="srr-patch-editor-row">' +
            '<label>Old:</label>' +
            '<div class="srr-patch-editor-old" title="' + oldVal.replace(/"/g, '&quot;') + '">' + oldVal + '</div>' +
          '</div>' +
          '<div class="srr-patch-editor-row">' +
            '<label>New:</label>' +
            '<div class="srr-patch-editor-new">' +
              '<input type="text" id="srr-pe-new-' + change.field + '" value="' + newVal.replace(/"/g, '&quot;') + '" ' +
                'onclick="event.stopPropagation()" onchange="srrUpdatePatchEditorValue(\'' + change.field + '\', this.value)">' +
            '</div>' +
          '</div>' +
        '</div>';
      }).join('');
      
      container.innerHTML = html;
    }
    
    // v1.4.18: Update new value from Fields panel (AC-02)
    function srrUpdatePatchEditorValue(fieldKey, newValue) {
      if (srrState.proposedChanges[fieldKey]) {
        srrState.proposedChanges[fieldKey].to = newValue;
        srrState.editedValues[fieldKey] = newValue;
        srrSyncProposedChanges();
        renderSrrFields(srrState.currentRecord);  // Update Field Inspector display
        console.log('[SRR] Patch Editor updated:', fieldKey, 'to:', newValue);
      }
    }
    
    // v1.5.2: Track selected field for Patch Type chip actions
    var srrPeSelectedField = null;
    
    function srrPeSelectField(fieldKey, fieldLabel) {
      srrPeSelectedField = { key: fieldKey, label: fieldLabel };
      
      // Update chip area to show selection
      var chipsContainer = document.getElementById('srr-patch-type-chips');
      var labelEl = document.getElementById('srr-patch-type-selected-field');
      
      if (chipsContainer) {
        chipsContainer.classList.remove('no-selection');
      }
      if (labelEl) {
        labelEl.textContent = 'Selected: ' + fieldLabel;
        labelEl.style.background = '#e8f5e9';
        labelEl.style.color = '#2e7d32';
      }
      console.log('[SRR] Field selected for action:', fieldKey);
    }
    
    function srrPeClearSelection() {
      srrPeSelectedField = null;
      
      var chipsContainer = document.getElementById('srr-patch-type-chips');
      var labelEl = document.getElementById('srr-patch-type-selected-field');
      
      if (chipsContainer) {
        chipsContainer.classList.add('no-selection');
      }
      if (labelEl) {
        labelEl.textContent = 'Select a field to apply action';
        labelEl.style.background = '#f5f5f5';
        labelEl.style.color = '#666';
      }
    }
    
    function srrUpdateChangeCategory(fieldKey, category) {
      if (srrState.proposedChanges[fieldKey]) {
        srrState.proposedChanges[fieldKey].category = category;
        srrSyncProposedChanges();
        srrRenderPatchEditor();
      }
    }
    
    function srrSaveMiniPatch(fieldKey) {
      var justInput = document.getElementById('srr-mini-just-' + fieldKey);
      var commentInput = document.getElementById('srr-mini-comment-' + fieldKey);
      
      if (srrState.proposedChanges[fieldKey]) {
        srrState.proposedChanges[fieldKey].justification = justInput ? justInput.value : '';
        srrState.proposedChanges[fieldKey].comment = commentInput ? commentInput.value : '';
      }
      
      srrState.editingField = null;
      srrSyncProposedChanges();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
      
      showToast('Patch draft saved for: ' + fieldKey, 'success');
    }
    
    function srrSyncProposedChanges() {
      // Sync proposed changes to patch draft changes array
      srrState.patchDraft.changes = Object.values(srrState.proposedChanges).map(function(c) {
        return {
          path: c.field,
          label: c.label,
          before: c.from,
          after: c.to,
          category: c.category,
          justification: c.justification,
          comment: c.comment
        };
      });
    }
    
    // Check for unsaved changes
    function srrHasUnsavedChanges() {
      var editedFields = Object.keys(srrState.editedValues);
      if (editedFields.length === 0) return false;
      
      // Check if any edited field has incomplete patch data
      for (var i = 0; i < editedFields.length; i++) {
        var key = editedFields[i];
        var change = srrState.proposedChanges[key];
        if (!change || !change.justification) {
          return true;
        }
      }
      return false;
    }
    
    // Navigation guard
    // v1.4.20: Back to Grid with guard for unresolved fields
    function srrSetDocumentType(val) {
      if (val === '__add_new_doc_type__') {
        srrOpenNewDocTypeModal();
        var sel = document.getElementById('srr-doc-type');
        if (sel && srrState.currentRecord) sel.value = srrState.currentRecord._document_type || 'Unknown';
        return;
      }
      var record = srrState.currentRecord;
      if (!record) return;
      record._document_type = val;
      console.log('[SRR] Document type set:', val, 'for', srrState.currentRecordKey);
      if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
    }
    function srrOpenNewDocTypeModal() {
      var modal = document.getElementById('srr-new-doctype-modal');
      if (modal) {
        modal.style.display = 'flex';
        var nameInput = document.getElementById('srr-new-doctype-name');
        if (nameInput) { nameInput.value = ''; nameInput.focus(); }
        var justInput = document.getElementById('srr-new-doctype-justification');
        if (justInput) justInput.value = '';
      }
      console.log('[SRR-DOCTYPE] modal_opened');
    }

    function srrCloseNewDocTypeModal() {
      var modal = document.getElementById('srr-new-doctype-modal');
      if (modal) modal.style.display = 'none';
    }

    function srrSubmitNewDocType() {
      var nameInput = document.getElementById('srr-new-doctype-name');
      var justInput = document.getElementById('srr-new-doctype-justification');
      var name = (nameInput ? nameInput.value : '').trim();
      var justification = (justInput ? justInput.value : '').trim();
      if (!name) { showToast('Please enter a document type name', 'warning'); return; }
      if (justification.length < 5) { showToast('Please provide a justification (min 5 characters)', 'warning'); return; }
      var patchId = 'PR_DT_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6);
      var record = srrState.currentRecord;
      var patchArtifact = {
        request_id: patchId,
        type: 'doc_type_addition',
        artifact_type: 'doc_type_addition',
        status: 'Draft',
        record_id: srrState.currentRecordKey || '',
        contract_key: record ? (record.contract_key || '') : '',
        field_name: 'document_type',
        payload: { new_doc_type: name, justification: justification },
        intent: { category: 'doc_type_addition', field: 'document_type' },
        submitted_at_utc: new Date().toISOString(),
        created_at_utc: new Date().toISOString(),
        actor_id: (AuditTimeline._resolveActor() || {}).id || 'analyst',
        actor_role: (AuditTimeline._resolveActor() || {}).role || 'analyst',
        dataset_id: IDENTITY_CONTEXT.dataset_id || ''
      };
      PATCH_REQUEST_STORE.save(patchArtifact);
      AuditTimeline.emit('doc_type_addition_requested', {
        record_id: srrState.currentRecordKey || '',
        field_key: 'document_type',
        dataset_id: IDENTITY_CONTEXT.dataset_id || '',
        metadata: { patch_request_id: patchId, new_doc_type: name, justification: justification }
      });
      srrCloseNewDocTypeModal();
      showToast('Doc type "' + name + '" submitted as patch: ' + patchId, 'success');
      console.log('[SRR-DOCTYPE] patch_submitted: id=' + patchId + ', type=' + name);
      if (typeof renderAnalystTriage === 'function') renderAnalystTriage();
    }



    function srrPopulateDocTypeDropdown(record) {
      var sel = document.getElementById('srr-doc-type');
      if (!sel) return;
      var types = (rulesBundleCache.documentTypes && rulesBundleCache.documentTypes.length > 0)
        ? rulesBundleCache.documentTypes : ['Unknown'];
      var currentVal = (record && record._document_type) || 'Unknown';
      sel.innerHTML = '';
      types.forEach(function(t) {
        var opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        if (t === currentVal) opt.selected = true;
        sel.appendChild(opt);
      });
      if (types.indexOf(currentVal) < 0) {
        var opt = document.createElement('option');
        opt.value = currentVal;
        opt.textContent = currentVal;
        opt.selected = true;
        sel.appendChild(opt);
      }
      var addOpt = document.createElement('option');
      addOpt.value = '__add_new_doc_type__';
      addOpt.textContent = '+ Add New Doc Type…';
      addOpt.style.fontStyle = 'italic';
      addOpt.style.color = '#1565c0';
      sel.appendChild(addOpt);
    }

    function srrSetDocumentRole(val) {
      var record = srrState.currentRecord;
      if (!record) return;
      DocumentRoleInference.setManual(record, val, srrState.currentSheet, srrState.currentRowIndex);
      console.log('[SRR] Document role set:', val, 'for', srrState.currentRecordKey);
    }

    function srrConfirmDocumentRole() {
      var record = srrState.currentRecord;
      if (!record) return;
      if (DocumentRoleInference.confirmSuggestion(record, srrState.currentSheet, srrState.currentRowIndex)) {
        showToast('Document role confirmed: ' + record._document_role, 'success');
        srrPopulateDocRoleDropdown(record);
      }
    }

    function srrPopulateDocRoleDropdown(record) {
      var sel = document.getElementById('srr-doc-role');
      if (!sel) return;
      var currentVal = (record && record._document_role) || 'Unknown';
      sel.innerHTML = '';
      DOCUMENT_ROLE_ENUM.forEach(function(r) {
        var opt = document.createElement('option');
        opt.value = r;
        opt.textContent = r;
        if (r === currentVal) opt.selected = true;
        sel.appendChild(opt);
      });
      var suggBadge = document.getElementById('srr-doc-role-suggestion');
      if (suggBadge) {
        var sugg = record && record._document_role_suggestion;
        if (sugg) {
          suggBadge.style.display = 'inline-block';
          suggBadge.innerHTML = 'Suggested: ' + escapeHtml(sugg.role) + ' (' + Math.round(sugg.confidence * 100) + '%) <button onclick="srrConfirmDocumentRole()" style="margin-left:4px; padding:1px 8px; background:#4caf50; color:white; border:none; border-radius:3px; cursor:pointer; font-size:0.8em;">Confirm</button>';
        } else {
          suggBadge.style.display = 'none';
        }
      }
    }

    function getSrrNavigationList() {
      var filtered = gridState.filteredData;
      if (!filtered || filtered.length === 0) return [];
      return filtered.map(function(r) {
        return { sheet: r.sheet, idx: r._sheetRowIndex !== undefined ? r._sheetRowIndex : -1 };
      });
    }

    function srrFindCurrentNavIndex() {
      var list = getSrrNavigationList();
      var curSheet = srrState.currentSheetName;
      var curIdx = srrState.currentRowIndex;
      for (var i = 0; i < list.length; i++) {
        if (list[i].sheet === curSheet && list[i].idx === curIdx) return i;
      }
      return -1;
    }

    function srrUpdateNavButtons() {
      var list = getSrrNavigationList();
      var pos = srrFindCurrentNavIndex();
      var prevBtn = document.getElementById('srr-nav-prev');
      var nextBtn = document.getElementById('srr-nav-next');
      var posEl = document.getElementById('srr-nav-pos');
      if (!prevBtn || !nextBtn || !posEl) return;
      if (list.length === 0 || pos < 0) {
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        posEl.textContent = '—';
        var subtitleEl2 = document.getElementById('srr-page-subtitle');
        if (subtitleEl2) subtitleEl2.textContent = 'Per-record inspection with Evidence Pack authoring and Patch Request creation.';
        return;
      }
      prevBtn.disabled = (pos === 0);
      nextBtn.disabled = (pos >= list.length - 1);
      posEl.textContent = (pos + 1) + ' of ' + list.length;
      var subtitleEl = document.getElementById('srr-page-subtitle');
      if (subtitleEl) {
        var sheetLabel = gridState.sheet || srrState.currentSheetName || '';
        subtitleEl.textContent = 'Row ' + (pos + 1) + ' of ' + list.length + (sheetLabel ? ' — ' + sheetLabel : '');
      }
    }

    function srrNavigatePrev() {
        console.log('[T0:GUARD] srrNavigatePrev called');
      var list = getSrrNavigationList();
      var pos = srrFindCurrentNavIndex();
      if (pos <= 0) return;
      var target = list[pos - 1];
      openRowReviewDrawer(target.sheet, target.idx);
    }

    function srrNavigateNext() {
        console.log('[T0:GUARD] srrNavigateNext called');
      var list = getSrrNavigationList();
      var pos = srrFindCurrentNavIndex();
      if (pos < 0 || pos >= list.length - 1) return;
      var target = list[pos + 1];
      openRowReviewDrawer(target.sheet, target.idx);
    }

    function srrCheckAllFieldsCompleted() {
      var completedStates = { verified: 1, rfi: 1, submitted: 1, blocked: 1, modified: 1 };
      var fieldKeys = Object.keys(srrState.originalValues || {}).filter(function(k) {
        return !k.startsWith('_');
      });
      if (fieldKeys.length === 0) return false;
      for (var i = 0; i < fieldKeys.length; i++) {
        var state = srrState.fieldStates[fieldKeys[i]] || 'todo';
        if (!completedStates[state]) return false;
      }
      return true;
    }

    function srrAutoAdvance(reason) {
      var list = getSrrNavigationList();
      var pos = srrFindCurrentNavIndex();
      if (pos >= 0 && pos < list.length - 1) {
        showToast(reason + ' — advancing to next record');
        setTimeout(function() {
          var target = list[pos + 1];
          openRowReviewDrawer(target.sheet, target.idx);
        }, 600);
      } else {
        showToast(reason + ' — last record in list');
      }
    }

    function srrBackToGrid() {
      if (srrHasUnresolvedFields()) {
        srrShowGuardModal();
      } else {
        navigateTo('grid');
      }
    }
    
    function srrGuardCancel() {
      srrHideGuardModal();
    }
    
    // v1.4.20: Discard all changes and clear field states
    function srrGuardDiscardAll() {
      // Clear all PATCHED and RFI states
      for (var key in srrState.fieldStates) {
        var state = srrState.fieldStates[key];
        if (state === 'patched' || state === 'rfi') {
          delete srrState.fieldStates[key];
          delete srrState.proposedChanges[key];
          delete srrState.lockedFields[key];
          delete srrState.editedValues[key];
        }
      }
      srrState.patchDraft.changes = [];
      srrHideGuardModal();
      navigateTo('grid');
    }
    
    // ========== v1.5.1: PATCH TESTER TAB (Verifier SSR) ==========
    var srrPatchTesterState = {
      artifactId: null,
      field: null,
      oldValue: null,
      proposedValue: null
    };
    
    function srrSwitchRightTab(tabName) {
      var validTabs = ['fields', 'studio', 'tester'];
      if (validTabs.indexOf(tabName) === -1) tabName = 'fields';
      var fieldsTab = document.getElementById('srr-tab-fields');
      var studioTab = document.getElementById('srr-tab-studio');
      var testerTab = document.getElementById('srr-tab-tester');
      var tabBtns = document.querySelectorAll('.srr-panel-tab');
      
      tabBtns.forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
      });
      
      if (fieldsTab) fieldsTab.style.display = tabName === 'fields' ? 'block' : 'none';
      if (studioTab) studioTab.style.display = tabName === 'studio' ? 'block' : 'none';
      if (testerTab) testerTab.style.display = tabName === 'tester' ? 'block' : 'none';
      
      var titleMap = { fields: 'Fields', studio: 'Patch Studio', tester: 'Patch Tester' };
      var titleEl = document.getElementById('srr-right-panel-title');
      if (titleEl) {
        titleEl.textContent = titleMap[tabName] || 'Fields';
      }
    }
    
    function srrShowPatchTesterTabs() {
      var tabsEl = document.getElementById('srr-panel-tabs');
      if (!tabsEl) return;
      tabsEl.style.display = 'flex';
      
      var isVerifierOrAdmin = (currentMode === 'verifier' || currentMode === 'admin');
      var artifactId = srrState.currentArtifactId;
      var artifact = artifactId ? getArtifact(artifactId) : null;
      
      var isCorrectionOrBlacklist = false;
      if (artifact) {
        var patchType = (artifact.body && artifact.body.patch_type) ? artifact.body.patch_type : '';
        var artifactType = artifact.artifact_type || '';
        var normalizedPatchType = patchType ? String(patchType).toLowerCase() : '';
        var normalizedArtifactType = artifactType ? String(artifactType).toLowerCase() : '';
        
        if (normalizedPatchType === 'correction' || 
            normalizedPatchType === 'blacklist' || 
            normalizedPatchType === 'blacklist flag') {
          isCorrectionOrBlacklist = true;
        } else if (normalizedArtifactType === 'blacklist') {
          isCorrectionOrBlacklist = true;
        }
        if (normalizedPatchType === 'rfi' || normalizedArtifactType === 'rfi') {
          isCorrectionOrBlacklist = false;
        }
      }
      
      console.log('[SRR_TABS] Role:', currentMode, 'isCorrectionOrBlacklist:', isCorrectionOrBlacklist, 'isVerifierOrAdmin:', isVerifierOrAdmin);
      
      var testerBtn = tabsEl.querySelector('[data-tab="tester"]');
      if (testerBtn) {
        if (isVerifierOrAdmin && isCorrectionOrBlacklist && artifactId) {
          testerBtn.style.display = '';
        } else {
          testerBtn.style.display = 'none';
          var activeTab = tabsEl.querySelector('.srr-panel-tab.active');
          if (activeTab && activeTab.dataset.tab === 'tester') {
            srrSwitchRightTab('fields');
          }
        }
      }
    }
    
    function srrHidePatchTesterTabs() {
      var tabsEl = document.getElementById('srr-panel-tabs');
      if (!tabsEl) return;
      var testerBtn = tabsEl.querySelector('[data-tab="tester"]');
      if (testerBtn) testerBtn.style.display = 'none';
      var activeTab = tabsEl.querySelector('.srr-panel-tab.active');
      if (activeTab && activeTab.dataset.tab === 'tester') {
        srrSwitchRightTab('fields');
      }
    }
    
    function srrLoadPatchTesterData(artifactId) {
      // Load artifact data into Patch Tester tab
      var artifact = getArtifact(artifactId);
      if (!artifact) {
        console.log('[SRR_TESTER] No artifact found:', artifactId);
        return;
      }
      
      srrPatchTesterState.artifactId = artifactId;
      srrPatchTesterState.field = artifact.field_key || '—';
      srrPatchTesterState.oldValue = artifact.old_value || '—';
      srrPatchTesterState.proposedValue = artifact.new_value || '';
      
      // Populate UI
      var fieldEl = document.getElementById('srr-tester-field');
      var oldEl = document.getElementById('srr-tester-old-value');
      var proposedEl = document.getElementById('srr-tester-proposed-value');
      var newValueEl = document.getElementById('srr-tester-new-value');
      
      if (fieldEl) fieldEl.textContent = srrPatchTesterState.field;
      if (oldEl) oldEl.textContent = srrPatchTesterState.oldValue;
      if (proposedEl) proposedEl.textContent = srrPatchTesterState.proposedValue;
      if (newValueEl) newValueEl.value = srrPatchTesterState.proposedValue;
      
      // Clear notes
      var notesEl = document.getElementById('srr-tester-notes');
      if (notesEl) notesEl.value = '';
    }
    
    function srrSendBackToAnalyst() {
      var artifactId = srrPatchTesterState.artifactId;
      if (!artifactId) {
        showToast('No patch loaded to send back', 'warning');
        return;
      }
      
      var newValueEl = document.getElementById('srr-tester-new-value');
      var notesEl = document.getElementById('srr-tester-notes');
      
      var adjustedValue = newValueEl ? newValueEl.value.trim() : '';
      var verifierNotes = notesEl ? notesEl.value.trim() : '';
      
      if (!verifierNotes) {
        showToast('Please add verifier notes explaining the changes', 'warning');
        return;
      }
      
      // Update artifact with verifier feedback
      var artifact = getArtifact(artifactId);
      if (artifact) {
        artifact.status = 'needs_clarification';
        artifact.verifier_adjusted_value = adjustedValue;
        artifact.verifier_notes = verifierNotes;
        artifact.updated_at = Date.now();
        saveArtifact(artifact);
        
        // v1.5.1: Append thread message with feedback details
        if (artifact.thread_id) {
          var feedbackMsg = 'Patch Tester Feedback:\n';
          feedbackMsg += 'Field: ' + srrPatchTesterState.field + '\n';
          feedbackMsg += 'Proposed Value: ' + srrPatchTesterState.proposedValue + '\n';
          if (adjustedValue !== srrPatchTesterState.proposedValue) {
            feedbackMsg += 'Adjusted Value: ' + adjustedValue + '\n';
          }
          feedbackMsg += 'Notes: ' + verifierNotes;
          addThreadMessage(artifact.thread_id, feedbackMsg);
        }
        
        // Log event
        logArtifactEvent({
          event_type: 'PATCH_TESTER_FEEDBACK',
          artifact_id: artifactId,
          actor: getActorForRole(currentMode),
          payload: {
            adjusted_value: adjustedValue,
            verifier_notes: verifierNotes,
            original_value: srrPatchTesterState.proposedValue
          }
        });
      }
      
      showToast('Sent back to Analyst for clarification', 'success');
      
      // Clear tester state and SRR artifact context
      srrPatchTesterState = { artifactId: null, field: null, oldValue: null, proposedValue: null };
      srrState.currentArtifactId = null;
      srrState.isReadOnly = false;
      
      // Reset UI - close overlay and return to field inspector
      srrClosePatchOverlay();
      srrBackToFieldsInOverlay();
      
      // Navigate back to triage (verifier remains in review workflow)
      navigateTo('triage');
    }
    
    function _srrExpandPatchPanel() {
      if (!srrIsPatchOverlayOpen()) srrOpenPatchOverlay(srrState.patchType || 'correction');
    }
    function _srrCollapsePatchPanel() {
      srrClosePatchOverlay();
    }
    function _srrTogglePatchPanel() {
      if (srrIsPatchOverlayOpen()) {
        srrClosePatchOverlay();
      } else {
        srrOpenPatchOverlay(srrState.patchType || 'correction');
      }
    }
    function _srrUpdateToggleBtn() {
      var _pp = document.querySelector('.srr-panel-right');
      var btn = document.getElementById('srr-patch-toggle-btn');
      var strip = document.getElementById('srr-patch-expand-strip');
      var isCollapsed = _pp && _pp.classList.contains('collapsed');
      if (btn) btn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      if (strip) strip.style.display = isCollapsed ? 'block' : 'none';
    }

    var _srrActiveLeftTab = 'editor';
    var _srrGlossaryLoaded = false;

    function srrSwitchLeftTab(tabName) {
      _srrActiveLeftTab = tabName;
      var tabs = document.querySelectorAll('.srr-left-tab');
      var bodies = document.querySelectorAll('.srr-left-tab-body');
      for (var i = 0; i < tabs.length; i++) {
        tabs[i].classList.toggle('active', tabs[i].getAttribute('data-tab') === tabName);
      }
      for (var i = 0; i < bodies.length; i++) {
        bodies[i].classList.toggle('active', bodies[i].getAttribute('data-tab') === tabName);
      }
      if (tabName === 'patch') {
        srrMovePatchContentToTab();
      }
      if (tabName === 'glossary' && !_srrGlossaryLoaded) {
        srrRenderGlossary();
      }
      console.log('[SRR] Switched left tab to:', tabName);
    }

    function srrMovePatchContentToTab() {
      var patchTabContent = document.getElementById('srr-patch-tab-content');
      var fieldsContent = document.getElementById('srr-tab-fields');
      if (!patchTabContent || !fieldsContent) return;
      if (fieldsContent.parentNode !== patchTabContent) {
        patchTabContent.innerHTML = '';
        patchTabContent.appendChild(fieldsContent);
        fieldsContent.style.display = 'block';
      }
    }

    function srrOpenPatchOverlay(actionType) {
      srrSwitchLeftTab('patch');
      srrMovePatchContentToTab();
      console.log('[SRR] Patch Studio tab opened:', actionType);
    }

    function srrClosePatchOverlay() {
      srrSwitchLeftTab('editor');
      console.log('[SRR] Returned to Editor tab');
    }

    function srrOpenTesterInOverlay() {
      console.log('[SRR] Patch Tester (stub) - not yet in tab mode');
    }

    function srrBackToFieldsInOverlay() {
      srrSwitchLeftTab('editor');
    }

    function srrShowPatchTesterBtnInOverlay() {
    }

    function srrIsPatchOverlayOpen() {
      return _srrActiveLeftTab === 'patch';
    }

    function srrRenderGlossary() {
      var listEl = document.getElementById('srr-glossary-list');
      var filterEl = document.getElementById('srr-glossary-sheet-filter');
      if (!listEl) return;

      var fields = [];
      if (rulesBundleCache && rulesBundleCache.fieldMeta && rulesBundleCache.fieldMeta.fields) {
        fields = rulesBundleCache.fieldMeta.fields;
      }

      if (fields.length === 0) {
        _srrGlossaryLoaded = false;
        listEl.innerHTML = '<div class="srr-glossary-empty">Glossary loading... Switch tabs and come back, or import a workbook.</div>';
        return;
      }
      _srrGlossaryLoaded = true;

      var sheets = {};
      for (var i = 0; i < fields.length; i++) {
        var s = fields[i].sheet || 'Other';
        if (!sheets[s]) sheets[s] = [];
        sheets[s].push(fields[i]);
      }
      var sheetNames = Object.keys(sheets).sort();

      if (filterEl) {
        var filterHtml = '<span class="srr-filter-chip active" data-gsheet="all" onclick="srrFilterGlossarySheet(\'all\')" style="font-size:0.75em; padding:3px 8px; cursor:pointer; border-radius:12px; background:#e3f2fd; color:#1565c0; border:1px solid #bbdefb;">All</span>';
        for (var i = 0; i < sheetNames.length; i++) {
          filterHtml += '<span class="srr-filter-chip" data-gsheet="' + sheetNames[i] + '" onclick="srrFilterGlossarySheet(\''+sheetNames[i]+'\')" style="font-size:0.75em; padding:3px 8px; cursor:pointer; border-radius:12px; background:#f5f5f5; color:#666; border:1px solid #ddd;">' + sheetNames[i] + ' (' + sheets[sheetNames[i]].length + ')</span>';
        }
        filterEl.innerHTML = filterHtml;
      }

      window._srrGlossaryFields = fields;
      window._srrGlossarySheetFilter = 'all';
      srrRenderGlossaryList(fields);
    }

    function srrRenderGlossaryList(fields) {
      var listEl = document.getElementById('srr-glossary-list');
      if (!listEl) return;

      if (fields.length === 0) {
        listEl.innerHTML = '<div class="srr-glossary-empty">No matching fields found.</div>';
        return;
      }

      var html = '';
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        var def = (f.definition || '').trim();
        var label = f.field_label || f.field_key || '';
        var key = f.field_key || '';
        var sheet = f.sheet || '';
        var format = f.return_format || '';
        var req = f.requiredness || '';
        var example = f.example_output || '';
        var hasDef = def.length > 0;

        html += '<div class="srr-glossary-entry" data-sheet="' + sheet + '" data-key="' + key + '" onclick="srrToggleGlossaryEntry(this)">';
        html += '<div style="display:flex; justify-content:space-between; align-items:flex-start;">';
        html += '<div><div class="srr-glossary-field-label">' + _escHtml(label) + '</div>';
        html += '<div class="srr-glossary-field-key">' + _escHtml(key) + '</div></div>';
        html += '<span style="font-size:0.7em; color:#aaa; padding:2px 6px; background:#f5f5f5; border-radius:8px;">' + _escHtml(sheet) + '</span>';
        html += '</div>';
        html += '<div class="srr-glossary-detail" style="display:none;">';
        if (hasDef) {
          html += '<div style="margin-bottom:8px;">' + _escHtml(def) + '</div>';
        } else {
          html += '<div style="margin-bottom:8px; color:#bbb; font-style:italic;">No definition available yet.</div>';
        }
        if (example) {
          html += '<div style="margin-bottom:6px; font-size:0.85em;"><strong>Example:</strong> <code style="background:#f5f5f5; padding:2px 6px; border-radius:3px;">' + _escHtml(example) + '</code></div>';
        }
        html += '<div class="srr-glossary-meta">';
        if (format) html += '<span class="srr-glossary-tag format">' + _escHtml(format) + '</span>';
        if (req === 'required') html += '<span class="srr-glossary-tag required">Required</span>';
        else if (req === 'optional') html += '<span class="srr-glossary-tag optional">Optional</span>';
        else if (req === 'not_needed') html += '<span class="srr-glossary-tag" style="background:#f5f5f5; color:#999;">Not Needed</span>';
        if (f.picklist && f.options && f.options.length > 0) {
          html += '<span class="srr-glossary-tag" style="background:#fff3e0; color:#e65100;">Picklist (' + f.options.length + ')</span>';
        }
        html += '</div>';
        if (f.picklist && f.options && f.options.length > 0) {
          html += '<div style="margin-top:8px; font-size:0.8em;"><strong>Options:</strong> ' + f.options.map(function(o) { return '<code style="background:#f9f9f9; padding:1px 4px; border-radius:2px; margin:1px;">' + _escHtml(o) + '</code>'; }).join(', ') + '</div>';
        }
        html += '</div>';
        html += '</div>';
      }
      listEl.innerHTML = html;
    }

    function srrToggleGlossaryEntry(el) {
      var detail = el.querySelector('.srr-glossary-detail');
      if (!detail) return;
      var isOpen = detail.style.display !== 'none';
      detail.style.display = isOpen ? 'none' : 'block';
      el.classList.toggle('expanded', !isOpen);
    }

    function srrFilterGlossary() {
      var searchEl = document.getElementById('srr-glossary-search');
      var query = (searchEl && searchEl.value || '').toLowerCase().trim();
      var fields = window._srrGlossaryFields || [];
      var sheetFilter = window._srrGlossarySheetFilter || 'all';
      var filtered = [];
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        if (sheetFilter !== 'all' && f.sheet !== sheetFilter) continue;
        if (query) {
          var searchable = ((f.field_label || '') + ' ' + (f.field_key || '') + ' ' + (f.definition || '') + ' ' + (f.sheet || '')).toLowerCase();
          if (searchable.indexOf(query) === -1) continue;
        }
        filtered.push(f);
      }
      srrRenderGlossaryList(filtered);
    }

    function srrFilterGlossarySheet(sheet) {
      window._srrGlossarySheetFilter = sheet;
      var chips = document.querySelectorAll('#srr-glossary-sheet-filter .srr-filter-chip');
      for (var i = 0; i < chips.length; i++) {
        var isActive = chips[i].getAttribute('data-gsheet') === sheet;
        chips[i].classList.toggle('active', isActive);
        chips[i].style.background = isActive ? '#e3f2fd' : '#f5f5f5';
        chips[i].style.color = isActive ? '#1565c0' : '#666';
        chips[i].style.borderColor = isActive ? '#bbdefb' : '#ddd';
      }
      srrFilterGlossary();
    }

    function _escHtml(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

        function srrSelectField(fieldKey) {
      // Highlight selected field
      document.querySelectorAll('.srr-field-item').forEach(function(el) {
        el.classList.remove('active');
      });
      var selected = document.querySelector('.srr-field-item[data-field="' + fieldKey + '"]');
      if (selected) selected.classList.add('active');
      
      srrState.selectedField = fieldKey;
      
      // Update document viewer highlight placeholder
      srrUpdateViewerHighlight(fieldKey);
      
      // Update evidence anchors list
      srrUpdateAnchorList(fieldKey);
      
      // v1.5.3 Fix: Update Patch Editor to reflect the selected field's patch type
      var fieldState = srrState.fieldStates[fieldKey] || 'todo';
      var fieldChange = srrState.patchDraft.changes ? srrState.patchDraft.changes[fieldKey] : null;
      
      // v1.5.3 Fix: For verifier mode, derive patch type from submitted change in payload
      var fieldPatchType = 'correction';
      if (srrState.verifierMode && srrState.verifierPayload) {
        var payload = srrState.verifierPayload;
        var submittedChange = null;
        
        // Find submitted change for this field
        if (payload.field === fieldKey) {
          submittedChange = { category: payload.patch_type || payload.category };
        }
        if (payload.changes && Array.isArray(payload.changes)) {
          payload.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
        if (payload.body && payload.body.changes) {
          payload.body.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
        
        // Derive patch type from submitted change
        if (submittedChange && submittedChange.category) {
          var cat = submittedChange.category.toLowerCase();
          if (cat === 'rfi' || cat.includes('rfi')) fieldPatchType = 'rfi';
          else if (cat === 'blacklist' || cat === 'blacklist flag') fieldPatchType = 'blacklist';
        } else if (submittedChange && submittedChange.patch_type) {
          fieldPatchType = submittedChange.patch_type;
        }
      } else {
        // Analyst mode: derive from field state or draft changes
        if (fieldState === 'rfi' || fieldState === 'rfi_pending') {
          fieldPatchType = 'rfi';
        } else if (fieldState === 'blocked') {
          fieldPatchType = 'blacklist';
        } else if (fieldChange && fieldChange.category) {
          if (fieldChange.category === 'RFI') fieldPatchType = 'rfi';
          else if (fieldChange.category === 'Blacklist Flag') fieldPatchType = 'blacklist';
        }
      }
      
      // v1.5.3 Fix: Always update patch editor when selecting a field (not just when type changes)
      srrState.patchType = fieldPatchType;
      
      // Update patch type chips
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === fieldPatchType) chip.classList.add('active');
      });
      
      // Update form sections visibility
      srrUpdatePatchFormSections();
      
      // v1.5.3 Fix: Use different rendering for verifier mode vs analyst mode
      if (srrState.verifierMode) {
        // Verifier mode: show read-only summary for the selected field
        srrRenderPatchEditorForField(fieldKey);
      } else {
        // Analyst mode: use interactive patch editor
        srrRenderPatchEditor();
      }
      
      console.log('[SRR] Selected field:', fieldKey, 'state:', fieldState, 'patchType:', fieldPatchType);
    }
    
    function srrRenderPatchEditorForField(fieldKey) {
      // v1.5.3: Render Patch Review for verifier mode - shows submitted patch data with actions
      var container = document.getElementById('srr-patch-editor-fields');
      if (!container) return;
      
      var fieldState = srrState.fieldStates[fieldKey] || 'todo';
      var record = srrState.currentRecord;
      var currentVal = record ? record[fieldKey] : '';
      
      // v1.5.3 Fix: Load submitted patch data from verifier payload (not just local draft)
      var payload = srrState.verifierPayload;
      var submittedChange = null;
      
      // Check if payload has this field's change
      if (payload) {
        // Single-field payload
        if (payload.field === fieldKey) {
          submittedChange = {
            old_value: payload.old_value,
            new_value: payload.new_value,
            justification: payload.justification,
            category: payload.patch_type || payload.category
          };
        }
        // Multi-field payload (changes array)
        if (payload.changes && Array.isArray(payload.changes)) {
          payload.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
        // PatchRequest with body.changes
        if (payload.body && payload.body.changes && Array.isArray(payload.body.changes)) {
          payload.body.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
      }
      
      // Fallback to local draft if no submitted change found
      if (!submittedChange && srrState.patchDraft.changes) {
        submittedChange = srrState.patchDraft.changes[fieldKey];
      }
      
      // v1.5.3 Fix: Derive patch type from submitted change category (per-field, not global)
      var fieldPatchType = 'correction';
      if (submittedChange && submittedChange.category) {
        var cat = submittedChange.category.toLowerCase();
        if (cat === 'rfi' || cat.includes('rfi')) fieldPatchType = 'rfi';
        else if (cat === 'blacklist' || cat === 'blacklist flag') fieldPatchType = 'blacklist';
      } else if (submittedChange && submittedChange.patch_type) {
        fieldPatchType = submittedChange.patch_type;
      } else {
        // Fallback to field state
        if (fieldState === 'rfi' || fieldState === 'rfi_pending') fieldPatchType = 'rfi';
        else if (fieldState === 'blocked') fieldPatchType = 'blacklist';
      }
      
      var typeColor = fieldPatchType === 'rfi' ? '#7b1fa2' : (fieldPatchType === 'blacklist' ? '#c62828' : '#1565c0');
      var typeLabel = fieldPatchType.toUpperCase();
      
      var html = '<div style="padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ' + typeColor + ';">';
      html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">';
      html += '<span style="font-weight: 600;">Field: ' + fieldKey + '</span>';
      html += '<span style="background: ' + typeColor + '; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em;">' + typeLabel + '</span>';
      html += '</div>';
      
      // Current/Old value
      var oldValue = (submittedChange && submittedChange.old_value !== undefined) ? submittedChange.old_value : currentVal;
      html += '<div style="margin-bottom: 8px;">';
      html += '<span style="font-size: 0.75em; color: #888;">Current Value:</span> ';
      html += '<span style="font-family: monospace; color: #666; text-decoration: ' + (submittedChange ? 'line-through' : 'none') + ';">' + (oldValue || '(empty)') + '</span>';
      html += '</div>';
      
      // Show submitted change details
      if (submittedChange) {
        if (submittedChange.new_value !== undefined) {
          html += '<div style="margin-bottom: 8px;">';
          html += '<span style="font-size: 0.75em; color: #888;">Proposed Value:</span> ';
          html += '<span style="font-family: monospace; color: #2e7d32; font-weight: 600;">' + (submittedChange.new_value || '(empty)') + '</span>';
          html += '</div>';
        }
        if (submittedChange.justification) {
          html += '<div style="margin-bottom: 8px;">';
          html += '<span style="font-size: 0.75em; color: #888;">Justification:</span> ';
          html += '<span>' + submittedChange.justification + '</span>';
          html += '</div>';
        }
        if (submittedChange.comment) {
          html += '<div style="margin-bottom: 8px;">';
          html += '<span style="font-size: 0.75em; color: #888;">Comment:</span> ';
          html += '<span style="font-style: italic;">' + submittedChange.comment + '</span>';
          html += '</div>';
        }
      }
      
      // Field state indicator
      html += '<div style="margin-bottom: 8px;">';
      html += '<span style="font-size: 0.75em; color: #888;">Review Status:</span> ';
      var stateColor = fieldState === 'verified' ? '#2e7d32' : 
                       fieldState === 'rfi_pending' ? '#7b1fa2' : 
                       fieldState === 'blocked' ? '#c62828' : '#1565c0';
      var stateLabel = fieldState === 'verified' ? 'APPROVED' : 
                       fieldState === 'rfi_pending' ? 'NEEDS CLARIFICATION' : 
                       fieldState === 'blocked' ? 'REJECTED' : 'PENDING REVIEW';
      html += '<span style="color: ' + stateColor + '; font-weight: 500;">' + stateLabel + '</span>';
      html += '</div>';
      
      // v1.5.3: Add verifier action buttons for non-final states
      if (fieldState !== 'verified' && fieldState !== 'submitted') {
        html += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0; display: flex; gap: 8px; flex-wrap: wrap;">';
        html += '<button onclick="verifierApproveField(\'' + fieldKey + '\')" style="padding: 6px 12px; background: #2e7d32; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Approve</button>';
        html += '<button onclick="verifierRequestClarification(\'' + fieldKey + '\')" style="padding: 6px 12px; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Request Clarification</button>';
        html += '<button onclick="verifierRejectField(\'' + fieldKey + '\')" style="padding: 6px 12px; background: #c62828; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Reject</button>';
        html += '</div>';
      }
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    function verifierApproveField(fieldKey) {
      // v1.5.3: Verifier approves a field change - integrates with canonical workflow
      var patchRequestId = srrState.currentPatchRequestId;
      var patchRequest = patchRequestId ? PATCH_REQUEST_STORE.get(patchRequestId) : null;
      
      srrState.fieldStates[fieldKey] = 'verified';
      
      // Update PatchRequest and log audit event
      if (patchRequest) {
        if (!patchRequest.field_decisions) patchRequest.field_decisions = {};
        patchRequest.field_decisions[fieldKey] = {
          decision: 'approved',
          by: currentMode,
          at: new Date().toISOString()
        };
        
        // Check if all fields are approved - update overall status
        var allApproved = checkAllFieldsApproved(patchRequest);
        if (allApproved) {
          patchRequest.status = currentMode === 'admin' ? 'resolved' : 'sent_to_admin';
        }
        
        // Log audit event (canonical pattern)
        if (!patchRequest.audit_log) patchRequest.audit_log = [];
        patchRequest.audit_log.push({
          event: 'FIELD_APPROVED',
          field: fieldKey,
          by: currentMode,
          actor: getActorForRole(currentMode),
          at: new Date().toISOString()
        });
        
        PATCH_REQUEST_STORE.update(patchRequestId, patchRequest);
      }
      
      // Update Verifier Review state if we're in that context
      if (vrState.currentPatchId && patchRequest) {
        vrState.reviewState = 'Under_Review';
        vrUpdateStateBadge();
        vrUpdateActionButtons();
      }
      
      showToast('Approved: ' + fieldKey, 'success');
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditorForField(fieldKey);
      console.log('[Verifier] Approved field:', fieldKey);
      AuditTimeline.emit('FIELD_VERIFIED', {
        record_id: srrState.currentRecordKey || '',
        field_key: fieldKey,
        file_id: srrState.currentSheetName || '',
        patch_request_id: patchRequestId || '',
        metadata: { decision: 'approved', by_verifier: true }
      });
    }
    
    function verifierRequestClarification(fieldKey) {
      // v1.5.3: Verifier requests clarification - integrates with canonical workflow
      var patchRequestId = srrState.currentPatchRequestId;
      var patchRequest = patchRequestId ? PATCH_REQUEST_STORE.get(patchRequestId) : null;
      
      srrState.fieldStates[fieldKey] = 'rfi_pending';
      
      // Update PatchRequest and log audit event
      if (patchRequest) {
        if (!patchRequest.field_decisions) patchRequest.field_decisions = {};
        patchRequest.field_decisions[fieldKey] = {
          decision: 'needs_clarification',
          by: currentMode,
          at: new Date().toISOString()
        };
        patchRequest.status = 'needs_clarification';
        
        // Log audit event (canonical pattern)
        if (!patchRequest.audit_log) patchRequest.audit_log = [];
        patchRequest.audit_log.push({
          event: 'REQUEST_CLARIFICATION',
          field: fieldKey,
          by: currentMode,
          actor: getActorForRole(currentMode),
          at: new Date().toISOString()
        });
        
        PATCH_REQUEST_STORE.update(patchRequestId, patchRequest);
      }
      
      // Update Verifier Review state
      if (vrState.currentPatchId) {
        vrState.reviewState = 'Needs_Clarification';
        vrUpdateStateBadge();
        vrUpdateActionButtons();
        vrRenderDecisionSummary();
      }
      
      showToast('Clarification requested: ' + fieldKey, 'info');
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditorForField(fieldKey);
      console.log('[Verifier] Request clarification for field:', fieldKey);
      AuditTimeline.emit('REQUEST_CLARIFICATION', {
        record_id: srrState.currentRecordKey || '',
        field_key: fieldKey,
        file_id: srrState.currentSheetName || '',
        patch_request_id: patchRequestId || '',
        metadata: { decision: 'needs_clarification' }
      });
    }
    
    function verifierRejectField(fieldKey) {
      // v1.5.3: Verifier rejects a field change - integrates with canonical workflow
      var patchRequestId = srrState.currentPatchRequestId;
      var patchRequest = patchRequestId ? PATCH_REQUEST_STORE.get(patchRequestId) : null;
      
      srrState.fieldStates[fieldKey] = 'blocked';
      
      // Update PatchRequest and log audit event
      if (patchRequest) {
        if (!patchRequest.field_decisions) patchRequest.field_decisions = {};
        patchRequest.field_decisions[fieldKey] = {
          decision: 'rejected',
          by: currentMode,
          at: new Date().toISOString()
        };
        
        // Log audit event (canonical pattern)
        if (!patchRequest.audit_log) patchRequest.audit_log = [];
        patchRequest.audit_log.push({
          event: 'FIELD_REJECTED',
          field: fieldKey,
          by: currentMode,
          actor: getActorForRole(currentMode),
          at: new Date().toISOString()
        });
        
        PATCH_REQUEST_STORE.update(patchRequestId, patchRequest);
      }
      
      showToast('Rejected: ' + fieldKey, 'warning');
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditorForField(fieldKey);
      console.log('[Verifier] Rejected field:', fieldKey);
      UndoManager.push({ field_key: fieldKey, before_value: beforeVal, after_value: newVal, record_id: srrState.currentRecordKey || '', sheet: srrState.currentSheetName, row_index: srrState.currentRowIndex, source: 'srr_inline', artifact_status: null });
      AuditTimeline.emit('FIELD_CORRECTED', {
        record_id: srrState.currentRecordKey || '',
        field_key: fieldKey,
        file_id: srrState.currentSheetName || '',
        patch_request_id: patchRequestId || '',
        metadata: { decision: 'rejected' }
      });
    }
    
    function checkAllFieldsApproved(patchRequest) {
      // v1.5.3: Check if all fields in the PatchRequest have been approved
      if (!patchRequest.field_decisions) return false;
      
      var changedFields = [];
      
      // Collect all changed field keys
      if (patchRequest.field) changedFields.push(patchRequest.field);
      if (patchRequest.changes) {
        patchRequest.changes.forEach(function(c) {
          if (c.field) changedFields.push(c.field);
        });
      }
      if (patchRequest.body && patchRequest.body.changes) {
        patchRequest.body.changes.forEach(function(c) {
          if (c.field) changedFields.push(c.field);
        });
      }
      
      // Check all fields have approved decision
      for (var i = 0; i < changedFields.length; i++) {
        var fk = changedFields[i];
        var decision = patchRequest.field_decisions[fk];
        if (!decision || decision.decision !== 'approved') {
          return false;
        }
      }
      
      return changedFields.length > 0;
    }
    
    // PDF anchor search state
    var pdfMatchState = { matches: [], current: -1, fieldKey: '', loading: false, searchToken: 0, searchQuery: '' };
    var pdfMatchDismissTimer = null;

    function pdfMatchDismiss() {
      if (pdfMatchDismissTimer) { clearTimeout(pdfMatchDismissTimer); pdfMatchDismissTimer = null; }
      var hadSearch = pdfMatchState.searchQuery;
      pdfMatchState = { matches: [], current: -1, fieldKey: '', loading: false, searchToken: pdfMatchState.searchToken, searchQuery: '' };
      var bar = document.getElementById('srr-pdf-match-bar');
      if (bar) bar.classList.remove('visible');
      if (hadSearch) {
        srrForcePageNav(srrState.docPage || 1, '');
      }
    }

    function pdfMatchUpdateBar() {
      var bar = document.getElementById('srr-pdf-match-bar');
      var fieldEl = document.getElementById('match-bar-field');
      var countEl = document.getElementById('match-bar-count');
      var prevBtn = document.getElementById('match-bar-prev');
      var nextBtn = document.getElementById('match-bar-next');
      if (!bar) return;

      var displayLabel = pdfMatchState.fieldKey.replace(/_c$/, '').replace(/_/g, ' ');
      fieldEl.textContent = displayLabel;

      if (pdfMatchState.loading) {
        countEl.innerHTML = '<span class="match-loading">Searching...</span>';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        bar.classList.add('visible');
        return;
      }

      bar.classList.remove('has-match');
      if (pdfMatchState.matches.length === 0) {
        countEl.innerHTML = '<span class="match-not-found">No match found</span>';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        bar.classList.add('visible');
        if (pdfMatchDismissTimer) clearTimeout(pdfMatchDismissTimer);
        var dismissToken = pdfMatchState.searchToken;
        pdfMatchDismissTimer = setTimeout(function() {
          if (pdfMatchState.searchToken === dismissToken) pdfMatchDismiss();
        }, 3000);
        return;
      }

      countEl.textContent = 'Match ' + (pdfMatchState.current + 1) + ' of ' + pdfMatchState.matches.length;
      prevBtn.disabled = pdfMatchState.matches.length <= 1;
      nextBtn.disabled = pdfMatchState.matches.length <= 1;
      bar.classList.add('visible');
      bar.classList.add('has-match');
      var docFrame = document.querySelector('.srr-doc-frame');
      if (docFrame) {
        docFrame.classList.remove('match-active');
        void docFrame.offsetWidth;
        docFrame.classList.add('match-active');
      }
    }

    function pdfMatchNav(dir) {
      if (pdfMatchState.matches.length === 0) return;
      pdfMatchState.current = (pdfMatchState.current + dir + pdfMatchState.matches.length) % pdfMatchState.matches.length;
      var page = pdfMatchState.matches[pdfMatchState.current];
      pdfMatchUpdateBar();
      srrNavigateToPage(page);
    }

    function srrNavigateToPage(pageNum) {
      srrState.docPage = pageNum;
      var searchQ = pdfMatchState.searchQuery || '';
      srrForcePageNav(pageNum, searchQ);
      console.log('[PDF_ANCHOR] Navigating to page', pageNum, searchQ ? '(search: ' + searchQ.substring(0, 20) + ')' : '');
    }

    function srrForcePageNav(pageNum, searchText) {
      var obj = document.getElementById('srr-pdf-object');
      if (!obj || !srrState.currentPdfUrl) return;
      srrUpdatePageDisplay();
      var baseUrl = srrState.currentPdfUrl.split('#')[0];
      var fragment = '#page=' + pageNum + '&navpanes=0&scrollbar=1&toolbar=1&view=FitH';
      if (srrState.useFragmentZoom !== false) {
        fragment += '&zoom=' + srrState.zoom;
      }
      if (searchText) {
        fragment += '&search=' + encodeURIComponent(searchText);
      }
      var newSrc = baseUrl + fragment;
      var currentData = obj.data || '';
      var currentBase = currentData.split('#')[0];
      var currentFragment = currentData.split('#')[1] || '';
      var currentPage = '';
      var currentSearch = '';
      var fragParts = currentFragment.split('&');
      for (var fp = 0; fp < fragParts.length; fp++) {
        if (fragParts[fp].indexOf('page=') === 0) currentPage = fragParts[fp].split('=')[1];
        if (fragParts[fp].indexOf('search=') === 0) currentSearch = decodeURIComponent(fragParts[fp].split('=')[1] || '');
      }
      var sameBase = currentBase === baseUrl;
      var samePage = currentPage === String(pageNum);
      var sameSearch = currentSearch === (searchText || '');
      if (sameBase && samePage && sameSearch) {
        _p1eLog('nav_skip_unchanged', { page: pageNum, search: (searchText || '').substring(0, 20) });
        return;
      }
      _p1eLog('nav_update', { page: pageNum, search: (searchText || '').substring(0, 20), reload: !sameBase ? 'full' : 'fragment' });
      setTimeout(function() {
        obj.data = newSrc;
        var openTabLink = document.getElementById('srr-pdf-open-tab');
        if (openTabLink) openTabLink.href = newSrc;
      }, sameBase ? 50 : 120);
    }

    function srrClearHighlight() {
      pdfMatchDismiss();
    }

    function srrUpdateViewerHighlight(fieldKey) {
      if (!fieldKey) { pdfMatchDismiss(); return; }

      var record = srrState.currentRecord;
      if (!record) { pdfMatchDismiss(); _p1eLog('highlight_abort', 'no_record'); return; }
      var value = record[fieldKey];
      if (!value || (typeof value === 'string' && !value.trim())) {
        pdfMatchState = { matches: [], current: -1, fieldKey: fieldKey, loading: false, searchToken: pdfMatchState.searchToken, searchQuery: '' };
        pdfMatchUpdateBar();
        _p1eLog('highlight_skip', { field: fieldKey, reason: 'empty_value' });
        return;
      }
      var searchQuery = String(value).trim();
      var fileUrl = srrResolveFieldValue(record, 'file_url');
      if (!fileUrl) {
        showToast('No document URL for text search', 'info');
        _p1eLog('highlight_abort', { field: fieldKey, reason: 'no_file_url' });
        return;
      }

      _p1eLog('anchor_search_start', { field: fieldKey, query: searchQuery.substring(0, 40), url: fileUrl.substring(0, 60) });

      if (pdfMatchDismissTimer) { clearTimeout(pdfMatchDismissTimer); pdfMatchDismissTimer = null; }
      var token = ++pdfMatchState.searchToken;
      pdfMatchState = { matches: [], current: -1, fieldKey: fieldKey, loading: true, searchToken: token, searchQuery: searchQuery };
      pdfMatchUpdateBar();

      var proxyBase = window._pdfProxyBaseUrl || '';
      var apiUrl = proxyBase + '/api/pdf/text?url=' + encodeURIComponent(fileUrl);

      _p1eLog('text_extract_request', { url: apiUrl.substring(0, 80) });

      fetch(apiUrl)
        .then(function(r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
        .then(function(data) {
          if (pdfMatchState.searchToken !== token) return;
          var pages = data.pages || [];
          _p1eDiagState.pageCount = pages.length;
          _p1eDiagState.sourceUrl = fileUrl;
          _p1eDiagState.lastLoaded = new Date();

          _p1eLog('text_extract_ok', { pages: pages.length, totalChars: pages.reduce(function(s, p) { return s + (p.text || '').length; }, 0) });

          var nonSearch = _p1eDetectNonSearchable(pages);
          if (nonSearch.nonSearchable) {
            _p1eDiagState.textStatus = 'non_searchable';
            _p1eLog('text_not_searchable', { reason: nonSearch.reason });
            _p1eRouteToPreFlight(record, 'TEXT_NOT_SEARCHABLE', 'PDF text is not searchable: ' + nonSearch.reason);
            pdfMatchState.matches = [];
            pdfMatchState.loading = false;
            pdfMatchUpdateBar();
            return;
          }

          var allText = pages.map(function(p) { return p.text || ''; }).join(' ');
          var mojibake = _p1eDetectMojibake(allText);
          if (mojibake.isMojibake) {
            _p1eDiagState.textStatus = 'mojibake';
            _p1eLog('mojibake_detected', { reason: mojibake.reason, ratio: mojibake.ratio });
            _p1eRouteToPreFlight(record, 'OCR_UNREADABLE', 'PDF text contains encoding artifacts (mojibake): ' + mojibake.reason);
          } else {
            _p1eDiagState.textStatus = 'ok';
          }

          var result = _p1eMatchInPages(pages, searchQuery);
          _p1eDiagState.matchAttempts = result.attempts;

          pdfMatchState.matches = result.matchPages;
          pdfMatchState.loading = false;
          pdfMatchState.searchQuery = result.variant;
          if (result.matchPages.length > 0) {
            pdfMatchState.current = 0;
            srrNavigateToPage(result.matchPages[0]);
            _p1eLog('anchor_page_jump', { page: result.matchPages[0], totalMatches: result.matchPages.length });
          } else {
            _p1eLog('anchor_no_match', { field: fieldKey, query: searchQuery.substring(0, 40) });
          }
          pdfMatchUpdateBar();
          _p1eLog('highlight_complete', { field: fieldKey, matchCount: result.matchPages.length, status: result.matchPages.length > 0 ? 'PASS' : 'FAIL' });
        })
        .catch(function(err) {
          if (pdfMatchState.searchToken !== token) return;
          _p1eLog('text_extract_fail', { error: err.message, url: fileUrl.substring(0, 60) });
          _p1eDiagState.textStatus = 'error';
          pdfMatchState.loading = false;
          pdfMatchState.matches = [];
          pdfMatchUpdateBar();
        });
    }

    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        var bar = document.getElementById('srr-pdf-match-bar');
        if (bar && bar.classList.contains('visible')) {
          pdfMatchDismiss();
        }
      }
    });
    
    function srrUpdateAnchorList(fieldKey) {
      var container = document.getElementById('srr-anchor-list');
      if (!container) return;
      
      if (!fieldKey) {
        container.innerHTML = '<div style="font-size: 0.8em; font-weight: 600; color: #666; margin-bottom: 8px;">Evidence Anchors</div>' +
          '<div class="srr-empty-state" style="padding: 10px;">Select a field to search in document</div>';
        return;
      }
      
      var record = srrState.currentRecord;
      var value = record ? record[fieldKey] : null;
      var hasValue = value && String(value).trim();
      var displayLabel = fieldKey.replace(/_c$/, '').replace(/_/g, ' ');
      
      container.innerHTML = '<div style="font-size: 0.8em; font-weight: 600; color: #666; margin-bottom: 8px;">Evidence Anchors</div>' +
        '<div class="srr-anchor-item" onclick="srrJumpToAnchor(\'' + fieldKey + '\')" style="' + (hasValue ? '' : 'opacity: 0.5; cursor: default;') + '">' +
          '<div style="font-weight: 500;">' + escapeHtml(displayLabel) + '</div>' +
          '<div style="font-size: 0.75em; color: #888;">' + (hasValue ? 'Click to find in document' : 'No value to search') + '</div>' +
        '</div>';
    }
    
    function srrJumpToAnchor(fieldKey) {
      console.log('[SRR] Anchor search for:', fieldKey);
      srrUpdateViewerHighlight(fieldKey);
    }
    
    function renderSrrPatchList() {
      var container = document.getElementById('srr-patch-list');
      var changes = srrState.patchDraft.changes || [];
      var patchStatus = srrState.patchDraft.status || 'Draft';
      
      if (changes.length === 0) {
        container.innerHTML = '<div class="srr-empty-state" style="padding: 12px;">No changes proposed yet</div>';
        return;
      }
      
      // Status-based badge styling
      var statusBadge = patchStatus === 'Submitted' 
        ? '<span class="srr-patch-status submitted">Submitted</span>'
        : '<span class="srr-patch-status draft">Draft</span>';
      
      var html = '<div class="srr-patch-header">Proposed Changes ' + statusBadge + '</div>';
      html += changes.map(function(c, idx) {
        var categoryColor = c.category === 'RFI' ? '#673ab7' : (c.category === 'Blacklist Flag' ? '#f44336' : '#1565c0');
        var fromVal = c.before !== null && c.before !== undefined && c.before !== '' ? c.before : '(empty)';
        var toVal = c.after !== null && c.after !== undefined && c.after !== '' ? c.after : '(empty)';
        
        return '<div class="srr-proposed-change">' +
          '<div class="srr-proposed-change-header">' +
            '<div class="srr-proposed-change-field">' + (c.label || c.path) + ' <span style="font-weight: normal; color: #888; font-size: 0.8em;">(' + c.path + ')</span></div>' +
            '<span style="font-size: 0.7em; padding: 2px 6px; border-radius: 8px; background: ' + categoryColor + '; color: white;">' + (c.category || 'Correction') + '</span>' +
          '</div>' +
          '<div class="srr-proposed-change-values">' +
            '<span class="srr-proposed-change-from">' + fromVal + '</span>' +
            '<span style="color: #666;">→</span>' +
            '<span class="srr-proposed-change-to">' + toVal + '</span>' +
          '</div>' +
          (c.justification ? '<div style="font-size: 0.75em; color: #666; margin-top: 4px;"><strong>Why:</strong> ' + c.justification + '</div>' : '') +
        '</div>';
      }).join('');
      
      container.innerHTML = html;
    }
    
    // PDF Viewer State Persistence
    var SRR_PDF_STATE_KEY = 'orchestrate.srr_pdf_state.v1';
    
    function getSrrPdfStateKey(record) {
      if (!record) return null;
      // v1.4.15: Use field resolver for cache key with Salesforce-style columns
      return (record.contract_key || '') + '|' + srrResolveFieldValue(record, 'file_url') + '|' + srrResolveFieldValue(record, 'file_name');
    }
    
    function loadSrrPdfState(record) {
      try {
        var key = getSrrPdfStateKey(record);
        if (!key) return { page: 1, zoom: 1 };
        var allState = JSON.parse(localStorage.getItem(SRR_PDF_STATE_KEY) || '{}');
        return allState[key] || { page: 1, zoom: 1 };
      } catch (e) { return { page: 1, zoom: 1 }; }
    }
    
    function saveSrrPdfState(record) {
      try {
        var key = getSrrPdfStateKey(record);
        if (!key) return;
        var allState = JSON.parse(localStorage.getItem(SRR_PDF_STATE_KEY) || '{}');
        allState[key] = { page: srrState.docPage, zoom: srrState.zoom };
        localStorage.setItem(SRR_PDF_STATE_KEY, JSON.stringify(allState));
      } catch (e) { console.warn('[SRR] Failed to save PDF state:', e); }
    }
    
    // v1.4.13: Helper to coerce and validate PDF URL
    function srrNormalizePdfValue(val) {
      if (val === null || val === undefined) return '';
      return String(val).trim();
    }
    
    // v1.4.15: Resolve file_url/file_name from record using column mapping or case-insensitive key scan
    var SRR_FILE_URL_ALIASES = ['file_url', 'fileurl', 'file url', 'url', 'contract source', 'contract url', 'pdf url', 'source', 'document_url', 'doc_url', 'link', 'file_url_c', 'file_url__c'];
    var SRR_FILE_NAME_ALIASES = ['file_name', 'filename', 'file name', 'contract file', 'contract file name', 'document', 'doc_name', 'file_name_c', 'file_name__c'];
    
    function _srrResolveRecordName(record) {
      if (!record) return '';
      var NAME_FIELDS = [
        'Account_Name_c', 'Account_Name__c', 'Account_Name', 'account_name',
        'Artist_Name_pka_or_dba_c', 'Artist_Name__c', 'Artist_Name',
        'Legal_Name_c', 'Legal_Name__c', 'Legal_Name',
        'Name', 'name', 'Payee_c', 'Payee__c',
        'Company_Name_c', 'Company_Name__c', 'Company_Name',
        'Contact_Name_c', 'Contact_Name__c', 'Contact_Name',
        'Opportunity_Name_c', 'Opportunity_Name__c', 'Opportunity_Name',
        'Contract_Name_c', 'Contract_Name__c', 'Contract_Name',
        'Display_Name_c', 'Display_Name__c', 'Display_Name'
      ];
      for (var i = 0; i < NAME_FIELDS.length; i++) {
        var v = record[NAME_FIELDS[i]];
        if (v && typeof v === 'string' && v.trim() && v.trim() !== 'N/A' && v.trim() !== '-' && v.trim().length > 1) {
          return v.trim();
        }
      }
      return record.contract_key || '';
    }

    function srrResolveFieldValue(record, fieldType) {
      if (!record) return '';
      
      // First try column mapping state (set during workbook parsing)
      if (fieldType === 'file_url' && COLUMN_MAPPING_STATE.fileUrlColumn) {
        var val = record[COLUMN_MAPPING_STATE.fileUrlColumn];
        if (val) return srrNormalizePdfValue(val);
      }
      if (fieldType === 'file_name' && COLUMN_MAPPING_STATE.fileNameColumn) {
        var val = record[COLUMN_MAPPING_STATE.fileNameColumn];
        if (val) return srrNormalizePdfValue(val);
      }
      
      // Fallback: scan all record keys for aliases (case-insensitive)
      var aliases = fieldType === 'file_url' ? SRR_FILE_URL_ALIASES : SRR_FILE_NAME_ALIASES;
      var keys = Object.keys(record);
      
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var keyLower = key.toLowerCase().replace(/__/g, '_').replace(/_c$/, '');
        
        for (var j = 0; j < aliases.length; j++) {
          var alias = aliases[j].toLowerCase().replace(/_/g, '').replace(/\s+/g, '');
          var keyNorm = keyLower.replace(/_/g, '');
          if (keyNorm === alias || keyLower === aliases[j]) {
            var val = record[key];
            if (val) return srrNormalizePdfValue(val);
          }
        }
      }
      
      return '';
    }
    
    // v1.6.54: File Action Bar functions
    function srrUpdateFileActionBar(fileName, fileUrl) {
      var nameEl = document.getElementById('srr-action-bar-filename');
      var editBtn = document.getElementById('srr-edit-link-btn');
      var downloadBtn = document.getElementById('srr-download-btn');
      var editBar = document.getElementById('srr-edit-link-bar');
      if (editBar) editBar.style.display = 'none';
      
      if (nameEl) {
        if (fileName) {
          var formatted = fileName.replace(/_/g, ' ').replace(/\.pdf$/i, '').trim();
          nameEl.textContent = formatted;
          nameEl.title = fileName;
        } else {
          nameEl.textContent = 'No file loaded';
          nameEl.title = '';
        }
      }
      
      if (downloadBtn) {
        if (fileUrl) {
          downloadBtn.href = fileUrl;
          downloadBtn.removeAttribute('disabled');
          downloadBtn.style.pointerEvents = '';
          downloadBtn.style.opacity = '';
          downloadBtn.title = 'Download file';
        } else {
          downloadBtn.href = '#';
          downloadBtn.setAttribute('disabled', 'true');
          downloadBtn.style.pointerEvents = 'none';
          downloadBtn.style.opacity = '0.4';
          downloadBtn.title = 'No file URL available';
        }
      }
    }
    
    var _srrEditLinkOriginalUrl = '';
    
    function srrToggleEditLink() {
      var actionBar = document.getElementById('srr-file-action-bar');
      var editBar = document.getElementById('srr-edit-link-bar');
      var editInput = document.getElementById('srr-edit-link-input');
      if (!editBar || !editInput) return;
      
      var record = srrState.currentRecord;
      var currentUrl = record ? srrResolveFieldValue(record, 'file_url') : '';
      _srrEditLinkOriginalUrl = currentUrl;
      editInput.value = currentUrl;
      
      if (actionBar) actionBar.style.display = 'none';
      editBar.style.display = 'flex';
      editInput.focus();
    }
    
    function srrCancelEditLink() {
      var actionBar = document.getElementById('srr-file-action-bar');
      var editBar = document.getElementById('srr-edit-link-bar');
      if (actionBar) actionBar.style.display = 'flex';
      if (editBar) editBar.style.display = 'none';
    }
    
    function srrSaveEditLink() {
      var editInput = document.getElementById('srr-edit-link-input');
      if (!editInput) return;
      var newUrl = editInput.value.trim();
      
      var record = srrState.currentRecord;
      if (!record) { srrCancelEditLink(); return; }
      
      // Find the actual key used for file_url in this record
      var urlKey = null;
      if (COLUMN_MAPPING_STATE.fileUrlColumn) {
        urlKey = COLUMN_MAPPING_STATE.fileUrlColumn;
      } else {
        var SRR_FILE_URL_KEYS = ['File_URL_c', 'file_url', 'FileURL', 'File URL', 'File_Url_c', 'file_url_c'];
        for (var i = 0; i < SRR_FILE_URL_KEYS.length; i++) {
          if (record.hasOwnProperty(SRR_FILE_URL_KEYS[i])) {
            urlKey = SRR_FILE_URL_KEYS[i];
            break;
          }
        }
        if (!urlKey) urlKey = 'File_URL_c';
      }
      
      record[urlKey] = newUrl;
      
      // Also update in the sheet data if possible
      if (srrState.currentSheet && srrState.currentRowIdx !== undefined) {
        var sheetData = APP_STATE.allSheets[srrState.currentSheet];
        if (sheetData && sheetData[srrState.currentRowIdx]) {
          sheetData[srrState.currentRowIdx][urlKey] = newUrl;
        }
      }
      
      // Update action bar display
      var fileName = srrResolveFieldValue(record, 'file_name');
      srrUpdateFileActionBar(fileName, newUrl);
      
      // Reload the PDF viewer with the new URL
      srrCancelEditLink();
      if (typeof srrLoadPdfForRecord === 'function') {
        srrLoadPdfForRecord(record);
      }
    }

    function srrIsValidPdfUrl(url) {
      if (!url || typeof url !== 'string') return false;
      var lower = url.toLowerCase();
      if (!lower.startsWith('http://') && !lower.startsWith('https://')) return false;
      var pathPart = lower.split('?')[0];
      return pathPart.endsWith('.pdf') || lower.includes('.pdf?') || lower.includes('/pdf');
    }
    
    function srrHidePdfError() {
      var errorEl = document.getElementById('srr-pdf-error');
      if (errorEl) errorEl.style.display = 'none';
    }
    
    function srrShowPdfError(title, msg, networkUrl, hasLocalFallback) {
      var errorEl = document.getElementById('srr-pdf-error');
      var titleEl = document.getElementById('srr-pdf-error-title');
      var msgEl = document.getElementById('srr-pdf-error-msg');
      var openTabEl = document.getElementById('srr-pdf-open-tab');
      var useLocalBtn = document.getElementById('srr-pdf-use-local');
      
      if (!errorEl) return;
      
      if (titleEl) titleEl.textContent = title || 'PDF failed to render';
      if (msgEl) msgEl.textContent = msg || 'The document could not be displayed in the viewer.';
      
      if (openTabEl) {
        if (networkUrl) {
          openTabEl.href = networkUrl;
          openTabEl.style.display = 'inline';
        } else {
          openTabEl.style.display = 'none';
        }
      }
      
      if (useLocalBtn) {
        useLocalBtn.style.display = hasLocalFallback ? 'inline-block' : 'none';
      }
      
      errorEl.style.display = 'block';
    }
    
    function srrSwitchToLocalAttachment() {
      if (!srrState.localAttachmentFallback) {
        console.warn('[SRR_PDF] No local attachment fallback available');
        return;
      }
      
      srrHidePdfError();
      srrState.currentPdfUrl = srrState.localAttachmentFallback.url;
      srrState.pdfSourceType = 'Local Attachment';
      srrState.useFragmentZoom = true; // Local object URLs support fragments
      
      var sourceTypeEl = document.getElementById('srr-doc-source-type');
      var sourceNameEl = document.getElementById('srr-doc-source-name');
      if (sourceTypeEl) sourceTypeEl.textContent = 'Local Attachment:';
      if (sourceNameEl) sourceNameEl.textContent = srrState.localAttachmentFallback.name || '';
      
      srrUpdateIframeSrc();
      console.log('[SRR_PDF_LOAD] Switched to local attachment:', srrState.localAttachmentFallback.name);
    }
    
    // v1.4.13: Cache-aware PDF loading with offline support
    // v1.4.14: Build structured log entry with sheet/row context
    function srrBuildLogEntry(sourceType, cacheStatus, url) {
      return {
        sheetName: srrState.currentSheetName || 'unknown',
        rowIndex: srrState.currentRowIndex !== undefined ? srrState.currentRowIndex : -1,
        recordKey: srrState.currentRecordKey || 'unknown',
        file_name: srrState.currentRecord ? srrResolveFieldValue(srrState.currentRecord, 'file_name') : '',
        file_url: url ? (url.length > 60 ? url.substring(0, 60) + '...' : url) : '',
        sourceType: sourceType,
        cacheStatus: cacheStatus
      };
    }
    
    function srrLoadPdfForRecord(record) {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var iframeEl = document.getElementById('srr-pdf-object');
      var sourceEl = document.getElementById('srr-doc-source');
      var sourceTypeEl = document.getElementById('srr-doc-source-type');
      var sourceNameEl = document.getElementById('srr-doc-source-name');
      
      if (!emptyEl || !containerEl || !iframeEl) return;
      
      srrHidePdfError();
      srrState.localAttachmentFallback = null;
      srrState.useFragmentZoom = true;
      srrState.networkPdfUrl = null;
      srrState.cacheStatus = null;
      
      var attachments = [];
      try {
        attachments = JSON.parse(localStorage.getItem(STORAGE_KEY_PDF_ATTACHMENTS) || '[]');
      } catch (e) {}
      
      // v1.4.14: Use recordKey from srrState, fall back to record fields
      var recordId = srrState.currentRecordKey || (record ? (record.contract_key || record.id || 'unknown') : 'no-record');
      // v1.4.15: Use field resolver for Salesforce-style columns (File_URL_c, File_Name_c, etc)
      var fileUrl = record ? srrResolveFieldValue(record, 'file_url') : '';
      var fileName = record ? srrResolveFieldValue(record, 'file_name') : '';
      
      // Compute cache key for this record
      var cacheKey = computePdfCacheKey(recordId, fileUrl);
      
      // Check if network URL is valid
      var hasNetworkUrl = srrIsValidPdfUrl(fileUrl);
      
      // Track local fallback
      if (hasNetworkUrl && attachments.length > 0) {
        var fallbackMatch = fileName ? attachments.find(function(a) { return a.file_name === fileName; }) : attachments[0];
        if (fallbackMatch && fallbackMatch.local_object_url) {
          srrState.localAttachmentFallback = { url: fallbackMatch.local_object_url, name: fallbackMatch.file_name };
        }
      }
      
      // Try cache first for network URLs
      if (hasNetworkUrl) {
        srrState.networkPdfUrl = fileUrl;
        
        getCachedPdf(cacheKey).then(function(cachedBlob) {
          if (cachedBlob) {
            // Cache hit - render from cached blob
            var objectUrl = URL.createObjectURL(cachedBlob);
            srrState.cacheStatus = 'hit';
            srrRenderPdf(record, objectUrl, 'Cached', fileName || fileUrl.split('/').pop().split('?')[0], srrBuildLogEntry('Cached', 'hit', fileUrl));
            console.log('[PDF_CACHE] Cache hit for:', cacheKey);
          } else {
            // Cache miss - fetch from network
            srrFetchAndCachePdf(record, fileUrl, fileName, cacheKey, attachments);
          }
        });
      } else {
        // No network URL - try local attachments
        var pdfUrl = null;
        var sourceType = null;
        var sourceName = null;
        
        if (fileName && attachments.length > 0) {
          var match = attachments.find(function(a) { return a.file_name === fileName; });
          if (match && match.local_object_url) {
            pdfUrl = match.local_object_url;
            sourceType = 'Local Attachment';
            sourceName = match.file_name;
          }
        }
        
        if (!pdfUrl && attachments.length > 0 && attachments[0].local_object_url) {
          pdfUrl = attachments[0].local_object_url;
          sourceType = 'Local Attachment';
          sourceName = attachments[0].file_name;
        }
        
        if (pdfUrl) {
          srrRenderPdf(record, pdfUrl, sourceType, sourceName, srrBuildLogEntry(sourceType, 'local', 'local-attachment'));
        } else {
          srrShowEmptyState();
        }
      }
    }
    
    // v1.4.13: Fetch PDF from network and cache it
    // v1.4.14: Use structured log entries
    // v1.4.16: Route through FastAPI proxy to avoid CORS and download prompts
    function srrFetchAndCachePdf(record, networkUrl, fileName, cacheKey, attachments) {
      var recordId = srrState.currentRecordKey || (record ? (record.contract_key || record.id || 'unknown') : 'no-record');
      
      // v1.4.16: Build proxy URL if enabled
      var fetchUrl = networkUrl;
      var usingProxy = false;
      
      if (PDF_PROXY_CONFIG.ENABLED && networkUrl) {
        fetchUrl = PDF_PROXY_CONFIG.BASE_URL + '?url=' + encodeURIComponent(networkUrl);
        usingProxy = true;
        console.log('[SRR_PDF] Fetching via', PDF_PROXY_CONFIG.PROXY_TYPE, 'proxy:', fetchUrl.substring(0, 80));
      }
      
      // v1.4.17: Add auth header for Supabase proxy
      var fetchOptions = {};
      if (usingProxy && PDF_PROXY_CONFIG.AUTH_HEADER) {
        fetchOptions.headers = { 'Authorization': PDF_PROXY_CONFIG.AUTH_HEADER };
      } else if (!usingProxy) {
        fetchOptions.mode = 'cors';
      }
      
      fetch(fetchUrl, fetchOptions)
        .then(function(response) {
          if (!response.ok) throw new Error('HTTP ' + response.status);
          return response.blob();
        })
        .then(function(blob) {
          // Validate PDF signature (basic check: starts with %PDF)
          return blob.slice(0, 5).text().then(function(sig) {
            if (!sig.startsWith('%PDF')) {
              throw new Error('Invalid PDF signature');
            }
            return blob;
          });
        })
        .then(function(blob) {
          var objectUrl = URL.createObjectURL(blob);
          var sourceName = fileName || networkUrl.split('/').pop().split('?')[0];
          var sourceLabel = usingProxy ? 'Proxy' : 'URL';
          // Check if file is too large to cache
          if (blob.size > PDF_CACHE_CONFIG.MAX_FILE_BYTES) {
            srrState.cacheStatus = 'too-large';
            console.log('[PDF_CACHE] File too large to cache:', (blob.size / 1024 / 1024).toFixed(2), 'MB');
            srrRenderPdf(record, objectUrl, sourceLabel + ' (not cached)', sourceName, srrBuildLogEntry(sourceLabel, 'too-large', networkUrl));
          } else {
            // Cache the PDF
            cachePdf(cacheKey, networkUrl, blob).then(function(cached) {
              srrState.cacheStatus = cached ? 'cached' : 'cache-failed';
              srrRenderPdf(record, objectUrl, cached ? sourceLabel + ' (cached)' : sourceLabel, sourceName, srrBuildLogEntry(sourceLabel, cached ? 'cached' : 'cache-failed', networkUrl));
            });
          }
        })
        .catch(function(err) {
          console.warn('[SRR_PDF] Fetch failed:', err.message, usingProxy ? '(proxy)' : '(direct)');
          srrState.cacheStatus = usingProxy ? 'proxy-failed' : 'cors-blocked';
          // v1.4.16: If proxy failed, show clear message
          if (usingProxy) {
            // Proxy unavailable - show deterministic message
            if (srrState.localAttachmentFallback) {
              srrRenderPdf(record, srrState.localAttachmentFallback.url, 'Local Attachment (proxy unavailable)', srrState.localAttachmentFallback.name, srrBuildLogEntry('Local Attachment', 'proxy-fallback', 'local-attachment'));
              showToast('Proxy unavailable - using local attachment', 'warning');
            } else {
              srrShowOfflineStub(networkUrl);
              showToast('Proxy unavailable - start server/pdf_proxy.py', 'error');
            }
            return;
          }
          // v1.4.15: CORS fallback - try direct iframe src if local fallback unavailable
          if (srrState.localAttachmentFallback) {
            srrRenderPdf(record, srrState.localAttachmentFallback.url, 'Local Attachment (offline fallback)', srrState.localAttachmentFallback.name, srrBuildLogEntry('Local Attachment', 'offline-fallback', 'local-attachment'));
          } else if (networkUrl && srrIsValidPdfUrl(networkUrl)) {
            // CORS blocked but URL is valid - try direct iframe (not cached)
            var sourceName = fileName || networkUrl.split('/').pop().split('?')[0];
            console.log('[SRR_PDF] CORS blocked, trying direct iframe for:', networkUrl.substring(0, 60));
            srrRenderPdf(record, networkUrl, 'Network PDF (not cached)', sourceName, srrBuildLogEntry('URL-Direct', 'cors-blocked', networkUrl));
            showToast('Viewing network PDF (not cached due to CORS)', 'info');
          } else {
            // Show offline stub
            srrShowOfflineStub(networkUrl);
          }
        });
    }
    
    // v1.4.13: Render PDF in iframe
    function srrRenderPdf(record, pdfUrl, sourceType, sourceName, logEntry) {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var iframeEl = document.getElementById('srr-pdf-object');
      var sourceEl = document.getElementById('srr-doc-source');
      var sourceTypeEl = document.getElementById('srr-doc-source-type');
      var sourceNameEl = document.getElementById('srr-doc-source-name');
      
      var savedState = loadSrrPdfState(record);
      srrState.docPage = savedState.page || 1;
      srrState.zoom = savedState.zoom || 125;
      srrState.docTotalPages = null;
      srrState.currentPdfUrl = pdfUrl;
      srrState.pdfSourceType = sourceType;
      
      logEntry.page = srrState.docPage;
      logEntry.zoom = srrState.zoom;
      
      if (emptyEl) emptyEl.style.display = 'none';
      if (containerEl) containerEl.style.display = 'block';
      
      if (sourceEl && sourceTypeEl && sourceNameEl) {
        sourceEl.style.display = 'block';
        sourceTypeEl.textContent = sourceType + ':';
        sourceNameEl.textContent = sourceName || '';
      }
      
      srrSetupIframeHandlers(iframeEl);
      srrUpdateIframeSrc();
      srrUpdateZoomDisplay();
      srrUpdatePageDisplay();
      
      console.log('[SRR_PDF_LOAD]', JSON.stringify(logEntry));
    }
    
    // v1.4.13: Show empty state
    // v1.4.14: Use structured log with sheet/row context
    function srrShowEmptyState() {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var iframeEl = document.getElementById('srr-pdf-object');
      var sourceEl = document.getElementById('srr-doc-source');
      
      srrState.docPage = 1;
      srrState.docTotalPages = null;
      srrState.zoom = 125;
      srrState.currentPdfUrl = null;
      srrState.pdfSourceType = null;
      
      if (emptyEl) emptyEl.style.display = 'block';
      if (containerEl) containerEl.style.display = 'none';
      if (sourceEl) sourceEl.style.display = 'none';
      if (iframeEl) iframeEl.data = 'about:blank';
      srrUpdateZoomDisplay();
      srrUpdatePageDisplay();
      
      console.log('[SRR_PDF_LOAD]', JSON.stringify(srrBuildLogEntry('none', 'empty', '')));
    }
    
    // v1.4.13: Show offline stub when network unavailable and no local fallback
    // v1.4.14: Use structured log with sheet/row context
    function srrShowOfflineStub(networkUrl) {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var sourceEl = document.getElementById('srr-doc-source');
      
      srrState.docPage = 1;
      srrState.zoom = 125;
      srrState.currentPdfUrl = null;
      srrState.pdfSourceType = null;
      
      if (containerEl) containerEl.style.display = 'none';
      if (sourceEl) sourceEl.style.display = 'none';
      
      // Show offline stub in empty state area
      if (emptyEl) {
        emptyEl.style.display = 'block';
        emptyEl.innerHTML = '<div style="font-size: 3em; margin-bottom: 10px;">📵</div>' +
          '<div style="font-weight: 500; color: #e65100;">Document not available offline</div>' +
          '<div style="font-size: 0.85em; color: #999; margin-top: 8px;">This PDF has not been cached. Connect to the network to view.</div>' +
          (networkUrl ? '<a href="' + networkUrl + '" target="_blank" style="display: inline-block; margin-top: 12px; color: #1565c0; text-decoration: underline;">Open in New Tab (when online)</a>' : '');
      }
      
      console.log('[SRR_PDF_LOAD]', JSON.stringify(srrBuildLogEntry('none', 'offline-no-cache', networkUrl || '')));
    }
    
    // v1.4.13: Setup iframe load/error handlers for best-effort failure detection
    function srrSetupIframeHandlers(iframeEl) {
      if (!iframeEl) return;
      
      iframeEl.onload = function() {
        console.log('[SRR_PDF] Iframe onload fired');
        srrHidePdfError();
      };
      
      iframeEl.onerror = function() {
        console.warn('[SRR_PDF] Iframe onerror fired');
        srrShowPdfError(
          'PDF failed to render',
          'The document could not be loaded. Try opening in a new tab.',
          srrState.networkPdfUrl,
          !!srrState.localAttachmentFallback
        );
      };
    }
    
    // v1.4.13: Update iframe src with fragment compatibility fallback
    function srrUpdateIframeSrc() {
      var iframeEl = document.getElementById('srr-pdf-object');
      if (!iframeEl || !srrState.currentPdfUrl) return;
      
      var baseUrl = srrState.currentPdfUrl.split('#')[0];
      
      // Build fragment: page is always included, zoom only if useFragmentZoom is true
      // Some PDF renderers break with zoom fragment, so we keep it UI-only in those cases
      // v1.6.13: Add navpanes=0 to hide thumbnail sidebar, scrollbar=1 for continuous scroll
      var fragment = '#page=' + srrState.docPage + '&navpanes=0&scrollbar=1&toolbar=1&view=FitH';
      if (srrState.useFragmentZoom !== false) {
        fragment += '&zoom=' + srrState.zoom;
      }
      
      var newSrc = baseUrl + fragment;
      
      // Only update if data changed (prevents unnecessary reloads)
      // v1.4.18: Use .data attribute for <object> element instead of .src for <iframe>
      if (iframeEl.data !== newSrc) {
        iframeEl.data = newSrc;
        // Also update the fallback link
        var openTabLink = document.getElementById('srr-pdf-open-tab');
        if (openTabLink) openTabLink.href = newSrc;
        console.log('[SRR_PDF] Set object data:', newSrc.length > 100 ? newSrc.substring(0, 100) + '...' : newSrc);
      }
    }
    
    // v1.4.13: Fallback to page-only fragment if zoom causes issues
    function srrDisableFragmentZoom() {
      srrState.useFragmentZoom = false;
      console.log('[SRR_PDF] Disabled fragment zoom, using UI-only zoom indicator');
      srrUpdateIframeSrc();
    }
    
    function srrUpdateZoomDisplay() {
      var zoomEl = document.getElementById('srr-zoom-indicator');
      var zoomInBtn = document.getElementById('srr-zoom-in');
      var zoomOutBtn = document.getElementById('srr-zoom-out');
      if (zoomEl) zoomEl.textContent = srrState.zoom + '%';
      if (zoomInBtn) zoomInBtn.disabled = srrState.zoom >= 300;
      if (zoomOutBtn) zoomOutBtn.disabled = srrState.zoom <= 50;
    }
    
    function srrUpdatePageDisplay() {
      var pageEl = document.getElementById('srr-page-indicator');
      var headerPageEl = document.getElementById('srr-doc-page');
      // Show "Page X" without total (total pages unknown with iframe rendering)
      var text = 'Page ' + srrState.docPage;
      if (pageEl) pageEl.textContent = text;
      if (headerPageEl) headerPageEl.textContent = text;
      
      var prevBtn = document.getElementById('srr-prev-btn');
      var nextBtn = document.getElementById('srr-next-btn');
      // Prev disabled at page 1; Next always enabled (total unknown)
      if (prevBtn) prevBtn.disabled = srrState.docPage <= 1;
      if (nextBtn) nextBtn.disabled = false;
    }
    
    function srrPrevPage() {
      if (srrState.docPage > 1) {
        srrState.docPage--;
        srrUpdateIframeSrc();
        srrUpdatePageDisplay();
        saveSrrPdfState(srrState.currentRecord);
        console.log('[SRR] Page:', srrState.docPage);
      }
    }
    
    function srrNextPage() {
      // Allow increment (total pages unknown with iframe)
      srrState.docPage++;
      srrUpdateIframeSrc();
      srrUpdatePageDisplay();
      saveSrrPdfState(srrState.currentRecord);
      console.log('[SRR] Page:', srrState.docPage);
    }
    
    function srrZoomIn() {
      if (srrState.zoom < 300) {
        srrState.zoom = Math.min(srrState.zoom + 25, 300);
        srrUpdateIframeSrc();
        srrUpdateZoomDisplay();
        saveSrrPdfState(srrState.currentRecord);
        console.log('[SRR] Zoom:', srrState.zoom + '%');
      }
    }
    
    function srrZoomOut() {
      if (srrState.zoom > 50) {
        srrState.zoom = Math.max(srrState.zoom - 25, 50);
        srrUpdateIframeSrc();
        srrUpdateZoomDisplay();
        saveSrrPdfState(srrState.currentRecord);
        console.log('[SRR] Zoom:', srrState.zoom + '%');
      }
    }
    
    // Patch actions
    // v1.4.18: Save Evidence Pack draft (AC-03)
    // v1.4.19: Set patch type and update form sections
    // v1.4.20: Internal patch type setter (now auto-driven, not user-clickable)
    function srrSetPatchType(type) {
      srrState.patchType = type;
      srrState.patchDraft.patch_type = type;
      srrUpdatePatchTypeDisplay();
      srrUpdatePatchFormSections();
      srrSaveEvidenceDraft();
      console.log('[SRR] Patch type auto-set:', type);
    }
    
    // v1.4.20: Update patch type display (read-only indicator)
    function srrUpdatePatchTypeDisplay() {
      // Update chips to match current patch type
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === srrState.patchType) chip.classList.add('active');
      });
      // Update form sections
      srrUpdatePatchFormSections();
    }
    
    // v1.4.20: Guard modal for leaving SRR with unresolved fields
    function srrShowGuardModal() {
      var count = srrGetUnresolvedCount();
      var modal = document.getElementById('srr-guard-modal');
      var countEl = document.getElementById('srr-guard-count');
      if (countEl) countEl.textContent = count;
      if (modal) modal.classList.add('visible');
    }
    
    function srrHideGuardModal() {
      var modal = document.getElementById('srr-guard-modal');
      if (modal) modal.classList.remove('visible');
    }
    
    
    // v1.4.19: Update form sections based on patch type
    function srrUpdatePatchFormSections() {
      var type = srrState.patchType;
      var isCorrection = type === 'correction';
      var isBlacklist = type === 'blacklist';
      var isRfi = type === 'rfi';
      
      // Observation/Expected blocks (Correction only)
      var obsBlock = document.getElementById('srr-observation-block');
      var expBlock = document.getElementById('srr-expected-block');
      if (obsBlock) obsBlock.classList.toggle('srr-section-hidden', !isCorrection);
      if (expBlock) expBlock.classList.toggle('srr-section-hidden', !isCorrection);
      
      // Repro block (Correction only, when not override)
      var reproBlock = document.getElementById('srr-repro-block');
      if (reproBlock) {
        var showRepro = isCorrection && !srrState.overrideEnabled;
        reproBlock.classList.toggle('srr-section-hidden', !showRepro);
      }
      
      // Override section (Correction only, when applicable)
      var overrideSection = document.getElementById('srr-override-section');
      if (overrideSection) {
        var showOverride = isCorrection && srrIsOverrideApplicable();
        overrideSection.classList.toggle('srr-section-hidden', !showOverride);
      }
      
      // Override badge
      var overrideBadge = document.getElementById('srr-override-badge');
      if (overrideBadge) {
        overrideBadge.classList.toggle('srr-section-hidden', !srrState.overrideEnabled);
      }
      
      // Blacklist Subject (Blacklist Flag only)
      var blacklistSection = document.getElementById('srr-blacklist-section');
      if (blacklistSection) {
        blacklistSection.classList.toggle('srr-section-hidden', !isBlacklist);
        if (isBlacklist) srrUpdateBlacklistSubject();
      }
      
      // RFI Assignment stub (RFI only)
      var rfiSection = document.getElementById('srr-rfi-section');
      if (rfiSection) rfiSection.classList.toggle('srr-section-hidden', !isRfi);
      
      // Update action box title based on patch type
      var actionBoxTitle = document.getElementById('srr-action-box-title');
      if (actionBoxTitle) {
        if (isCorrection) {
          actionBoxTitle.textContent = 'Changed Fields';
        } else if (isBlacklist) {
          actionBoxTitle.textContent = 'Blacklist Request';
        } else if (isRfi) {
          actionBoxTitle.textContent = 'RFI Request';
        }
      }
      
      // Update helper text based on patch type
      var helperEl = document.getElementById('srr-action-box-helper');
      if (helperEl && !Object.keys(srrState.proposedChanges).length) {
        if (isCorrection) {
          helperEl.textContent = 'Click a field value to edit. Changed fields appear here.';
        } else if (isBlacklist) {
          helperEl.textContent = 'Click the Block icon on a field to flag it for blacklist.';
        } else if (isRfi) {
          helperEl.textContent = 'Click the RFI icon on a field to request clarification.';
        }
      }
      
      // Update justification label (Comment for RFI)
      var justLabel = document.getElementById('srr-justification-label');
      var justTextarea = document.getElementById('srr-justification');
      if (justLabel) {
        if (isRfi) {
          justLabel.innerHTML = 'Comment';
          if (justTextarea) justTextarea.placeholder = 'Add your question or note for the team...';
        } else {
          justLabel.innerHTML = 'Justification <span class="srr-evidence-alias">(BECAUSE)</span>';
          if (justTextarea) justTextarea.placeholder = 'Explain why this change/flag is necessary...';
        }
      }
      
      // Update patch type chips
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === type) chip.classList.add('active');
      });
      
      // Update submit button text and style based on patch type
      var submitBtn = document.getElementById('srr-submit-btn');
      if (submitBtn) {
        if (isRfi) {
          submitBtn.textContent = 'Send RFI';
          submitBtn.style.background = '#f57c00';  // Orange for RFI
        } else if (isBlacklist) {
          submitBtn.textContent = 'Submit Blacklist';
          submitBtn.style.background = '#d32f2f';  // Red for blacklist
        } else {
          submitBtn.textContent = 'Submit Patch Request';
          submitBtn.style.background = '#1565c0';  // Blue default
        }
      }
    }
    
    // Handle patch type dropdown change
    function srrOnPatchTypeChange(newType) {
      // v1.6.55: Set type first, then open overlay so title is correct
      srrState.patchType = newType;
      srrState.patchDraft.patch_type = newType;
      _srrExpandPatchPanel();
      // v1.5.2: If a field is selected, apply the action to that field
      if (srrPeSelectedField) {
        var fieldKey = srrPeSelectedField.key;
        var fieldLabel = srrPeSelectedField.label;
        var record = srrState.currentRecord;
        var currentValue = record ? record[fieldKey] : '';
        
        console.log('[SRR] Patch type chip action:', newType, 'on field:', fieldKey);
        
        if (newType === 'rfi') {
          // Same as srrRfiField
          srrState.rfiField = { key: fieldKey, label: fieldLabel, value: currentValue };
          srrState.fieldStates[fieldKey] = 'rfi_pending';
          showToast('RFI started for: ' + fieldLabel, 'info');
        } else if (newType === 'blacklist') {
          // Same as srrBlacklistField
          srrState.fieldStates[fieldKey] = 'blocked';
          srrState.patchDraft.blacklist_subject = fieldLabel + ': ' + (currentValue || '(empty)');
          var subjectEl = document.getElementById('srr-blacklist-subject-value');
          if (subjectEl) {
            subjectEl.textContent = fieldLabel + ': ' + (currentValue || '(empty)');
          }
          showToast('Blacklist flag set for: ' + fieldLabel, 'info');
        } else if (newType === 'correction') {
          // Set up for correction / edit mode
          if (!srrState.proposedChanges[fieldKey]) {
            srrState.proposedChanges[fieldKey] = {
              field: fieldKey,
              label: fieldLabel,
              from: currentValue,
              to: currentValue,
              category: 'correction'
            };
          }
          srrState.fieldStates[fieldKey] = 'modified';
          showToast('Correction mode for: ' + fieldLabel, 'info');
        }
        
        // Refresh Field Inspector
        renderSrrFields(srrState.currentRecord);
      }
      
      // Update patch type state
      srrState.patchType = newType;
      srrState.patchDraft.patch_type = newType;
      srrUpdatePatchFormSections();
      srrRenderPatchEditor();
      srrSaveEvidenceDraft();
      console.log('[SRR] Patch type changed to:', newType);
    }
    
    // v1.4.19: Check if override is applicable based on observation/expected
    function srrIsOverrideApplicable() {
      var obsType = document.getElementById('srr-observation-type').value;
      var expType = document.getElementById('srr-expected-type').value;
      return obsType === 'override_needed' || expType === 'allow_override';
    }
    
    // v1.4.19: Toggle override
    function srrToggleOverride() {
      srrState.overrideEnabled = !srrState.overrideEnabled;
      var toggle = document.getElementById('srr-override-toggle');
      if (toggle) toggle.classList.toggle('active', srrState.overrideEnabled);
      srrUpdatePatchFormSections();
      srrSaveEvidenceDraft();
      console.log('[SRR] Override toggled:', srrState.overrideEnabled);
    }
    
    // v1.4.19: Update Blacklist Subject from selected field
    function srrUpdateBlacklistSubject() {
      var changes = Object.values(srrState.proposedChanges);
      var subjectEl = document.getElementById('srr-blacklist-subject-value');
      if (!subjectEl) return;
      
      if (changes.length === 0) {
        subjectEl.textContent = '(No field selected — edit a field first)';
      } else if (changes.length === 1) {
        subjectEl.textContent = changes[0].label + ': ' + (changes[0].to || changes[0].from);
      } else {
        subjectEl.textContent = changes.length + ' fields: ' + changes.map(function(c) { return c.label; }).join(', ');
      }
    }
    
    // v1.4.19: Handle observation change (show/hide override)
    function srrOnObservationChange() {
      srrSaveEvidenceDraft();
      srrUpdatePatchFormSections();
    }
    
    // v1.4.19: Handle expected change (show/hide override)
    function srrOnExpectedChange() {
      srrSaveEvidenceDraft();
      srrUpdatePatchFormSections();
    }
    
    function srrSaveEvidenceDraft() {
      srrState.patchDraft.patch_type = srrState.patchType;
      srrState.patchDraft.observation_type = document.getElementById('srr-observation-type').value;
      srrState.patchDraft.expected_type = document.getElementById('srr-expected-type').value;
      srrState.patchDraft.justification = document.getElementById('srr-justification').value;
      srrState.patchDraft.repro_type = document.getElementById('srr-repro-type').value;
      srrState.patchDraft.replay_type = document.getElementById('srr-replay-type') ? document.getElementById('srr-replay-type').value : '';
      srrState.patchDraft.replay_steps = document.getElementById('srr-replay-steps') ? document.getElementById('srr-replay-steps').value : '';
      srrState.patchDraft.replay_expected_result = document.getElementById('srr-replay-expected-result') ? document.getElementById('srr-replay-expected-result').value : '';
      // RFI target stub - no input field yet (coming soon)
      srrState.patchDraft.rfi_target = '';
      srrState.patchDraft.override_enabled = srrState.overrideEnabled;
    }
    
    // v1.4.18: Handle repro file attachment
    function srrHandleReproFile(input) {
      if (input.files && input.files[0]) {
        srrState.patchDraft.repro_file = input.files[0];
        document.getElementById('srr-repro-file-name').textContent = input.files[0].name;
        console.log('[SRR] Repro file attached:', input.files[0].name);
      }
    }
    
    function srrSaveDraft() {
      srrSaveEvidenceDraft();
      
      // Emit audit event (stub)
      console.log('[SRR] PATCH_DRAFTED:', srrState.patchDraft);
      showToast('Draft saved', 'success');
      _srrCollapsePatchPanel();
    }
    
    function srrCheckEvidenceGate(patchType, draft, changeCount, overrideEnabled) {
      var missing = [];
      if (patchType === 'correction') {
        if (!draft.observation_type) missing.push('Observation type');
        if (!draft.expected_type) missing.push('Expected behavior');
        if (changeCount === 0) missing.push('At least one field change');
        if (!overrideEnabled && !draft.repro_type) missing.push('Repro method (or enable Override)');
        if (draft.repro_type === 'doc_evidence_mismatch' && !draft.repro_file) missing.push('File attachment for Doc Evidence Mismatch');
        if (!draft.justification || draft.justification.trim().length < 10) missing.push('Justification (min 10 chars)');
        // v1.6.57: Replay contract required for Correction
        if (!draft.replay_type || draft.replay_type === 'NA') missing.push('Replay Type (cannot be N/A for Correction)');
        if (!draft.replay_steps || draft.replay_steps.trim().length < 5) missing.push('Replay Steps (min 5 chars)');
        if (!draft.replay_expected_result || draft.replay_expected_result.trim().length < 5) missing.push('Replay Expected Result (min 5 chars)');
      } else if (patchType === 'blacklist') {
        if (!draft.justification || draft.justification.trim().length < 10) missing.push('Justification (min 10 chars)');
        // v1.6.57: Replay contract required for Blacklist
        if (!draft.replay_type || draft.replay_type === 'NA') missing.push('Replay Type (cannot be N/A for Blacklist)');
        if (!draft.replay_steps || draft.replay_steps.trim().length < 5) missing.push('Replay Steps (min 5 chars)');
        if (!draft.replay_expected_result || draft.replay_expected_result.trim().length < 5) missing.push('Replay Expected Result (min 5 chars)');
      } else {
        // RFI: replay_type may be NA; replay_steps and replay_expected_result optional
        if (!draft.justification || draft.justification.trim().length < 10) missing.push('Justification (min 10 chars)');
      }
      return missing;
    }

    // v1.6.57: Shared submission gate validation (used by both SRR and Patch Studio)
    function validateSubmissionGates(patchType, draft, changeCount, overrideEnabled) {
      var result = { pass: true, evidenceGaps: [], preflightGaps: [] };
      result.evidenceGaps = srrCheckEvidenceGate(patchType, draft, changeCount, overrideEnabled);
      result.preflightGaps = srrCheckPreflightGate();
      result.pass = (result.evidenceGaps.length === 0 && result.preflightGaps.length === 0);
      return result;
    }

    // v1.6.57: Self-approval check — returns true if current user authored the patch
    function isSelfApproval(patchRequest) {
      if (!patchRequest) return false;
      var currentUser = getCurrentUserName();
      return currentUser && patchRequest.author && currentUser.toLowerCase() === patchRequest.author.toLowerCase();
    }

    function srrCheckPreflightGate() {
      var steps = [
        { key: 'baseVersion', label: 'Base Version Check' },
        { key: 'validation', label: 'Validation Report' },
        { key: 'conflict', label: 'Conflict Check' },
        { key: 'smokeBaseline', label: 'Smoke Baseline' },
        { key: 'smokeEdge', label: 'Smoke Edge' }
      ];
      var failed = [];
      for (var i = 0; i < steps.length; i++) {
        var step = steps[i];
        var status = (preflightEvidence[step.key] && preflightEvidence[step.key].status) || 'pending';
        if (status === 'pending') failed.push(step.label + ' (not run)');
        else if (status === 'fail') failed.push(step.label + ' (failed)');
      }
      return failed;
    }

    function srrCheckContractPreflightGate() {
      var record = srrState.currentRecord;
      if (!record) return [];
      var contractKey = record.contract_key || srrState.currentRecordKey || '';
      if (!contractKey) return [];
      var blockers = [];
      var allItems = (typeof analystTriageState !== 'undefined' && analystTriageState.manualItems) ? analystTriageState.manualItems : [];
      var batchItems = (typeof _p1fBatchScanItems !== 'undefined') ? _p1fBatchScanItems : [];
      var combined = allItems.concat(batchItems);
      for (var i = 0; i < combined.length; i++) {
        var item = combined[i];
        var itemContract = item.contract_key || item.contract_id || item.record_id || '';
        if (itemContract !== contractKey) continue;
        if (item.status === 'resolved' || item.status === 'dismissed') continue;
        if (item.severity === 'blocker') {
          var label = item.reason_label || item.blocker_type || item.signal_type || 'Unknown blocker';
          var field = item.field_label || item.field_name || '';
          blockers.push(label + (field ? ' (' + field + ')' : ''));
        }
      }
      if (blockers.length > 0) {
        console.log('[SRR-PREFLIGHT] contract_gate_blocked: contract=' + contractKey + ', blockers=' + blockers.length);
      }
      return blockers;
    }

    function srrSubmitPatchRequest() {
      srrSaveEvidenceDraft();
      
      var patchType = srrState.patchType;
      var changeCount = Object.keys(srrState.proposedChanges).length;
      var draft = srrState.patchDraft;
      var justification = draft.justification;

      // v1.6.46: Evidence Pack gate
      var evidenceGaps = srrCheckEvidenceGate(patchType, draft, changeCount, srrState.overrideEnabled);
      if (evidenceGaps.length > 0) {
        showToast('Missing requirements: ' + evidenceGaps.join(', '), 'warning');
        console.log('[SRR] Submit blocked — evidence gaps:', evidenceGaps);
        return;
      }

      // v1.6.46: Preflight gate
      var preflightGaps = srrCheckPreflightGate();
      if (preflightGaps.length > 0) {
        showToast('Missing requirements: ' + preflightGaps.join(', '), 'warning');
        console.log('[SRR] Submit blocked — preflight gaps:', preflightGaps);
        return;
      }

      var contractBlockers = srrCheckContractPreflightGate();
      if (contractBlockers.length > 0) {
        showToast('Contract has ' + contractBlockers.length + ' unresolved blocker(s): ' + contractBlockers.slice(0, 3).join('; ') + (contractBlockers.length > 3 ? ' (+' + (contractBlockers.length - 3) + ' more)' : ''), 'warning');
        console.log('[SRR] Submit blocked — contract preflight blockers:', contractBlockers);
        return;
      }
      
      // v1.4.19: Build patch request based on type
      var changes = Object.values(srrState.proposedChanges);
      var changeSummary = changes.length > 0 ? changes.map(function(c) {
        return c.label + ': ' + (c.from || '(empty)') + ' → ' + c.to;
      }).join('; ') : '(no field changes)';
      
      var record = srrState.currentRecord || {};
      var author = getCurrentUserName();  // v1.6.33: Use logged-in user
      
      // Determine action type based on patch type
      var actionType = patchType === 'correction' ? 'SET_VALUE' : (patchType === 'blacklist' ? 'BLACKLIST' : 'RFI');
      var whenText = patchType === 'correction' ? 'Field value is incorrect' : 
                     (patchType === 'blacklist' ? 'Value should be blacklisted' : 'Clarification needed');
      
      // v1.5.2: Get stable record_id from record identity
      var recordId = (record._identity && record._identity.record_id) || record.record_id || record.contract_key || srrState.currentRecordKey;
      var datasetId = (record._identity && record._identity.dataset_id) || IDENTITY_CONTEXT.dataset_id || sessionState.fileName || 'default';
      
      var request = createPatchRequest({
        author: author,
        author_role: currentMode || 'Analyst',
        // v1.5.2: Include record_id and dataset_id
        record_id: recordId,
        dataset_id: datasetId,
        tenant_id: IDENTITY_CONTEXT.tenant_id,
        division_id: IDENTITY_CONTEXT.division_id,
        contract_key: record.contract_key || srrState.currentRecordKey,
        file_url: srrResolveFieldValue(record, 'file_url'),
        file_name: srrResolveFieldValue(record, 'file_name'),
        sheet: srrState.currentSheetName,
        field: changes.length === 1 ? changes[0].field : (changes.length > 1 ? '(multiple)' : '(none)'),
        target: 'field_values',
        target_field: changes.length === 1 ? changes[0].field : null,
        condition_type: 'FIELD_VALUE',
        action_type: actionType,
        patch_type: patchType,
        patch_kind: patchType,
        override_enabled: srrState.overrideEnabled,
        old_value: changes.length > 0 ? changes[0].from : '',
        new_value: changes.length > 0 ? changes[0].to : '',
        proposed_changes: changes.map(function(c) { return { field: c.field, old_value: c.from, new_value: c.to }; }),
        when: whenText,
        then: changeSummary,
        because: justification || '',
        evidence_observation: patchType === 'correction' ? srrState.patchDraft.observation_type : '',
        evidence_expected: patchType === 'correction' ? srrState.patchDraft.expected_type : '',
        evidence_justification: justification,
        evidence_repro: patchType === 'correction' ? srrState.patchDraft.repro_type : '',
        replay_type: srrState.patchDraft.replay_type || '',
        replay_steps: srrState.patchDraft.replay_steps || '',
        replay_expected_result: srrState.patchDraft.replay_expected_result || '',
        rfi_target: patchType === 'rfi' ? srrState.patchDraft.rfi_target : '',
        rationale: changeSummary
      });
      
      // Submit the patch request
      var submittedRequest = submitPatchRequest(request.request_id, author, currentMode || 'Analyst');
      
      // v1.5.1: Create artifact in artifact store (primary)
      var fieldKey = changes.length > 0 ? changes[0].field : (srrState.rfiField ? srrState.rfiField.key : 'N/A');
      // v1.5.2: Use stable recordId and datasetId from identity model
      var artifact = createArtifact({
        dataset_id: datasetId,
        record_id: recordId,
        field_key: fieldKey,
        artifact_type: patchType === 'rfi' ? 'rfi' : 'patch_request',
        status: 'open',
        created_by_actor_id: author,
        created_by_role: currentMode || 'analyst',
        sheet_name: srrState.currentSheetName,
        file_url: srrResolveFieldValue(record, 'file_url'),
        file_name: srrResolveFieldValue(record, 'file_name'),
        body: {
          patch_type: patchType,
          patch_request_id: request.request_id,
          old_value: changes.length > 0 ? changes[0].from : (srrState.rfiField ? srrState.rfiField.value : ''),
          new_value: changes.length > 0 ? changes[0].to : '',
          comment: justification,
          changes: changes,
          override_enabled: srrState.overrideEnabled,
          evidence: {
            observation_type: srrState.patchDraft.observation_type,
            expected_type: srrState.patchDraft.expected_type,
            repro_type: srrState.patchDraft.repro_type,
            justification: justification
          },
          legacy_request_id: request.request_id
        }
      });
      
      // v1.5.2: Add to verifier queue with proper identity fields
      addVerifierPayload({
        id: artifact.artifact_id,
        type: patchType,
        // v1.5.2: Use stable record_id and include dataset_id + patch_request_id
        record_id: recordId,
        dataset_id: datasetId,
        patch_request_id: request.request_id,
        division_id: IDENTITY_CONTEXT.division_id,
        field: fieldKey,
        old_value: changes.length > 0 ? changes[0].from : (srrState.rfiField ? srrState.rfiField.value : ''),
        new_value: changes.length > 0 ? changes[0].to : '',
        comment: justification,
        analyst_id: author,
        timestamp: new Date().toISOString(),
        status: 'pending',
        artifact_id: artifact.artifact_id
      });
      
      // Update local state
      srrState.patchDraft.status = 'Submitted';
      
      // Update field states based on patch type
      if (patchType === 'correction') {
        // Correction: Set all modified fields to 'submitted' (clears from To Do)
        Object.keys(srrState.proposedChanges).forEach(function(fieldKey) {
          srrState.fieldStates[fieldKey] = 'submitted';
        });
      }
      // v1.5.3 Fix: RFI submit should only clear the selected field, preserve other pending RFIs
      if (patchType === 'rfi') {
        // Only change the selected field's state, not all rfi_pending fields
        var selectedField = srrState.selectedField || (srrState.rfiField && srrState.rfiField.key ? srrState.rfiField.key : null);
        if (selectedField && srrState.fieldStates[selectedField] === 'rfi_pending') {
          srrState.fieldStates[selectedField] = 'rfi';
        }
        // If specific field from changes, use that
        if (changes.length === 1 && changes[0].field) {
          srrState.fieldStates[changes[0].field] = 'rfi';
        }
      }
      // Blocked fields stay as 'blocked' (already set when Blacklist clicked)
      
      // Re-render field list to reflect state changes
      renderSrrFields(srrState.currentRecord);
      
      // Emit audit events (both uppercase canonical and lowercase alias)
      console.log('[SRR] PATCH_SUBMITTED (' + patchType + '):', request);
      AuditTimeline.emit('PATCH_SUBMITTED', {
        actor_id: author,
        record_id: recordId || '',
        dataset_id: datasetId || '',
        file_id: srrResolveFieldValue(record, 'file_name') || '',
        patch_request_id: request.request_id,
        metadata: { patch_type: patchType, change_count: changeCount, sheet: srrState.currentSheetName }
      });
      AuditTimeline.emit('patch_submitted', {
        actor_id: author,
        record_id: recordId || '',
        dataset_id: datasetId || '',
        patch_request_id: request.request_id,
        metadata: { patch_type: patchType, change_count: changeCount }
      });
      console.log('[SRR] patch_submitted + REVIEW_REQUESTED: patch_id=' + request.request_id);
      
      // Show appropriate toast based on patch type
      if (patchType === 'rfi') {
        showToast('RFI sent — analyst handoff complete', 'success');
      } else if (patchType === 'blacklist') {
        showToast('Blacklist submitted — visible in Patch Console', 'success');
      } else {
        showToast('Patch Request submitted — visible in Patch Console', 'success');
      }
      
      // Clear scope draft for this record
      var scopeKey = (recordId || '') + ':' + (srrState.currentSheetName || '');
      try { sessionStorage.removeItem('srr_studio_draft_' + scopeKey); } catch(e) {}
      
      // Persist studio state and rerender
      if (typeof srrStudioPersist === 'function') srrStudioPersist();
      if (typeof srrStudioRender === 'function') srrStudioRender();
      
      // Reset state after submission
      resetPatchEditorState();
      
      // Close the patch overlay, returning to field inspector
      srrClosePatchOverlay();
      if (srrCheckAllFieldsCompleted()) {
        setTimeout(function() { srrAutoAdvance('Patch submitted — all fields addressed'); }, 800);
      }
    }
    
    function resetPatchEditorState() {
      // Reset patch draft in srrState
      srrState.patchDraft = {
        patch_type: 'correction',
        observation_type: '',
        expected_type: '',
        justification: '',
        repro_type: '',
        repro_file: null,
        rfi_target: '',
        blacklist_category: '',
        blacklist_subject: '',
        changes: [],
        status: 'Draft'
      };
      srrState.patchType = 'correction';
      srrState.overrideEnabled = false;
      srrState.rfiField = null;
      srrState.proposedChanges = {};
      srrState.lockedFields = {};
      
      // Reset form inputs
      var obsEl = document.getElementById('srr-observation-type');
      var expEl = document.getElementById('srr-expected-type');
      var justEl = document.getElementById('srr-justification');
      var reproEl = document.getElementById('srr-repro-type');
      
      if (obsEl) obsEl.value = '';
      if (expEl) expEl.value = '';
      if (justEl) justEl.value = '';
      if (reproEl) reproEl.value = '';
      
      // Reset patch type chips
      document.querySelectorAll('.srr-patch-chip').forEach(function(chip) {
        chip.classList.toggle('active', chip.dataset.patchtype === 'correction');
      });
      
      // Clear override toggle
      var overrideToggle = document.getElementById('srr-override-toggle');
      if (overrideToggle) overrideToggle.checked = false;
      
      // Clear blacklist subject display
      var blacklistEl = document.getElementById('srr-blacklist-subject');
      if (blacklistEl) blacklistEl.textContent = '';
      
      // Clear RFI display
      var rfiEl = document.getElementById('srr-rfi-request-display');
      if (rfiEl) rfiEl.innerHTML = '';
      
      // Clear old/new value displays in patch editor
      var oldValEl = document.getElementById('srr-patch-old-value');
      var newValEl = document.getElementById('srr-patch-new-value');
      if (oldValEl) oldValEl.textContent = '';
      if (newValEl) newValEl.value = '';
      
      // Update visibility of conditional sections
      if (typeof updatePatchEditorSections === 'function') {
        updatePatchEditorSections();
      }
      
      console.log('[SRR] Patch Editor state reset');
    }

    function srrStudioEnsureLoaded(recordId, sheetName) {
      var scopeKey = (recordId || '') + ':' + (sheetName || '');
      try {
        var raw = sessionStorage.getItem('srr_studio_draft_' + scopeKey);
        if (raw) {
          var draft = JSON.parse(raw);
          console.log('[SRR_STUDIO] Hydrated draft for scope:', scopeKey, draft);
          srrState.patchDraft = Object.assign(srrState.patchDraft || {}, draft);
        }
      } catch (e) {
        console.warn('[SRR_STUDIO] Failed to hydrate draft:', e);
      }
    }

    function srrStudioOnRecordScopeChanged() {
      var rec = srrState.currentRecord || {};
      var recordId = (rec._identity && rec._identity.record_id) || rec.record_id || srrState.currentRecordKey || '';
      var sheetName = srrState.currentSheetName || '';
      srrStudioEnsureLoaded(recordId, sheetName);
      if (typeof srrStudioRender === 'function') srrStudioRender();
      console.log('[SRR_STUDIO] Record scope changed:', recordId, sheetName);
    }

    function srrStudioPersist() {
      var rec = srrState.currentRecord || {};
      var recordId = (rec._identity && rec._identity.record_id) || rec.record_id || srrState.currentRecordKey || '';
      var sheetName = srrState.currentSheetName || '';
      var scopeKey = recordId + ':' + sheetName;
      try {
        sessionStorage.setItem('srr_studio_draft_' + scopeKey, JSON.stringify(srrState.patchDraft || {}));
      } catch (e) {
        console.warn('[SRR_STUDIO] Failed to persist draft:', e);
      }
    }

    function srrStudioRender() {
      var el = document.getElementById('srr-studio-content');
      if (!el) return;
      var draft = srrState.patchDraft || {};
      var changeCount = Object.keys(srrState.proposedChanges || {}).length;
      var html = '<div style="font-size: 0.85em; color: #666;">';
      html += '<div style="margin-bottom: 8px;"><strong>Type:</strong> ' + (draft.patch_type || 'correction') + '</div>';
      html += '<div style="margin-bottom: 8px;"><strong>Changes:</strong> ' + changeCount + ' field(s)</div>';
      html += '<div style="margin-bottom: 8px;"><strong>Status:</strong> ' + (draft.status || 'Draft') + '</div>';
      if (draft.justification) {
        html += '<div style="margin-bottom: 8px;"><strong>Justification:</strong> ' + escapeHtml(draft.justification).substring(0, 100) + '</div>';
      }
      html += '</div>';
      el.innerHTML = html;
    }

    
    // v1.6.4: Show audit log for current record using meta sheet data
    // v1.6.59: Audit Log — reads from AuditTimeline IndexedDB store
    // ========== V2.2 P0: AUDIT UX (3-TIER) ==========
    function toggleAuditHeaderDropdown() {
      var dd = document.getElementById('audit-header-dropdown');
      if (!dd) return;
      if (dd.style.display === 'none' || !dd.style.display) {
        refreshAuditHeaderDropdown();
        dd.style.display = 'block';
        document.addEventListener('click', _closeAuditDropdownOutside, true);
      } else {
        dd.style.display = 'none';
        document.removeEventListener('click', _closeAuditDropdownOutside, true);
      }
    }

    function _closeAuditDropdownOutside(e) {
      var container = document.getElementById('audit-header-dropdown-container');
      if (container && !container.contains(e.target)) {
        var dd = document.getElementById('audit-header-dropdown');
        if (dd) dd.style.display = 'none';
        document.removeEventListener('click', _closeAuditDropdownOutside, true);
      }
    }

    function refreshAuditHeaderDropdown() {
      var events = AuditTimeline._memCache.slice().sort(function(a, b) {
        return (b.timestamp_iso || '').localeCompare(a.timestamp_iso || '');
      }).slice(0, 10);

      var badge = document.getElementById('audit-header-badge');
      if (badge) badge.textContent = AuditTimeline._memCache.length;

      var list = document.getElementById('audit-header-list');
      if (!list) return;
      if (events.length === 0) {
        list.innerHTML = '<div style="padding: 16px; text-align: center; color: #999; font-size: 0.85em;">No audit events yet</div>';
        return;
      }
      var html = '';
      events.forEach(function(ev) {
        var time = ev.timestamp_iso ? new Date(ev.timestamp_iso).toLocaleTimeString() : '';
        var evType = _canonicalAuditEventName(ev.event_type);
        var scopeType = _inferAuditScope(ev);
        html += '<div style="padding: 8px 16px; border-bottom: 1px solid #f5f5f5; cursor: pointer; transition: background 0.15s;" onmouseover="this.style.background=\'#f5f5f5\'" onmouseout="this.style.background=\'white\'">';
        html += '<div style="display: flex; justify-content: space-between; align-items: baseline;">';
        html += '<span style="font-size: 0.85em; font-weight: 600; color: #333;">' + escapeHtml(evType) + '</span>';
        html += '<span style="font-size: 0.75em; color: #999;">' + escapeHtml(time) + '</span>';
        html += '</div>';
        html += '<div style="font-size: 0.78em; color: #888; margin-top: 2px;">' + escapeHtml(ev.actor_role || '') + ' &middot; ' + escapeHtml(scopeType) + (ev.record_id ? ' &middot; ' + escapeHtml((ev.record_id || '').substring(0, 20)) : '') + '</div>';
        html += '</div>';
      });
      list.innerHTML = html;
    }

    var _savedAuditFilterPresets = JSON.parse(localStorage.getItem('audit_filter_presets_v1') || '[]');

    function saveCurrentAuditFilter() {
      var scope = (document.getElementById('audit-full-filter-scope') || {}).value || '';
      var type = (document.getElementById('audit-full-filter-type') || {}).value || '';
      var role = (document.getElementById('audit-full-filter-role') || {}).value || '';
      var search = (document.getElementById('audit-full-search') || {}).value || '';
      if (!scope && !type && !role && !search) { showToast('No filters to save', 'warning'); return; }
      var name = prompt('Name this filter preset:');
      if (!name) return;
      _savedAuditFilterPresets.push({ name: name, scope: scope, type: type, role: role, search: search });
      localStorage.setItem('audit_filter_presets_v1', JSON.stringify(_savedAuditFilterPresets));
      renderAuditFilterPresets();
      showToast('Filter preset saved: ' + name, 'success');
    }

    function applyAuditFilterPreset(idx) {
      var preset = _savedAuditFilterPresets[idx];
      if (!preset) return;
      var s = document.getElementById('audit-full-filter-scope'); if (s) s.value = preset.scope || '';
      var t = document.getElementById('audit-full-filter-type'); if (t) t.value = preset.type || '';
      var r = document.getElementById('audit-full-filter-role'); if (r) r.value = preset.role || '';
      var q = document.getElementById('audit-full-search'); if (q) q.value = preset.search || '';
      refreshFullAuditPanel();
    }

    function deleteAuditFilterPreset(idx) {
      _savedAuditFilterPresets.splice(idx, 1);
      localStorage.setItem('audit_filter_presets_v1', JSON.stringify(_savedAuditFilterPresets));
      renderAuditFilterPresets();
    }

    function renderAuditFilterPresets() {
      var container = document.getElementById('audit-filter-presets');
      if (!container) return;
      if (_savedAuditFilterPresets.length === 0) { container.innerHTML = ''; return; }
      var html = '';
      _savedAuditFilterPresets.forEach(function(p, i) {
        html += '<span onclick="applyAuditFilterPreset(' + i + ')" style="display:inline-flex; align-items:center; gap:4px; padding:3px 10px; background:#e3f2fd; border:1px solid #bbdefb; border-radius:12px; font-size:0.78em; cursor:pointer; margin-right:4px;" title="Click to apply">';
        html += escapeHtml(p.name);
        html += '<span onclick="event.stopPropagation(); deleteAuditFilterPreset(' + i + ')" style="color:#999; cursor:pointer; font-size:0.9em;" title="Delete preset">&times;</span>';
        html += '</span>';
      });
      container.innerHTML = html;
    }

    function applyAuditQuickChip(category) {
      var t = document.getElementById('audit-full-filter-type');
      if (t) t.value = category;
      refreshFullAuditPanel();
    }

    function _canonicalAuditEventName(evType) {
      var ALIASES = {
        'BATCH_MERGED': 'batch_merged',
        'TENANT_RULE_PROMOTED_TO_BATCH': 'tenant_rule_promoted_to_batch',
        'CONTRACT_INDEX_BUILT': 'contract_index_built',
        'CONTRACT_ROLLUP_UPDATED': 'contract_rollup_updated',
        'UNKNOWN_COLUMN_DETECTED': 'unknown_column_detected',
        'BATCH_CREATED': 'batch_created',
        'CATALOG_GROUP_SET': 'catalog_group_set',
        'MANUAL_ROW_ADD': 'manual_row_add',
        'SESSION_RESTORED': 'session_restored',
        'SCHEMA_CHANGE': 'schema_change',
        'FIELD_VERIFIED': 'field_verified',
        'FIELD_BLACKLISTED': 'field_blacklisted',
        'FIELD_CORRECTED': 'field_corrected',
        'REQUEST_CLARIFICATION': 'request_clarification',
        'PATCH_SUBMITTED': 'patch_submitted',
        'PATCH_ADMIN_PROMOTED': 'patch_admin_promoted',
        'SYSTEM_CHANGE_APPLIED': 'system_change_applied',
        'UNDO_LOCAL': 'undo_local',
        'ROLLBACK_CREATED': 'rollback_created',
        'ROLLBACK_APPLIED': 'rollback_applied',
        'SYSTEM_CHANGE_ROUTED_TO_PATCH': 'system_change_routed_to_patch'
      };
      return ALIASES[evType] || evType;
    }

    function _inferAuditScope(ev) {
      var evType = (ev.event_type || '').toLowerCase();
      if (evType.indexOf('batch') >= 0) return 'batch';
      if (evType.indexOf('contract') >= 0 || evType.indexOf('rollup') >= 0) return 'contract';
      if (evType.indexOf('document') >= 0 || evType.indexOf('doc_role') >= 0) return 'document';
      if (evType.indexOf('schema') >= 0) return 'batch';
      if (evType.indexOf('session') >= 0) return 'session';
      if (evType.indexOf('undo') >= 0) return 'row';
      if (evType.indexOf('rollback') >= 0) {
        var meta = ev.metadata || {};
        return meta.scope || 'row';
      }
      if (ev.record_id && ev.record_id.indexOf('ctr_') === 0) return 'contract';
      if (ev.record_id) return 'row';
      return 'batch';
    }

    var AUDIT_TYPE_CATEGORIES = {
      patch: ['patch_submitted', 'PATCH_SUBMITTED', 'patch_admin_promoted', 'PATCH_ADMIN_PROMOTED', 'field_verified', 'FIELD_VERIFIED', 'field_blacklisted', 'FIELD_BLACKLISTED', 'field_corrected', 'FIELD_CORRECTED', 'request_clarification', 'REQUEST_CLARIFICATION'],
      schema_change: ['schema_change', 'SCHEMA_CHANGE'],
      system_change: ['system_pass_rerun', 'system_change_proposed', 'system_change_accepted', 'system_change_rejected', 'system_change_applied', 'SYSTEM_CHANGE_APPLIED'],
      rollback: ['preflight_blocker_detected', 'rollback_created', 'ROLLBACK_CREATED', 'rollback_applied', 'ROLLBACK_APPLIED', 'undo_local', 'UNDO_LOCAL', 'system_change_routed_to_patch', 'SYSTEM_CHANGE_ROUTED_TO_PATCH'],
      session: ['session_restored', 'SESSION_RESTORED', 'document_role_confirmed', 'document_role_set', 'catalog_group_set', 'CATALOG_GROUP_SET', 'manual_row_add', 'MANUAL_ROW_ADD', 'batch_merged', 'BATCH_MERGED', 'tenant_rule_promoted_to_batch', 'TENANT_RULE_PROMOTED_TO_BATCH', 'contract_index_built', 'CONTRACT_INDEX_BUILT', 'batch_created', 'BATCH_CREATED', 'contract_rollup_updated', 'CONTRACT_ROLLUP_UPDATED', 'unknown_column_detected', 'UNKNOWN_COLUMN_DETECTED']
    };

    function _eventMatchesTypeCategory(evType, category) {
      if (!category) return true;
      var list = AUDIT_TYPE_CATEGORIES[category];
      return list ? list.indexOf(evType) >= 0 : false;
    }

    function openFullAuditPanel() {
      var dd = document.getElementById('audit-header-dropdown');
      if (dd) dd.style.display = 'none';
      var panel = document.getElementById('audit-full-panel');
      if (panel) panel.style.display = 'block';
      refreshFullAuditPanel();
    }

    function closeFullAuditPanel() {
      var panel = document.getElementById('audit-full-panel');
      if (panel) panel.style.display = 'none';
    }

    function refreshFullAuditPanel() {
      var scopeFilter = document.getElementById('audit-full-filter-scope');
      var typeFilter = document.getElementById('audit-full-filter-type');
      var roleFilter = document.getElementById('audit-full-filter-role');
      var searchInput = document.getElementById('audit-full-search');
      var scope = scopeFilter ? scopeFilter.value : '';
      var typeCategory = typeFilter ? typeFilter.value : '';
      var role = roleFilter ? roleFilter.value : '';
      var search = searchInput ? searchInput.value.toLowerCase().trim() : '';

      var events = AuditTimeline._memCache.slice().sort(function(a, b) {
        return (b.timestamp_iso || '').localeCompare(a.timestamp_iso || '');
      });

      var filtered = events.filter(function(ev) {
        if (scope && _inferAuditScope(ev) !== scope) return false;
        if (typeCategory && !_eventMatchesTypeCategory(ev.event_type, typeCategory)) return false;
        if (role && ev.actor_role !== role) return false;
        if (search) {
          var hay = ((ev.event_type || '') + ' ' + (ev.record_id || '') + ' ' + (ev.actor_role || '') + ' ' + JSON.stringify(ev.metadata || {})).toLowerCase();
          if (hay.indexOf(search) < 0) return false;
        }
        return true;
      });

      var countEl = document.getElementById('audit-full-count');
      if (countEl) countEl.textContent = filtered.length + ' of ' + events.length + ' events';

      var tbody = document.getElementById('audit-full-table-body');
      if (!tbody) return;
      if (filtered.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="padding: 20px; text-align: center; color: #999;">No events match filters</td></tr>';
        return;
      }

      var displayEvents = filtered.slice(0, 200);
      var html = '';
      displayEvents.forEach(function(ev) {
        var ts = ev.timestamp_iso ? new Date(ev.timestamp_iso).toLocaleString() : '';
        var evType = _canonicalAuditEventName(ev.event_type);
        var scopeType = _inferAuditScope(ev);
        var scopeId = ev.record_id || ev.dataset_id || '';
        var details = '';
        if (ev.field_key) details += ev.field_key + ': ';
        if (ev.before_value !== null && ev.before_value !== undefined) details += '"' + String(ev.before_value).substring(0, 20) + '"→';
        if (ev.after_value !== null && ev.after_value !== undefined) details += '"' + String(ev.after_value).substring(0, 20) + '"';
        if (!details && ev.metadata) {
          var metaKeys = Object.keys(ev.metadata).slice(0, 3);
          details = metaKeys.map(function(k) { return k + ':' + String(ev.metadata[k]).substring(0, 15); }).join(', ');
        }
        html += '<tr style="border-bottom: 1px solid #f0f0f0;">';
        html += '<td style="padding: 6px 10px; white-space: nowrap; color: #666;">' + escapeHtml(ts) + '</td>';
        html += '<td style="padding: 6px 10px; font-weight: 600;">' + escapeHtml(evType) + '</td>';
        html += '<td style="padding: 6px 10px;"><span style="background: #e3f2fd; padding: 1px 6px; border-radius: 3px; font-size: 0.85em;">' + escapeHtml(scopeType) + '</span> <span style="font-size: 0.8em; color: #888;">' + escapeHtml(scopeId.substring(0, 20)) + '</span></td>';
        html += '<td style="padding: 6px 10px;">' + escapeHtml(ev.actor_role || '') + '</td>';
        html += '<td style="padding: 6px 10px; font-size: 0.9em; color: #666; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + escapeHtml(details) + '</td>';
        html += '</tr>';
      });
      if (filtered.length > 200) {
        html += '<tr><td colspan="5" style="padding: 10px; text-align: center; color: #888; font-size: 0.85em;">Showing 200 of ' + filtered.length + ' events</td></tr>';
      }
      tbody.innerHTML = html;
    }

    function exportAuditLogOnly() {
      if (typeof XLSX === 'undefined') {
        showToast('SheetJS not loaded — cannot export', 'error');
        return;
      }
      var events = AuditTimeline._memCache.slice().sort(function(a, b) {
        return (a.timestamp_iso || '').localeCompare(b.timestamp_iso || '');
      });
      var headers = ['event_id', 'timestamp', 'event_type', 'subtype', 'actor_role', 'scope_type', 'scope_id', 'payload_summary', 'artifact_refs'];
      var rows = [headers];
      events.forEach(function(ev) {
        var evType = _canonicalAuditEventName(ev.event_type);
        var scopeType = _inferAuditScope(ev);
        var scopeId = ev.record_id || ev.dataset_id || '';
        var subtype = (ev.metadata && ev.metadata.subtype) || (ev.metadata && ev.metadata.event_type) || '';
        var payloadSummary = '';
        if (ev.field_key) payloadSummary += 'field:' + ev.field_key;
        if (ev.before_value !== null && ev.before_value !== undefined) payloadSummary += ' before:' + String(ev.before_value).substring(0, 80);
        if (ev.after_value !== null && ev.after_value !== undefined) payloadSummary += ' after:' + String(ev.after_value).substring(0, 80);
        if (ev.metadata) {
          var metaStr = JSON.stringify(ev.metadata);
          if (metaStr.length > 2) payloadSummary += ' meta:' + metaStr.substring(0, 200);
        }
        var artifactRefs = '';
        if (ev.patch_request_id) artifactRefs += 'patch:' + ev.patch_request_id;
        if (ev.metadata && ev.metadata.patch_request_id) artifactRefs += (artifactRefs ? '; ' : '') + 'patch:' + ev.metadata.patch_request_id;
        if (ev.metadata && ev.metadata.proposal_id) artifactRefs += (artifactRefs ? '; ' : '') + 'proposal:' + ev.metadata.proposal_id;
        if (ev.metadata && ev.metadata.rollback_id) artifactRefs += (artifactRefs ? '; ' : '') + 'rollback:' + ev.metadata.rollback_id;
        rows.push([ev.event_id, ev.timestamp_iso, ev.actor_role, scopeType, scopeId, evType, subtype, payloadSummary, artifactRefs]);
      });
      var wb = XLSX.utils.book_new();
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) { return { wch: Math.max(15, h.length + 5) }; });
      XLSX.utils.book_append_sheet(wb, ws, 'Audit_Log');
      var dsId = IDENTITY_CONTEXT.dataset_id || 'export';
      var ts = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
      XLSX.writeFile(wb, 'audit_log_' + dsId + '_' + ts + '.xlsx');
      showToast('Audit log exported (' + events.length + ' events)', 'success');
    }

    function showAuditLogForRecord() {
      var recordKey = srrState.currentRecordKey || (srrState.currentSheet + ':' + srrState.currentRowIndex);
      console.log('[SRR] Opening audit log for record:', recordKey);

      AuditTimeline.query({ record_id: recordKey }).then(function(events) {
        if (!events || events.length === 0) {
          showToast('No audit log entries for this record', 'info');
          return;
        }
        events.sort(function(a, b) { return a.timestamp_iso < b.timestamp_iso ? -1 : 1; });
        showAuditLogModal(events, { scope: 'record', scopeLabel: recordKey });
      });
    }

    function showAuditLogForDataset(filters) {
      var dsId = (filters && filters.dataset_id) || IDENTITY_CONTEXT.dataset_id || '';
      var q = { dataset_id: dsId };
      if (filters && filters.file_id) q.file_id = filters.file_id;
      if (filters && filters.event_type) q.event_type = filters.event_type;
      if (filters && filters.actor_role) q.actor_role = filters.actor_role;
      if (filters && filters.patch_request_id) q.patch_request_id = filters.patch_request_id;

      AuditTimeline.query(q).then(function(events) {
        if (!events || events.length === 0) {
          showToast('No audit log entries found', 'info');
          return;
        }
        events.sort(function(a, b) { return a.timestamp_iso < b.timestamp_iso ? -1 : 1; });
        showAuditLogModal(events, { scope: 'dataset', scopeLabel: dsId, filters: q });
      });
    }

    var _auditLogSortAsc = true;
    var _auditLogFilters = {};

    function showAuditLogModal(events, options) {
      var opts = options || {};
      _auditLogFilters = opts.filters || {};

      var eventTypes = [];
      var roles = [];
      events.forEach(function(ev) {
        var _evType = ev.event_type;
        var _ALIASES = {'BATCH_MERGED':'batch_merged','TENANT_RULE_PROMOTED_TO_BATCH':'tenant_rule_promoted_to_batch'};
        var _canonical = _ALIASES[_evType] || _evType;
        if (eventTypes.indexOf(_canonical) < 0) eventTypes.push(_canonical);
        if (roles.indexOf(ev.actor_role) < 0) roles.push(ev.actor_role);
      });
      eventTypes.sort();
      roles.sort();

      var html = '<div style="margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">';
      html += '<select id="audit-filter-type" onchange="auditLogApplyFilters()" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em;">';
      html += '<option value="">All Events</option>';
      eventTypes.forEach(function(t) { html += '<option value="' + t + '">' + t + '</option>'; });
      html += '</select>';
      html += '<select id="audit-filter-role" onchange="auditLogApplyFilters()" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em;">';
      html += '<option value="">All Roles</option>';
      roles.forEach(function(r) { html += '<option value="' + r + '">' + r.charAt(0).toUpperCase() + r.slice(1) + '</option>'; });
      html += '</select>';
      html += '<input id="audit-filter-prid" placeholder="Patch Request ID" onkeyup="auditLogApplyFilters()" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.85em; width: 140px;">';
      html += '<button onclick="auditLogToggleSort()" style="padding: 4px 10px; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5; cursor: pointer; font-size: 0.85em;" title="Toggle sort order" id="audit-sort-btn">Oldest First</button>';
      html += '</div>';

      html += '<div id="audit-log-body" style="max-height: 55vh; overflow-y: auto;">';
      html += renderAuditLogTable(events);
      html += '</div>';

      window._auditLogEvents = events;
      showInfoModal('Audit Log (' + events.length + ' events)', html);
    }

    function renderAuditLogTable(events) {
      var typeColors = {
        'PATCH_REQUEST_SUBMITTED': '#e3f2fd',
        'VERIFIER_APPROVED': '#e8f5e9',
        'ADMIN_APPROVED': '#f3e5f5',
        'PATCH_REJECTED': '#fce4ec',
        'PATCH_CANCELLED': '#efebe9',
        'FIELD_VERIFIED': '#e8f5e9',
        'FIELD_BLACKLISTED': '#fce4ec',
        'FIELD_CORRECTED': '#fff3e0',
        'REQUEST_CLARIFICATION': '#fff8e1',
        'MANUAL_ROW_ADD': '#e0f2f1',
        'PATCH_SUBMITTED': '#e3f2fd',
        'PATCH_ADMIN_PROMOTED': '#f3e5f5',
        'CATALOG_GROUP_SET': '#e0f2f1',
        'CONTRACT_INDEX_BUILT': '#e3f2fd',
        'SCHEMA_CHANGE': '#f3e5f5',
        'BATCH_CREATED': '#e8eaf6',
        'UNKNOWN_COLUMN_DETECTED': '#fff3e0',
        'CONTRACT_ROLLUP_UPDATED': '#e0f7fa',
        'SESSION_RESTORED': '#eceff1',
        'BATCH_MERGED': '#e8eaf6',
        'batch_merged': '#e8eaf6',
        'TENANT_RULE_PROMOTED_TO_BATCH': '#f3e5f5',
        'tenant_rule_promoted_to_batch': '#f3e5f5'
      };

      var html = '<table style="width: 100%; border-collapse: collapse; font-size: 0.82em;">';
      html += '<thead><tr style="background: #f5f5f5;">';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd; white-space: nowrap;">Time</th>';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd;">Event</th>';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd;">Actor</th>';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd;">Role</th>';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd;">Record</th>';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd;">Field</th>';
      html += '<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #ddd;">Details</th>';
      html += '</tr></thead><tbody>';

      events.slice(0, 200).forEach(function(ev) {
        var evType = ev.event_type;
        var AUDIT_EVENT_ALIASES = {'BATCH_MERGED':'batch_merged','TENANT_RULE_PROMOTED_TO_BATCH':'tenant_rule_promoted_to_batch'};
        var canonicalType = AUDIT_EVENT_ALIASES[evType] || evType;
        var bg = typeColors[canonicalType] || typeColors[evType] || '#f9f9f9';
        var ts = ev.timestamp_iso ? new Date(ev.timestamp_iso).toLocaleString() : '-';
        var details = '';
        if (ev.metadata) {
          if (ev.metadata.from_status && ev.metadata.to_status) details = ev.metadata.from_status + ' → ' + ev.metadata.to_status;
          else if (ev.metadata.notes) details = ev.metadata.notes;
          else if (ev.metadata.decision) details = ev.metadata.decision;
          else if (ev.metadata.patch_type) details = ev.metadata.patch_type;
        }
        var recordLink = ev.record_id ? '<a href="#" onclick="auditLogNavigateToRecord(\x27' + escapeHtml(ev.record_id) + '\x27); return false;" style="color: #1565c0;">' + escapeHtml(ev.record_id) + '</a>' : '-';

        html += '<tr style="border-bottom: 1px solid #eee;">';
        html += '<td style="padding: 6px 8px; white-space: nowrap; color: #666;">' + escapeHtml(ts) + '</td>';
        html += '<td style="padding: 6px 8px;"><span style="background: ' + bg + '; color: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.85em;">' + escapeHtml(canonicalType) + '</span></td>';
        html += '<td style="padding: 6px 8px; font-size: 0.9em;">' + escapeHtml(ev.actor_id || '-') + '</td>';
        html += '<td style="padding: 6px 8px;"><span style="text-transform: capitalize;">' + escapeHtml(ev.actor_role || '-') + '</span></td>';
        html += '<td style="padding: 6px 8px; font-family: monospace; font-size: 0.85em;">' + recordLink + '</td>';
        html += '<td style="padding: 6px 8px; font-family: monospace; font-size: 0.85em;">' + escapeHtml(ev.field_key || '-') + '</td>';
        html += '<td style="padding: 6px 8px; font-size: 0.9em;">' + escapeHtml(details || '-') + '</td>';
        html += '</tr>';
      });

      html += '</tbody></table>';
      if (events.length > 200) {
        html += '<div style="padding: 8px; text-align: center; color: #666; font-size: 0.85em;">Showing 200 of ' + events.length + ' events</div>';
      }
      return html;
    }

    function auditLogApplyFilters() {
      var typeFilter = document.getElementById('audit-filter-type')?.value || '';
      var roleFilter = document.getElementById('audit-filter-role')?.value || '';
      var prFilter = document.getElementById('audit-filter-prid')?.value.trim() || '';
      var events = (window._auditLogEvents || []).filter(function(ev) {
        if (typeFilter) { var _a2 = {'BATCH_MERGED':'batch_merged','TENANT_RULE_PROMOTED_TO_BATCH':'tenant_rule_promoted_to_batch'}; var _c2 = _a2[ev.event_type] || ev.event_type; if (_c2 !== typeFilter) return false; }
        if (roleFilter && ev.actor_role !== roleFilter) return false;
        if (prFilter && (!ev.patch_request_id || ev.patch_request_id.indexOf(prFilter) < 0)) return false;
        return true;
      });
      events.sort(function(a, b) {
        return _auditLogSortAsc
          ? (a.timestamp_iso < b.timestamp_iso ? -1 : 1)
          : (a.timestamp_iso > b.timestamp_iso ? -1 : 1);
      });
      var body = document.getElementById('audit-log-body');
      if (body) body.innerHTML = renderAuditLogTable(events);
    }

    function auditLogToggleSort() {
      _auditLogSortAsc = !_auditLogSortAsc;
      var btn = document.getElementById('audit-sort-btn');
      if (btn) btn.textContent = _auditLogSortAsc ? 'Oldest First' : 'Newest First';
      auditLogApplyFilters();
    }

    function auditLogNavigateToRecord(recordId) {
      var overlay = document.getElementById('info-modal-overlay');
      if (overlay) overlay.remove();
      if (!recordId || recordId === '-') return;
      var parts = recordId.split(':');
      if (parts.length >= 2) {
        var sheet = parts[0];
        var idx = parseInt(parts[1], 10);
        if (!isNaN(idx) && workbook && workbook.sheets && workbook.sheets[sheet]) {
          navigateTo('srr');
          setTimeout(function() { srrNavigateToRecord(sheet, idx); }, 200);
        }
      }
    }
    
    // v1.6.4: Simple info modal helper
    function showInfoModal(title, contentHtml) {
      var overlay = document.createElement('div');
      overlay.className = 'modal-overlay active';
      overlay.id = 'info-modal-overlay';
      overlay.onclick = function(e) { if (e.target === overlay) overlay.remove(); };
      
      overlay.innerHTML = '<div class="modal" style="max-width: 700px;">' +
        '<div class="modal-header"><h3>' + escapeHtml(title) + '</h3><button class="modal-close" onclick="document.getElementById(\'info-modal-overlay\').remove()">&times;</button></div>' +
        '<div class="modal-body">' + contentHtml + '</div>' +
        '<div class="modal-footer"><button class="modal-btn modal-btn-secondary" onclick="document.getElementById(\'info-modal-overlay\').remove()">Close</button></div>' +
        '</div>';
      
      document.body.appendChild(overlay);
    }

    // ========== VERIFIER TRIAGE & PAYLOAD SYSTEM (v1.5.2) ==========
    var verifierQueueState = {
      activeQueue: 'pending',
      payloads: JSON.parse(localStorage.getItem('srr_verifier_queue_v1') || '[]')
    };
    
    // v1.5.2: Verifier filter state with persistence
    var verifierFilterState = {
      division: localStorage.getItem('verifier_filter_division') || '',
      status: localStorage.getItem('verifier_filter_status') || '',
      patchType: localStorage.getItem('verifier_filter_patchtype') || ''
    };
    
    function onVerifierFilterChange() {
      var divisionEl = document.getElementById('verifier-filter-division');
      var statusEl = document.getElementById('verifier-filter-status');
      
      verifierFilterState.division = divisionEl ? divisionEl.value : '';
      verifierFilterState.status = statusEl ? statusEl.value : '';
      
      // Persist to localStorage
      localStorage.setItem('verifier_filter_division', verifierFilterState.division);
      localStorage.setItem('verifier_filter_status', verifierFilterState.status);
      
      // Re-render triage with filters
      renderVerifierTriage();
      
      // Also re-render grid if in verifier mode
      if (currentMode === 'verifier') {
        renderVerifierGrid();
      }
      
      console.log('[Verifier] Filter changed:', verifierFilterState);
    }
    
    function setVerifierPatchType(ptype) {
      verifierFilterState.patchType = ptype;
      localStorage.setItem('verifier_filter_patchtype', ptype);
      
      // Update tab styling
      document.querySelectorAll('.pt-tab').forEach(function(tab) {
        var tabPtype = tab.getAttribute('data-ptype');
        if (tabPtype === ptype) {
          tab.style.background = '#e3f2fd';
          tab.style.color = '#1565c0';
          tab.style.border = '1px solid #1565c0';
        } else {
          tab.style.background = '#f5f5f5';
          tab.style.color = '#333';
          tab.style.border = '1px solid #ddd';
        }
      });
      
      renderVerifierTriage();
      console.log('[Verifier] Patch type changed:', ptype);
    }
    
    function initVerifierFilters() {
      // Populate division dropdown from PatchRequest store
      var divisions = new Set();
      var hasUnassigned = false;
      var allPRs = PATCH_REQUEST_STORE.list();
      
      allPRs.forEach(function(pr) {
        if (pr.division_id) {
          divisions.add(pr.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      // Also scan verifier queue payloads
      verifierQueueState.payloads.forEach(function(p) {
        if (p.division_id) {
          divisions.add(p.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      var divisionEl = document.getElementById('verifier-filter-division');
      if (divisionEl) {
        divisionEl.innerHTML = '<option value="">All Divisions</option>';
        // Add Unassigned option if there are items without division_id
        if (hasUnassigned) {
          var unassignedOpt = document.createElement('option');
          unassignedOpt.value = '__unassigned__';
          unassignedOpt.textContent = 'Unassigned';
          divisionEl.appendChild(unassignedOpt);
        }
        Array.from(divisions).sort().forEach(function(div) {
          var opt = document.createElement('option');
          opt.value = div;
          opt.textContent = div;
          divisionEl.appendChild(opt);
        });
        
        // Restore saved filter
        divisionEl.value = verifierFilterState.division;
      }
      
      var statusEl = document.getElementById('verifier-filter-status');
      if (statusEl) {
        statusEl.value = verifierFilterState.status;
      }
      
      // Restore patch type tab styling
      if (verifierFilterState.patchType) {
        setVerifierPatchType(verifierFilterState.patchType);
      } else {
        updatePatchTypeCounts();
      }
      
      // Also init grid filter dropdowns
      initVerifierGridFilters();
    }
    
    function updatePatchTypeCounts() {
      var counts = { all: 0, correction: 0, blacklist: 0, rfi: 0 };
      verifierQueueState.payloads.forEach(function(p) {
        counts.all++;
        if (p.type === 'correction') counts.correction++;
        else if (p.type === 'blacklist') counts.blacklist++;
        else if (p.type === 'rfi') counts.rfi++;
      });
      
      var allEl = document.getElementById('pt-count-all');
      var corrEl = document.getElementById('pt-count-correction');
      var blEl = document.getElementById('pt-count-blacklist');
      var rfiEl = document.getElementById('pt-count-rfi');
      
      if (allEl) allEl.textContent = '(' + counts.all + ')';
      if (corrEl) corrEl.textContent = '(' + counts.correction + ')';
      if (blEl) blEl.textContent = '(' + counts.blacklist + ')';
      if (rfiEl) rfiEl.textContent = '(' + counts.rfi + ')';
    }
    
    function initVerifierGridFilters() {
      // Populate grid division dropdown (same data as triage)
      var divisions = new Set();
      var hasUnassigned = false;
      var allPRs = PATCH_REQUEST_STORE.list();
      
      allPRs.forEach(function(pr) {
        if (pr.division_id) {
          divisions.add(pr.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      verifierQueueState.payloads.forEach(function(p) {
        if (p.division_id) {
          divisions.add(p.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      var divisionEl = document.getElementById('verifier-grid-filter-division');
      if (divisionEl) {
        divisionEl.innerHTML = '<option value="">All Divisions</option>';
        // Add Unassigned option if there are items without division_id
        if (hasUnassigned) {
          var unassignedOpt = document.createElement('option');
          unassignedOpt.value = '__unassigned__';
          unassignedOpt.textContent = 'Unassigned';
          divisionEl.appendChild(unassignedOpt);
        }
        Array.from(divisions).sort().forEach(function(div) {
          var opt = document.createElement('option');
          opt.value = div;
          opt.textContent = div;
          divisionEl.appendChild(opt);
        });
        divisionEl.value = verifierFilterState.division;
      }
      
      var statusEl = document.getElementById('verifier-grid-filter-status');
      if (statusEl) {
        statusEl.value = verifierFilterState.status;
      }
    }
    
    function onVerifierGridFilterChange() {
      var divisionEl = document.getElementById('verifier-grid-filter-division');
      var statusEl = document.getElementById('verifier-grid-filter-status');
      
      verifierFilterState.division = divisionEl ? divisionEl.value : '';
      verifierFilterState.status = statusEl ? statusEl.value : '';
      
      // Persist
      localStorage.setItem('verifier_filter_division', verifierFilterState.division);
      localStorage.setItem('verifier_filter_status', verifierFilterState.status);
      
      // Sync triage dropdowns
      var triageDivisionEl = document.getElementById('verifier-filter-division');
      var triageStatusEl = document.getElementById('verifier-filter-status');
      if (triageDivisionEl) triageDivisionEl.value = verifierFilterState.division;
      if (triageStatusEl) triageStatusEl.value = verifierFilterState.status;
      
      // Re-render grid with new filters applied
      renderGrid();
      
      console.log('[Verifier] Grid filter changed:', verifierFilterState);
    }
    
    function renderVerifierGrid() {
      // v1.5.2: Verifier-specific grid with status highlighting and read-only behavior
      // This enhances the normal grid render with PR status highlighting
      
      // First, build a map of record_id -> PatchRequest status
      var prStatusMap = {};
      var allPRs = PATCH_REQUEST_STORE.list();
      
      allPRs.forEach(function(pr) {
        var recordId = pr.record_id || '';
        var prInfo = {
          status: pr.status,
          patch_request_id: pr.request_id || pr.patch_request_id,
          dataset_id: pr.dataset_id,
          division_id: pr.division_id
        };
        
        // v1.5.3 Fix: Index by multiple aliases for reliable lookup
        if (recordId) {
          prStatusMap[recordId] = prInfo;
        }
        // Also index by contract_key if present
        if (pr.contract_key && pr.contract_key !== recordId) {
          prStatusMap[pr.contract_key] = prInfo;
        }
        // Also index by record_identity.contract_key if different
        if (pr.record_identity && pr.record_identity.contract_key) {
          var ck = pr.record_identity.contract_key;
          if (ck !== recordId) {
            prStatusMap[ck] = prInfo;
          }
        }
      });
      
      // Also scan verifier queue payloads
      verifierQueueState.payloads.forEach(function(p) {
        var recordId = p.record_id || '';
        var prInfo = {
          status: p.status,
          patch_request_id: p.patch_request_id || p.id,
          artifact_id: p.artifact_id || p.id,
          dataset_id: p.dataset_id,
          division_id: p.division_id
        };
        
        // v1.5.3 Fix: Index by multiple aliases
        if (recordId) {
          prStatusMap[recordId] = prInfo;
        }
        // Also index by contract_key as alias
        if (p.contract_key && p.contract_key !== recordId) {
          prStatusMap[p.contract_key] = prInfo;
        }
      });
      
      // Store for use in row click handler and grid filtering
      window.verifierPrStatusMap = prStatusMap;
      
      // Update count display
      var countEl = document.getElementById('verifier-grid-filter-count');
      if (countEl) {
        var activeCount = Object.keys(prStatusMap).length;
        var filterText = activeCount + ' records with active PatchRequests';
        if (verifierFilterState.division || verifierFilterState.status) {
          filterText += ' (filtered)';
        }
        countEl.textContent = filterText;
      }
      
      console.log('[Verifier] Grid status map built:', Object.keys(prStatusMap).length, 'records');
    }
    
    function getVerifierRowHighlight(recordId) {
      // v1.5.2: Return highlight color based on PatchRequest status
      if (!window.verifierPrStatusMap) return null;
      var prInfo = window.verifierPrStatusMap[recordId];
      if (!prInfo) return null;
      
      var status = prInfo.status;
      switch (status) {
        case 'pending':
        case 'pending_review':
          return { bg: '#fffde7', border: '#fff59d' }; // Subtle yellow
        case 'needs_clarification':
          return { bg: '#fff3e0', border: '#ffcc80' }; // Orange
        case 'sent_to_admin':
          return { bg: '#e3f2fd', border: '#90caf9' }; // Blue
        case 'resolved':
          return { bg: '#e8f5e9', border: '#a5d6a7' }; // Green
        default:
          return null;
      }
    }
    
    function handleVerifierRowClick(recordId, sheetName, rowIndex) {
      // v1.5.3 Fix: Verifier row click - route to Verifier Review via patch_request_id
      // Try multiple lookup keys for robustness
      var prInfo = null;
      var keysChecked = [];
      
      if (window.verifierPrStatusMap) {
        // Try record_id first
        if (recordId) {
          keysChecked.push(recordId);
          prInfo = window.verifierPrStatusMap[recordId];
        }
        
        // Fallback: try sheetName:rowIndex pattern
        if (!prInfo) {
          var aliasKey = sheetName + ':' + rowIndex;
          keysChecked.push(aliasKey);
          prInfo = window.verifierPrStatusMap[aliasKey];
        }
      }
      
      if (prInfo && prInfo.patch_request_id) {
        // Open Verifier Review with this patch_request_id
        console.log('[Verifier] Opening Verifier Review for:', prInfo.patch_request_id, 'record:', recordId);
        openVerifierReviewDetail(prInfo.patch_request_id);
      } else {
        // No PatchRequest found - provide detailed debug info
        var knownRecordIds = window.verifierPrStatusMap ? Object.keys(window.verifierPrStatusMap) : [];
        
        console.warn('[Verifier] No PatchRequest for record. Keys checked:', keysChecked.join(', '),
          '| Known PRs (' + knownRecordIds.length + '):', knownRecordIds.slice(0, 8).join(', ') + (knownRecordIds.length > 8 ? '...' : ''));
        
        // Show more helpful message
        if (knownRecordIds.length === 0) {
          showToast('No PatchRequests loaded. Submit a patch from Analyst view first.', 'warning');
        } else {
          showToast('No PatchRequest found for record ' + recordId + '. Checked keys: ' + keysChecked.join(', '), 'info');
        }
      }
    }

    // v1.5.3 Fix: Reload verifier queues from canonical stores (independent of analyst SRR state)
    function reloadVerifierQueuesFromStore() {
      console.log('[Verifier] Reloading queues from canonical stores...');
      
      // Step 1: Load from localStorage-persisted verifier queue
      var savedQueue = localStorage.getItem('srr_verifier_queue_v1');
      if (savedQueue) {
        try {
          var parsed = JSON.parse(savedQueue);
          if (Array.isArray(parsed)) {
            verifierQueueState.payloads = parsed;
            console.log('[Verifier] Loaded', parsed.length, 'items from saved queue');
          }
        } catch (e) {
          console.warn('[Verifier] Failed to parse saved queue:', e);
        }
      }
      
      // Step 2: Build comprehensive existingIds set (includes all ID types)
      var existingIds = new Set();
      verifierQueueState.payloads.forEach(function(p) {
        if (p.id) existingIds.add(p.id);
        if (p.patch_request_id) existingIds.add(p.patch_request_id);
        if (p.artifact_id) existingIds.add(p.artifact_id);
      });
      
      // Step 3: Sync with PATCH_REQUEST_STORE (canonical source) - add missing items
      var allPRs = PATCH_REQUEST_STORE.list();
      allPRs.forEach(function(pr) {
        var prId = pr.request_id || pr.id;
        var artId = pr.artifact_id;
        
        // Skip if already in queue (by any ID type)
        if (existingIds.has(prId) || (artId && existingIds.has(artId))) return;
        
        // Add to queue as payload
        var newPayload = {
          id: artId || prId,
          type: pr.patch_type || pr.patch_kind || 'correction',
          record_id: pr.record_id,
          dataset_id: pr.dataset_id,
          patch_request_id: prId,
          division_id: pr.division_id,
          field: pr.field || pr.target_field,
          old_value: pr.old_value || '',
          new_value: pr.new_value || '',
          comment: pr.because || pr.evidence_justification || '',
          analyst_id: pr.author,
          timestamp: pr.created_at,
          status: pr.status || 'pending',
          artifact_id: artId
        };
        verifierQueueState.payloads.push(newPayload);
        
        // v1.5.3 Fix: Update existingIds to prevent duplicates in Step 4
        existingIds.add(prId);
        if (artId) existingIds.add(artId);
        console.log('[Verifier] Added PR from store:', prId);
      });
      
      // Step 4: Sync with ArtifactStore - add missing artifacts (checks updated existingIds)
      var allArtifacts = listArtifacts ? listArtifacts() : [];
      allArtifacts.forEach(function(art) {
        // v1.5.3 Fix: Check all ID types to prevent duplicates
        if (existingIds.has(art.artifact_id)) return;
        var linkedPrId = art.body?.patch_request_id || art.body?.legacy_request_id;
        if (linkedPrId && existingIds.has(linkedPrId)) return;
        
        // Add artifact to queue
        var newPayload = {
          id: art.artifact_id,
          type: art.body?.patch_type || (art.artifact_type === 'rfi' ? 'rfi' : 'correction'),
          record_id: art.record_id,
          dataset_id: art.dataset_id,
          patch_request_id: linkedPrId,
          division_id: art.division_id,
          field: art.field_key,
          old_value: art.body?.old_value || '',
          new_value: art.body?.new_value || '',
          comment: art.body?.comment || '',
          analyst_id: art.created_by_actor_id,
          timestamp: art.created_at,
          status: art.status || 'pending',
          artifact_id: art.artifact_id
        };
        verifierQueueState.payloads.push(newPayload);
        
        // Update existingIds
        existingIds.add(art.artifact_id);
        if (linkedPrId) existingIds.add(linkedPrId);
        console.log('[Verifier] Added artifact from store:', art.artifact_id);
      });
      
      // Step 5: Final de-dupe pass by id (safety net)
      var seenIds = new Set();
      verifierQueueState.payloads = verifierQueueState.payloads.filter(function(p) {
        var key = p.id || p.patch_request_id || p.artifact_id;
        if (seenIds.has(key)) return false;
        seenIds.add(key);
        return true;
      });
      
      // Save merged queue
      saveVerifierQueue();
      console.log('[Verifier] Queue reload complete. Total items:', verifierQueueState.payloads.length);
    }
    
    function addVerifierPayload(payload) {
      verifierQueueState.payloads.push(payload);
      saveVerifierQueue();
      console.log('[Verifier] Payload added:', payload);
    }

    function saveVerifierQueue() {
      localStorage.setItem('srr_verifier_queue_v1', JSON.stringify(verifierQueueState.payloads));
    }

    function setVerifierQueue(queue) {
      verifierQueueState.activeQueue = queue;
      document.querySelectorAll('.v-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.vqueue === queue);
        t.style.background = t.dataset.vqueue === queue ? '#e3f2fd' : 'transparent';
        t.style.color = t.dataset.vqueue === queue ? '#1565c0' : '#666';
      });
      renderVerifierTriage();
    }

    function matchesDivisionFilter(item) {
      // Helper to check if item matches division filter, handling Unassigned
      if (!verifierFilterState.division) return true;
      if (verifierFilterState.division === '__unassigned__') {
        return !item.division_id;
      }
      return item.division_id === verifierFilterState.division;
    }
    
    // =====================
    // ANALYST TRIAGE (v1.5.5) - Multi-queue dashboard
    // =====================
    

    // ========================================================================
    // V2.3: Triage Analytics Aggregator + Renderer
    // ========================================================================

    // ===== P1G: Contract Health Score Engine =====
    var ContractHealthScore = {
      _scores: {},
      _prevScores: {},
      _activeBandFilter: 'all',

      PENALTY: {
        PREFLIGHT_BLOCKER: 20,
        PREFLIGHT_WARNING: 5,
        PREFLIGHT_CAP: 60,
        SP_READY: 10,
        SP_PROPOSALS_PENDING: 15,
        SP_REJECTED: 8,
        LIFECYCLE: {
          loaded: 15,
          preflight_complete: 12,
          system_pass_ready: 10,
          system_pass_complete: 8,
          system_changes_reviewed: 6,
          patch_submitted: 4,
          rfi_submitted: 4,
          verifier_complete: 2,
          admin_promoted: 0,
          applied: 0
        },
        UNKNOWN_COLUMNS: 6,
        DOC_TYPE_MISSING: 8,
        STALENESS_PER_30: 2,
        STALENESS_CAP: 10
      },

      BANDS: [
        { key: 'critical', label: 'Critical', min: 0, max: 34, color: '#c62828', bg: '#ffebee' },
        { key: 'at_risk', label: 'At Risk', min: 35, max: 59, color: '#e65100', bg: '#fff3e0' },
        { key: 'watch', label: 'Watch', min: 60, max: 84, color: '#f9a825', bg: '#fffde7' },
        { key: 'healthy', label: 'Healthy', min: 85, max: 100, color: '#2e7d32', bg: '#e8f5e9' }
      ],

      getBand: function(score) {
        for (var i = 0; i < this.BANDS.length; i++) {
          if (score >= this.BANDS[i].min && score <= this.BANDS[i].max) return this.BANDS[i];
        }
        return this.BANDS[0];
      },

      computeScore: function(contractId, contractData, cache) {
        var base = 100;
        var penalties = [];
        var P = this.PENALTY;

        var pfAlerts = contractData.preflight_alerts || 0;
        var semAlerts = contractData.semantic_alerts || 0;
        var patchAlerts = contractData.patch_alerts || 0;
        var stage = contractData.current_stage || 'loaded';

        var pfBlockers = 0, pfWarnings = 0;
        var _pfSeenIds = {};
        if (typeof _p1fBatchScanItems !== 'undefined' && _p1fBatchScanItems.length > 0) {
          _p1fBatchScanItems.forEach(function(item) {
            var ck = item.contract_key || item.contract_id || '';
            var cid = item.contract_id || item.contract_key || '';
            if (ck === contractId || cid === contractId) {
              var itemKey = (item.request_id || '') + '_' + (item.field_name || '') + '_' + (item.sheet_name || '');
              if (_pfSeenIds[itemKey]) return;
              _pfSeenIds[itemKey] = true;
              var sev = (item.severity || item.condition || '').toLowerCase();
              var sigType = (item.signal_type || '').toLowerCase();
              if (sev.indexOf('blocker') >= 0 || sev.indexOf('not_searchable') >= 0 || sev.indexOf('mojibake') >= 0 || sigType.indexOf('not_searchable') >= 0 || sigType.indexOf('mojibake') >= 0 || sigType.indexOf('ocr') >= 0) pfBlockers++;
              else pfWarnings++;
            }
          });
        }
        if (typeof analystTriageState !== 'undefined' && analystTriageState.manualItems) {
          analystTriageState.manualItems.forEach(function(item) {
            var ck = item.contract_key || item.contract_id || '';
            var cid = item.contract_id || item.contract_key || '';
            if (ck === contractId || cid === contractId) {
              var itemKey = (item.request_id || '') + '_' + (item.field_name || '') + '_' + (item.sheet_name || '');
              if (_pfSeenIds[itemKey]) return;
              _pfSeenIds[itemKey] = true;
              var sev = (item.severity || '').toLowerCase();
              var sigType = (item.signal_type || '').toLowerCase();
              if (sev.indexOf('blocker') >= 0 || sigType.indexOf('not_searchable') >= 0 || sigType.indexOf('mojibake') >= 0 || sigType.indexOf('ocr') >= 0) pfBlockers++;
              else pfWarnings++;
            }
          });
        }
        if (pfBlockers === 0 && pfWarnings === 0 && pfAlerts > 0) {
          pfBlockers = Math.ceil(pfAlerts / 2);
          pfWarnings = pfAlerts - pfBlockers;
        }

        var pfPenalty = Math.min(pfBlockers * P.PREFLIGHT_BLOCKER + pfWarnings * P.PREFLIGHT_WARNING, P.PREFLIGHT_CAP);
        if (pfPenalty > 0) penalties.push({ reason: 'Pre-Flight issues', detail: pfBlockers + ' blocker, ' + pfWarnings + ' warning', value: pfPenalty });

        var spPenalty = 0;
        if (stage === 'system_pass_ready') {
          spPenalty += P.SP_READY;
          penalties.push({ reason: 'System Pass not processed', detail: 'Awaiting System Pass', value: P.SP_READY });
        }
        if (semAlerts > 0) {
          spPenalty += P.SP_PROPOSALS_PENDING;
          penalties.push({ reason: 'System proposals pending', detail: semAlerts + ' proposals', value: P.SP_PROPOSALS_PENDING });
        }

        var lcPenalty = P.LIFECYCLE[stage] || 0;
        if (lcPenalty > 0) penalties.push({ reason: 'Lifecycle stage', detail: stage.replace(/_/g, ' '), value: lcPenalty });

        var unknownCols = 0;
        if (typeof ContractIndex !== 'undefined' && ContractIndex._index && ContractIndex._index.unknown_columns) {
          var uc = ContractIndex._index.unknown_columns[contractId];
          if (uc && uc.length > 0) unknownCols = uc.length;
        }
        if (unknownCols > 0) penalties.push({ reason: 'Unknown columns', detail: unknownCols + ' columns', value: P.UNKNOWN_COLUMNS });

        var docMissing = false;
        if (!contractData.doc_role || contractData.doc_role === '-' || contractData.doc_role === '') {
          if (typeof ContractIndex !== 'undefined' && ContractIndex._index && ContractIndex._index.contracts) {
            var ci = ContractIndex._index.contracts[contractId];
            if (ci && ci.sheets) {
              var sheetKeys = Object.keys(ci.sheets);
              if (sheetKeys.length > 0) docMissing = true;
            }
          }
        }
        if (docMissing) penalties.push({ reason: 'Document type missing', detail: 'No doc role assigned', value: P.DOC_TYPE_MISSING });

        var staleMin = 0;
        if (contractData.last_updated) {
          var updatedAt = new Date(contractData.last_updated);
          if (!isNaN(updatedAt.getTime())) {
            staleMin = Math.floor((Date.now() - updatedAt.getTime()) / 60000);
          }
        }
        if (staleMin > 60) {
          var stalePenalty = Math.min(Math.floor((staleMin - 60) / 30) * P.STALENESS_PER_30, P.STALENESS_CAP);
          if (stalePenalty > 0) penalties.push({ reason: 'Staleness', detail: Math.floor(staleMin / 60) + 'h idle', value: stalePenalty });
        }

        var totalPenalty = 0;
        penalties.forEach(function(p) { totalPenalty += p.value; });
        var score = Math.max(0, Math.min(100, base - totalPenalty));
        var band = this.getBand(score);

        return {
          contract_id: contractId,
          score: score,
          band: band,
          penalties: penalties,
          total_penalty: totalPenalty
        };
      },

      computeAll: function(cache) {
        if (!cache || !cache.contracts) return;
        this._prevScores = JSON.parse(JSON.stringify(this._scores || {}));
        this._scores = {};
        var bandCounts = { critical: 0, at_risk: 0, watch: 0, healthy: 0 };
        var self = this;

        cache.contracts.forEach(function(c) {
          var result = self.computeScore(c.contract_id, c, cache);
          self._scores[c.contract_id] = result;
          bandCounts[result.band.key]++;
          c._health_score = result.score;
          c._health_band = result.band;
          c._health_penalties = result.penalties;
        });

        console.log('[CONTRACT-HEALTH][P1G] score_computed | contracts=' + cache.contracts.length + ', critical=' + bandCounts.critical + ', at_risk=' + bandCounts.at_risk + ', watch=' + bandCounts.watch + ', healthy=' + bandCounts.healthy);
        console.log('[CONTRACT-HEALTH][P1G] band_assigned | distribution: critical=' + bandCounts.critical + ', at_risk=' + bandCounts.at_risk + ', watch=' + bandCounts.watch + ', healthy=' + bandCounts.healthy);

        this._updateFilterChips(bandCounts);
        this._updateTrend();
      },

      _updateFilterChips: function(counts) {
        var bar = document.getElementById('ta-health-filter-bar');
        if (bar) bar.style.display = 'flex';
        var keys = ['critical', 'at_risk', 'watch', 'healthy'];
        keys.forEach(function(k) {
          var el = document.getElementById('health-chip-' + k.replace('_', '-') + '-count');
          if (el) el.textContent = counts[k] || 0;
        });
      },

      _updateTrend: function() {
        var updated = 0;
        var self = this;
        Object.keys(this._scores).forEach(function(cid) {
          var prev = self._prevScores[cid];
          var curr = self._scores[cid];
          if (prev && prev.score !== curr.score) {
            curr.delta = curr.score - prev.score;
            updated++;
          } else {
            curr.delta = 0;
          }
        });
        if (updated > 0) {
          console.log('[CONTRACT-HEALTH][P1G] trend_updated | contracts_with_delta=' + updated);
        }
      },

      renderHealthCell: function(c) {
        var score = c._health_score != null ? c._health_score : 100;
        var band = c._health_band || this.getBand(score);
        var result = this._scores[c.contract_id];
        var delta = result ? result.delta : 0;
        var penalties = result ? result.penalties : (c._health_penalties || []);

        var tooltipLines = ['Score: ' + score + '/100 (' + band.label + ')'];
        if (penalties.length > 0) {
          tooltipLines.push('---');
          penalties.forEach(function(p) { tooltipLines.push('-' + p.value + ' ' + p.reason + ' (' + p.detail + ')'); });
        }
        var tooltip = tooltipLines.join('\n').replace(/"/g, '&quot;');

        var deltaHtml = '';
        if (delta > 0) deltaHtml = ' <span style="color:#2e7d32; font-size:0.8em;" title="Improved +' + delta + '">&#9650;' + delta + '</span>';
        else if (delta < 0) deltaHtml = ' <span style="color:#c62828; font-size:0.8em;" title="Declined ' + delta + '">&#9660;' + Math.abs(delta) + '</span>';

        return '<td style="padding: 8px 12px; text-align: center;" title="' + tooltip + '">' +
          '<span style="display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 10px; font-size: 0.85em; background: ' + band.bg + '; color: ' + band.color + '; font-weight: 600; cursor: help;">' +
          score + '</span>' + deltaHtml + '</td>';
      },

      sortByHealth: function(contracts) {
        return contracts.slice().sort(function(a, b) {
          var sa = a._health_score != null ? a._health_score : 100;
          var sb = b._health_score != null ? b._health_score : 100;
          return sa - sb;
        });
      },

      filterByBand: function(bandKey) {
        this._activeBandFilter = bandKey;

        var chips = document.querySelectorAll('.health-filter-chip');
        chips.forEach(function(chip) {
          var isActive = chip.getAttribute('data-health-band') === bandKey;
          chip.style.border = isActive ? '2px solid ' + (bandKey === 'all' ? '#1565c0' : chip.style.color) : '1px solid transparent';
        });

        console.log('[CONTRACT-HEALTH][P1G] filter_applied | band=' + bandKey);

        if (typeof TriageAnalytics !== 'undefined' && TriageAnalytics._cache) {
          TriageAnalytics._renderContractTable(TriageAnalytics._cache, TriageAnalytics._activeStageFilter);
        }
      },

      getFilteredContracts: function(contracts) {
        if (this._activeBandFilter === 'all') return contracts;
        var band = this._activeBandFilter;
        return contracts.filter(function(c) {
          return c._health_band && c._health_band.key === band;
        });
      }
    };

    var TriageAnalytics = {
      _cache: null,
      _lastRefreshedAt: null,

      refresh: function() {
        var cache = {
          refreshed_at: new Date().toISOString(),
          lanes: {
            preflight: { unknown_columns: 0, ocr_unreadable: 0, low_confidence: 0, document_type: 0, total: 0 },
            semantic: { proposals_created: 0, accepted: 0, rejected: 0, pending: 0, hinge_impacted: 0, total: 0 },
            patch_review: { draft: 0, submitted: 0, in_verifier: 0, in_admin: 0, rfi_submitted: 0, clarification: 0, promoted: 0, applied: 0, total: 0 }
          },
          lifecycle: {
            loaded: { count: 0, pct: 0 },
            preflight_complete: { count: 0, pct: 0 },
            system_pass_ready: { count: 0, pct: 0 },
            system_pass_complete: { count: 0, pct: 0 },
            system_changes_reviewed: { count: 0, pct: 0 },
            patch_submitted: { count: 0, pct: 0 },
            rfi_submitted: { count: 0, pct: 0 },
            verifier_complete: { count: 0, pct: 0 },
            admin_promoted: { count: 0, pct: 0 },
            applied: { count: 0, pct: 0 }
          },
          contracts: [],
          schema: { standard_matched: 0, standard_total: 0, unknown_columns: 0, missing_required: 0, schema_drift: 0, defsheet_extracted_keys: 0, defsheet_fallback_hits: 0, batch_headers_total: 0, batch_headers_mapped: 0, schema_missing_required_headers: 0, data_missing_required_values: 0, _batch_mapped_items: [], _batch_unmapped_items: [], _missing_headers_items: [], _missing_values_items: [] },
          processing: { queued: 0, processing: 0, completed: 0, failed: 0 },
          total_contracts: 0
        };

        (analystTriageState.manualItems || []).forEach(function(item) {
          var bt = (item.blocker_type || item.signal_type || '').toUpperCase();
          if (bt === 'UNKNOWN_COLUMN') cache.lanes.preflight.unknown_columns++;
          else if (bt === 'OCR_UNREADABLE' || bt === 'OCR_MOJIBAKE') cache.lanes.preflight.ocr_unreadable++;
          else if (bt === 'LOW_CONFIDENCE') cache.lanes.preflight.low_confidence++;
          else if (bt === 'DOCUMENT_TYPE_MISSING') { cache.lanes.preflight.document_type++; }
          else if (bt === 'DOCUMENT_TYPE_MISSING') cache.lanes.preflight.document_type = (cache.lanes.preflight.document_type || 0) + 1;
        });
        cache.lanes.preflight.total = cache.lanes.preflight.unknown_columns + cache.lanes.preflight.ocr_unreadable + cache.lanes.preflight.low_confidence + (cache.lanes.preflight.document_type || 0);
        console.log('[TRIAGE-CANONICAL][P1X] ocr_parent_rollup: total=' + cache.lanes.preflight.ocr_unreadable);

        if (typeof SystemPass !== 'undefined' && SystemPass._proposals) {
          SystemPass._proposals.forEach(function(p) {
            cache.lanes.semantic.proposals_created++;
            if (p.status === 'accepted') cache.lanes.semantic.accepted++;
            else if (p.status === 'rejected') cache.lanes.semantic.rejected++;
            else cache.lanes.semantic.pending++;
            if (p.is_hinge) cache.lanes.semantic.hinge_impacted++;
          });
          cache.lanes.semantic.total = cache.lanes.semantic.proposals_created;
        }

        var allPatches = typeof PATCH_REQUEST_STORE !== 'undefined' ? PATCH_REQUEST_STORE.list() : [];
        allPatches.forEach(function(pr) {
          var s = (pr.status || '').toLowerCase().replace(/\s+/g, '_');
          if (s === 'draft') cache.lanes.patch_review.draft++;
          else if (s === 'submitted') cache.lanes.patch_review.submitted++;
          else if (s === 'verifier_responded' || s === 'verifier_reviewing') cache.lanes.patch_review.in_verifier++;
          else if (s.indexOf('rfi') >= 0) cache.lanes.patch_review.rfi_submitted++;
          else if (s === 'needs_clarification') cache.lanes.patch_review.clarification++;
          else if (s === 'verifier_approved') cache.lanes.patch_review.in_admin++;
          else if (s === 'admin_approved') cache.lanes.patch_review.promoted++;
          else if (s === 'applied' || s === 'closed') cache.lanes.patch_review.applied++;
        });
        cache.lanes.patch_review.total = allPatches.length;

        var totalContracts = 0;
        if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && ContractIndex._index) {
          var contractIds = Object.keys(ContractIndex._index.contracts);
          totalContracts = contractIds.length;
          cache.total_contracts = totalContracts;

          contractIds.forEach(function(cid) {
            var c = ContractIndex._index.contracts[cid];
            var contractPatches = allPatches.filter(function(pr) {
              return pr.contract_key === cid || pr.contract_id === cid;
            });

            var stage = 'loaded';
            var _hasScanResults = (typeof _p1fScanState !== 'undefined' && _p1fScanState.results);
            var _scanResult = _hasScanResults ? _p1fScanState.results[cid] : null;
            var _scanHasRun = _hasScanResults && (_p1fScanState.scanned > 0 || Object.keys(_p1fScanState.results).length > 0);

            var hasBlockers = false;
            (analystTriageState.manualItems || []).forEach(function(item) {
              if (item.contract_id === cid || item.contract_key === cid) hasBlockers = true;
            });
            if (typeof _p1fBatchScanItems !== 'undefined') {
              _p1fBatchScanItems.forEach(function(item) {
                if (item.contract_id === cid || item.contract_key === cid) hasBlockers = true;
              });
            }

            if (_scanResult) {
              if (_scanResult === 'clean') {
                if (hasBlockers) {
                  stage = 'preflight_complete';
                } else {
                  stage = 'preflight_complete';
                  var _isRoutedToSP = (typeof _p1f2CleanItems !== 'undefined') && _p1f2CleanItems.some(function(ci) { return ci.contract_key === cid; });
                  if (_isRoutedToSP) stage = 'system_pass_complete';
                }
              } else {
                stage = 'preflight_complete';
              }
            } else if (_scanHasRun && !hasBlockers) {
              stage = 'preflight_complete';
            }

            if (!hasBlockers && typeof SystemPass !== 'undefined' && SystemPass._lastRunTimestamp) {
              var cProposals = (SystemPass._proposals || []).filter(function(p) { return p.contract_id === cid; });
              if (cProposals.length > 0) {
                stage = 'system_pass_complete';
                var allReviewed = cProposals.every(function(p) { return p.status !== 'pending'; });
                if (allReviewed) stage = 'system_changes_reviewed';
              } else if (stage === 'preflight_complete') {
                var _isRoutedToSP2 = (typeof _p1f2CleanItems !== 'undefined') && _p1f2CleanItems.some(function(ci) { return ci.contract_key === cid; });
                if (_isRoutedToSP2) stage = 'system_pass_complete';
              }
            }

            if (contractPatches.length > 0) {
              stage = 'patch_submitted';
              if (contractPatches.some(function(p) { return (p.status || '').toLowerCase().indexOf('rfi') >= 0 || p.artifact_type === 'rfi'; })) stage = 'rfi_submitted';
              if (contractPatches.every(function(p) { var s = (p.status||'').toLowerCase(); return s === 'verifier_approved' || s === 'admin_approved' || s === 'applied' || s === 'closed'; })) stage = 'verifier_complete';
              if (contractPatches.every(function(p) { var s = (p.status||'').toLowerCase(); return s === 'admin_approved' || s === 'applied' || s === 'closed'; })) stage = 'admin_promoted';
              if (contractPatches.every(function(p) { var s = (p.status||'').toLowerCase(); return s === 'applied' || s === 'closed'; })) stage = 'applied';
            }

            if (typeof window._lifecycleAudit === 'undefined') window._lifecycleAudit = {};
            window._lifecycleAudit[cid] = stage;

            cache.lifecycle[stage] = cache.lifecycle[stage] || { count: 0, pct: 0 };
            cache.lifecycle[stage].count++;

            var pfAlerts = 0, semAlerts = 0, patchAlerts = contractPatches.length;
            if (typeof _p1fBatchScanItems !== 'undefined' && _p1fBatchScanItems.length > 0) {
              _p1fBatchScanItems.forEach(function(item) {
                if (item.contract_id === cid || item.contract_key === cid) pfAlerts++;
              });
            }
            (analystTriageState.manualItems || []).forEach(function(item) {
              if (item.contract_id === cid || item.contract_key === cid) pfAlerts++;
            });
            (SystemPass._proposals || []).forEach(function(p) {
              if (p.contract_id === cid) semAlerts++;
            });

            var displayName = c.file_name || cid;
            var docRole = '';
            if (c.sheets) {
              var firstSheet = Object.keys(c.sheets)[0];
              if (firstSheet && typeof workbook !== 'undefined' && workbook.sheets[firstSheet] && c.sheets[firstSheet][0]) {
                var firstRow = workbook.sheets[firstSheet].rows[c.sheets[firstSheet][0].row_index];
                if (firstRow) docRole = firstRow._document_role || firstRow.document_type || '';
              }
            }

            cache.contracts.push({
              contract_id: cid, display_name: displayName, doc_role: docRole,
              current_stage: stage, preflight_alerts: pfAlerts, semantic_alerts: semAlerts,
              patch_alerts: patchAlerts, last_updated: new Date().toISOString(), row_count: c.row_count || 0
            });
          });

          if (ContractIndex._index.orphan_rows && ContractIndex._index.orphan_rows.length > 0) {
            cache._orphan_row_count = ContractIndex._index.orphan_rows.length;
            console.log('[TRIAGE-ANALYTICS][P0.1] lifecycle: excluded ' + cache._orphan_row_count + ' orphan rows from contract lifecycle');
          }
        } else {
          cache.total_contracts = 1;
          cache.lifecycle.loaded.count = 1;
          totalContracts = 1;
        }

        Object.keys(cache.lifecycle).forEach(function(stage) {
          cache.lifecycle[stage].pct = totalContracts > 0 ? Math.round((cache.lifecycle[stage].count / totalContracts) * 100) : 0;
        });

        var _lcSum = 0;
        var _lcDetail = [];
        Object.keys(cache.lifecycle).forEach(function(stage) {
          _lcSum += cache.lifecycle[stage].count;
          if (cache.lifecycle[stage].count > 0) _lcDetail.push(stage + '=' + cache.lifecycle[stage].count);
        });
        console.log('[TRIAGE-ANALYTICS][LIFECYCLE-AUDIT] total_contracts=' + totalContracts + ' sum_of_stages=' + _lcSum + ' breakdown: ' + _lcDetail.join(', '));
        if (_lcSum !== totalContracts) {
          console.warn('[TRIAGE-ANALYTICS][LIFECYCLE-AUDIT] MISMATCH: sum_of_stages(' + _lcSum + ') != total_contracts(' + totalContracts + ')');
        }

        if (typeof rulesBundleCache !== 'undefined' && rulesBundleCache.fieldMeta && rulesBundleCache.fieldMeta.fields) {
          var _allGlossaryFields = rulesBundleCache.fieldMeta.fields;
          var _normKey = function(s) { return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, ''); };
          var _activeSheetsNorm = {};
          var _activeSectionCount = 0;
          if (typeof workbook !== 'undefined' && workbook.order) {
            workbook.order.forEach(function(sn) {
              var norm = _normKey(sn);
              if (!_activeSheetsNorm[norm]) {
                _activeSheetsNorm[norm] = true;
                _activeSectionCount++;
              }
              if (typeof _normSheetName === 'function') {
                var equiv = _normSheetName(sn);
                if (!_activeSheetsNorm[equiv]) _activeSheetsNorm[equiv] = true;
              }
            });
          }
          var _hasActiveSheets = _activeSectionCount > 0;
          var allFields = _hasActiveSheets ? _allGlossaryFields.filter(function(f) {
            var fs = _normKey(f.sheet || '');
            if (_activeSheetsNorm[fs]) return true;
            var fsEquiv = (typeof _normSheetName === 'function') ? _normSheetName(f.sheet || '') : fs;
            var activeKeys = Object.keys(_activeSheetsNorm);
            for (var _ak = 0; _ak < activeKeys.length; _ak++) {
              if ((typeof _sheetsEquivalent === 'function') && _sheetsEquivalent(activeKeys[_ak], fs)) return true;
            }
            return false;
          }) : _allGlossaryFields;
          cache.schema.standard_total = allFields.length;
          cache.schema._glossary_total = _allGlossaryFields.length;
          cache.schema._active_sections = _activeSectionCount;
          var wbCols = {};
          var wbCanonicals = {};
          var wbColTokens = {};
          if (typeof workbook !== 'undefined' && workbook.order) {
            workbook.order.forEach(function(sn) {
              var sh = workbook.sheets[sn];
              if (sh && sh.headers) sh.headers.forEach(function(h) {
                wbCols[h.toLowerCase()] = true;
                wbCols[_normKey(h)] = true;
                var aliasNorm = _normKey(h);
                if (typeof COLUMN_ALIAS_MAP !== 'undefined' && COLUMN_ALIAS_MAP[aliasNorm]) {
                  var aliasEntries = COLUMN_ALIAS_MAP[aliasNorm];
                  if (Array.isArray(aliasEntries)) {
                    aliasEntries.forEach(function(ae) {
                      if (ae && ae.canonical_key) {
                        wbCanonicals[ae.canonical_key.toLowerCase()] = true;
                        wbCanonicals[_normKey(ae.canonical_key)] = true;
                      }
                    });
                  } else if (typeof aliasEntries === 'string') {
                    wbCanonicals[aliasEntries.toLowerCase()] = true;
                    wbCanonicals[_normKey(aliasEntries)] = true;
                  }
                }
              });
              if (sn.toLowerCase().indexOf('fields defini') >= 0 && sh && sh.headers && sh.rows) {
                var apiIdx = -1; var labelIdx = -1;
                var _canonicalKeyRe = /[A-Za-z][A-Za-z0-9_]*__(c|r)|[A-Za-z][A-Za-z0-9_]*(Id|ID)\b/;
                for (var hi = 0; hi < sh.headers.length; hi++) {
                  var hn = sh.headers[hi].toLowerCase().replace(/[^a-z0-9_ ]/g, '').trim();
                  if (hn === 'field api name' || hn === 'field_api_name' || hn === 'api name' || hn === 'api_name' || hn === 'field name' || hn === 'field_name') apiIdx = hi;
                  if (hn === 'field label' || hn === 'field_label' || hn === 'label') labelIdx = hi;
                }
                var _defsheetExtracted = 0;
                var _defsheetFallbackHits = 0;
                sh.rows.forEach(function(row) {
                  var apiVal = apiIdx >= 0 ? String(row[sh.headers[apiIdx]] || '').trim() : '';
                  var isInvalid = !apiVal || apiVal === '(' || apiVal.length < 2;
                  if (isInvalid && sh.headers) {
                    for (var ci = 0; ci < sh.headers.length; ci++) {
                      var cellVal = String(row[sh.headers[ci]] || '').trim();
                      var m = cellVal.match(_canonicalKeyRe);
                      if (m) {
                        apiVal = m[0];
                        _defsheetFallbackHits++;
                        break;
                      }
                    }
                  }
                  var labelVal = labelIdx >= 0 ? (row[sh.headers[labelIdx]] || '') : '';
                  if (apiVal && apiVal.length >= 2 && apiVal !== '(') {
                    _defsheetExtracted++;
                    wbCols[apiVal.toLowerCase()] = true;
                    wbCols[_normKey(apiVal)] = true;
                  }
                  if (labelVal) {
                    wbCols[labelVal.toLowerCase()] = true;
                    wbCols[_normKey(labelVal)] = true;
                    var labelNorm = _normKey(labelVal);
                    if (typeof COLUMN_ALIAS_MAP !== 'undefined' && COLUMN_ALIAS_MAP[labelNorm]) {
                      var lEntries = COLUMN_ALIAS_MAP[labelNorm];
                      if (Array.isArray(lEntries)) {
                        lEntries.forEach(function(le) {
                          if (le && le.canonical_key) {
                            wbCanonicals[le.canonical_key.toLowerCase()] = true;
                            wbCanonicals[_normKey(le.canonical_key)] = true;
                          }
                        });
                      }
                    }
                  }
                });
                cache.schema.defsheet_extracted_keys += _defsheetExtracted;
                cache.schema.defsheet_fallback_hits += _defsheetFallbackHits;
              }
            });
          }
          if (typeof _normFieldToken === 'function') {
            var _wck = Object.keys(wbCols);
            for (var _ti = 0; _ti < _wck.length; _ti++) { wbColTokens[_normFieldToken(_wck[_ti])] = true; }
          }
          var _fieldMatches = function(fk, fl) {
            var fkl = fk.toLowerCase();
            var fkn = _normKey(fk);
            var fkt = (typeof _normFieldToken === 'function') ? _normFieldToken(fk) : fkn;
            if (wbCols[fkl] || wbCols[fkl + '_c'] || wbCols[fkn] || wbCols[fkn + '_c']) return true;
            if (wbCanonicals[fkl] || wbCanonicals[fkn]) return true;
            if (wbColTokens[fkt]) return true;
            if (fl) {
              var fll = fl.toLowerCase();
              var fln = _normKey(fl);
              var flt = (typeof _normFieldToken === 'function') ? _normFieldToken(fl) : fln;
              if (wbCols[fll] || wbCols[fln] || wbCols[fln + '_c']) return true;
              if (wbCanonicals[fll] || wbCanonicals[fln]) return true;
              if (wbColTokens[flt]) return true;
            }
            return false;
          };
          allFields.forEach(function(f) {
            if (_fieldMatches(f.field_key, f.field_label)) cache.schema.standard_matched++;
          });

          var _missingHeaderItems = [];
          var _missingValueItems = [];
          allFields.forEach(function(f) {
            if (f.requiredness !== 'required') return;
            var matched = _fieldMatches(f.field_key, f.field_label);
            if (!matched) {
              _missingHeaderItems.push({ field_key: f.field_key, label: f.field_label || f.field_key, sheet: f.sheet || '', requiredness: f.requiredness });
            } else if (typeof workbook !== 'undefined' && workbook.order) {
              var fkn = _normKey(f.field_key);
              var fln = f.field_label ? _normKey(f.field_label) : '';
              workbook.order.forEach(function(sn) {
                var sh = workbook.sheets[sn];
                if (!sh || !sh.headers || !sh.rows) return;
                var matchedHeader = null;
                for (var _hi = 0; _hi < sh.headers.length; _hi++) {
                  var hn = _normKey(sh.headers[_hi]);
                  if (hn === fkn || hn === fln || (typeof COLUMN_ALIAS_MAP !== 'undefined' && COLUMN_ALIAS_MAP[hn])) {
                    var isAlias = typeof COLUMN_ALIAS_MAP !== 'undefined' && COLUMN_ALIAS_MAP[hn];
                    if (hn === fkn || hn === fln) { matchedHeader = sh.headers[_hi]; break; }
                    if (isAlias) {
                      var _ae = COLUMN_ALIAS_MAP[hn];
                      for (var _ai = 0; _ai < _ae.length; _ai++) {
                        if (_normKey(_ae[_ai].canonical_key) === fkn) { matchedHeader = sh.headers[_hi]; break; }
                      }
                      if (matchedHeader) break;
                    }
                  }
                }
                if (!matchedHeader) return;
                var blankCount = 0;
                var invalidPicklistCount = 0;
                var blankRows = [];
                var invalidRows = [];
                var isPicklist = f.picklist === true && f.options && f.options.length > 0;
                var optionsLower = [];
                if (isPicklist) { f.options.forEach(function(o) { optionsLower.push(String(o).toLowerCase().trim()); }); }
                for (var _ri = 0; _ri < sh.rows.length; _ri++) {
                  var val = sh.rows[_ri] ? sh.rows[_ri][matchedHeader] : undefined;
                  if (typeof isBlankValue === 'function' && isBlankValue(val)) {
                    blankCount++;
                    blankRows.push(_ri);
                  } else if (isPicklist && val !== null && val !== undefined) {
                    var valLower = String(val).toLowerCase().trim();
                    if (optionsLower.indexOf(valLower) === -1) { invalidPicklistCount++; invalidRows.push(_ri); }
                  }
                }
                if (blankCount > 0) {
                  _missingValueItems.push({ field_key: f.field_key, label: f.field_label || f.field_key, section: sn, header: matchedHeader, blank_count: blankCount, total_rows: sh.rows.length, reason: 'blank_like', affected_rows: blankRows });
                }
                if (invalidPicklistCount > 0) {
                  _missingValueItems.push({ field_key: f.field_key, label: f.field_label || f.field_key, section: sn, header: matchedHeader, blank_count: invalidPicklistCount, total_rows: sh.rows.length, reason: 'invalid_picklist', affected_rows: invalidRows });
                }
              });
            }
          });
          cache.schema.schema_missing_required_headers = _missingHeaderItems.length;
          cache.schema.data_missing_required_values = _missingValueItems.length;
          cache.schema._missing_headers_items = _missingHeaderItems;
          cache.schema._missing_values_items = _missingValueItems;
          cache.schema.missing_required = _missingHeaderItems.length;

          var _batchHeaderSet = {};
          var _batchMappedItems = [];
          var _batchUnmappedItems = [];
          if (typeof workbook !== 'undefined' && workbook.order) {
            workbook.order.forEach(function(sn) {
              var sh = workbook.sheets[sn];
              if (!sh || !sh.headers) return;
              if (sn.indexOf('_change_log') !== -1) return;
              if (sn === 'RFIs & Analyst Notes') return;
              if (typeof isReferenceSheet === 'function' && isReferenceSheet(sn)) return;
              if (typeof isMetaSheet === 'function' && isMetaSheet(sn)) return;
              sh.headers.forEach(function(h) {
                if (!h || h.charAt(0) === '_') return;
                var norm = _normKey(h);
                if (!norm) return;
                var dedupKey = sn + '||' + norm;
                if (_batchHeaderSet[dedupKey]) return;
                _batchHeaderSet[dedupKey] = true;
                var mapped = false;
                var canonicalMatch = '';
                
                var resolved = typeof normalizeColumnName === 'function' ? normalizeColumnName(h, sn) : norm;
                var normToken = (typeof _normFieldToken === 'function') ? _normFieldToken(h) : norm;
                var resolvedToken = (typeof _normFieldToken === 'function') ? _normFieldToken(resolved) : resolved;
                if (!mapped) {
                  for (var _gi = 0; _gi < allFields.length; _gi++) {
                    var gf = allFields[_gi];
                    var gfk = _normKey(gf.field_key);
                    var gfl = gf.field_label ? _normKey(gf.field_label) : '';
                    var gfkt = (typeof _normFieldToken === 'function') ? _normFieldToken(gf.field_key) : gfk;
                    var gflt = gf.field_label ? ((typeof _normFieldToken === 'function') ? _normFieldToken(gf.field_label) : gfl) : '';
                    if (norm === gfk || norm === gfl || resolved === gfk || resolved === gfl) {
                      mapped = true; canonicalMatch = gf.field_key; break;
                    }
                    if (normToken === gfkt || normToken === gflt || resolvedToken === gfkt || resolvedToken === gflt) {
                      mapped = true; canonicalMatch = gf.field_key; break;
                    }
                  }
                }
                if (!mapped && typeof COLUMN_ALIAS_MAP !== 'undefined') {
                  if (COLUMN_ALIAS_MAP[norm]) {
                    mapped = true;
                    canonicalMatch = COLUMN_ALIAS_MAP[norm][0] ? COLUMN_ALIAS_MAP[norm][0].canonical_key : norm;
                  } else if (COLUMN_ALIAS_MAP[normToken]) {
                    mapped = true;
                    canonicalMatch = COLUMN_ALIAS_MAP[normToken][0] ? COLUMN_ALIAS_MAP[normToken][0].canonical_key : normToken;
                  }
                }
                var _canonicalOverrides = { totalamount: 'Amount__c', thresholdnumberofdays: 'Threshold_of_days__c' };
                if (!mapped && _canonicalOverrides[normToken]) { mapped = true; canonicalMatch = _canonicalOverrides[normToken]; }
                var sysFields = { contract_key:1, file_name:1, file_url:1, status:1, sheet:1, record_id:1, dataset_id:1, group_id:1, document_type:1, artists:1, amountbreakdown:1, amount_breakdown:1, addons:1, add_ons:1 };
                var sysToken = (typeof _normFieldToken === 'function') ? _normFieldToken(h) : norm;
                if (!mapped && (sysFields[norm] || sysFields[sysToken])) { mapped = true; canonicalMatch = (sysFields[norm] ? norm : sysToken) + ' (system)'; }
                if (mapped) {
                  _batchMappedItems.push({ section: sn, header: h, canonical: canonicalMatch });
                } else {
                  _batchUnmappedItems.push({ section: sn, header: h, normalized: norm });
                }
              });
            });
          }
          cache.schema.batch_headers_total = _batchMappedItems.length + _batchUnmappedItems.length;
          cache.schema.batch_headers_mapped = _batchMappedItems.length;
          cache.schema._batch_mapped_items = _batchMappedItems;
          cache.schema._batch_unmapped_items = _batchUnmappedItems;
        }
        var _snapshotTotal = 0;
        var _snapshot = (typeof getCurrentUnknownColumnsSnapshot === 'function') ? getCurrentUnknownColumnsSnapshot() : {};
        Object.keys(_snapshot).forEach(function(k) { _snapshotTotal += (_snapshot[k] || []).length; });
        cache.schema.unknown_columns = _snapshotTotal;
        var _ciTotal = 0;
        if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && ContractIndex._index && ContractIndex._index.unknown_columns) {
          Object.keys(ContractIndex._index.unknown_columns).forEach(function(k) {
            _ciTotal += (ContractIndex._index.unknown_columns[k] || []).length;
          });
        }
        console.log('[SCHEMA-SNAPSHOT] unknown_snapshot=' + _snapshotTotal + ' unknown_contract_index=' + _ciTotal);
        cache.schema.schema_drift = cache.schema.unknown_columns + cache.schema.schema_missing_required_headers;
        cache.schema._drift_detail = 'Unknown(' + cache.schema.unknown_columns + ') + MissingHeaders(' + cache.schema.schema_missing_required_headers + ')';
        cache.processing.completed = totalContracts;

        this._cache = cache;
        this._lastRefreshedAt = cache.refreshed_at;
        console.log('[TRIAGE-ANALYTICS][P0.1] lifecycle_recompute: contracts=' + cache.total_contracts + ', orphan_excluded=' + (cache._orphan_row_count || 0));
        console.log('[TRIAGE-ANALYTICS][P0.1] refresh: PreFlight=' + cache.lanes.preflight.total + ', Semantic=' + cache.lanes.semantic.total + ', PatchReview=' + cache.lanes.patch_review.total + ', Contracts=' + cache.total_contracts + ', Schema=' + cache.schema.standard_matched + '/' + cache.schema.standard_total);
        console.log('[GLOSSARY-MAP] fields_total=' + cache.schema.standard_total);
        console.log('[GLOSSARY-MAP] batch_matched=' + cache.schema.standard_matched);
        console.log('[SCHEMA-SNAPSHOT] batch_coverage=' + cache.schema.batch_headers_mapped + '/' + cache.schema.batch_headers_total + ', missing_headers=' + cache.schema.schema_missing_required_headers + ', missing_values=' + cache.schema.data_missing_required_values + ', drift=' + cache.schema.schema_drift);
        console.log('[GLOSSARY-MAP] defsheet_extracted_keys=' + cache.schema.defsheet_extracted_keys);
        console.log('[GLOSSARY-MAP] defsheet_fallback_hits=' + cache.schema.defsheet_fallback_hits);

        // P0.2: Compute batch summary
        var totalRecords = 0;
        if (typeof workbook !== 'undefined' && workbook.order) {
          workbook.order.forEach(function(sn) {
            var sh = workbook.sheets[sn];
            if (sh && sh.rows && (typeof isOperationalSheet === 'function' ? isOperationalSheet(sn) : !(typeof isMetaSheet === 'function' && isMetaSheet(sn)))) {
              totalRecords += sh.rows.length;
            }
          });
        }
        cache.batch_summary = {
          contracts_total: cache.total_contracts,
          records_total: totalRecords,
          completed: 0,
          needs_review: 0,
          pending: 0,
          affected_contracts: 0,
          records_impacted: 0,
          unassigned_rows: cache._orphan_row_count || 0,
          updated_at: cache.refreshed_at
        };
        cache.contracts.forEach(function(c) {
          if (c.current_stage === 'applied') cache.batch_summary.completed++;
          else if (c.preflight_alerts > 0 || c.semantic_alerts > 0 || c.patch_alerts > 0) cache.batch_summary.needs_review++;
          else cache.batch_summary.pending++;
        });
        var _affectedCk = {};
        var _impactedRecords = 0;
        var _normalizeContractKey = function(item) {
          var raw = item.contract_key || item.contract_id || '';
          if (raw.indexOf('ctr_') === 0) return raw;
          if (item.record && typeof ContractIndex !== 'undefined' && typeof ContractIndex.deriveContractId === 'function') {
            var derived = ContractIndex.deriveContractId(item.record);
            if (derived) return derived;
          }
          if (typeof ContractIndex !== 'undefined' && ContractIndex._index && ContractIndex._index.contracts) {
            var cKeys = Object.keys(ContractIndex._index.contracts);
            for (var ci = 0; ci < cKeys.length; ci++) {
              var c = ContractIndex._index.contracts[cKeys[ci]];
              if (c && (c.file_name === raw || c.contract_id === raw)) return cKeys[ci];
            }
          }
          return raw;
        };
        (analystTriageState.manualItems || []).forEach(function(item) {
          if (item.contract_key || item.contract_id) _affectedCk[_normalizeContractKey(item)] = true;
          if (item.record_id) _impactedRecords++;
        });
        (typeof _p1fBatchScanItems !== 'undefined' ? _p1fBatchScanItems : []).forEach(function(item) {
          if (item.contract_key || item.contract_id) _affectedCk[_normalizeContractKey(item)] = true;
        });
        cache.batch_summary.affected_contracts = Object.keys(_affectedCk).length;
        cache.batch_summary.records_impacted = _impactedRecords;
        console.log('[TRIAGE-CANONICAL][P1X] counts_computed: contracts=' + cache.batch_summary.contracts_total + ', records=' + cache.batch_summary.records_total + ', affected=' + cache.batch_summary.affected_contracts + ', impacted=' + cache.batch_summary.records_impacted);
        console.log('[TRIAGE-ANALYTICS][P0.2] batch_summary_recomputed: contracts=' + cache.batch_summary.contracts_total + ', records=' + cache.batch_summary.records_total + ', completed=' + cache.batch_summary.completed + ', review=' + cache.batch_summary.needs_review + ', pending=' + cache.batch_summary.pending + ', unassigned=' + cache.batch_summary.unassigned_rows);

        // P0.2: Reconciliation check
        var lifecycleTotal = 0;
        Object.keys(cache.lifecycle).forEach(function(k) { lifecycleTotal += cache.lifecycle[k].count; });
        var contractSummaryTotal = cache.contracts.length;
        cache._reconciliation = {
          lifecycle_total: lifecycleTotal,
          contract_summary_total: contractSummaryTotal,
          match: lifecycleTotal === contractSummaryTotal
        };
        if (cache._reconciliation.match) {
          console.log('[TRIAGE-ANALYTICS][P0.2] lifecycle_reconcile_ok: lifecycle=' + lifecycleTotal + ', contracts=' + contractSummaryTotal);
        } else {
          console.warn('[TRIAGE-ANALYTICS][P0.2] lifecycle_reconcile_mismatch: lifecycle=' + lifecycleTotal + ', contracts=' + contractSummaryTotal + ', delta=' + (lifecycleTotal - contractSummaryTotal));
        }

        return cache;
      },

      getCache: function() {
        if (!this._cache) this.refresh();
        return this._cache;
      },

      renderHeader: function() {
        var cache = this.getCache();
        var header = document.getElementById('triage-analytics-header');
        if (!header) return;
        header.style.display = 'block';

        var el = function(id) { return document.getElementById(id); };
        if (el('ta-preflight-total')) el('ta-preflight-total').textContent = cache.lanes.preflight.total;
        if (el('ta-pf-unknown')) el('ta-pf-unknown').textContent = cache.lanes.preflight.unknown_columns;
        if (el('ta-pf-ocr')) el('ta-pf-ocr').textContent = cache.lanes.preflight.ocr_unreadable;
        if (el('ta-pf-lowconf')) el('ta-pf-lowconf').textContent = cache.lanes.preflight.low_confidence;
        if (el('ta-pf-doctype')) el('ta-pf-doctype').textContent = cache.lanes.preflight.document_type || 0;
        if (el('ta-pf-affected')) el('ta-pf-affected').textContent = cache.batch_summary ? cache.batch_summary.affected_contracts : 0;
        if (el('ta-pf-impacted')) el('ta-pf-impacted').textContent = cache.batch_summary ? cache.batch_summary.records_impacted : 0;

        if (el('ta-semantic-total')) el('ta-semantic-total').textContent = cache.lanes.semantic.total;
        if (el('ta-sem-proposals')) el('ta-sem-proposals').textContent = cache.lanes.semantic.proposals_created;
        if (el('ta-sem-accepted')) el('ta-sem-accepted').textContent = cache.lanes.semantic.accepted;
        if (el('ta-sem-rejected')) el('ta-sem-rejected').textContent = cache.lanes.semantic.rejected;
        if (el('ta-sem-pending')) el('ta-sem-pending').textContent = cache.lanes.semantic.pending;


        if (el('ta-patch-total')) el('ta-patch-total').textContent = cache.lanes.patch_review.total;
        if (el('ta-pr-draft')) el('ta-pr-draft').textContent = cache.lanes.patch_review.draft;
        if (el('ta-pr-submitted')) el('ta-pr-submitted').textContent = cache.lanes.patch_review.submitted;
        if (el('ta-pr-verifier')) el('ta-pr-verifier').textContent = cache.lanes.patch_review.in_verifier;
        if (el('ta-pr-admin')) el('ta-pr-admin').textContent = cache.lanes.patch_review.in_admin;
        if (el('ta-pr-rfi')) el('ta-pr-rfi').textContent = cache.lanes.patch_review.rfi_submitted;
        if (el('ta-pr-promoted')) el('ta-pr-promoted').textContent = cache.lanes.patch_review.promoted;

        this._renderLifecycle(cache);
        if (typeof ContractHealthScore !== 'undefined') ContractHealthScore.computeAll(cache);
        this._renderContractTable(cache);
        this._renderSchemaSnapshot(cache);

        if (el('ta-lifecycle-updated')) el('ta-lifecycle-updated').textContent = 'Updated: ' + new Date(cache.refreshed_at).toLocaleTimeString();
        console.log('[TRIAGE-ANALYTICS][P0.1] renderHeader: displayed=' + (header.style.display !== 'none') + ', lifecycle_stages=9, contracts=' + cache.total_contracts);

        // P1: Telemetry recompute and banner render
        if (typeof TriageTelemetry !== 'undefined') {
          try {
            TriageTelemetry.recompute();
            TriageTelemetry.renderBanner();
            TriageTelemetry.renderLifecycleDeltas();
            TriageTelemetry.renderContractChips();
          } catch(e) { console.warn('[P1] Telemetry render error:', e); }
        }

        // P0.2: Render batch summary
        if (el('ta-bs-contracts')) el('ta-bs-contracts').textContent = cache.batch_summary ? cache.batch_summary.contracts_total : cache.total_contracts;
        if (el('ta-bs-records')) el('ta-bs-records').textContent = cache.batch_summary ? cache.batch_summary.records_total : 0;
        if (el('ta-bs-completed')) el('ta-bs-completed').textContent = cache.batch_summary ? cache.batch_summary.completed : 0;
        if (el('ta-bs-review')) el('ta-bs-review').textContent = cache.batch_summary ? cache.batch_summary.needs_review : 0;
        if (el('ta-bs-pending')) el('ta-bs-pending').textContent = cache.batch_summary ? cache.batch_summary.pending : 0;
        if (el('ta-bs-updated')) el('ta-bs-updated').textContent = cache.batch_summary ? new Date(cache.batch_summary.updated_at).toLocaleTimeString() : '--';
        var unassignedEl = el('ta-bs-unassigned');
        if (unassignedEl) {
          if (cache.batch_summary && cache.batch_summary.unassigned_rows > 0) {
            unassignedEl.style.display = '';
            if (el('ta-bs-unassigned-count')) el('ta-bs-unassigned-count').textContent = cache.batch_summary.unassigned_rows;
          } else {
            unassignedEl.style.display = 'none';
          }
        }
        // P0.2: Reconciliation warning badge
        var reconcileWarn = el('ta-reconcile-warn');
        if (reconcileWarn) {
          reconcileWarn.style.display = (cache._reconciliation && !cache._reconciliation.match) ? '' : 'none';
        }
        console.log('[TRIAGE-ANALYTICS][P0.2] header_reorder_applied: batch_summary=true, contract_summary=true, lanes=true, lifecycle=true, schema=true');

        if (typeof updateProgressBlock === 'function') updateProgressBlock();
      },

      _renderLifecycle: function(cache) {
        var container = document.getElementById('ta-lifecycle-stages');
        if (!container) return;
        var stages = [
          { key: 'loaded', label: 'Loaded', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>' },
          { key: 'preflight_complete', label: 'Pre-Flight', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>' },
          { key: 'system_pass_complete', label: 'System Pass', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>' },
          { key: 'system_changes_reviewed', label: 'Reviewed', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>' },
          { key: 'patch_submitted', label: 'Patch Sub.', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>' },
          { key: 'rfi_submitted', label: 'RFI', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>' },
          { key: 'verifier_complete', label: 'Verifier', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>' },
          { key: 'admin_promoted', label: 'Promoted', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>' },
          { key: 'applied', label: 'Applied', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>' }
        ];
        var html = '';
        stages.forEach(function(s, i) {
          var data = cache.lifecycle[s.key] || { count: 0, pct: 0 };
          var active = data.count > 0;
          var bg = active ? '#e3f2fd' : '#f5f5f5';
          var border = active ? '#1976d2' : '#e0e0e0';
          var color = active ? '#1565c0' : '#999';
          html += '<div class="ta-lifecycle-stage" onclick="TriageAnalytics.handleStageClick(\'' + s.key + '\')" style="flex: 1; min-width: 64px; text-align: center; padding: 6px 3px; background: ' + bg + '; border: 1px solid ' + border + '; border-radius: 5px; cursor: pointer; line-height: 1.2;">';
          html += '<div style="font-size: 0.85em; color: ' + color + '; display:flex; align-items:center; justify-content:center;">' + s.icon + '</div>';
          html += '<div style="font-size: 0.62em; font-weight: 600; color: ' + color + '; margin: 2px 0 0;">' + s.label + '</div>';
          html += '<div style="font-size: 0.9em; font-weight: 700; color: ' + (active ? '#1565c0' : '#bbb') + ';">' + data.count + ' <span style="font-size:0.65em; font-weight:400;">(' + data.pct + '%)</span></div>';
          html += '</div>';
          if (i < stages.length - 1) html += '<div style="display: flex; align-items: center; color: #ccc; font-size: 0.7em;">\u25B6</div>';
        });
        container.innerHTML = html;
      },

      _renderContractTable: function(cache, stageFilter) {
        var tbody = document.getElementById('ta-contract-tbody');
        if (!tbody) return;
        var el = function(id) { return document.getElementById(id); };

        var contracts = cache.contracts;
        if (stageFilter) {
          contracts = contracts.filter(function(c) { return c.current_stage === stageFilter; });
        }

        var countLabel = stageFilter ? contracts.length + ' of ' + cache.contracts.length + ' contracts' : cache.contracts.length + ' contract' + (cache.contracts.length !== 1 ? 's' : '');
        if (el('ta-contract-count')) el('ta-contract-count').textContent = countLabel;
        var completedC = 0, pendingC = 0, reviewC = 0;
        (cache.contracts || []).forEach(function(c) {
          if (c.current_stage === 'applied') completedC++;
          else if (c.preflight_alerts > 0 || c.semantic_alerts > 0 || c.patch_alerts > 0) reviewC++;
          else pendingC++;
        });
        var chipsEl = el('ta-contract-summary-chips');
        if (chipsEl) {
          chipsEl.innerHTML = '<span style="padding:1px 6px; border-radius:8px; background:#e8f5e9; color:#2e7d32; font-weight:600;">' + completedC + ' done</span>' +
            '<span style="padding:1px 6px; border-radius:8px; background:#fff3e0; color:#e65100; font-weight:600;">' + reviewC + ' review</span>' +
            '<span style="padding:1px 6px; border-radius:8px; background:#f5f5f5; color:#666; font-weight:600;">' + pendingC + ' pending</span>';
        }
        console.log('[TRIAGE-ANALYTICS][P0.2] contract_summary_recomputed: total=' + cache.contracts.length + ', completed=' + completedC + ', review=' + reviewC + ', pending=' + pendingC);

        if (contracts.length === 0) {
          tbody.innerHTML = '<tr><td colspan="8" style="padding: 20px; text-align: center; color: #999;">' + (stageFilter ? 'No contracts at this stage' : 'No contracts indexed') + '</td></tr>';
          return;
        }

        var SL = { loaded: 'Loaded', preflight_complete: 'Pre-Flight Done', system_pass_ready: 'SP Ready', system_pass_complete: 'System Pass', system_changes_reviewed: 'Reviewed', patch_submitted: 'Patch Sub.', rfi_submitted: 'RFI', verifier_complete: 'Verifier Done', admin_promoted: 'Promoted', applied: 'Applied' };
        var SC = { loaded: '#9e9e9e', preflight_complete: '#4caf50', system_pass_ready: '#66bb6a', system_pass_complete: '#ff9800', system_changes_reviewed: '#2196f3', patch_submitted: '#1976d2', rfi_submitted: '#f57f17', verifier_complete: '#7b1fa2', admin_promoted: '#00897b', applied: '#2e7d32' };

        // P1G: Apply health band filter
        if (typeof ContractHealthScore !== 'undefined') {
          contracts = ContractHealthScore.getFilteredContracts(contracts);
          contracts = ContractHealthScore.sortByHealth(contracts);
          console.log('[CONTRACT-HEALTH][P1G] sort_applied | contracts=' + contracts.length + ', filter=' + ContractHealthScore._activeBandFilter);
        }

        if (contracts.length === 0 && ContractHealthScore._activeBandFilter !== 'all') {
          tbody.innerHTML = '<tr><td colspan="8" style="padding: 20px; text-align: center; color: #999;">No contracts in this health band</td></tr>';
          return;
        }

        var html = '';
        contracts.forEach(function(c) {
          var sl = SL[c.current_stage] || c.current_stage;
          var sc = SC[c.current_stage] || '#666';
          var dn = (c.display_name || c.contract_id || '').replace(/"/g, '&quot;').replace(/'/g, "\\'");
          html += '<tr class="ta-contract-row" onclick="TriageAnalytics.handleContractClick(\'' + c.contract_id + '\', \'' + c.current_stage + '\')" style="cursor: pointer; border-bottom: 1px solid #f0f0f0;">';
          html += '<td style="padding: 8px 12px; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="' + (c.display_name || '').replace(/"/g, '&quot;') + '">' + (c.display_name || c.contract_id) + '</td>';
          html += '<td style="padding: 8px 12px; color: #666;">' + (c.doc_role || '-') + '</td>';
          html += '<td style="padding: 8px 12px; text-align: center;"><span style="padding: 2px 8px; border-radius: 10px; font-size: 0.85em; background: ' + sc + '22; color: ' + sc + '; font-weight: 600;">' + sl + '</span></td>';
          html += '<td style="padding: 8px 12px; text-align: center; color: ' + (c.preflight_alerts > 0 ? '#c62828' : '#ccc') + '; font-weight: 600;">' + c.preflight_alerts + '</td>';
          html += '<td style="padding: 8px 12px; text-align: center; color: ' + (c.semantic_alerts > 0 ? '#e65100' : '#ccc') + '; font-weight: 600;">' + c.semantic_alerts + '</td>';
          html += '<td style="padding: 8px 12px; text-align: center; color: ' + (c.patch_alerts > 0 ? '#1565c0' : '#ccc') + '; font-weight: 600;">' + c.patch_alerts + '</td>';
          html += '<td style="padding: 8px 12px; text-align: right; color: #666;">' + (c.row_count || 0) + '</td>';
          html += (typeof ContractHealthScore !== 'undefined') ? ContractHealthScore.renderHealthCell(c) : '<td></td>';
          html += '</tr>';
        });
        tbody.innerHTML = html;
      },

      _renderSchemaSnapshot: function(cache) {
        var el = function(id) { return document.getElementById(id); };
        var batchPct = cache.schema.batch_headers_total > 0 ? Math.round((cache.schema.batch_headers_mapped / cache.schema.batch_headers_total) * 100) : 0;
        if (el('ta-schema-matched-pct')) el('ta-schema-matched-pct').textContent = batchPct + '%';
        if (el('ta-schema-matched-count')) el('ta-schema-matched-count').textContent = cache.schema.batch_headers_mapped + ' / ' + cache.schema.batch_headers_total + ' batch headers';
        if (el('ta-schema-matched-scope')) {
          var _scopeLabel = cache.schema._active_sections > 0
            ? cache.schema._active_sections + ' active sections'
            : 'all sections';
          el('ta-schema-matched-scope').textContent = _scopeLabel;
        }
        if (el('ta-schema-matched-subtext')) {
          var _secCount = (typeof workbook !== 'undefined' && workbook && workbook.order) ? workbook.order.length : 0;
          el('ta-schema-matched-subtext').textContent = cache.schema.batch_headers_mapped + ' of ' + cache.schema.batch_headers_total + ' uploaded columns recognized';
          if (_secCount > 0 && el('ta-schema-matched-scope')) el('ta-schema-matched-scope').textContent = 'Across ' + _secCount + ' contract section' + (_secCount !== 1 ? 's' : '');
        }
        if (el('ta-schema-glossary-secondary')) {
          var gPct = cache.schema.standard_total > 0 ? Math.round((cache.schema.standard_matched / cache.schema.standard_total) * 100) : 0;
          el('ta-schema-glossary-secondary').textContent = 'Glossary: ' + cache.schema.standard_matched + '/' + cache.schema.standard_total + ' (' + gPct + '%)';
        }
        if (el('ta-schema-unknown')) el('ta-schema-unknown').textContent = cache.schema.unknown_columns;
        var missingTotal = cache.schema.schema_missing_required_headers + cache.schema.data_missing_required_values;
        if (el('ta-schema-missing')) el('ta-schema-missing').textContent = missingTotal;
        if (el('ta-schema-missing-split')) el('ta-schema-missing-split').textContent = cache.schema.schema_missing_required_headers + ' missing headers / ' + cache.schema.data_missing_required_values + ' missing values';
        if (el('ta-schema-drift')) el('ta-schema-drift').textContent = cache.schema.schema_drift;
        if (el('ta-schema-drift-detail')) el('ta-schema-drift-detail').textContent = cache.schema._drift_detail || '';
      },

      handleLaneClick: function(lane) {
        // P1: Apply lane drill-down filter
        if (typeof TriageTelemetry !== 'undefined') {
          TriageTelemetry.applyLaneFilter(lane);
        }
        var filterMap = { preflight: 'preflight', semantic: 'semantic', patch: 'patch' };
        navigateToGridFiltered(filterMap[lane] || 'all');
      },

      _activeStageFilter: null,

      toggleContractTable: function() {
        var body = document.getElementById('ta-contract-body');
        var toggle = document.getElementById('ta-contract-toggle');
        if (!body) return;
        if (body.style.display === 'none') {
          body.style.display = '';
          if (toggle) toggle.style.transform = 'rotate(90deg)';
          this._activeStageFilter = null;
          this._renderContractTable(this._cache);
          var badge = document.getElementById('ta-contract-filter-badge');
          if (badge) badge.style.display = 'none';
          var gridBtn4 = document.getElementById('ta-contract-view-grid');
          if (gridBtn4) gridBtn4.style.display = 'none';
        } else {
          body.style.display = 'none';
          if (toggle) toggle.style.transform = '';
          this._activeStageFilter = null;
          var badge = document.getElementById('ta-contract-filter-badge');
          if (badge) badge.style.display = 'none';
          var gridBtn3 = document.getElementById('ta-contract-view-grid');
          if (gridBtn3) gridBtn3.style.display = 'none';
        }
      },

      handleStageClick: function(stage) {
        var body = document.getElementById('ta-contract-body');
        var toggle = document.getElementById('ta-contract-toggle');
        var badge = document.getElementById('ta-contract-filter-badge');
        if (!body) return;

        if (this._activeStageFilter === stage) {
          body.style.display = 'none';
          if (toggle) toggle.style.transform = '';
          this._activeStageFilter = null;
          if (badge) badge.style.display = 'none';
          var gridBtn2 = document.getElementById('ta-contract-view-grid');
          if (gridBtn2) gridBtn2.style.display = 'none';
          document.querySelectorAll('.ta-lifecycle-stage').forEach(function(el) { el.style.outline = ''; });
          return;
        }

        this._activeStageFilter = stage;
        body.style.display = '';
        if (toggle) toggle.style.transform = 'rotate(90deg)';

        var SL = { loaded: 'Loaded', preflight_complete: 'Pre-Flight', system_pass_ready: 'SP Ready', system_pass_complete: 'System Pass', system_changes_reviewed: 'Reviewed', patch_submitted: 'Patch Sub.', rfi_submitted: 'RFI', verifier_complete: 'Verifier', admin_promoted: 'Promoted', applied: 'Applied' };
        if (badge) { badge.textContent = SL[stage] || stage; badge.style.display = 'inline'; }
        var gridBtn = document.getElementById('ta-contract-view-grid');
        if (gridBtn) gridBtn.style.display = 'inline';

        document.querySelectorAll('.ta-lifecycle-stage').forEach(function(el) { el.style.outline = ''; });
        var idx = ['loaded','preflight_complete','system_pass_ready','system_pass_complete','system_changes_reviewed','patch_submitted','rfi_submitted','verifier_complete','admin_promoted','applied'].indexOf(stage);
        var stageEls = document.querySelectorAll('.ta-lifecycle-stage');
        if (idx >= 0 && stageEls[idx]) stageEls[idx].style.outline = '2px solid #1976d2';

        this._renderContractTable(this._cache, stage);
      },

      viewFilteredInGrid: function() {
        if (this._activeStageFilter) {
          navigateToGridFiltered('stage_' + this._activeStageFilter);
        }
      },

      handleSchemaClick: function(type) {
        console.log('[SCHEMA-SNAPSHOT] detail_click: type=' + type);
        var cache = this.getCache();
        this._openSchemaDetailModal(type, cache);
      },

      _openSchemaDetailModal: function(type, cache) {
        var existing = document.getElementById('schema-detail-modal');
        if (existing) existing.remove();

        var overlay = document.createElement('div');
        overlay.id = 'schema-detail-modal';
        overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10000;display:flex;align-items:center;justify-content:center;';
        overlay.onclick = function(e) { if (e.target === overlay) overlay.remove(); };

        var modal = document.createElement('div');
        modal.style.cssText = 'background:#fff;border-radius:12px;max-width:800px;width:90%;max-height:80vh;overflow:auto;padding:24px;box-shadow:0 8px 32px rgba(0,0,0,0.2);';

        var title = '';
        var html = '';

        if (type === 'matched') {
          var bPct = cache.schema.batch_headers_total > 0 ? Math.round((cache.schema.batch_headers_mapped / cache.schema.batch_headers_total) * 100) : 0;
          title = 'Columns Mapped: ' + bPct + '% (' + cache.schema.batch_headers_mapped + ' / ' + cache.schema.batch_headers_total + ' headers)';
          var gPct = cache.schema.standard_total > 0 ? Math.round((cache.schema.standard_matched / cache.schema.standard_total) * 100) : 0;
          html += '<div style="margin-bottom:12px;padding:8px 12px;background:#f0f4f8;border-radius:6px;font-size:0.85em;color:#555;">Glossary coverage: ' + cache.schema.standard_matched + ' / ' + cache.schema.standard_total + ' (' + gPct + '%)</div>';
          if (cache.schema._batch_mapped_items && cache.schema._batch_mapped_items.length > 0) {
            html += '<h4 style="margin:12px 0 8px;font-size:0.9em;color:#2e7d32;">Mapped Headers (' + cache.schema._batch_mapped_items.length + ')</h4>';
            html += '<table style="width:100%;border-collapse:collapse;font-size:0.8em;"><thead><tr style="background:#f5f5f5;"><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Section</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Header</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Canonical Field</th></tr></thead><tbody>';
            cache.schema._batch_mapped_items.forEach(function(item) {
              html += '<tr><td style="padding:4px 8px;border-bottom:1px solid #eee;">' + item.section + '</td><td style="padding:4px 8px;border-bottom:1px solid #eee;">' + item.header + '</td><td style="padding:4px 8px;border-bottom:1px solid #eee;color:#2e7d32;">' + item.canonical + '</td></tr>';
            });
            html += '</tbody></table>';
          }
          if (cache.schema._batch_unmapped_items && cache.schema._batch_unmapped_items.length > 0) {
            html += '<h4 style="margin:16px 0 8px;font-size:0.9em;color:#e65100;">Unmapped Headers (' + cache.schema._batch_unmapped_items.length + ')</h4>';
            html += '<table style="width:100%;border-collapse:collapse;font-size:0.8em;"><thead><tr style="background:#fff3e0;"><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Section</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Header</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Normalized</th></tr></thead><tbody>';
            cache.schema._batch_unmapped_items.forEach(function(item) {
              html += '<tr><td style="padding:4px 8px;border-bottom:1px solid #eee;">' + item.section + '</td><td style="padding:4px 8px;border-bottom:1px solid #eee;">' + item.header + '</td><td style="padding:4px 8px;border-bottom:1px solid #eee;color:#e65100;">' + item.normalized + '</td></tr>';
            });
            html += '</tbody></table>';
          }
        } else if (type === 'unknown') {
          title = 'Unknown Columns (' + cache.schema.unknown_columns + ')';
          var unknownStored = getCurrentUnknownColumnsSnapshot();
          var decisions = {};
          try { decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}'); } catch(e) {}
          var sections = Object.keys(unknownStored);
          if (sections.length === 0) {
            html += '<div style="padding:16px;text-align:center;color:#999;">No unknown columns detected. All imported columns match the canonical schema.</div>';
          } else {
            html += '<table style="width:100%;border-collapse:collapse;font-size:0.8em;"><thead><tr style="background:#fff3e0;"><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Section</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Original Header</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Normalized</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Suggested</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Decision</th></tr></thead><tbody>';
            sections.forEach(function(sn) {
              var cols = unknownStored[sn] || [];
              cols.forEach(function(col) {
                var decKey = sn + '||' + col.normalized_name;
                var curDecision = (decisions[decKey] && decisions[decKey].decision) || col.decision || '';
                var suggested = col.suggested_canonical || '';
                html += '<tr>';
                html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;">' + sn + '</td>';
                html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;font-weight:600;">' + col.original_name + '</td>';
                html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;color:#888;">' + col.normalized_name + '</td>';
                html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;color:#1565c0;">' + (suggested || '—') + '</td>';
                html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;">';
                html += '<select data-uc-section="' + sn + '" data-uc-norm="' + col.normalized_name + '" onchange="TriageAnalytics._saveUnknownDecision(this)" style="font-size:0.9em;padding:2px 4px;border:1px solid #ccc;border-radius:4px;">';
                html += '<option value=""' + (curDecision === '' ? ' selected' : '') + '>—</option>';
                html += '<option value="add_global"' + (curDecision === 'add_global' ? ' selected' : '') + '>Add to glossary</option>';
                html += '<option value="source_specific"' + (curDecision === 'source_specific' ? ' selected' : '') + '>Source-specific</option>';
                html += '<option value="ignore"' + (curDecision === 'ignore' ? ' selected' : '') + '>Ignore</option>';
                html += '</select></td></tr>';
              });
            });
            html += '</tbody></table>';
          }
        } else if (type === 'missing') {
          var missingTotal = cache.schema.schema_missing_required_headers + cache.schema.data_missing_required_values;
          title = 'Missing Required (' + missingTotal + ')';
          if (cache.schema._missing_headers_items && cache.schema._missing_headers_items.length > 0) {
            html += '<h4 style="margin:0 0 8px;font-size:0.9em;color:#c62828;">Missing Headers (' + cache.schema._missing_headers_items.length + ')</h4>';
            html += '<div style="margin-bottom:6px;font-size:0.75em;color:#888;">Required glossary fields with no matching column header in the workbook.</div>';
            html += '<table style="width:100%;border-collapse:collapse;font-size:0.8em;margin-bottom:16px;"><thead><tr style="background:#ffebee;"><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Field Key</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Label</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Expected Section</th></tr></thead><tbody>';
            cache.schema._missing_headers_items.forEach(function(item) {
              html += '<tr><td style="padding:4px 8px;border-bottom:1px solid #eee;font-family:monospace;font-size:0.9em;">' + item.field_key + '</td><td style="padding:4px 8px;border-bottom:1px solid #eee;">' + item.label + '</td><td style="padding:4px 8px;border-bottom:1px solid #eee;">' + (item.sheet || '—') + '</td></tr>';
            });
            html += '</tbody></table>';
          } else {
            html += '<div style="padding:8px;color:#4caf50;font-size:0.85em;margin-bottom:12px;">All required headers present.</div>';
          }
          if (cache.schema._missing_values_items && cache.schema._missing_values_items.length > 0) {
            html += '<h4 style="margin:0 0 8px;font-size:0.9em;color:#ef6c00;display:flex;align-items:center;gap:6px;">Missing Values (' + cache.schema._missing_values_items.length + ') <span style="display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:50%;background:#ef6c00;color:#fff;font-size:0.7em;cursor:pointer;font-style:normal;font-weight:700;position:relative;" onclick="event.stopPropagation();var p=this.querySelector(\x27.mv-legend-pop\x27);if(p){p.style.display=p.style.display===\x27none\x27?\x27block\x27:\x27none\x27;}" title="Column legend">i<div class="mv-legend-pop" style="display:none;position:absolute;top:24px;left:0;z-index:9999;background:#fff;border:1px solid #ddd;border-radius:6px;box-shadow:0 4px 16px rgba(0,0,0,0.15);padding:12px 14px;width:320px;font-size:12px;font-weight:400;color:#333;text-align:left;line-height:1.5;cursor:default;" onclick="event.stopPropagation()"><div style="font-weight:600;margin-bottom:6px;font-size:13px;color:#ef6c00;">Column Legend</div><div style="margin-bottom:4px;"><b>Field</b> &mdash; The canonical field name from the glossary that is required.</div><div style="margin-bottom:4px;"><b>Section</b> &mdash; The contract section (sheet) where this field appears in your workbook.</div><div style="margin-bottom:4px;"><b>Reason</b> &mdash; Why the error was flagged: <span style="color:#e65100;">Blank / missing</span> means the cell is empty; <span style="color:#6a1b9a;">Invalid picklist</span> means the value doesn\x27t match the allowed options.</div><div style="margin-bottom:4px;"><b>Errors</b> &mdash; How many records have this problem, with the percentage of all records in that section.</div><div><b>Rows in Section</b> &mdash; Total number of records in that contract section. This is the denominator for the error percentage.</div></div></span></h4>';
            html += '<div style="margin-bottom:6px;font-size:0.75em;color:#888;">Required fields present as headers but with blank/missing values in records. Click a row to expand and see affected records.</div>';
            html += '<table style="width:100%;border-collapse:collapse;font-size:0.8em;" id="mv-expand-table"><thead><tr style="background:#fff3e0;"><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;width:20px;"></th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Field</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Section</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Reason</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Errors</th><th style="padding:6px 8px;text-align:left;border-bottom:1px solid #ddd;">Rows in Section</th></tr></thead><tbody>';
            cache.schema._missing_values_items.forEach(function(item, idx) {
              var pct = item.total_rows > 0 ? Math.round((item.blank_count / item.total_rows) * 100) : 0;
              var reasonLabel = item.reason === 'invalid_picklist' ? 'Invalid picklist' : 'Blank / missing';
              var reasonColor = item.reason === 'invalid_picklist' ? '#6a1b9a' : '#e65100';
              var rowId = 'mv-expand-' + idx;
              html += '<tr style="cursor:pointer;" onclick="(function(){var el=document.getElementById(\x27' + rowId + '\x27);if(el){el.style.display=el.style.display===\x27none\x27?\x27table-row\x27:\x27none\x27;var arrow=document.getElementById(\x27' + rowId + '-arrow\x27);if(arrow)arrow.textContent=el.style.display===\x27none\x27?\x27\u25B6\x27:\x27\u25BC\x27;}})()">';
              html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;color:#888;font-size:0.85em;" id="' + rowId + '-arrow">\u25B6</td>';
              html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;font-family:monospace;font-size:0.9em;">' + escapeHtml(item.field_key) + '</td>';
              html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;">' + escapeHtml(item.section) + '</td>';
              html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;color:' + reasonColor + ';font-size:0.85em;">' + reasonLabel + '</td>';
              html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;color:#e65100;font-weight:600;">' + item.blank_count + ' (' + pct + '%)</td>';
              html += '<td style="padding:4px 8px;border-bottom:1px solid #eee;">' + item.total_rows + '</td>';
              html += '</tr>';
              html += '<tr id="' + rowId + '" style="display:none;"><td colspan="6" style="padding:0;border-bottom:1px solid #ddd;">';
              html += '<div style="max-height:200px;overflow-y:auto;background:#fafafa;padding:6px 12px 6px 28px;">';
              var rows = item.affected_rows || [];
              if (rows.length === 0) {
                html += '<div style="color:#888;font-size:0.8em;padding:4px 0;">No individual row data available.</div>';
              } else {
                var wb = (typeof workbook !== 'undefined') ? workbook : null;
                var sh = (wb && wb.sheets && wb.sheets[item.section]) ? wb.sheets[item.section] : null;
                for (var ri = 0; ri < rows.length; ri++) {
                  var rowIdx = rows[ri];
                  var rowData = (sh && sh.rows && sh.rows[rowIdx]) ? sh.rows[rowIdx] : null;
                  var contractLabel = '';
                  if (rowData) {
                    var rawName = rowData.file_name || rowData.contract_key || '';
                    if (rawName && typeof ContractIndex !== 'undefined' && typeof ContractIndex._isHeaderLike === 'function' && !ContractIndex._isHeaderLike(rawName)) {
                      contractLabel = rawName;
                      if (contractLabel.length > 40) contractLabel = contractLabel.substring(0, 37) + '...';
                    }
                  }
                  var rowLabel = 'Row ' + (rowIdx + 1);
                  if (rowData && typeof _srrGetAccountName === 'function') {
                    var acctName = _srrGetAccountName(rowData);
                    if (acctName && acctName !== 'Unknown') {
                      rowLabel = acctName;
                      if (rowLabel.length > 30) rowLabel = rowLabel.substring(0, 27) + '...';
                    }
                  }
                  var cellVal = rowData ? rowData[item.header] : '';
                  var displayVal = (cellVal === null || cellVal === undefined || String(cellVal).trim() === '') ? '(empty)' : String(cellVal);
                  if (displayVal.length > 40) displayVal = displayVal.substring(0, 37) + '...';
                  var escapedSection = item.section.replace(/\x27/g, '\\\x27');
                  html += '<div style="display:flex;align-items:center;padding:3px 0;border-bottom:1px solid #f0f0f0;font-size:0.82em;" class="mv-record-row">';
                  html += '<span style="cursor:pointer;color:#1565c0;text-decoration:underline;flex:0 0 auto;margin-right:8px;" onclick="event.stopPropagation();var _m=document.getElementById(\x27schema-detail-modal\x27);if(_m)_m.remove();openRowReviewDrawer(\x27' + escapedSection + '\x27,' + rowIdx + ')">' + escapeHtml(rowLabel) + '</span>';
                  if (contractLabel) html += '<span style="color:#555;margin-right:8px;flex:0 0 auto;">' + escapeHtml(contractLabel) + '</span>';
                  html += '<span style="color:#999;font-family:monospace;font-size:0.9em;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + escapeHtml(displayVal) + '</span>';
                  html += '</div>';
                }
              }
              html += '</div></td></tr>';
            });
            html += '</tbody></table>';
          } else {
            html += '<div style="padding:8px;color:#4caf50;font-size:0.85em;">No blank required values detected.</div>';
          }
        } else if (type === 'drift') {
          title = 'Schema Structure Issues (' + cache.schema.schema_drift + ')';
          html += '<div style="margin-bottom:12px;padding:10px 14px;background:#f0f4f8;border-radius:6px;font-size:0.85em;color:#555;">Schema Structure Issues = Unknown Columns (' + cache.schema.unknown_columns + ') + Missing Required Headers (' + cache.schema.schema_missing_required_headers + ') (excludes missing values).</div>';
          if (cache.schema.unknown_columns > 0) {
            html += '<div style="margin-bottom:8px;cursor:pointer;color:#1565c0;font-size:0.85em;text-decoration:underline;" onclick="document.getElementById(\x27schema-detail-modal\x27).remove();TriageAnalytics.handleSchemaClick(\x27unknown\x27);">View ' + cache.schema.unknown_columns + ' unknown column(s)</div>';
          }
          if (cache.schema.schema_missing_required_headers > 0) {
            html += '<div style="cursor:pointer;color:#1565c0;font-size:0.85em;text-decoration:underline;" onclick="document.getElementById(\x27schema-detail-modal\x27).remove();TriageAnalytics.handleSchemaClick(\x27missing\x27);">View ' + cache.schema.schema_missing_required_headers + ' missing required header(s)</div>';
          }
          if (cache.schema.schema_drift === 0) {
            html += '<div style="padding:16px;text-align:center;color:#4caf50;">No schema drift detected.</div>';
          }
        }

        modal.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;"><h3 style="margin:0;font-size:1.1em;color:#333;">' + title + '</h3><button onclick="document.getElementById(\x27schema-detail-modal\x27).remove()" style="background:none;border:none;font-size:1.4em;cursor:pointer;color:#999;padding:0 4px;">&times;</button></div>' + html;
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
      },

      _saveUnknownDecision: function(selectEl) {
        var section = selectEl.getAttribute('data-uc-section');
        var norm = selectEl.getAttribute('data-uc-norm');
        var decision = selectEl.value;
        var decisions = {};
        try { decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}'); } catch(e) {}
        var key = section + '||' + norm;
        decisions[key] = { section: section, normalized: norm, decision: decision, timestamp: new Date().toISOString() };
        localStorage.setItem('unknown_columns_decisions', JSON.stringify(decisions));
        console.log('[SCHEMA-SNAPSHOT] unknown_decision_saved: ' + key + ' -> ' + decision);
      },

      handleContractClick: function(contractId, stage) {
        var params = ['contract=' + encodeURIComponent(contractId)];
        if (stage) params.push('stage=' + encodeURIComponent(stage));
        navigateTo('grid', { queryParams: params.join('&') });
      }
    };

    
    // ============================================================
    // P1: Triage Analytics — Telemetry + Stage Observability
    // ============================================================

    var TriageTelemetry = {
      _state: null,
      _prevSnapshot: null,
      _startedAt: null,
      _staleTimeoutMs: 60000,
      _staleTimer: null,
      _debounceTimer: null,
      _debounceMs: 300,
      _eventDedupeSet: {},
      _activeLaneFilter: null,

      // P1-6: Event → Stage mapping table (single source of truth)
      EVENT_STAGE_MAP: {
        'dataset_loaded':            { stage: 'loaded',                 delta: +1 },
        'file_parsed':               { stage: 'loaded',                 delta: +1 },
        'preflight_complete':        { stage: 'preflight_complete',     delta: +1 },
        'system_pass_ready':         { stage: 'system_pass_ready',      delta: +1 },
        'preflight_blocker_detected':{ stage: 'loaded',                 delta: 0  },
        'system_pass_complete':      { stage: 'system_pass_complete',   delta: +1 },
        'proposal_accepted':         { stage: 'system_changes_reviewed',delta: +1 },
        'proposal_rejected':         { stage: 'system_changes_reviewed',delta: +1 },
        'system_change_routed_to_patch':{ stage: 'patch_submitted',     delta: +1 },
        'patch_submitted':           { stage: 'patch_submitted',        delta: +1 },
        'rfi_submitted':             { stage: 'rfi_submitted',          delta: +1 },
        'VERIFIER_APPROVED':         { stage: 'verifier_complete',      delta: +1 },
        'VERIFIER_REJECTED':         { stage: 'verifier_complete',      delta: +1 },
        'ADMIN_APPROVED':            { stage: 'admin_promoted',         delta: +1 },
        'patch_applied':             { stage: 'applied',                delta: +1 },
        'rollback_applied':          { stage: 'loaded',                 delta: 0  },
        'schema_change':             { stage: null,                     delta: 0  }
      },

      init: function() {
        this._state = this._createEmptyState();
        this._startedAt = Date.now();
        this._eventDedupeSet = {};
        console.log('[TRIAGE-ANALYTICS][P1] telemetry_init');
      },

      _createEmptyState: function() {
        return {
          files_total: 0,
          files_processed: 0,
          processing_state: 'idle',
          lane_counts: { preflight: 0, semantic: 0, patch_review: 0 },
          lifecycle_stage_counts: {},
          lifecycle_stage_pcts: {},
          lifecycle_stage_deltas: {},
          last_updated_at: null,
          throughput: null
        };
      },

      // P1-6: Dedupe key generation
      _dedupeKey: function(eventType, payload) {
        if (payload && payload.event_id) return payload.event_id;
        var parts = [eventType];
        if (payload) {
          if (payload.record_id) parts.push(payload.record_id);
          if (payload.contract_id) parts.push(payload.contract_id);
          if (payload.field_key) parts.push(payload.field_key);
          if (payload.artifact_id) parts.push(payload.artifact_id);
        }
        return parts.join('::');
      },

      // P1-6: Process event through mapping table with dedupe
      processEvent: function(eventType, payload) {
        var key = this._dedupeKey(eventType, payload);
        if (this._eventDedupeSet[key]) {
          console.log('[TRIAGE-ANALYTICS][P1] event_dedupe_hit: ' + eventType + ' key=' + key);
          return false;
        }
        this._eventDedupeSet[key] = true;

        var mapping = this.EVENT_STAGE_MAP[eventType];
        if (mapping) {
          console.log('[TRIAGE-ANALYTICS][P1] event_stage_mapped: ' + eventType + ' -> stage=' + (mapping.stage || 'none') + ', delta=' + mapping.delta);
        }
        return true;
      },

      // P1-1: Recompute telemetry from existing stores
      recompute: function() {
        if (!TriageAnalytics._cache) return;
        var cache = TriageAnalytics._cache;
        var prevSnapshot = this._prevSnapshot ? JSON.parse(JSON.stringify(this._prevSnapshot)) : null;

        var state = this._createEmptyState();

        // Files total/processed from workbook
        if (typeof workbook !== 'undefined' && workbook.order) {
          state.files_total = workbook.order.length;
          state.files_processed = workbook.order.length;
        }

        // Lane counts from cache
        state.lane_counts.preflight = cache.lanes.preflight.total;
        state.lane_counts.semantic = cache.lanes.semantic.total;
        state.lane_counts.patch_review = cache.lanes.patch_review.total;

        // Lifecycle stage counts from cache
        var stageKeys = ['loaded','preflight_complete','system_pass_ready','system_pass_complete','system_changes_reviewed','patch_submitted','rfi_submitted','verifier_complete','admin_promoted','applied'];
        var totalContracts = cache.total_contracts || 0;
        stageKeys.forEach(function(sk) {
          var count = cache.lifecycle[sk] ? cache.lifecycle[sk].count : 0;
          state.lifecycle_stage_counts[sk] = count;
          state.lifecycle_stage_pcts[sk] = totalContracts > 0 ? Math.round((count / totalContracts) * 100) : 0;

          // P1-2: Delta since prior refresh
          var prevCount = (prevSnapshot && prevSnapshot.lifecycle_stage_counts[sk]) || 0;
          state.lifecycle_stage_deltas[sk] = count - prevCount;
        });

        // P1-5: Processing state determination
        // State depends on: files loaded, ContractIndex availability, and pending items
        var hasPendingWork = state.lane_counts.preflight > 0 || state.lane_counts.semantic > 0 || state.lane_counts.patch_review > 0;
        if (state.files_total === 0) {
          state.processing_state = 'idle';
        } else if (typeof ContractIndex !== 'undefined' && !ContractIndex.isAvailable()) {
          state.processing_state = 'running';
        } else if (this._state && this._state.processing_state === 'stale') {
          state.processing_state = 'stale';
        } else {
          state.processing_state = 'complete';
        }

        // P1-2: Throughput calculation when running
        if (state.processing_state === 'running' && this._startedAt) {
          var elapsedMin = (Date.now() - this._startedAt) / 60000;
          if (elapsedMin > 0) {
            state.throughput = Math.round(state.files_processed / elapsedMin * 10) / 10;
          }
        }

        state.last_updated_at = new Date().toISOString();
        this._prevSnapshot = JSON.parse(JSON.stringify(state));
        this._state = state;

        // P1-5: Stale detection
        this._resetStaleTimer();

        console.log('[TRIAGE-ANALYTICS][P1] telemetry_recompute: state=' + state.processing_state + ', files=' + state.files_processed + '/' + state.files_total + ', lanes=[pf:' + state.lane_counts.preflight + ',sem:' + state.lane_counts.semantic + ',pr:' + state.lane_counts.patch_review + ']');

        if (state.processing_state !== (prevSnapshot ? prevSnapshot.processing_state : 'idle')) {
          console.log('[TRIAGE-ANALYTICS][P1] processing_state_changed: ' + (prevSnapshot ? prevSnapshot.processing_state : 'idle') + ' -> ' + state.processing_state);
        }

        return state;
      },

      // P1-5: Stale timer management
      _resetStaleTimer: function() {
        var self = this;
        if (this._staleTimer) clearTimeout(this._staleTimer);
        if (this._state && this._state.processing_state !== 'idle') {
          this._staleTimer = setTimeout(function() {
            if (self._state) {
              self._state.processing_state = 'stale';
              console.log('[TRIAGE-ANALYTICS][P1] stale_state_entered: no update for ' + (self._staleTimeoutMs / 1000) + 's');
              self.renderBanner();
            }
          }, this._staleTimeoutMs);
        }
      },

      clearStale: function() {
        if (this._state && this._state.processing_state === 'stale') {
          this._state.processing_state = 'complete';
          console.log('[TRIAGE-ANALYTICS][P1] stale_state_cleared');
          this.renderBanner();
        }
      },

      // P1-7: Debounced UI refresh
      debouncedRefresh: function() {
        var self = this;
        if (this._debounceTimer) clearTimeout(this._debounceTimer);
        this._debounceTimer = setTimeout(function() {
          self.recompute();
          self.renderBanner();
          self.renderLifecycleDeltas();
          self.renderContractChips();
          console.log('[TRIAGE-ANALYTICS][P1] lifecycle_refresh: debounced');
        }, this._debounceMs);
      },

      // P1-5: Render processing status banner
      renderBanner: function() {
        var banner = document.getElementById('ta-processing-banner');
        if (!banner || !this._state) return;
        banner.style.display = '';

        var s = this._state;
        var icon = document.getElementById('ta-proc-icon');
        var text = document.getElementById('ta-proc-text');
        var detail = document.getElementById('ta-proc-detail');
        var stageEl = document.getElementById('ta-proc-stage');
        var timeEl = document.getElementById('ta-proc-time');
        var throughputEl = document.getElementById('ta-proc-throughput');
        var staleEl = document.getElementById('ta-proc-stale');

        // State-based styling
        var configs = {
          idle:     { color: '#9e9e9e', bg: '#f5f5f5', border: '#e0e0e0', label: 'No data loaded', icon: '&#9679;' },
          running:  { color: '#1976d2', bg: '#e3f2fd', border: '#bbdefb', label: 'Processing', icon: '&#9881;' },
          stale:    { color: '#e65100', bg: '#fff3e0', border: '#ffe0b2', label: 'Stale', icon: '&#9888;' },
          complete: { color: '#2e7d32', bg: '#e8f5e9', border: '#c8e6c9', label: 'Up to date', icon: '&#10003;' }
        };
        var cfg = configs[s.processing_state] || configs.idle;

        banner.style.background = cfg.bg;
        banner.style.borderColor = cfg.border;
        if (icon) { icon.innerHTML = cfg.icon; icon.style.color = cfg.color; }
        if (text) { text.textContent = cfg.label; text.style.color = cfg.color; }

        if (detail) {
          if (s.processing_state === 'running') {
            detail.textContent = s.files_processed + '/' + s.files_total + ' files';
          } else if (s.processing_state === 'complete') {
            detail.textContent = s.files_total + ' files processed';
          } else {
            detail.textContent = '';
          }
        }

        // Dominant stage
        if (stageEl) {
          var SL = { loaded: 'Loaded', preflight_complete: 'Pre-Flight', system_pass_ready: 'SP Ready', system_pass_complete: 'System Pass', system_changes_reviewed: 'Reviewed', patch_submitted: 'Patch', rfi_submitted: 'RFI', verifier_complete: 'Verifier', admin_promoted: 'Promoted', applied: 'Applied' };
          var dominant = this._getDominantStage();
          stageEl.textContent = dominant ? ('Stage: ' + (SL[dominant] || dominant)) : '';
        }

        if (timeEl && s.last_updated_at) {
          timeEl.textContent = 'Updated: ' + new Date(s.last_updated_at).toLocaleTimeString();
        }

        // Throughput
        if (throughputEl) {
          if (s.throughput && s.processing_state === 'running') {
            throughputEl.style.display = '';
            throughputEl.textContent = s.throughput + ' items/min';
          } else {
            throughputEl.style.display = 'none';
          }
        }

        // Stale indicator
        if (staleEl) {
          staleEl.style.display = s.processing_state === 'stale' ? '' : 'none';
        }
      },

      _getDominantStage: function() {
        if (!this._state || !this._state.lifecycle_stage_counts) return null;
        var max = 0, dominant = null;
        var counts = this._state.lifecycle_stage_counts;
        Object.keys(counts).forEach(function(k) {
          if (counts[k] > max) { max = counts[k]; dominant = k; }
        });
        return dominant;
      },

      // P1-2: Render lifecycle deltas and percentages on existing stage elements
      renderLifecycleDeltas: function() {
        if (!this._state) return;
        var stageKeys = ['loaded','preflight_complete','system_pass_ready','system_pass_complete','system_changes_reviewed','patch_submitted','rfi_submitted','verifier_complete','admin_promoted','applied'];
        var stageEls = document.querySelectorAll('.ta-lifecycle-stage');

        stageKeys.forEach(function(sk, idx) {
          if (!stageEls[idx]) return;
          var delta = this._state.lifecycle_stage_deltas[sk] || 0;
          var pct = this._state.lifecycle_stage_pcts[sk] || 0;

          // Find or create delta badge
          var deltaEl = stageEls[idx].querySelector('.ta-stage-delta');
          if (!deltaEl) {
            deltaEl = document.createElement('div');
            deltaEl.className = 'ta-stage-delta';
            deltaEl.style.cssText = 'font-size:0.65em;margin-top:2px;font-weight:600;';
            stageEls[idx].appendChild(deltaEl);
          }

          if (delta > 0) {
            deltaEl.textContent = '+' + delta;
            deltaEl.style.color = '#2e7d32';
            deltaEl.style.display = '';
          } else if (delta < 0) {
            deltaEl.textContent = '' + delta;
            deltaEl.style.color = '#c62828';
            deltaEl.style.display = '';
          } else {
            deltaEl.style.display = 'none';
          }

          // Find or create pct badge
          var pctEl = stageEls[idx].querySelector('.ta-stage-pct');
          if (!pctEl) {
            pctEl = document.createElement('div');
            pctEl.className = 'ta-stage-pct';
            pctEl.style.cssText = 'font-size:0.6em;color:#999;margin-top:1px;';
            stageEls[idx].appendChild(pctEl);
          }
          pctEl.textContent = pct + '%';
        }.bind(this));
      },

      // P1-4: Derive and render contract state chips
      renderContractChips: function() {
        var chipsEl = document.getElementById('ta-contract-summary-chips');
        if (!chipsEl || !TriageAnalytics._cache) return;

        var cache = TriageAnalytics._cache;
        var chips = {
          preflight_blocked: 0,
          semantic_pending: 0,
          patch_pending: 0,
          ready_for_verifier: 0,
          promoted: 0
        };

        (cache.contracts || []).forEach(function(c) {
          if (c.preflight_alerts > 0) chips.preflight_blocked++;
          if (c.semantic_alerts > 0) chips.semantic_pending++;
          if (c.patch_alerts > 0) chips.patch_pending++;
          if (c.current_stage === 'verifier_complete' || c.current_stage === 'system_changes_reviewed') chips.ready_for_verifier++;
          if (c.current_stage === 'admin_promoted' || c.current_stage === 'applied') chips.promoted++;
        });

        var chipDefs = [
          { key: 'preflight_blocked', label: 'PF Blocked', color: '#c62828', bg: '#ffebee' },
          { key: 'semantic_pending',  label: 'Sem. Pending', color: '#e65100', bg: '#fff3e0' },
          { key: 'patch_pending',     label: 'Patch Pending', color: '#1565c0', bg: '#e3f2fd' },
          { key: 'ready_for_verifier',label: 'Ready for Verifier', color: '#7b1fa2', bg: '#f3e5f5' },
          { key: 'promoted',          label: 'Promoted', color: '#2e7d32', bg: '#e8f5e9' }
        ];

        var html = '';
        chipDefs.forEach(function(cd) {
          if (chips[cd.key] > 0) {
            html += '<span style="padding:2px 8px;border-radius:10px;background:' + cd.bg + ';color:' + cd.color + ';font-weight:600;cursor:pointer;" onclick="TriageTelemetry.filterByChip(\'' + cd.key + '\')" title="' + cd.label + ': ' + chips[cd.key] + '">' + chips[cd.key] + ' ' + cd.label + '</span>';
          }
        });
        chipsEl.innerHTML = html;
      },

      // P1-3: Lane drill-down with deterministic filter + clear
      applyLaneFilter: function(lane) {
        if (this._activeLaneFilter === lane) {
          this.clearLaneFilter();
          return;
        }
        this._activeLaneFilter = lane;
        console.log('[TRIAGE-ANALYTICS][P1] lane_filter_applied: ' + lane);

        // Filter contract summary by lane-relevant alerts
        if (TriageAnalytics._cache && TriageAnalytics._cache.contracts) {
          var filtered = TriageAnalytics._cache.contracts.filter(function(c) {
            if (lane === 'preflight') return c.preflight_alerts > 0;
            if (lane === 'semantic') return c.semantic_alerts > 0;
            if (lane === 'patch') return c.patch_alerts > 0;
            return true;
          });
          TriageAnalytics._renderContractTable(
            Object.assign({}, TriageAnalytics._cache, { contracts: filtered }),
            null
          );
          // Expand the contract table
          var body = document.getElementById('ta-contract-body');
          var toggle = document.getElementById('ta-contract-toggle');
          if (body) body.style.display = '';
          if (toggle) toggle.style.transform = 'rotate(90deg)';
        }

        // Show clear-filter action
        this._showClearFilterButton(lane);
      },

      clearLaneFilter: function() {
        this._activeLaneFilter = null;
        console.log('[TRIAGE-ANALYTICS][P1] lane_filter_cleared');
        if (TriageAnalytics._cache) {
          TriageAnalytics._renderContractTable(TriageAnalytics._cache, null);
        }
        this._hideClearFilterButton();
      },

      _showClearFilterButton: function(lane) {
        var badge = document.getElementById('ta-contract-filter-badge');
        if (badge) {
          var labels = { preflight: 'Pre-Flight', semantic: 'Semantic', patch: 'Patch Review' };
          badge.textContent = (labels[lane] || lane) + ' \u2715';
          badge.style.display = 'inline';
          badge.style.cursor = 'pointer';
          badge.onclick = function() { TriageTelemetry.clearLaneFilter(); };
        }
      },

      _hideClearFilterButton: function() {
        var badge = document.getElementById('ta-contract-filter-badge');
        if (badge) {
          badge.textContent = '';
          badge.style.display = 'none';
          badge.onclick = null;
        }
      },

      // P1-4: Filter by contract chip
      filterByChip: function(chipKey) {
        if (!TriageAnalytics._cache) return;
        var filtered = TriageAnalytics._cache.contracts.filter(function(c) {
          if (chipKey === 'preflight_blocked') return c.preflight_alerts > 0;
          if (chipKey === 'semantic_pending') return c.semantic_alerts > 0;
          if (chipKey === 'patch_pending') return c.patch_alerts > 0;
          if (chipKey === 'ready_for_verifier') return c.current_stage === 'verifier_complete' || c.current_stage === 'system_changes_reviewed';
          if (chipKey === 'promoted') return c.current_stage === 'admin_promoted' || c.current_stage === 'applied';
          return true;
        });
        TriageAnalytics._renderContractTable(
          Object.assign({}, TriageAnalytics._cache, { contracts: filtered }),
          null
        );
        var body = document.getElementById('ta-contract-body');
        var toggle = document.getElementById('ta-contract-toggle');
        if (body) body.style.display = '';
        if (toggle) toggle.style.transform = 'rotate(90deg)';
        this._showClearFilterButton(chipKey);
      },

      getState: function() { return this._state; }
    };
    // Initialize telemetry
    TriageTelemetry.init();

    var analystTriageState = {
      manualItems: [],
      sflogicItems: [],
      patchItems: [],
      systemItems: []
    };
    
    // Map PatchRequest status to pipeline section
    var ANALYST_STATUS_MAP = {
      'Submitted': { section: 'pending', label: 'Pending Review', color: '#e65100' },
      'Verifier_Responded': { section: 'verifier', label: 'At Verifier', color: '#1565c0' },
      'Verifier_Approved': { section: 'admin', label: 'At Admin', color: '#7b1fa2' },
      'Admin_Hold': { section: 'admin', label: 'Admin Hold', color: '#7b1fa2' },
      'Needs_Clarification': { section: 'clarification', label: 'Needs Response', color: '#f57f17' },
      'Admin_Approved': { section: 'approved', label: 'Approved', color: '#2e7d32' },
      'Applied': { section: 'approved', label: 'Applied', color: '#2e7d32' },
      'Sent_to_Kiwi': { section: 'approved', label: 'In Progress', color: '#2e7d32' },
      'Kiwi_Returned': { section: 'approved', label: 'Kiwi Returned', color: '#2e7d32' },
      'Rejected': { section: 'rejected', label: 'Rejected', color: '#c62828' },
      'Cancelled': { section: 'rejected', label: 'Cancelled', color: '#c62828' },
      'Draft': { section: 'pending', label: 'Draft', color: '#757575' }
    };
    
    // v1.6.0: Dataset load timestamp for signal items
    var datasetLoadTimestamp = null;
    
    var _preflightBlockerTypes = {
        UNKNOWN_COLUMN: { label: 'Unknown Column', badge: 'fail', icon: '\u2753', desc: 'Column not found in field_meta.json. Threshold: columns with >0 non-empty values are flagged.' },
        OCR_MOJIBAKE: { label: 'Mojibake (Encoding)', badge: 'warn', icon: '\u26a0', desc: 'PDF contains encoding artifacts at low or medium impact level.' },
        OCR_UNREADABLE: { label: 'OCR Unreadable', badge: 'fail', icon: '\ud83d\udeab', desc: 'OCR extraction returned unreadable or garbled text. Manual review required.' },
        LOW_CONFIDENCE: { label: 'Low Confidence', badge: 'warn', icon: '\u26a0', desc: 'Extraction confidence below 60%. Values may be unreliable.' },
        DOCUMENT_TYPE_MISSING: { label: 'Document Type Missing', badge: 'warn', icon: '\ud83d\udcc4', desc: 'Document type not assigned or not recognized. Assign a valid document type before proceeding.' },
        MISSING_REQUIRED: { label: 'Missing Required', badge: 'fail', icon: '\u2757', desc: 'A required field defined in field_meta.json is missing or empty in this record.' },
        PICKLIST_INVALID: { label: 'Invalid Picklist', badge: 'warn', icon: '\ud83d\udcdd', desc: 'Field value does not match any allowed option in the picklist.' }
    };

    function loadAnalystTriageFromStore() {
      // v1.6.33: Seed Patch Requests from meta sheet (RFIs from modified dataset)
      // Only seed if data is loaded (workbook populated)
      if (dataLoaded && workbook && workbook.sheets && Object.keys(workbook.sheets).length > 0) {
        seedPatchRequestsFromMetaSheet();
      }
      
      // v1.6.9: Seed Verifier RFI queue from meta sheet (if not already done)
      seedVerifierRFIQueueFromMetaSheet();
      
      var allPRs = PATCH_REQUEST_STORE.list();
      console.log('[AnalystTriage] Loading from store, found:', allPRs.length);
      
      // Map all patch requests to triage items (existing behavior)
      var patchRequestItems = allPRs.map(function(pr) {
        var statusInfo = ANALYST_STATUS_MAP[pr.status] || { section: 'pending', label: pr.status || 'Unknown', color: '#757575' };
        
        var patchType = 'correction';
        if (pr.artifact_type === 'rfi') patchType = 'rfi';
        else if (pr.type) patchType = pr.type;
        else if (pr.intent && pr.intent.category === 'blacklist') patchType = 'blacklist';
        
        return {
          request_id: pr.request_id,
          type: patchType,
          record_id: pr.record_id || (pr.payload && pr.payload.record_id) || 'Unknown',
          contract_key: pr.contract_key || (pr.payload && pr.payload.contract_key),
          field_name: pr.field_name || ((pr.payload && pr.payload.changes) ? Object.keys(pr.payload.changes)[0] : 'Multiple'),
          status: pr.status,
          section: statusInfo.section,
          status_label: statusInfo.label,
          status_color: statusInfo.color,
          updated_at: pr.updated_at_utc || pr.submitted_at_utc || pr.created_at_utc,
          notes: pr.clarification_notes || pr.rejection_reason,
          thread: pr.thread,
          source: 'patch_request'
        };
      }).sort(function(a, b) {
        return (b.updated_at || '').localeCompare(a.updated_at || '');
      });
      
      // v1.6.0: Populate queues from signalStore
      var signalItems = getSignalTriageItems();
      
      // v2.3.5-P1D.1: Build record_id → contract reverse map for pre-flight enrichment
      var _rid2contract = {};
      if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && ContractIndex._index) {
        var _ciContracts = ContractIndex._index.contracts;
        var _ciKeys = Object.keys(_ciContracts);
        for (var _ci = 0; _ci < _ciKeys.length; _ci++) {
          var _cid = _ciKeys[_ci];
          var _cObj = _ciContracts[_cid];
          var _shKeys = Object.keys(_cObj.sheets || {});
          for (var _si = 0; _si < _shKeys.length; _si++) {
            var _shRows = _cObj.sheets[_shKeys[_si]];
            for (var _ri = 0; _ri < _shRows.length; _ri++) {
              var _rid = _shRows[_ri].record_id;
              if (_rid) _rid2contract[_rid] = { contract_id: _cid, file_name: _cObj.file_name || '', file_url: _cObj.file_url || '' };
            }
          }
        }
        console.log('[TRIAGE-CONTRACT-HEALTH][P1D.1] enrichment_map_built: records=' + Object.keys(_rid2contract).length + ', contracts=' + _ciKeys.length);
      }

      // Manual Review: OCR_UNREADABLE (encoding artifacts / mojibake)
      analystTriageState.manualItems = signalItems.filter(function(item) {
        return item.signal_type === 'OCR_UNREADABLE' || item.signal_type === 'OCR_MOJIBAKE';
      });
      analystTriageState.manualItems.forEach(function(item) {
        if ((item.signal_type === 'OCR_UNREADABLE' || item.signal_type === 'OCR_MOJIBAKE') && !item._preflightRouted) {
          item._preflightRouted = true;
          item.blocker_type = item.signal_type;
          item.reason_summary = item.signal_type === 'OCR_UNREADABLE' ? 'High Impact — Unreadable' : 'Encoding artifacts (mojibake)';
        }
        if (!item.contract_key && !item.contract_id && item.record_id && _rid2contract[item.record_id]) {
          var _cm = _rid2contract[item.record_id];
          item.contract_id = _cm.contract_id;
          item.contract_key = _cm.contract_id;
          item.file_name = _cm.file_name;
          item.file_url = _cm.file_url;
        }
        if (!item.sheet_name && item.record_id) {
          var _cIdx = item.record_id.lastIndexOf(':');
          if (_cIdx > 0) item.sheet_name = item.record_id.substring(0, _cIdx);
        }
        if (!item.sheet_name && item.contract_key) {
          var _ckIdx = item.contract_key.indexOf(':ROW_');
          if (_ckIdx > 0) item.sheet_name = item.contract_key.substring(0, _ckIdx);
        }
      });
      
      // Salesforce Logic Flags: QA_FLAG with ERROR or WARNING severity
      analystTriageState.sflogicItems = signalItems.filter(function(item) {
        return item.signal_type === 'QA_FLAG' && (item.severity === 'error' || item.severity === 'warning');
      });
      
      // v1.6.33: Patch Queue - only show actual patch requests (RFIs, corrections, etc.)
      // Validation signals (MISSING_REQUIRED, PICKLIST_INVALID) moved to Manual Review
      // Sort by updated_at descending to show most recent first
      patchRequestItems.sort(function(a, b) {
        var aTime = a.updated_at || a.updated_at_utc || '';
        var bTime = b.updated_at || b.updated_at_utc || '';
        return bTime.localeCompare(aTime);
      });
      var preSanitizeCount = patchRequestItems.length;
      var _excludedMeta = 0, _excludedRef = 0, _excludedSysFields = 0;
      patchRequestItems = patchRequestItems.filter(function(item) {
        var sheet = item.sheet || item.sheet_name || '';
        if (sheet && (typeof isMetaSheet === 'function' && isMetaSheet(sheet))) { _excludedMeta++; return false; }
        if (sheet && (typeof isReferenceSheet === 'function' && isReferenceSheet(sheet))) { _excludedRef++; return false; }
        var fld = (item.field_name || '').toLowerCase();
        if (fld.indexOf('__meta') === 0 || fld.indexOf('_glossary') === 0 || fld === '_system' || fld === '_internal') { _excludedSysFields++; return false; }
        return true;
      });
      console.log('[TRIAGE-ANALYTICS][P0.2] queue_exclusions_applied: pre=' + preSanitizeCount + ', post=' + patchRequestItems.length + ', removed=' + (preSanitizeCount - patchRequestItems.length) + ', meta_sheets=' + _excludedMeta + ', ref_sheets=' + _excludedRef + ', sys_fields=' + _excludedSysFields);
      analystTriageState.patchItems = patchRequestItems;
      
      // v1.6.33: Add validation signals to Manual Review queue (not Patch Queue)
      var validationSignals = signalItems.filter(function(item) {
        return item.signal_type === 'MISSING_REQUIRED' || item.signal_type === 'PICKLIST_INVALID';
      });
      validationSignals.forEach(function(item) {
        if (!item.contract_key && !item.contract_id && item.record_id && _rid2contract[item.record_id]) {
          var _cm = _rid2contract[item.record_id];
          item.contract_id = _cm.contract_id;
          item.contract_key = _cm.contract_id;
          item.file_name = _cm.file_name;
          item.file_url = _cm.file_url;
        }
        if (!item.sheet_name && item.record_id) {
          var _cIdx = item.record_id.lastIndexOf(':');
          if (_cIdx > 0) item.sheet_name = item.record_id.substring(0, _cIdx);
        }
        if (!item.sheet_name && item.contract_key) {
          var _ckIdx = item.contract_key.indexOf(':ROW_');
          if (_ckIdx > 0) item.sheet_name = item.contract_key.substring(0, _ckIdx);
        }
      });
      analystTriageState.manualItems = analystTriageState.manualItems.concat(validationSignals);
      
      // v1.6.35: Add Manual Review items from canonical store (seeded from RFI meta sheet)
      if (typeof seedManualReviewFromMetaSheet === 'function') {
        seedManualReviewFromMetaSheet(); // Seed to canonical store
      }
      var metaManualItems = META_TRIAGE_STORE.getManualReview();
      if (metaManualItems && metaManualItems.length > 0) {
        analystTriageState.manualItems = analystTriageState.manualItems.concat(metaManualItems);
      }
      
      // v2.2 P0+P2: Pre-Flight blockers: unknown columns, unreadable OCR, low-confidence extraction, mojibake
      

      // v2.3 T11: Timeline lock alignment - governed decision enforcement
      var _governedDecisions = {
        resolveAsOf: function(record) {
          var docDate = record.document_date || record.doc_date || record.effective_date || null;
          var manualDate = record.as_of || record.as_of_date || null;
          if (docDate) return { as_of: docDate, as_of_source: 'document_date' };
          if (manualDate) return { as_of: manualDate, as_of_source: 'manual' };
          return { as_of: new Date().toISOString().split('T')[0], as_of_source: 'system_default' };
        },

        validateScheduleAttachment: function(scheduleRecord, parentRecord) {
          if (!parentRecord) {
            return {
              valid: false,
              blocker: {
                type: 'preflight_blocker',
                blocker_type: 'UNATTACHED_SCHEDULE',
                message: 'Schedule document has no parent contract. Attach before proceeding.',
                severity: 'blocker',
                can_create_patch: false
              }
            };
          }
          return { valid: true, blocker: null };
        },

        canPerformAction: function(action, role, isProduction) {
          if (!isProduction) return true;
          var permissions = {
            'edit_draft': ['analyst', 'admin'],
            'submit_patch': ['analyst', 'admin'],
            'verify_patch': ['verifier', 'admin'],
            'approve_patch': ['admin'],
            'promote_rule': ['admin'],
            'attach_schedule': ['analyst', 'admin'],
            'set_governing': ['analyst', 'admin'],
            'rollback': ['admin']
          };
          var allowed = permissions[action] || [];
          return allowed.indexOf(role) >= 0;
        },

        resolveGoverningState: function(documents) {
          if (!documents || documents.length === 0) return { governing: null, ambiguous: false };
          var candidates = documents.filter(function(d) {
            return d.document_role === 'Root Agreement' || d.document_role === 'Amendment' || d.document_role === 'Governing';
          });
          if (candidates.length === 0) return { governing: null, ambiguous: false };
          if (candidates.length === 1) return { governing: candidates[0], ambiguous: false };
          candidates.sort(function(a, b) {
            var da = a.effective_date || a.document_date || '';
            var db = b.effective_date || b.document_date || '';
            return db.localeCompare(da);
          });
          return { governing: candidates[0], ambiguous: true, all_candidates: candidates };
        }
      };

      window._governedDecisions = _governedDecisions;

      if (typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && ContractIndex._index) {
        var contracts = ContractIndex.listContracts();
        contracts.forEach(function(c) {
          var rollup = ContractIndex.getRollup(c.contract_id);
          if (rollup && rollup.unknown_columns && rollup.unknown_columns.length > 0) {
            rollup.unknown_columns.forEach(function(uc) {
              var ucSeverity = uc.severity || (Number(uc.non_empty || 0) > 3 ? 'blocker' : 'warning');
              analystTriageState.manualItems.push({
                request_id: 'preflight_unk_' + c.contract_id + '_' + uc.column,
                type: 'preflight_blocker',
                signal_type: 'UNKNOWN_COLUMN',
                record_id: c.contract_id,
                contract_id: c.contract_id,
                contract_key: c.contract_id,
                field_name: uc.column,
                sheet_name: uc.sheet || '',
                severity: ucSeverity,
                message: 'Unknown column: ' + uc.column + ' (sheet: ' + uc.sheet + ', non-empty: ' + uc.non_empty + ', severity: ' + ucSeverity + ')',
                status: 'open',
                updated_at: new Date().toISOString(),
                source: 'preflight',
                note_type: 'Pre-Flight Blocker',
                blocker_type: 'UNKNOWN_COLUMN',
                can_create_patch: true
              });
              AuditTimeline.emit('preflight_blocker_detected', {
                record_id: c.contract_id,
                field_key: uc.column,
                dataset_id: IDENTITY_CONTEXT.dataset_id || '',
                metadata: { blocker_type: 'unknown_column', sheet: uc.sheet, non_empty: uc.non_empty, scope: 'contract' }
              });
            });
          }
          // v2.2 P2: OCR unreadable, low-confidence, mojibake detection from rollup signals
          if (rollup && rollup.extraction_signals) {
            (rollup.extraction_signals || []).forEach(function(sig) {
              var bt = sig.blocker_type || '';
              if (['OCR_UNREADABLE', 'LOW_CONFIDENCE'].indexOf(bt) >= 0) {
                var meta = _preflightBlockerTypes[bt] || {};
                analystTriageState.manualItems.push({
                  request_id: 'preflight_' + bt.toLowerCase() + '_' + c.contract_id + '_' + (sig.field || sig.sheet || ''),
                  type: 'preflight_blocker',
                  signal_type: bt,
                  record_id: c.contract_id,
                  contract_id: c.contract_id,
                  contract_key: c.contract_id,
                  field_name: sig.field || '',
                  sheet_name: sig.sheet || '',
                  severity: bt === 'LOW_CONFIDENCE' ? 'warning' : 'blocker',
                  message: meta.label + ': ' + (sig.detail || sig.field || '') + (sig.sheet ? ' (sheet: ' + sig.sheet + ')' : '') + (sig.confidence ? ' [conf: ' + Math.round(sig.confidence * 100) + '%]' : ''),
                  status: 'open',
                  updated_at: new Date().toISOString(),
                  source: 'preflight',
                  note_type: 'Pre-Flight Blocker',
                  blocker_type: bt,
                  can_create_patch: bt !== 'LOW_CONFIDENCE'
                });
                AuditTimeline.emit('preflight_blocker_detected', {
                  record_id: c.contract_id,
                  field_key: sig.field || '',
                  dataset_id: IDENTITY_CONTEXT.dataset_id || '',
                  metadata: { blocker_type: bt.toLowerCase(), sheet: sig.sheet || '', confidence: sig.confidence, scope: 'contract' }
                });
              }
            });
          }
        });
      }

      // P1F.2: Merge batch scan flagged items into manualItems for Contract Health table
      if (typeof _p1fBatchScanItems !== 'undefined' && _p1fBatchScanItems.length > 0) {
        var _existKeys = {};
        analystTriageState.manualItems.forEach(function(m) {
          if (m.contract_key && m.field_name) _existKeys[m.signal_type + ':' + m.contract_key + ':' + (m.sheet_name || '') + ':' + m.field_name] = true;
        });
        _p1fBatchScanItems.forEach(function(item) {
          var key = item.signal_type + ':' + item.contract_key + ':' + (item.sheet_name || '') + ':' + item.field_name;
          if (!_existKeys[key]) {
            analystTriageState.manualItems.push(item);
            _existKeys[key] = true;
          }
        });
      }

      // System Changes: QA_FLAG with INFO severity
      analystTriageState.systemItems = signalItems.filter(function(item) {
        return item.signal_type === 'QA_FLAG' && item.severity === 'info';
      });
      
      // v1.6.35: Add System Changes from canonical store (seeded from *_change_log sheets)
      if (typeof seedSystemChangesFromChangeLog === 'function') {
        seedSystemChangesFromChangeLog(); // Seed to canonical store
      }
      var changeLogItems = META_TRIAGE_STORE.getSystemChanges();
      if (changeLogItems && changeLogItems.length > 0) {
        analystTriageState.systemItems = analystTriageState.systemItems.concat(changeLogItems);
      }
      
      console.log('[AnalystTriage] Queue counts from signals: Manual=' + analystTriageState.manualItems.length + 
        ', SystemPass=' + analystTriageState.sflogicItems.length + 
        ', Patch=' + analystTriageState.patchItems.length + 
        ', System=' + analystTriageState.systemItems.length);
      
      // v1.6.33: Update progress block after seeding patch requests
      if (typeof updateProgressBlock === 'function') {
        updateProgressBlock();
      }
    }
    
    // v1.6.0: Convert signalStore to triage items
    function getSignalTriageItems() {
      var items = [];
      var loadTime = datasetLoadTimestamp || new Date().toISOString();
      
      // Iterate over signalStore.signals_by_cell
      var recordIds = Object.keys(signalStore.signals_by_cell).sort();
      
      recordIds.forEach(function(recordId) {
        var fieldSignals = signalStore.signals_by_cell[recordId];
        var fieldKeys = Object.keys(fieldSignals).sort();
        
        fieldKeys.forEach(function(fieldKey) {
          var signals = fieldSignals[fieldKey];
          signals.forEach(function(signal) {
            var _sheetFromRid = signalStore._recordToSheet[recordId] || '';
            if (!_sheetFromRid) {
              var _colonIdx = recordId.lastIndexOf(':');
              if (_colonIdx > 0) _sheetFromRid = recordId.substring(0, _colonIdx);
            }
            items.push({
              id: recordId + '|' + fieldKey + '|' + signal.signal_type,
              signal_type: signal.signal_type,
              type: mapSignalTypeToTriageType(signal.signal_type),
              record_id: recordId,
              field_name: signal.field_label || fieldKey,
              field_key: fieldKey,
              sheet_name: _sheetFromRid,
              status: signal.signal_type,
              status_label: mapSignalTypeToLabel(signal.signal_type),
              status_color: mapSignalSeverityToColor(signal.severity),
              severity: signal.severity,
              message: signal.message,
              updated_at: loadTime,
              source: 'signal'
            });
          });
        });
      });
      
      return items;
    }
    
    // v1.6.0: Map signal types to triage display types
    function mapSignalTypeToTriageType(signalType) {
      switch (signalType) {
        case 'MISSING_REQUIRED': return 'required';
        case 'PICKLIST_INVALID': return 'picklist';
        case 'OCR_UNREADABLE': return 'encoding';
        case 'QA_FLAG': return 'qa';
        default: return 'signal';
      }
    }
    
    function mapSignalTypeToLabel(signalType) {
      switch (signalType) {
        case 'MISSING_REQUIRED': return 'Required';
        case 'PICKLIST_INVALID': return 'Invalid Value';
        case 'OCR_UNREADABLE': return 'Encoding Issue';
        case 'QA_FLAG': return 'QA Flag';
        default: return signalType;
      }
    }
    
    function mapSignalSeverityToColor(severity) {
      switch (severity) {
        case 'error': return '#c62828';
        case 'warning': return '#f57f17';
        case 'warn': return '#f57f17';  // Handle both 'warn' and 'warning'
        case 'info': return '#1565c0';
        default: return '#757575';
      }
    }
    
    function renderTriageQueueTable(items, containerId, emptyMessage, isPreFlight) {
      var container = document.getElementById(containerId);
      if (!container) return;
      
      if (items.length === 0) {
        container.innerHTML = '<tr><td colspan="' + (isPreFlight ? '8' : '7') + '" style="padding: 24px; text-align: center; color: #999;">' + emptyMessage + '</td></tr>';
        return;
      }
      
      container.innerHTML = items.map(function(item) {
        // v1.6.0: Handle both signal items and patch request items
        var typeLabel = getTriageTypeLabel(item.type);
        var typeBadgeColor = getTriageTypeColor(item.type);
        
        var timestamp = item.updated_at ? new Date(item.updated_at).toLocaleString() : 'Unknown';
        var statusBadge = '<span style="display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: ' + 
          item.status_color + '15; color: ' + item.status_color + ';">' + item.status_label + '</span>';
        var notesIndicator = item.notes ? '<span title="Has verifier notes" style="margin-left: 4px; color: #f57f17;">💬</span>' : '';
        
        var recordDisplay = '';
        if (isPreFlight) {
          var _ck = item.contract_key || item.contract_id || '';
          var _sn = item.sheet_name || '';
          var _ri = (item.row_index !== undefined && item.row_index !== null && item.row_index >= 0) ? item.row_index : -1;
          if (_ck && _sn && _ri >= 0) {
            recordDisplay = _ck.substring(0, 12) + ' ' + _sn + ':' + _ri;
          } else if (_ck && _sn) {
            recordDisplay = _ck.substring(0, 12) + ' ' + _sn;
          } else if (_ck) {
            recordDisplay = _ck.substring(0, 18);
          } else {
            recordDisplay = 'Batch-level';
          }
        } else {
          recordDisplay = item.contract_key || item.record_id || 'Unknown';
        }
        if (recordDisplay.length > 28) recordDisplay = recordDisplay.substring(0, 26) + '...';
        
        var rowStyle = item.section === 'clarification' ? 'background: #fff8e1;' : '';
        
        // v1.6.0: Different click handlers for signal vs patch request items
        var clickHandler = item.source === 'signal' 
          ? 'openSignalTriageItem(\'' + item.record_id + '\', \'' + item.field_key + '\')'
          : 'openAnalystTriageItem(\'' + item.request_id + '\')';
        
        var viewHandler;
        if (isPreFlight) {
          viewHandler = 'openPreflightItem(\'' + (item.request_id || '') + '\', \'' + (item.record_id || '') + '\', \'' + (item.contract_id || item.contract_key || '') + '\', \'' + (item.field_name || item.field_key || '') + '\')';
        } else if (item.source === 'signal') {
          viewHandler = 'openSignalTriageItem(\'' + item.record_id + '\', \'' + item.field_key + '\')';
        } else {
          viewHandler = 'openAnalystTriageItem(\'' + item.request_id + '\')';
        }
        
        var preflightBadge = '';
        if (isPreFlight && item.blocker_type && typeof _preflightBlockerTypes !== 'undefined') {
          var bt = _preflightBlockerTypes[item.blocker_type] || {};
          var badgeClass = bt.badge === 'fail' ? 'background:#ffebee; color:#c62828; border:1px solid #ef9a9a;' : 'background:#fff3e0; color:#e65100; border:1px solid #ffe082;';
          preflightBadge = ' <span style="display:inline-flex; align-items:center; gap:2px; padding:1px 6px; border-radius:10px; font-size:0.75em; font-weight:600; ' + badgeClass + '" title="' + (bt.desc || '') + '">' + (bt.icon || '') + ' ' + (bt.label || item.blocker_type) + '</span>';
        }
        var patchFromBlockerBtn = '';
        if (isPreFlight && item.can_create_patch && item.status === 'open') {
          patchFromBlockerBtn = ' <button class="btn-secondary" style="padding:2px 6px; font-size:0.72em; background:#e3f2fd; border:1px solid #bbdefb;" onclick="event.stopPropagation(); createPatchFromBlocker(\'' + (item.request_id || '') + '\', \'' + (item.record_id || '') + '\', \'' + (item.field_name || '') + '\', \'' + (item.blocker_type || '') + '\')">Create Patch</button>';
        }
        return '<tr style="border-bottom: 1px solid #eee; cursor: pointer; ' + rowStyle + '" onclick="' + clickHandler + '">' +
          '<td style="padding: 10px 12px;"><span style="display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: ' + typeBadgeColor + '15; color: ' + typeBadgeColor + ';" title="' + getTriageTypeTip(item.type) + '">' + typeLabel + '</span>' + preflightBadge + '</td>' +
          '<td style="padding: 10px 12px; font-family: monospace; font-size: 0.85em;">' + recordDisplay + '</td>' +
          '<td style="padding: 10px 12px;">' + (item.field_name || '-') + '</td>' +
          '<td style="padding: 10px 12px; font-size: 0.82em;">' + (isPreFlight && item.blocker_type ? (function() { var _bt = _preflightBlockerTypes[item.blocker_type] || {}; var _reasonLabel = _bt.label || (item.blocker_type || '').replace(/_/g, ' '); var _reasonTip = _bt.desc || item.message || ''; return '<span style="display:inline-block; padding: 2px 7px; border-radius: 3px; background: #fff3e0; color: #e65100; font-size: 0.85em; font-weight: 500; cursor: help;" title="' + _reasonTip.replace(/"/g, '&quot;') + '">' + _reasonLabel + '</span>'; })() : (item.reason_summary || item.signal_type || '-')) + '</td>' +
          '<td style="padding: 10px 12px;">' + statusBadge + notesIndicator + '</td>' +
          '<td style="padding: 10px 12px; color: #666; font-size: 0.85em;">' + timestamp + '</td>' +
          '<td style="padding: 10px 12px;"><button class="btn-secondary" style="padding: 4px 8px; font-size: 0.75em;" onclick="event.stopPropagation(); ' + viewHandler + '">View</button>' + patchFromBlockerBtn + '</td>' +
          (function() { var qHealthHtml = '<td style="padding:10px 12px; text-align:center;">'; if (typeof ContractHealthScore !== 'undefined') { var qCk = item.contract_key || item.contract_id || ''; var qHs = qCk ? ContractHealthScore._scores[qCk] : null; if (qHs) { qHealthHtml += '<span style="padding:2px 6px;border-radius:10px;font-size:0.85em;background:' + qHs.band.bg + ';color:' + qHs.band.color + ';font-weight:600;cursor:help;" title="Health: ' + qHs.score + '/100 (' + qHs.band.label + ')">' + qHs.score + '</span>'; } else { qHealthHtml += '-'; } } else { qHealthHtml += '-'; } qHealthHtml += '</td>'; return qHealthHtml; })() +
          '</tr>';
      }).join('');
    }
    
    // v1.6.0: Get type label for triage display
    var _p1aLabelMap = {
      'rfi': { label: 'RFI', tip: 'Request for Information — analyst needs clarification' },
      'blacklist': { label: 'Blacklisted', tip: 'Field or value is on the exclusion list' },
      'qa': { label: 'QA Flag', tip: 'Quality assurance flag from qa_flags.json rules' },
      'required': { label: 'Missing Required', tip: 'Required field is missing or empty (field_meta.json)' },
      'picklist': { label: 'Invalid Picklist', tip: 'Value not in allowed picklist options' },
      'encoding': { label: 'Encoding Issue', tip: 'Character encoding problem detected' },
      'correction': { label: 'Correction', tip: 'Value correction suggested by system rules' },
      'extraction': { label: 'Extraction Error', tip: 'Data extraction from source document failed or is suspect' },
      'logic': { label: 'Logic Flag', tip: 'Business logic rule triggered a warning' },
      'preflight_blocker': { label: 'Pre-Flight', tip: 'Pre-flight blocker — must resolve before proceeding' }
    };
    function getTriageTypeLabel(type) {
      var entry = _p1aLabelMap[type];
      if (entry) return entry.label;
      return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Signal';
    }
    function getTriageTypeTip(type) {
      var entry = _p1aLabelMap[type];
      return entry ? entry.tip : '';
    }
    
    // v1.6.0: Get type color for triage display
    function getTriageTypeColor(type) {
      switch (type) {
        case 'preflight_blocker': return '#d32f2f';
        case 'rfi': return '#1565c0';
        case 'blacklist': return '#c62828';
        case 'qa': return '#ff9800';
        case 'required': return '#c62828';
        case 'picklist': return '#f57f17';
        case 'encoding': return '#9c27b0';
        case 'correction': return '#2e7d32';
        case 'extraction': return '#9c27b0';
        case 'logic': return '#00bcd4';
        default: return '#757575';
      }
    }
    

    // ═══════════════════════════════════════════════════════════════
    // P0.8: Unified Triage Record-Link Resolver
    // ═══════════════════════════════════════════════════════════════
    var _p08UnresolvedPayload = null;

    function resolveRecordForTriageItem(item, activeDatasetId) {
      var result = { resolved: false, path: 'unresolved', target: null, debug: null };
      var itemDatasetId = item.dataset_id || '';
      var itemRecordId = item.record_id || '';
      var itemContractId = item.contract_id || item.contract_key || '';
      var itemSheetName = item.sheet_name || '';
      var itemRowIndex = (item.row_index !== undefined && item.row_index !== null) ? item.row_index : -1;
      var itemFieldKey = item.field_key || item.field_name || '';

      console.log('[P0.8-LINK] route_attempt: item_id=' + (item.request_id || item.id || 'unknown') +
        ', active_dataset=' + (activeDatasetId || 'null') +
        ', item_dataset=' + itemDatasetId +
        ', record_id=' + itemRecordId +
        ', contract_id=' + itemContractId +
        ', sheet=' + itemSheetName +
        ', row=' + itemRowIndex);

      // Step 1: Exact match by record_id
      if (itemRecordId) {
        var found = typeof findRecordById === 'function' ? findRecordById(itemRecordId) : null;
        if (found) {
          console.log('[P0.8-LINK] route_resolved_record: record_id=' + itemRecordId + ' found in workbook sheet=' + found.sheetName);
          result.resolved = true;
          result.path = 'exact_record';
          result.target = found;
          result.fieldKey = itemFieldKey;
          return result;
        }
        // Also try canonical store
        var tid = (typeof IDENTITY_CONTEXT !== 'undefined') ? IDENTITY_CONTEXT.tenant_id : '';
        var did = activeDatasetId || '';
        if (tid && did) {
          var storeKey = 'kiwi/v1/' + tid + '/records/' + did + '/' + itemRecordId + '.json';
          var stored = localStorage.getItem(storeKey);
          if (stored) {
            try {
              var rec = JSON.parse(stored);
              console.log('[P0.8-LINK] route_resolved_record: record_id=' + itemRecordId + ' found in canonical store');
              result.resolved = true;
              result.path = 'canonical_store';
              result.target = { row: rec, rowIndex: 0, sheetName: 'canonical', fromStore: true };
              result.fieldKey = itemFieldKey;
              return result;
            } catch (e) { /* ignore parse errors */ }
          }
        }
      }

      // Step 2: sheet_name + row_index lookup
      if (itemSheetName && itemRowIndex >= 0 && workbook && workbook.sheets) {
        var sheet = workbook.sheets[itemSheetName];
        if (sheet && sheet.rows && itemRowIndex < sheet.rows.length) {
          console.log('[P0.8-LINK] route_resolved_record: sheet=' + itemSheetName + ' row=' + itemRowIndex);
          result.resolved = true;
          result.path = 'sheet_row';
          result.target = { row: sheet.rows[itemRowIndex], rowIndex: itemRowIndex, sheetName: itemSheetName };
          result.fieldKey = itemFieldKey;
          return result;
        }
      }

      // Step 3: contract_id + field_key - find any record in active dataset matching contract
      if (itemContractId && workbook && workbook.sheets && typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable()) {
        var contractInfo = ContractIndex._index && ContractIndex._index.contracts ? ContractIndex._index.contracts[itemContractId] : null;
        if (contractInfo && contractInfo.sheets) {
          var sheetKeys = Object.keys(contractInfo.sheets);
          for (var si = 0; si < sheetKeys.length; si++) {
            var sn = sheetKeys[si];
            var rowIndices = contractInfo.sheets[sn];
            if (rowIndices && rowIndices.length > 0 && workbook.sheets[sn] && workbook.sheets[sn].rows) {
              var ri = rowIndices[0];
              if (ri < workbook.sheets[sn].rows.length) {
                console.log('[P0.8-LINK] route_resolved_contract: contract=' + itemContractId + ' sheet=' + sn + ' row=' + ri);
                result.resolved = true;
                result.path = 'contract_field';
                result.target = { row: workbook.sheets[sn].rows[ri], rowIndex: ri, sheetName: sn };
                result.fieldKey = itemFieldKey;
                return result;
              }
            }
          }
        }
      }

      // Step 4: Contract-level fallback - open first record in Record Inspector
      if (itemContractId) {
        console.log('[P0.8-LINK] route_resolved_contract: fallback record_inspector contract=' + itemContractId + ' sheet=' + itemSheetName);
        result.resolved = true;
        result.path = 'contract_grid';
        result.contractId = itemContractId;
        result.sheetName = itemSheetName;
        return result;
      }

      // Step 5: Unresolved - show diagnostics modal
      var debugPayload = {
        item_id: item.request_id || item.id || 'unknown',
        item_type: item.type || item.source || 'unknown',
        record_id: itemRecordId,
        contract_id: itemContractId,
        field: itemFieldKey,
        sheet_name: itemSheetName,
        row_index: itemRowIndex,
        item_dataset_id: itemDatasetId,
        active_dataset_id: activeDatasetId || 'null',
        source_file: item.file_url || item.file_name || '',
        reason: 'no_match_found'
      };
      console.log('[P0.8-LINK] route_unresolved_modal: item_id=' + debugPayload.item_id + ' reason=' + debugPayload.reason);
      result.debug = debugPayload;
      return result;
    }

    function executeTriageResolution(item) {
      console.log('[P0.9-CLEANUP] ds_route_resolved: item_id=' + (item.request_id || 'unknown') + ', source=' + (item.source || ''));
      var activeDatasetId = (typeof IDENTITY_CONTEXT !== 'undefined') ? IDENTITY_CONTEXT.dataset_id : null;
      var resolution = resolveRecordForTriageItem(item, activeDatasetId);

      if (resolution.resolved) {
        if (resolution.path === 'contract_grid') {
          var _cid = resolution.contractId;
          var _openedRecord = false;
          if (_cid && typeof ContractIndex !== 'undefined' && ContractIndex.isAvailable() && ContractIndex._index && ContractIndex._index.contracts[_cid]) {
            var _ci = ContractIndex._index.contracts[_cid];
            var _targetSheet = resolution.sheetName || '';
            if (_ci.sheets) {
              var _sheetKeys = _targetSheet ? [_targetSheet] : Object.keys(_ci.sheets);
              for (var _ski = 0; _ski < _sheetKeys.length; _ski++) {
                var _sn = _sheetKeys[_ski];
                var _rows = _ci.sheets[_sn];
                if (_rows && _rows.length > 0 && typeof workbook !== 'undefined' && workbook.sheets && workbook.sheets[_sn] && workbook.sheets[_sn].rows) {
                  var _ri = _rows[0].row_index !== undefined ? _rows[0].row_index : _rows[0];
                  if (_ri < workbook.sheets[_sn].rows.length) {
                    openRowReviewDrawer(_sn, _ri);
                    _openedRecord = true;
                    break;
                  }
                }
              }
            }
          }
          if (!_openedRecord) {
            _activeContractFilter = _cid;
            navigateTo('grid');
            setTimeout(function() { if (typeof renderGrid === 'function') renderGrid(); }, 100);
          }
        } else if (resolution.target) {
          if (resolution.target.sheetName && resolution.target.sheetName !== 'canonical') {
            openRowReviewDrawer(resolution.target.sheetName, resolution.target.rowIndex);
          } else {
            openRowReviewDrawer(resolution.target.row, resolution.target.rowIndex, item.record_id);
          }
          if (resolution.fieldKey) {
            setTimeout(function() {
              if (typeof focusFieldInInspector === 'function') focusFieldInInspector(resolution.fieldKey);
            }, 300);
          }
        }
      } else {
        showUnresolvedModal(resolution.debug);
      }
    }

    function showUnresolvedModal(debugPayload) {
      _p08UnresolvedPayload = debugPayload;
      var modal = document.getElementById('p08-unresolved-modal');
      if (!modal) return;
      var summaryEl = document.getElementById('p08-unresolved-summary');
      var jsonEl = document.getElementById('p08-unresolved-json');
      var btnContract = document.getElementById('p08-btn-open-contract');
      var btnSheet = document.getElementById('p08-btn-open-sheet');

      if (summaryEl) {
        summaryEl.innerHTML =
          '<div><strong>Item Type:</strong> ' + (debugPayload.item_type || '-') + '</div>' +
          '<div><strong>Record ID:</strong> ' + (debugPayload.record_id || '-') + '</div>' +
          '<div><strong>Contract ID:</strong> ' + (debugPayload.contract_id || '-') + '</div>' +
          '<div><strong>Field:</strong> ' + (debugPayload.field || '-') + '</div>' +
          '<div style="margin-top:8px; padding-top:8px; border-top:1px solid #ffe0b2;">' +
          '<strong>Item Dataset:</strong> ' + (debugPayload.item_dataset_id || '-') +
          ' &nbsp;|&nbsp; <strong>Active Dataset:</strong> ' + (debugPayload.active_dataset_id || '-') + '</div>' +
          '<div><strong>Sheet:</strong> ' + (debugPayload.sheet_name || '-') + ' &nbsp;|&nbsp; <strong>Row:</strong> ' + (debugPayload.row_index >= 0 ? debugPayload.row_index : '-') + '</div>' +
          '<div><strong>Source:</strong> ' + (debugPayload.source_file || '-') + '</div>';
      }
      if (jsonEl) {
        jsonEl.textContent = JSON.stringify(debugPayload, null, 2);
      }
      if (btnContract) {
        btnContract.style.display = debugPayload.contract_id ? 'inline-block' : 'none';
      }
      if (btnSheet) {
        btnSheet.style.display = (debugPayload.sheet_name && debugPayload.row_index >= 0) ? 'inline-block' : 'none';
      }

      modal.style.display = 'flex';

      if (typeof AuditTimeline !== 'undefined' && AuditTimeline.emit) {
        AuditTimeline.emit('triage_record_unresolved', {
          active_dataset_id: debugPayload.active_dataset_id,
          item_dataset_id: debugPayload.item_dataset_id,
          item_id: debugPayload.item_id,
          metadata: { reason: debugPayload.reason }
        });
      }
    }

    function closeUnresolvedModal() {
      var modal = document.getElementById('p08-unresolved-modal');
      if (modal) modal.style.display = 'none';
      _p08UnresolvedPayload = null;
    }

    function p08ActionOpenContract() {
      if (!_p08UnresolvedPayload || !_p08UnresolvedPayload.contract_id) return;
      _activeContractFilter = _p08UnresolvedPayload.contract_id;
      closeUnresolvedModal();
      navigateTo('grid');
      setTimeout(function() { if (typeof renderGrid === 'function') renderGrid(); }, 100);
    }

    function p08ActionOpenSheet() {
      if (!_p08UnresolvedPayload) return;
      var sn = _p08UnresolvedPayload.sheet_name;
      var ri = _p08UnresolvedPayload.row_index;
      if (sn && ri >= 0) {
        closeUnresolvedModal();
        openRowReviewDrawer(sn, ri);
      }
    }

    function p08CopyDebugJSON() {
      if (!_p08UnresolvedPayload) return;
      var text = JSON.stringify(_p08UnresolvedPayload, null, 2);
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(function() {
          showToast('Debug JSON copied to clipboard', 'success');
        });
      } else {
        window.prompt('Copy this debug JSON:', text);
      }
    }

    function p08PurgeStaleTriageItems(newDatasetId) {
      if (!newDatasetId) return;
      var purgedCount = 0;

      var allPRs = PATCH_REQUEST_STORE.list();
      for (var i = 0; i < allPRs.length; i++) {
        var pr = allPRs[i];
        var prDataset = pr.dataset_id || '';
        if (prDataset && prDataset !== newDatasetId && !pr.cross_dataset) {
          localStorage.removeItem(PATCH_REQUEST_STORE._key(pr.request_id));
          purgedCount++;
        }
      }

      if (purgedCount > 0) {
        console.log('[P0.8-LINK] dataset_mismatch_purged: count=' + purgedCount + ', new_dataset=' + newDatasetId);
        if (typeof AuditTimeline !== 'undefined' && AuditTimeline.emit) {
          AuditTimeline.emit('dataset_mismatch_purged', {
            metadata: { purged_count: purgedCount, new_dataset_id: newDatasetId }
          });
        }
      }
    }


    // v1.6.0: Open SRR at specific field from signal triage item
    function openSignalTriageItem(recordId, fieldKey) {
      console.log('[AnalystTriage] Opening signal item:', recordId, fieldKey);
      var item = {
        record_id: recordId,
        field_key: fieldKey,
        source: 'signal',
        dataset_id: (typeof IDENTITY_CONTEXT !== 'undefined' ? IDENTITY_CONTEXT.dataset_id : '') || ''
      };
      executeTriageResolution(item);
    }
    
    // v1.6.0: Focus a specific field in the Field Inspector
    function focusFieldInInspector(fieldKey) {
      // Find the field card by looking for the field key in card attributes (uses data-field attribute)
      var card = document.querySelector('.srr-field-card[data-field="' + fieldKey + '"]');
      
      // Try normalized lookup if exact match not found
      if (!card) {
        var fieldCards = document.querySelectorAll('.srr-field-card');
        for (var i = 0; i < fieldCards.length; i++) {
          var cardFieldKey = fieldCards[i].getAttribute('data-field');
          if (cardFieldKey && normalizeFieldKey(cardFieldKey) === normalizeFieldKey(fieldKey)) {
            card = fieldCards[i];
            break;
          }
        }
      }
      
      if (card) {
        // Scroll into view
        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Add highlight effect
        card.style.boxShadow = '0 0 0 3px #1565c0';
        setTimeout(function() {
          card.style.boxShadow = '';
        }, 2000);
        // Click to select
        card.click();
        console.log('[FieldInspector] Focused field:', fieldKey);
      } else {
        console.warn('[FieldInspector] Field not found:', fieldKey);
      }
    }
    
    function openPreflightItem(requestId, recordId, contractId, fieldName) {
      console.log('[TRIAGE-CANONICAL][P1X] route_decision: request_id=' + requestId + ', contract=' + (contractId || 'none'));
      console.log('[P1D-PREFLIGHT] view_routed: contract=' + contractId + ' record=' + recordId + ' field=' + fieldName);
      console.log('[TRIAGE-ANALYTICS][P0.2] route_decision_start: requestId=' + requestId + ', recordId=' + recordId + ', contractId=' + contractId);
      var item = {
        request_id: requestId,
        record_id: (recordId && recordId !== 'undefined') ? recordId : '',
        contract_id: (contractId && contractId !== 'undefined') ? contractId : '',
        field_name: (fieldName && fieldName !== 'undefined') ? fieldName : '',
        source: 'preflight',
        dataset_id: (typeof IDENTITY_CONTEXT !== 'undefined' ? IDENTITY_CONTEXT.dataset_id : '') || ''
      };
      executeTriageResolution(item);
    }

    var _p1aActiveSheet = 'All';
    var _p1aActiveIssueType = 'All';
    var _p1aActiveSeverity = 'All';

    var _ISSUE_TYPE_LABELS = {
      'MISSING_REQUIRED': 'Missing Required',
      'PICKLIST_INVALID': 'Invalid Picklist',
      'OCR_UNREADABLE': 'OCR Unreadable',
      'OCR_MOJIBAKE': 'Mojibake',
      'TEXT_NOT_SEARCHABLE': 'Non-Searchable PDF',
      'UNKNOWN_COLUMN': 'Unknown Column',
      'PDF_VERIFIED_CLEAN': 'PDF Clean',
      'LOW_CONFIDENCE': 'Low Confidence',
      'HEADER_ECHO': 'Header Echo',
      'MANUAL_REVIEW': 'Manual Review',
      'QA_FLAG': 'QA Flag'
    };

    var _ISSUE_TYPE_COLORS = {
      'MISSING_REQUIRED': { border: '#c62828', bg: '#ffebee', text: '#c62828' },
      'PICKLIST_INVALID': { border: '#e65100', bg: '#fff3e0', text: '#e65100' },
      'OCR_UNREADABLE': { border: '#b71c1c', bg: '#fce4ec', text: '#b71c1c' },
      'OCR_MOJIBAKE': { border: '#880e4f', bg: '#fce4ec', text: '#880e4f' },
      'TEXT_NOT_SEARCHABLE': { border: '#4a148c', bg: '#f3e5f5', text: '#4a148c' },
      'UNKNOWN_COLUMN': { border: '#1565c0', bg: '#e3f2fd', text: '#1565c0' },
      'PDF_VERIFIED_CLEAN': { border: '#2e7d32', bg: '#e8f5e9', text: '#2e7d32' }
    };

    function _p1aCountContracts(items) {
      var seen = {};
      for (var i = 0; i < items.length; i++) {
        var ck = items[i]._contract_group_id || items[i].contract_key || items[i].contract_id || items[i].record_id || ('_item_' + i);
        if (ck && ck !== '_batch_level') seen[ck] = true;
      }
      return Object.keys(seen).length;
    }

    function _p1aCountContractsByKey(items, keyFn) {
      var groups = {};
      for (var i = 0; i < items.length; i++) {
        var gk = keyFn(items[i]);
        if (!groups[gk]) groups[gk] = {};
        var ck = items[i]._contract_group_id || items[i].contract_key || items[i].contract_id || items[i].record_id || ('_item_' + i);
        if (ck && ck !== '_batch_level') groups[gk][ck] = true;
      }
      var result = {};
      var keys = Object.keys(groups);
      for (var j = 0; j < keys.length; j++) {
        result[keys[j]] = Object.keys(groups[keys[j]]).length;
      }
      return result;
    }

    function _p1aBuildIssueFilters(items) {
      var container = document.getElementById('p1a-preflight-issue-filters');
      if (!container) return;
      var typeContractMap = {};
      var sevContractMap = { blocker: {}, warning: {} };
      for (var i = 0; i < items.length; i++) {
        var rc = items[i].reason_code || items[i].blocker_type || items[i].signal_type || 'OTHER';
        if (!typeContractMap[rc]) typeContractMap[rc] = {};
        var _ck = items[i]._contract_group_id || items[i].contract_key || items[i].contract_id || items[i].record_id || ('_item_' + i);
        if (_ck && _ck !== '_batch_level') {
          typeContractMap[rc][_ck] = true;
          var sev = (items[i].severity || '').toLowerCase();
          if (sev === 'blocker') sevContractMap.blocker[_ck] = true;
          else sevContractMap.warning[_ck] = true;
        }
      }
      var typeCounts = {};
      var _tcKeys = Object.keys(typeContractMap);
      for (var _tci = 0; _tci < _tcKeys.length; _tci++) {
        typeCounts[_tcKeys[_tci]] = Object.keys(typeContractMap[_tcKeys[_tci]]).length;
      }
      var sevCounts = { blocker: Object.keys(sevContractMap.blocker).length, warning: Object.keys(sevContractMap.warning).length };
      var typeKeys = Object.keys(typeCounts).sort(function(a, b) { return typeCounts[b] - typeCounts[a]; });

      var activeIssueLabel = _p1aActiveIssueType === 'All' ? 'All Issues' : (_ISSUE_TYPE_LABELS[_p1aActiveIssueType] || _p1aActiveIssueType.replace(/_/g, ' '));
      var issueColors = _p1aActiveIssueType !== 'All' && _ISSUE_TYPE_COLORS[_p1aActiveIssueType] ? _ISSUE_TYPE_COLORS[_p1aActiveIssueType] : { border: '#999', bg: '#f5f5f5', text: '#555' };
      if (_p1aActiveIssueType !== 'All') {
        activeIssueLabel += ' (' + (typeCounts[_p1aActiveIssueType] || 0) + ')';
      }

      var activeSevLabel = _p1aActiveSeverity === 'All' ? 'All Severity' : (_p1aActiveSeverity === 'blocker' ? 'Blockers (' + sevCounts.blocker + ')' : 'Warnings (' + sevCounts.warning + ')');
      var sevColors = _p1aActiveSeverity === 'blocker' ? { border: '#c62828', bg: '#ffebee', text: '#c62828' } : (_p1aActiveSeverity === 'warning' ? { border: '#e65100', bg: '#fff3e0', text: '#e65100' } : { border: '#999', bg: '#f5f5f5', text: '#555' });

      var dropStyle = 'position:relative;display:inline-block;';
      var chipBase = 'padding:4px 10px;border-radius:14px;cursor:pointer;font-size:0.82em;display:inline-flex;align-items:center;gap:3px;user-select:none;';
      var menuBase = 'position:absolute;top:100%;left:0;margin-top:4px;background:#fff;border:1px solid #ddd;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:1000;min-width:180px;padding:4px 0;max-height:280px;overflow-y:auto;';
      var menuItem = 'padding:6px 12px;cursor:pointer;font-size:0.88em;display:flex;justify-content:space-between;align-items:center;';
      var arrow = ' <span style="font-size:0.7em;margin-left:2px;">\u25BC</span>';

      var html = '';
      html += '<div style="' + dropStyle + '" id="p1a-issue-dropdown">';
      html += '<div onclick="_p1aToggleDropdown(\x27issue\x27)" style="' + chipBase + 'border:1px solid ' + issueColors.border + ';background:' + issueColors.bg + ';color:' + issueColors.text + ';font-weight:500;">' + escapeHtml(activeIssueLabel) + arrow + '</div>';
      html += '<div id="p1a-issue-menu" style="' + menuBase + 'display:none;">';
      var allIssueActive = _p1aActiveIssueType === 'All';
      html += '<div onclick="_p1aSelectIssueType(\x27All\x27)" style="' + menuItem + (allIssueActive ? 'background:#e3f2fd;font-weight:600;color:#1565c0;' : '') + '" onmouseover="this.style.background=\x27#f0f0f0\x27" onmouseout="this.style.background=\x27' + (allIssueActive ? '#e3f2fd' : '') + '\x27"><span>All Issues</span><span style=\"color:#999;font-size:0.9em;\">' + items.length + '</span></div>';
      for (var t = 0; t < typeKeys.length; t++) {
        var tk = typeKeys[t];
        var tLabel = _ISSUE_TYPE_LABELS[tk] || tk.replace(/_/g, ' ');
        var tActive = _p1aActiveIssueType === tk;
        var tColor = _ISSUE_TYPE_COLORS[tk] || { text: '#555' };
        html += '<div onclick="_p1aSelectIssueType(\x27' + tk.replace(/'/g, "\\'") + '\x27)" style="' + menuItem + (tActive ? 'background:' + (tColor.bg || '#e3f2fd') + ';font-weight:600;color:' + tColor.text + ';' : '') + '" onmouseover="this.style.background=\x27#f0f0f0\x27" onmouseout="if(!this._a)this.style.background=\x27' + (tActive ? (tColor.bg || '#e3f2fd') : '') + '\x27"><span style="color:' + tColor.text + ';">\u25CF ' + escapeHtml(tLabel) + '</span><span style=\"color:#999;font-size:0.9em;\">' + typeCounts[tk] + '</span></div>';
      }
      html += '</div></div>';

      html += '<div style="' + dropStyle + '" id="p1a-sev-dropdown">';
      html += '<div onclick="_p1aToggleDropdown(\x27sev\x27)" style="' + chipBase + 'border:1px solid ' + sevColors.border + ';background:' + sevColors.bg + ';color:' + sevColors.text + ';font-weight:500;">' + escapeHtml(activeSevLabel) + arrow + '</div>';
      html += '<div id="p1a-sev-menu" style="' + menuBase + 'display:none;">';
      var sevAllActive = _p1aActiveSeverity === 'All';
      html += '<div onclick="_p1aSelectSeverity(\x27All\x27)" style="' + menuItem + (sevAllActive ? 'background:#e3f2fd;font-weight:600;color:#1565c0;' : '') + '" onmouseover="this.style.background=\x27#f0f0f0\x27" onmouseout="this.style.background=\x27' + (sevAllActive ? '#e3f2fd' : '') + '\x27"><span>All Severity</span></div>';
      if (sevCounts.blocker > 0) {
        var bAct = _p1aActiveSeverity === 'blocker';
        html += '<div onclick="_p1aSelectSeverity(\x27blocker\x27)" style="' + menuItem + (bAct ? 'background:#ffebee;font-weight:600;color:#c62828;' : '') + '" onmouseover="this.style.background=\x27#f0f0f0\x27" onmouseout="this.style.background=\x27' + (bAct ? '#ffebee' : '') + '\x27"><span style=\"color:#c62828;\">\u25CF Blockers</span><span style=\"color:#999;font-size:0.9em;\">' + sevCounts.blocker + '</span></div>';
      }
      if (sevCounts.warning > 0) {
        var wAct = _p1aActiveSeverity === 'warning';
        html += '<div onclick="_p1aSelectSeverity(\x27warning\x27)" style="' + menuItem + (wAct ? 'background:#fff3e0;font-weight:600;color:#e65100;' : '') + '" onmouseover="this.style.background=\x27#f0f0f0\x27" onmouseout="this.style.background=\x27' + (wAct ? '#fff3e0' : '') + '\x27"><span style=\"color:#e65100;\">\u25CF Warnings</span><span style=\"color:#999;font-size:0.9em;\">' + sevCounts.warning + '</span></div>';
      }
      html += '</div></div>';

      container.innerHTML = html;
    }

    function _p1aFilterByIssueAndSeverity(items) {
      var filtered = items;
      if (_p1aActiveIssueType !== 'All') {
        var result = [];
        for (var i = 0; i < filtered.length; i++) {
          var rc = filtered[i].reason_code || filtered[i].blocker_type || filtered[i].signal_type || 'OTHER';
          if (rc === _p1aActiveIssueType) result.push(filtered[i]);
        }
        filtered = result;
      }
      if (_p1aActiveSeverity !== 'All') {
        var result2 = [];
        for (var j = 0; j < filtered.length; j++) {
          if ((filtered[j].severity || '').toLowerCase() === _p1aActiveSeverity) result2.push(filtered[j]);
        }
        filtered = result2;
      }
      return filtered;
    }

    function _p1aSelectIssueType(issueType) {
      _p1aActiveIssueType = issueType;
      _p1aCloseDropdowns();
      console.log('[P1A] preflight_issue_filter: type=' + issueType);
      renderAnalystTriage();
    }

    function _p1aSelectSeverity(severity) {
      _p1aActiveSeverity = severity;
      _p1aCloseDropdowns();
      console.log('[P1A] preflight_severity_filter: severity=' + severity);
      renderAnalystTriage();
    }

    function _p1aToggleDropdown(which) {
      var issueMenu = document.getElementById('p1a-issue-menu');
      var sevMenu = document.getElementById('p1a-sev-menu');
      if (which === 'issue') {
        if (sevMenu) sevMenu.style.display = 'none';
        if (issueMenu) issueMenu.style.display = issueMenu.style.display === 'none' ? 'block' : 'none';
      } else {
        if (issueMenu) issueMenu.style.display = 'none';
        if (sevMenu) sevMenu.style.display = sevMenu.style.display === 'none' ? 'block' : 'none';
      }
    }

    function _p1aCloseDropdowns() {
      var im = document.getElementById('p1a-issue-menu');
      var sm = document.getElementById('p1a-sev-menu');
      if (im) im.style.display = 'none';
      if (sm) sm.style.display = 'none';
    }

    document.addEventListener('click', function(e) {
      var id = document.getElementById('p1a-issue-dropdown');
      var sd = document.getElementById('p1a-sev-dropdown');
      if (id && !id.contains(e.target) && sd && !sd.contains(e.target)) {
        _p1aCloseDropdowns();
      }
    });

    function _p1aBuildSheetTabs(items) {
      var container = document.getElementById('p1a-preflight-sheet-tabs');
      if (!container) return;
      var totalCount = _p1aCountContracts(items);
      var sheetContractMap = {};
      if (typeof rulesBundleCache !== 'undefined' && rulesBundleCache.fieldMeta && rulesBundleCache.fieldMeta.meta && rulesBundleCache.fieldMeta.meta.sheet_mapping) {
        var glossarySheets = Object.keys(rulesBundleCache.fieldMeta.meta.sheet_mapping);
        for (var gi = 0; gi < glossarySheets.length; gi++) {
          var _csResult = canonicalContractSection(glossarySheets[gi]);
          sheetContractMap[_csResult.contract_section_label] = {};
        }
      }
      for (var i = 0; i < items.length; i++) {
        var sn = items[i].contract_section_label || items[i].sheet_name || 'Unknown';
        if (!sheetContractMap[sn]) sheetContractMap[sn] = {};
        var _ck = items[i]._contract_group_id || items[i].contract_key || items[i].contract_id || items[i].record_id || ('_item_' + i);
        if (_ck && _ck !== '_batch_level') sheetContractMap[sn][_ck] = true;
      }
      var sheetCounts = {};
      var _smKeys = Object.keys(sheetContractMap);
      for (var _smi = 0; _smi < _smKeys.length; _smi++) {
        sheetCounts[_smKeys[_smi]] = Object.keys(sheetContractMap[_smKeys[_smi]]).length;
      }
      var sheets = Object.keys(sheetCounts).sort();
      var _q = String.fromCharCode(39);
      var _makeTab = function(name, count, isActive, isBold) {
        return '<button class="p1a-sheet-tab' + (isActive ? ' active' : '') + '" onclick="_p1aSelectSheet(' + _q + name.replace(/'/g, '\\' + _q) + _q + ')" style="padding: 4px 10px; border: 1px solid ' + (isActive ? '#1565c0' : '#ccc') + '; background: ' + (isActive ? '#e3f2fd' : '#f5f5f5') + '; color: ' + (isActive ? '#1565c0' : '#666') + '; border-radius: 14px; cursor: pointer; font-weight: ' + (isBold ? '600' : '500') + '; font-size: 0.9em;">' + name + ' <span style="font-weight: 400;">(' + count + ')</span></button>';
      };
      var tabsHtml = _makeTab('All', totalCount, _p1aActiveSheet === 'All', true);
      for (var s = 0; s < sheets.length; s++) {
        tabsHtml += _makeTab(sheets[s], sheetCounts[sheets[s]], _p1aActiveSheet === sheets[s], false);
      }
      container.innerHTML = tabsHtml;
      console.log('[P1A] preflight_sheet_tabs_built: total=' + totalCount + ', sheets=' + sheets.length + ', active=' + _p1aActiveSheet);
    }

    function _p1aFilterBySheet(items) {
      if (_p1aActiveSheet === 'All') return items;
      var filtered = [];
      for (var i = 0; i < items.length; i++) {
        var sn = items[i].contract_section_label || items[i].sheet_name || 'Unknown';
        if (sn === _p1aActiveSheet) filtered.push(items[i]);
      }
      return filtered;
    }

    function _p1aSelectSheet(sheetName) {
      _p1aActiveSheet = sheetName;
      console.log('[P1A] preflight_sheet_filter: sheet=' + sheetName); console.log('[P1D-PREFLIGHT] sheet_filter_applied: ' + sheetName);
      renderAnalystTriage();
    }

    function renderAnalystTriage() {
      // Reload from store
      loadAnalystTriageFromStore();

      // P1F.2: Re-merge clean items to System Pass after store reload
      if (typeof _p1f2MergeCleanToSystemPass === 'function') _p1f2MergeCleanToSystemPass();
      // P1E-FOLLOWUP: Check session diff on triage render
      if (typeof _p1fCheckSessionDiff === 'function' && !_p1fCheckSessionDiff._ran) { _p1fCheckSessionDiff._ran = true; _p1fCheckSessionDiff(); }
      // V2.3: Refresh and render analytics header
      if (typeof TriageAnalytics !== 'undefined') {
        try { TriageAnalytics.refresh(); } catch(e) { console.warn('[V2.3] Analytics refresh error:', e); }
      }
      if (typeof _buildMissingValuePreflightItems === 'function') _buildMissingValuePreflightItems();
      if (typeof _mergeMissingValuePreflightItems === 'function') _mergeMissingValuePreflightItems();
      if (typeof TriageAnalytics !== 'undefined') {
        try { TriageAnalytics.renderHeader(); } catch(e) { console.warn('[V2.3] Analytics render error:', e); }
      }

      
      // Update queue counts
      var _p1aFilteredItems = _p1aFilterBySheet(analystTriageState.manualItems);
      var manualCount = _p1aCountContracts(analystTriageState.manualItems);
      var sflogicCount = analystTriageState.sflogicItems.length;
      var patchCount = analystTriageState.patchItems.length;
      var systemCount = analystTriageState.systemItems.length;
      
      var manualCountEl = document.getElementById('manual-queue-count');
      var sflogicCountEl = document.getElementById('sflogic-queue-count');
      var patchCountEl = document.getElementById('patch-queue-count');
      var systemCountEl = document.getElementById('system-queue-count');
      
      if (manualCountEl) manualCountEl.textContent = '(' + manualCount + ')';
      if (sflogicCountEl) sflogicCountEl.textContent = '(' + sflogicCount + ')';
      if (patchCountEl) patchCountEl.textContent = '(' + patchCount + ')';
      if (systemCountEl) systemCountEl.textContent = '(' + systemCount + ')';
      
      // Render each queue table — enrich Pre-Flight items with glossary terms
      _pfTermCache = null;
      for (var _ei = 0; _ei < analystTriageState.manualItems.length; _ei++) {
        enrichPreflightItem(analystTriageState.manualItems[_ei]);
      }
      _logPfTermStats('renderAnalystTriage');
      _p1aBuildIssueFilters(analystTriageState.manualItems);
      var _p1aIssueFiltered = _p1aFilterByIssueAndSeverity(analystTriageState.manualItems);
      _p1aBuildSheetTabs(_p1aIssueFiltered);
      var _p1aFiltered = _p1aFilterBySheet(_p1aIssueFiltered);
      _p1dRenderGrouped(_p1aFiltered, 'p1d-preflight-container');
      renderTriageQueueTable(analystTriageState.sflogicItems, 'sflogic-queue-list', 'No system pass items');
      renderTriageQueueTable(analystTriageState.patchItems, 'patch-queue-list', 'No patch requests yet');
      renderTriageQueueTable(analystTriageState.systemItems, 'system-queue-list', 'No system changes');
      // P1: Debounced telemetry refresh
      if (typeof TriageTelemetry !== 'undefined') {
        TriageTelemetry.debouncedRefresh();
      }
    }
    
    function openAnalystTriageItem(requestId) {
      console.log('[AnalystTriage] Opening item:', requestId);
      var pr = PATCH_REQUEST_STORE.get(requestId);
      if (!pr) {
        console.error('[AnalystTriage] PatchRequest not found:', requestId);
        showToast('Could not find patch request', 'error');
        return;
      }
      var item = {
        request_id: requestId,
        record_id: pr.record_id || (pr.payload && pr.payload.record_id) || '',
        contract_id: pr.contract_id || ((pr.payload && pr.payload.contract_id) || '') || pr.contract_key || '',
        contract_key: pr.contract_key || '',
        field_name: pr.field_name || ((pr.payload && pr.payload.changes) ? Object.keys(pr.payload.changes)[0] : ''),
        dataset_id: pr.dataset_id || (typeof IDENTITY_CONTEXT !== 'undefined' ? IDENTITY_CONTEXT.dataset_id : '') || '',
        source: 'patch_request',
        type: pr.type || 'correction'
      };
      executeTriageResolution(item);

      if (pr.status === 'Needs_Clarification' && pr.clarification_notes) {
        setTimeout(function() {
          showToast('Verifier requested clarification: ' + pr.clarification_notes.substring(0, 100), 'warning');
        }, 500);
      }
    }
    
    function renderVerifierTriage() {
      const container = document.getElementById('verifier-queue-list');
      if (!container) return;

      const queue = verifierQueueState.activeQueue;
      
      // Update patch type counts first
      updatePatchTypeCounts();
      
      // v1.5.3: Apply division + status + patchType filters
      var filtered = verifierQueueState.payloads.filter(function(p) {
        // Filter by queue tab first
        if (p.status !== queue) return false;
        
        // Apply division filter (handles Unassigned)
        if (!matchesDivisionFilter(p)) return false;
        
        // Apply patch type filter
        if (verifierFilterState.patchType && p.type !== verifierFilterState.patchType) return false;
        
        return true;
      });
      
      // If status dropdown is set (overrides tab), apply that instead
      if (verifierFilterState.status) {
        filtered = verifierQueueState.payloads.filter(function(p) {
          if (p.status !== verifierFilterState.status) return false;
          if (!matchesDivisionFilter(p)) return false;
          if (verifierFilterState.patchType && p.type !== verifierFilterState.patchType) return false;
          return true;
        });
      }

      // Update counts (unfiltered by division for tab badges)
      const counts = { pending: 0, needs_clarification: 0, sent_to_admin: 0, resolved: 0 };
      verifierQueueState.payloads.forEach(p => counts[p.status] = (counts[p.status] || 0) + 1);
      
      document.getElementById('v-count-pending').textContent = `(${counts.pending})`;
      document.getElementById('v-count-clarification').textContent = `(${counts.needs_clarification})`;
      document.getElementById('v-count-admin').textContent = `(${counts.sent_to_admin})`;
      document.getElementById('v-count-resolved').textContent = `(${counts.resolved})`;
      
      // Update filter count indicator (show queue-scoped count)
      var filterCountEl = document.getElementById('verifier-filter-count');
      if (filterCountEl) {
        var queueCount = verifierQueueState.payloads.filter(function(p) { return p.status === queue; }).length;
        if (verifierFilterState.division || verifierFilterState.status || verifierFilterState.patchType) {
          filterCountEl.textContent = filtered.length + ' of ' + queueCount + ' items (filtered)';
        } else {
          filterCountEl.textContent = queueCount + ' items';
        }
      }

      if (filtered.length === 0) {
        var msg = 'No verifier items match the selected filters.';
        if (!verifierFilterState.division && !verifierFilterState.status && !verifierFilterState.patchType) {
          msg = 'No payloads in this queue';
        }
        container.innerHTML = '<tr><td colspan="7" style="padding: 40px; text-align: center; color: #999;">' + msg + '</td></tr>';
        return;
      }

      container.innerHTML = filtered.map(p => {
        const typeLabel = p.type.toUpperCase();
        const typeColor = p.type === 'rfi' ? '#ff9800' : (p.type === 'blacklist' ? '#d32f2f' : '#1565c0');
        const time = new Date(p.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        let actions = '';
        
        // RFI rows: view-only actions (no Approve in table)
        if (p.type === 'rfi') {
          actions = `
            <button onclick="event.stopPropagation(); openVerifierReviewDetail('${p.id}')" style="background:#1565c0; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Open Review</button>
            <button onclick="event.stopPropagation(); openRecordFromPayload('${p.id}')" style="background:#f5f5f5; color:#333; border:1px solid #ddd; padding:4px 8px; border-radius:4px; cursor:pointer;">Open Record</button>
          `;
        } else {
          // Correction/Blacklist: keep existing status-based actions
          if (p.status === 'pending') {
            actions = `
              <button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'sent_to_admin')" style="background:#2e7d32; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Approve</button>
              <button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'needs_clarification')" style="background:#f57c00; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">RFI</button>
            `;
          } else if (p.status === 'needs_clarification') {
            actions = `<button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'pending')" style="background:#1565c0; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Re-check</button>`;
          } else if (p.status === 'sent_to_admin') {
            actions = `<button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'resolved')" style="background:#7b1fa2; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Finalize</button>`;
          }
        }

        return `
          <tr style="border-bottom: 1px solid #eee; cursor: pointer;" onclick="openRecordFromPayload('${p.id}')" onmouseover="this.style.background='#f5f8ff'" onmouseout="this.style.background='transparent'">
            <td style="padding:12px;"><span style="background:${typeColor}; color:white; padding:2px 6px; border-radius:10px; font-size:0.8em;">${typeLabel}</span></td>
            <td style="padding:12px; font-weight:600;">${p.record_id}</td>
            <td style="padding:12px; font-family:monospace;">${p.field}</td>
            <td style="padding:12px;">${p.new_value || p.old_value || '(none)'}</td>
            <td style="padding:12px; color:#666; max-width:200px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="${p.comment}">${p.comment}</td>
            <td style="padding:12px; color:#888;">${time}</td>
            <td style="padding:12px; display:flex; gap:6px;">${actions}</td>
          </tr>
        `;
      }).join('');
    }

    function updatePayloadStatus(payloadId, newStatus) {
      const payload = verifierQueueState.payloads.find(p => p.id === payloadId);
      if (payload) {
        payload.status = newStatus;
        saveVerifierQueue();
        
        // v1.5.1: Also update artifact store and log event
        var artifact = getArtifact(payloadId);
        if (artifact) {
          updateArtifact(payloadId, { status: newStatus });
          // Log appropriate event based on status change
          var eventType = null;
          if (newStatus === 'sent_to_admin') {
            eventType = 'VERIFIER_APPROVED';
          } else if (newStatus === 'needs_clarification') {
            eventType = 'VERIFIER_CLARIFICATION_REQUESTED';
          } else if (newStatus === 'rejected') {
            eventType = 'VERIFIER_REJECTED';
          } else if (newStatus === 'resolved') {
            eventType = 'ADMIN_APPROVED';
          }
          if (eventType) {
            logArtifactEvent(eventType, {
              artifact_id: payloadId,
              artifact_type: artifact.artifact_type,
              record_id: artifact.record_id,
              field_key: artifact.field_key,
              new_status: newStatus
            });
          }
        }
        
        renderVerifierTriage();
        
        // Show appropriate toast
        var toastMsg = newStatus === 'sent_to_admin' ? 'Approved — sent to Admin queue' : 
                       newStatus === 'needs_clarification' ? 'Clarification requested' :
                       newStatus === 'rejected' ? 'Rejected' :
                       newStatus === 'resolved' ? 'Finalized' :
                       newStatus.replace(/_/g, ' ');
        showToast(toastMsg, newStatus === 'rejected' ? 'warning' : 'success');
      }
    }
    
    function openRecordFromPayload(payloadId) {
      // v1.5.3: Open record in Verifier SRR mode with PatchRequest-first loading
      
      // Step 1: Get artifact and payload first to find patch_request_id
      var artifact = getArtifact(payloadId);
      var payload = verifierQueueState.payloads.find(function(p) { return p.id === payloadId; });
      
      // Step 2: Determine patch_request_id - could be payloadId itself or a linked field
      var patchRequestId = payloadId;
      if (payload && payload.patch_request_id) {
        patchRequestId = payload.patch_request_id;
      } else if (artifact && artifact.patch_request_id) {
        patchRequestId = artifact.patch_request_id;
      }
      
      // Step 3: Load PatchRequest from CANONICAL PATCH_REQUEST_STORE
      var patchRequest = null;
      
      // Try direct lookup first using resolved patchRequestId
      patchRequest = PATCH_REQUEST_STORE.get(patchRequestId);
      
      // If not found by patchRequestId, try payloadId as fallback
      if (!patchRequest && payloadId !== patchRequestId) {
        patchRequest = PATCH_REQUEST_STORE.get(payloadId);
      }
      
      // If still not found, try scanning all PRs for matching IDs (fallback for legacy data)
      if (!patchRequest) {
        var allPRs = PATCH_REQUEST_STORE.list();
        patchRequest = allPRs.find(function(pr) {
          return pr.request_id === patchRequestId || 
                 pr.id === patchRequestId ||
                 pr.request_id === payloadId || 
                 pr.id === payloadId;
        });
        if (patchRequest) {
          console.log('[Verifier SRR] Found PatchRequest via scan:', patchRequest.request_id);
        }
      }
      
      // Debug: Log available PR IDs if not found
      if (!patchRequest) {
        var knownPRIds = PATCH_REQUEST_STORE.list().map(function(pr) { return pr.request_id; });
        console.warn('[Verifier SRR] PatchRequest not found. Looking for:', patchRequestId, 
          'Available IDs:', knownPRIds.slice(0, 10).join(', ') + (knownPRIds.length > 10 ? '...' : ''));
      }
      
      // Step 4: Check if PatchRequest was expected but not found (strict mode)
      var patchRequestExpected = patchRequestId !== payloadId || (payload && payload.patch_request_id) || (artifact && artifact.patch_request_id);
      if (patchRequestExpected && !patchRequest) {
        console.warn('[Verifier SRR] PatchRequest expected but not found:', patchRequestId);
        // Continue with artifact/payload fallback but log warning
      }
      
      // Step 5: Resolve record_id - prefer PatchRequest, then artifact, then payload
      var recordId = null;
      var datasetId = null;
      var tenantId = null;
      var fieldKey = null;
      var patchType = null;
      
      if (patchRequest) {
        recordId = patchRequest.record_id;
        datasetId = patchRequest.dataset_id;
        tenantId = patchRequest.tenant_id;
        fieldKey = patchRequest.field_key;
        patchType = patchRequest.patch_kind || patchRequest.patch_type || 'correction';
        console.log('[Verifier SRR] Loaded PatchRequest:', patchRequestId, 'record_id:', recordId);
      }
      
      // Fallback to artifact if no PatchRequest record_id
      if (!recordId && artifact) {
        recordId = artifact.record_id;
        datasetId = datasetId || artifact.dataset_id;
        tenantId = tenantId || artifact.tenant_id;
        fieldKey = fieldKey || artifact.field_key;
        patchType = patchType || artifact.type || 'correction';
      }
      
      // Fallback to payload if still no record_id
      if (!recordId && payload) {
        recordId = payload.record_id;
        datasetId = datasetId || payload.dataset_id;
        tenantId = tenantId || payload.tenant_id;
        fieldKey = fieldKey || payload.field;
        patchType = patchType || payload.type || 'correction';
      }
      
      // Also populate missing identity fields from any available source
      if (!datasetId) datasetId = (artifact && artifact.dataset_id) || (payload && payload.dataset_id);
      if (!tenantId) tenantId = (artifact && artifact.tenant_id) || (payload && payload.tenant_id);
      
      // Step 5: Validate record_id exists
      if (!recordId) {
        showBlockingError('Missing record_id', 
          'Cannot open record: PatchRequest ' + payloadId + ' has no record_id.\n\n' +
          'Key: patch_request_id=' + payloadId);
        console.error('[Verifier SRR] Missing record_id in PatchRequest:', payloadId);
        return;
      }
      
      // Step 7: Validate identity fields are available for store lookup
      var effectiveDatasetId = datasetId || IDENTITY_CONTEXT.dataset_id;
      var effectiveTenantId = tenantId || IDENTITY_CONTEXT.tenant_id;
      
      if (!effectiveTenantId) {
        showBlockingError('Missing tenant_id', 
          'Cannot open record: No tenant context available.\n\n' +
          'record_id=' + recordId + ', patch_request_id=' + payloadId);
        console.error('[Verifier SRR] Missing tenant_id for record lookup:', recordId);
        return;
      }
      
      if (!effectiveDatasetId) {
        showBlockingError('Missing dataset_id', 
          'Cannot open record: No dataset context available.\n\n' +
          'record_id=' + recordId + ', tenant_id=' + effectiveTenantId + ', patch_request_id=' + payloadId);
        console.error('[Verifier SRR] Missing dataset_id for record lookup:', recordId);
        return;
      }
      
      // Step 8: Find record using enhanced lookup with store fallback
      var recordInfo = findRecordById(recordId, effectiveDatasetId, effectiveTenantId);
      
      if (!recordInfo) {
        // v1.5.3 Fix: Enhanced debug info for record not found
        var storeKey = getRecordStorageKey(effectiveTenantId, effectiveDatasetId, recordId);
        var workbookSheets = workbook && workbook.sheets ? Object.keys(workbook.sheets) : [];
        var workbookRowCount = 0;
        workbookSheets.forEach(function(s) {
          if (workbook.sheets[s] && workbook.sheets[s].rows) {
            workbookRowCount += workbook.sheets[s].rows.length;
          }
        });
        
        var debugInfo = [
          'tenant_id: ' + effectiveTenantId,
          'dataset_id: ' + effectiveDatasetId,
          'record_id: ' + recordId,
          'patch_request_id: ' + payloadId,
          '',
          'Store key checked: ' + storeKey,
          'Workbook sheets: ' + workbookSheets.join(', '),
          'Workbook rows: ' + workbookRowCount
        ].join('\n');
        
        showBlockingError('Record not found', 
          'Cannot open record: No matching record in dataset or store.\n\n' + debugInfo);
        console.error('[Verifier SRR] Record not found:', recordId, 
          'dataset:', effectiveDatasetId, 
          'storeKey:', storeKey,
          'workbookSheets:', workbookSheets);
        return;
      }
      
      // Step 9: Set up Verifier SRR state
      srrState.currentSheetName = recordInfo.sheetName;
      srrState.focusFieldKey = fieldKey || null;
      srrState.verifierMode = true;
      srrState.verifierPayload = patchRequest || payload || artifact;
      srrState.verifierPatchType = patchType;
      srrState.verifierPayloadId = payloadId;
      
      // Navigate to SRR
      navigateTo('row/' + recordInfo.rowIndex);
      console.log('[Verifier SRR] Opened record:', recordId, 'patchType:', patchType, 'field:', fieldKey, 'fromStore:', !!recordInfo.fromStore);
    }
    
    function showBlockingError(title, message) {
      // v1.5.3: Show blocking error modal for critical failures
      var existingModal = document.getElementById('blocking-error-modal');
      if (existingModal) existingModal.remove();
      
      var modal = document.createElement('div');
      modal.id = 'blocking-error-modal';
      modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:9999; display:flex; align-items:center; justify-content:center;';
      modal.innerHTML = 
        '<div style="background:white; padding:24px; border-radius:8px; max-width:500px; box-shadow:0 4px 24px rgba(0,0,0,0.3);">' +
          '<h3 style="margin:0 0 12px 0; color:#c62828;">' + escapeHtml(title) + '</h3>' +
          '<pre style="margin:0 0 16px 0; padding:12px; background:#f5f5f5; border-radius:4px; white-space:pre-wrap; font-size:0.85em; max-height:200px; overflow:auto;">' + escapeHtml(message) + '</pre>' +
          '<button onclick="document.getElementById(\'blocking-error-modal\').remove()" style="padding:8px 16px; background:#1976d2; color:white; border:none; border-radius:4px; cursor:pointer;">Close</button>' +
        '</div>';
      document.body.appendChild(modal);
    }
    
    function initVerifierSRRMode() {
      // v1.5.3: Initialize Verifier SRR mode with read-only field inspector and Patch Review/Tester tabs
      if (!srrState.verifierMode) return;
      
      // Set read-only flag to prevent field editing (but allow actions on non-verified fields)
      srrState.isReadOnly = true;
      
      var patchType = srrState.verifierPatchType || 'correction';
      var payload = srrState.verifierPayload;
      
      // v1.5.3 Fix: Populate field states from PatchRequest for multi-issue records
      if (payload) {
        // If payload has a field property, set its state based on patch type
        var fieldKey = payload.field || payload.fieldKey;
        if (fieldKey) {
          if (patchType === 'rfi') {
            srrState.fieldStates[fieldKey] = 'rfi_pending';
          } else if (patchType === 'blacklist') {
            srrState.fieldStates[fieldKey] = 'blocked';
          } else if (patchType === 'correction') {
            srrState.fieldStates[fieldKey] = 'modified';
          }
        }
        
        // If payload has changes array, populate all field states
        if (payload.changes && Array.isArray(payload.changes)) {
          payload.changes.forEach(function(change) {
            var fk = change.field || change.fieldKey;
            if (fk) {
              var cat = (change.category || change.patch_type || 'correction').toLowerCase();
              if (cat === 'rfi') {
                srrState.fieldStates[fk] = 'rfi_pending';
              } else if (cat === 'blacklist flag' || cat === 'blacklist') {
                srrState.fieldStates[fk] = 'blocked';
              } else {
                srrState.fieldStates[fk] = 'modified';
              }
            }
          });
        }
        
        // Also check if payload is a PatchRequest with body.changes
        if (payload.body && payload.body.changes && Array.isArray(payload.body.changes)) {
          payload.body.changes.forEach(function(change) {
            var fk = change.field || change.fieldKey;
            if (fk) {
              var cat = (change.category || change.patch_type || 'correction').toLowerCase();
              if (cat === 'rfi') {
                srrState.fieldStates[fk] = 'rfi_pending';
              } else if (cat === 'blacklist flag' || cat === 'blacklist') {
                srrState.fieldStates[fk] = 'blocked';
              } else {
                srrState.fieldStates[fk] = 'modified';
              }
            }
          });
        }
        
        console.log('[Verifier SRR] Populated field states:', Object.keys(srrState.fieldStates).length, 'fields');
      }
      
      // Update right panel title and tabs
      var panelTitle = document.getElementById('srr-right-panel-title');
      var panelTabs = document.getElementById('srr-panel-tabs');
      
      if (panelTitle) panelTitle.textContent = 'Patch Review';
      
      if (panelTabs) {
        // v1.5.3: Show tabs for all patch types in verifier mode
        panelTabs.style.display = 'flex';
        // Update tab labels for verifier mode
        var tabBtns = panelTabs.querySelectorAll('.srr-panel-tab');
        tabBtns.forEach(function(btn) {
          if (btn.getAttribute('data-tab') === 'editor') {
            btn.textContent = 'Patch Review';
          }
        });
      }
      
      // v1.5.3 Fix: Keep patch type chips visible for navigation in verifier mode
      var patchTypeSelector = document.querySelector('.srr-patch-type-selector');
      if (patchTypeSelector) patchTypeSelector.style.display = '';  // Keep visible
      
      // Update patch type chips to show current type
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === patchType) chip.classList.add('active');
      });
      
      // Populate Patch Review tab with submitted patch data
      populateVerifierPatchReview(payload, patchType);
      
      // Populate Patch Tester if applicable
      if (patchType !== 'rfi' && payload) {
        populateVerifierPatchTester(payload);
      }
      
      // For RFI, show comment thread instead of patch editor
      if (patchType === 'rfi') {
        showRFICommentThread(payload);
      }
      
      // v1.5.3 Fix: Rerender field list with updated states and select first actionable field
      if (srrState.currentRecord) {
        renderSrrFields(srrState.currentRecord);
        
        // Select the first field with a non-final state (actionable)
        var firstActionableField = null;
        var fieldKeys = Object.keys(srrState.fieldStates);
        for (var i = 0; i < fieldKeys.length; i++) {
          var fk = fieldKeys[i];
          var fs = srrState.fieldStates[fk];
          if (fs !== 'verified' && fs !== 'submitted') {
            firstActionableField = fk;
            break;
          }
        }
        
        // If no actionable field found, try the focus field from payload
        if (!firstActionableField && srrState.focusFieldKey) {
          firstActionableField = srrState.focusFieldKey;
        }
        
        // Select and highlight the first actionable field
        if (firstActionableField) {
          srrSelectField(firstActionableField);
        }
      }
      
      console.log('[Verifier SRR] Mode initialized for patch type:', patchType);
    }
    
    function populateVerifierPatchReview(payload, patchType) {
      // v1.5.3: Populate the Patch Review (read-only) view with analyst's submitted patch
      var container = document.getElementById('srr-patch-editor-fields');
      if (!container || !payload) return;
      
      var typeLabel = (patchType || 'correction').toUpperCase();
      var typeColor = patchType === 'rfi' ? '#ff9800' : (patchType === 'blacklist' ? '#d32f2f' : '#1565c0');
      
      var html = '<div style="margin-bottom: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ' + typeColor + ';">';
      html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">';
      html += '<span style="font-weight: 600;">Submitted Patch</span>';
      html += '<span style="background: ' + typeColor + '; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em;">' + typeLabel + '</span>';
      html += '</div>';
      
      // Field being modified
      html += '<div style="margin-bottom: 8px;">';
      html += '<span style="font-size: 0.75em; color: #888;">Field:</span> ';
      html += '<span style="font-family: monospace; font-weight: 500;">' + (payload.field || '—') + '</span>';
      html += '</div>';
      
      // Old value
      if (payload.old_value !== undefined) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<span style="font-size: 0.75em; color: #888;">Current Value:</span> ';
        html += '<span style="color: #888; text-decoration: line-through;">' + (payload.old_value || '(empty)') + '</span>';
        html += '</div>';
      }
      
      // New value (for Correction/Blacklist)
      if (patchType !== 'rfi' && payload.new_value !== undefined) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<span style="font-size: 0.75em; color: #888;">Proposed Value:</span> ';
        html += '<span style="color: #2e7d32; font-weight: 600;">' + (payload.new_value || '(empty)') + '</span>';
        html += '</div>';
      }
      
      // Comment/Justification
      if (payload.comment) {
        html += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px dashed #ddd;">';
        html += '<span style="font-size: 0.75em; color: #888;">Analyst Comment:</span>';
        html += '<div style="margin-top: 4px; font-size: 0.9em; color: #555; font-style: italic;">"' + payload.comment + '"</div>';
        html += '</div>';
      }
      
      html += '</div>';
      
      // Add read-only indicator
      html += '<div style="text-align: center; color: #888; font-size: 0.8em; padding: 12px; background: #f5f5f5; border-radius: 6px;">';
      html += '<span style="margin-right: 6px;">👁</span> Read-only view — Use Patch Tester tab to modify';
      html += '</div>';
      
      container.innerHTML = html;
      
      // Hide change count and action box title for verifier mode
      var changeCount = document.getElementById('srr-change-count');
      var actionBoxTitle = document.getElementById('srr-action-box-title');
      if (changeCount) changeCount.style.display = 'none';
      if (actionBoxTitle) actionBoxTitle.textContent = 'Submitted Patch';
    }
    
    function populateVerifierPatchTester(payload) {
      // v1.5.3: Pre-populate Patch Tester with payload data
      var fieldEl = document.getElementById('srr-tester-field');
      var oldEl = document.getElementById('srr-tester-old-value');
      var proposedEl = document.getElementById('srr-tester-proposed-value');
      var newValueInput = document.getElementById('srr-tester-new-value');
      
      if (fieldEl) fieldEl.textContent = payload.field || '—';
      if (oldEl) oldEl.textContent = payload.old_value || '(empty)';
      if (proposedEl) proposedEl.textContent = payload.new_value || '(empty)';
      if (newValueInput) newValueInput.value = payload.new_value || '';
    }
    
    function showRFICommentThread(payload) {
      _srrExpandPatchPanel();
      // v1.5.3: For RFI type, show comment thread instead of Patch Tester
      // v1.6.9: Enhanced for legacy RFI imports with summary, details, category
      var editorTab = document.getElementById('srr-tab-fields');
      if (!editorTab) return;
      
      // Determine if this is a legacy RFI import
      var isLegacyImport = payload.source === 'legacy_rfi_import';
      
      // Replace editor content with RFI comment thread
      var rfiHtml = '<div style="margin-bottom: 16px; padding: 12px; background: #fff3e0; border-radius: 8px; border-left: 4px solid #ff9800;">';
      rfiHtml += '<div style="font-weight: 600; margin-bottom: 8px; color: #e65100;">Request for Information';
      if (isLegacyImport) {
        rfiHtml += ' <span style="font-size: 0.7em; background: #78909c; color: white; padding: 2px 6px; border-radius: 3px; margin-left: 8px;">Imported</span>';
      }
      rfiHtml += '</div>';
      rfiHtml += '<div style="margin-bottom: 8px;">';
      rfiHtml += '<span style="font-size: 0.75em; color: #888;">Field:</span> ';
      rfiHtml += '<span style="font-family: monospace;">' + escapeHtml(payload.field || payload.field_key || '—') + '</span>';
      rfiHtml += '</div>';
      
      // Show category if available (from legacy import)
      if (payload.category) {
        rfiHtml += '<div style="margin-bottom: 8px;">';
        rfiHtml += '<span style="font-size: 0.75em; color: #888;">Category:</span> ';
        rfiHtml += '<span style="background: #e3f2fd; padding: 2px 6px; border-radius: 4px; font-size: 0.85em;">' + escapeHtml(payload.category) + '</span>';
        rfiHtml += '</div>';
      }
      
      // Show detected by if available
      if (payload.detected_by) {
        rfiHtml += '<div style="margin-bottom: 8px;">';
        rfiHtml += '<span style="font-size: 0.75em; color: #888;">Detected By:</span> ';
        rfiHtml += '<span>' + escapeHtml(payload.detected_by) + '</span>';
        rfiHtml += '</div>';
      }
      
      rfiHtml += '<div style="margin-bottom: 8px;">';
      rfiHtml += '<span style="font-size: 0.75em; color: #888;">Current Value:</span> ';
      rfiHtml += '<span>' + escapeHtml(payload.old_value || '(empty)') + '</span>';
      rfiHtml += '</div>';
      
      // Show summary and details separately if available
      if (payload.summary || payload.details) {
        if (payload.summary) {
          rfiHtml += '<div style="margin-bottom: 8px; font-weight: 500; color: #333;">' + escapeHtml(payload.summary) + '</div>';
        }
        if (payload.details && payload.details !== payload.summary) {
          rfiHtml += '<div style="font-style: italic; color: #666; padding: 8px; background: #fafafa; border-radius: 4px;">' + escapeHtml(payload.details) + '</div>';
        }
      } else {
        rfiHtml += '<div style="font-style: italic; color: #666;">"' + escapeHtml(payload.comment || 'No question provided') + '"</div>';
      }
      
      // Show source URL if available
      if (payload.source_url) {
        rfiHtml += '<div style="margin-top: 8px;">';
        rfiHtml += '<a href="' + escapeHtml(payload.source_url) + '" target="_blank" style="font-size: 0.85em; color: #1565c0;">View Source Document</a>';
        rfiHtml += '</div>';
      }
      
      rfiHtml += '</div>';
      
      // Comment thread section
      rfiHtml += '<div style="font-size: 0.85em; font-weight: 600; margin-bottom: 12px;">Comment Thread</div>';
      rfiHtml += '<div id="srr-rfi-thread" style="background: #f8f9fa; border-radius: 8px; padding: 12px; margin-bottom: 16px; min-height: 100px;">';
      rfiHtml += '<div style="color: #888; font-size: 0.85em; text-align: center; padding: 20px;">No responses yet</div>';
      rfiHtml += '</div>';
      
      // Reply input
      rfiHtml += '<div style="margin-bottom: 16px;">';
      rfiHtml += '<textarea id="srr-rfi-reply" placeholder="Add a response to this RFI..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; resize: vertical;"></textarea>';
      rfiHtml += '</div>';
      
      rfiHtml += '<button class="srr-btn srr-btn-primary" style="width: 100%;" onclick="srrReplyToRFI()">Send Response</button>';
      
      // Update the container
      var container = document.getElementById('srr-patch-editor-fields');
      if (container) {
        container.innerHTML = rfiHtml;
      }
      
      // Hide evidence pack sections for RFI
      ['srr-observation-block', 'srr-expected-block', 'srr-repro-block'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
      // v1.6.57: Show replay contract for RFI but mark as optional
      // P0.9: Analyst sees no replay controls
      var replayBlock = document.getElementById('srr-replay-contract-block');
      var _replayCurrentMode = localStorage.getItem('viewer_mode_v10') || 'analyst';
      var _showReplay = (_replayCurrentMode === 'verifier' || _replayCurrentMode === 'admin');
      if (replayBlock) replayBlock.style.display = _showReplay ? 'block' : 'none';
      ['srr-replay-type-required', 'srr-replay-steps-required', 'srr-replay-expected-required'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.textContent = '(optional)';
      });
      var naOption = document.querySelector('#srr-replay-type option[value="NA"]');
      if (naOption) naOption.disabled = false;
    }
    
    function srrReplyToRFI() {
      var replyInput = document.getElementById('srr-rfi-reply');
      if (!replyInput || !replyInput.value.trim()) {
        showToast('Please enter a response', 'warning');
        return;
      }
      
      showToast('Response sent to analyst', 'success');
      replyInput.value = '';
    }
    
    function resetVerifierSRRMode() {
      // v1.5.3: Reset SRR to analyst mode when leaving verifier context
      srrState.verifierMode = false;
      srrState.verifierPayload = null;
      srrState.verifierPatchType = null;
      srrState.verifierPayloadId = null;
      srrState.isReadOnly = false;  // Restore editing capability
      
      // Restore panel title and tabs
      var panelTitle = document.getElementById('srr-right-panel-title');
      var panelTabs = document.getElementById('srr-panel-tabs');
      
      if (panelTitle) panelTitle.textContent = 'Fields';
      if (panelTabs) {
        panelTabs.style.display = 'none';
        var tabBtns = panelTabs.querySelectorAll('.srr-panel-tab');
        tabBtns.forEach(function(btn) {
          if (btn.getAttribute('data-tab') === 'editor') {
            btn.textContent = 'Editor';
          }
        });
      }
      
      // Restore patch type chips
      var patchTypeSelector = document.querySelector('.srr-patch-type-selector');
      if (patchTypeSelector) patchTypeSelector.style.display = '';
      
      // Restore evidence pack sections
      // v1.6.57: Restore replay contract as required for Correction/Blacklist
      // P0.5: Only show for Verifier/Admin
      var replayBlock = document.getElementById('srr-replay-contract-block');
      var _replayRole = (localStorage.getItem('viewer_mode_v10') || 'analyst').toLowerCase();
      if (replayBlock) replayBlock.style.display = (_replayRole === 'verifier' || _replayRole === 'admin') ? 'block' : 'none';
      ['srr-replay-type-required', 'srr-replay-steps-required', 'srr-replay-expected-required'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.textContent = '(required)';
      });
      var naOption = document.querySelector('#srr-replay-type option[value="NA"]');
      if (naOption) naOption.disabled = true;
      ['srr-observation-block', 'srr-expected-block', 'srr-repro-block'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.style.display = '';
      });
      
      // Restore change count
      var changeCount = document.getElementById('srr-change-count');
      var actionBoxTitle = document.getElementById('srr-action-box-title');
      if (changeCount) changeCount.style.display = '';
      if (actionBoxTitle) actionBoxTitle.textContent = 'Changed Fields';
    }

    // ========== VERIFIER REVIEW STATE + FUNCTIONS (v1.4.5) ==========
    var vrState = {
      currentPatchId: null,
      reviewState: 'Submitted', // Submitted, Under_Review, Needs_Clarification, Verifier_Approved, Rejected
      verifierActor: 'verifier@example.com',
      auditLog: [],
      notes: '',
      fromVerifierTriage: false,  // v1.5.0: Track if navigated from Verifier Triage
      currentPayload: null,       // v1.5.0: Store current payload for actions
      selectedPayloadId: null,    // v1.5.0: Store selected payload ID for navigation
      isAdminReview: false        // v1.5.1: Track if this is admin review context
    };
    
    function navigateBackFromVerifierReview() {
      // Reset header back to Verifier Review defaults
      var headerEl = document.querySelector('#page-verifier-review h2');
      if (headerEl) headerEl.textContent = 'Verifier Review';
      var descEl = document.querySelector('#page-verifier-review .page-desc');
      if (descEl) descEl.textContent = 'Review submitted Patch Requests, request clarification, approve or reject.';
      
      // Reset button handlers
      resetVerifierReviewButtons();
      
      // v1.5.1: Navigate back to appropriate queue
      if (vrState.isAdminReview) {
        vrState.isAdminReview = false;
        vrState.fromVerifierTriage = false;
        navigateTo('admin/patch-queue');
      } else if (vrState.fromVerifierTriage) {
        vrState.fromVerifierTriage = false;
        navigateTo('triage');  // Returns to triage which shows Verifier Triage in verifier mode
      } else {
        navigateTo('triage');
      }
    }
    
    function resetVerifierReviewButtons() {
      var btnBegin = document.getElementById('vr-btn-begin');
      var btnClarify = document.getElementById('vr-btn-clarify');
      var btnApprove = document.getElementById('vr-btn-approve');
      var btnReject = document.getElementById('vr-btn-reject');
      
      if (btnBegin) btnBegin.style.display = '';
      if (btnClarify) btnClarify.style.display = '';
      if (btnApprove) {
        btnApprove.textContent = 'Approve';
        btnApprove.onclick = function() { vrApprove(); };
      }
      if (btnReject) {
        btnReject.onclick = function() { vrReject(); };
      }
    }
    
    // Sample patch data for demo (would come from SRR in real flow)
    var vrSamplePatch = {
      patch_id: 'PATCH-2026-0001',
      author: 'analyst@example.com',
      submitted_at: new Date().toISOString(),
      intent: {
        observation: 'Contract has missing label_vendor field despite being a licensing agreement.',
        expected: 'Label_vendor should be populated when contract_type = LICENSING.',
        justification: 'Licensing agreements require label_vendor for downstream royalty calculations.'
      },
      evidence: {
        observation: 'Row 142 shows contract_type=LICENSING but label_vendor is blank.',
        expected: 'label_vendor = "Sony Music" based on contract header data.',
        justification: 'Header section row 1 references Sony Music as the licensing partner.',
        repro: '1. Load ostereo_demo_v1.json\n2. Navigate to row 142\n3. Observe label_vendor is empty\n4. Cross-reference with contract header'
      },
      preflight: { schema: 'pass', conflicts: 'pass', evidence: 'pass' },
      revisions: []
    };
    
    function loadVerifierReviewData(payloadId) {
      console.log('[VR_LOAD] loadVerifierReviewData called with payloadId:', payloadId);
      
      // v1.5.3 Fix: Handle both PR_ (PatchRequest) and art_ (Artifact) prefixes
      var artifact = null;
      var payload = null;
      var patchRequest = null;
      
      if (payloadId) {
        // v1.5.3: Check for PR_ prefix first - load from PATCH_REQUEST_STORE
        if (payloadId.startsWith('PR_')) {
          patchRequest = PATCH_REQUEST_STORE.get(payloadId);
          if (patchRequest) {
            console.log('[VR_LOAD] Found PatchRequest:', patchRequest.request_id);
            // Convert PatchRequest to payload-like structure for display
            payload = {
              id: patchRequest.request_id,
              type: patchRequest.patch_type || patchRequest.patch_kind || 'correction',
              record_id: patchRequest.record_id,
              dataset_id: patchRequest.dataset_id,
              field: patchRequest.field || patchRequest.target_field,
              old_value: patchRequest.old_value || '',
              new_value: patchRequest.new_value || '',
              comment: patchRequest.because || patchRequest.evidence_justification || '',
              analyst_id: patchRequest.author || patchRequest.created_by,
              timestamp: patchRequest.created_at,
              status: patchRequest.status,
              patch_request: patchRequest  // Keep reference to full PatchRequest
            };
          } else {
            console.log('[VR_LOAD] PatchRequest not found:', payloadId);
          }
        }
        
        // Try artifact store if no PatchRequest or payloadId starts with art_
        if (!payload) {
          artifact = getArtifact(payloadId);
          if (artifact) {
            console.log('[VR_LOAD] Found artifact:', artifact.artifact_id, artifact.artifact_type);
            // Convert artifact to payload-like structure for display
            payload = {
              id: artifact.artifact_id,
              type: artifact.body.patch_type || (artifact.artifact_type === 'rfi' ? 'rfi' : 'correction'),
              record_id: artifact.record_id,
              field: artifact.field_key,
              old_value: artifact.body.old_value || '',
              new_value: artifact.body.new_value || '',
              comment: artifact.body.comment || '',
              analyst_id: artifact.created_by_actor_id,
              timestamp: artifact.created_at,
              status: artifact.status,
              thread_id: artifact.thread_id,
              artifact: artifact  // Keep reference to full artifact
            };
          }
        }
        
        // Fallback to legacy verifier queue
        if (!payload) {
          payload = verifierQueueState.payloads.find(function(p) { return p.id === payloadId; });
          console.log('[VR_LOAD] Found legacy payload:', payload ? 'yes' : 'no');
        }
      }
      
      // Hide all type-specific content blocks
      document.getElementById('vr-rfi-content').style.display = 'none';
      document.getElementById('vr-correction-content').style.display = 'none';
      document.getElementById('vr-blacklist-content').style.display = 'none';
      document.getElementById('vr-legacy-content').style.display = 'none';
      
      var typeBadge = document.getElementById('vr-type-badge');
      
      if (payload) {
        // Update type badge
        if (payload.type === 'rfi') {
          typeBadge.textContent = 'RFI';
          typeBadge.style.background = '#ff9800';
          document.getElementById('vr-rfi-content').style.display = 'block';
          // Populate RFI fields
          document.getElementById('vr-rfi-field').textContent = payload.field || '—';
          document.getElementById('vr-rfi-value').textContent = payload.old_value || '(empty)';
          document.getElementById('vr-rfi-comment').textContent = payload.comment || '—';
        } else if (payload.type === 'blacklist') {
          typeBadge.textContent = 'BLACKLIST';
          typeBadge.style.background = '#d32f2f';
          document.getElementById('vr-blacklist-content').style.display = 'block';
          // Populate Blacklist fields
          document.getElementById('vr-bl-field').textContent = payload.field || '—';
          document.getElementById('vr-bl-value').textContent = payload.old_value || '(empty)';
          document.getElementById('vr-bl-subject').textContent = payload.field + ': ' + (payload.old_value || '(empty)');
          document.getElementById('vr-bl-comment').textContent = payload.comment || '—';
        } else {
          typeBadge.textContent = 'CORRECTION';
          typeBadge.style.background = '#1565c0';
          document.getElementById('vr-correction-content').style.display = 'block';
          // Populate Correction fields
          document.getElementById('vr-corr-field').textContent = payload.field || '—';
          document.getElementById('vr-corr-old').textContent = payload.old_value || '(empty)';
          document.getElementById('vr-corr-new').textContent = payload.new_value || '(no change)';
          document.getElementById('vr-corr-comment').textContent = payload.comment || '—';
        }
        
        document.getElementById('vr-author-name').textContent = payload.analyst_id || 'analyst@example.com';
        document.getElementById('vr-author-time').textContent = new Date(payload.timestamp).toLocaleString();
        document.getElementById('vr-patch-id').textContent = payload.id;
        
        // Map payload status to vrState
        var statusMap = { 'pending': 'Submitted', 'needs_clarification': 'Needs_Clarification', 'sent_to_admin': 'Verifier_Approved', 'resolved': 'Admin_Approved' };
        vrState.currentPatchId = payload.id;
        vrState.reviewState = statusMap[payload.status] || 'Submitted';
        vrState.currentPayload = payload;
      } else {
        // Fallback to sample/legacy data
        typeBadge.textContent = 'CORRECTION';
        typeBadge.style.background = '#1565c0';
        document.getElementById('vr-legacy-content').style.display = 'block';
        
        document.getElementById('vr-intent-when').textContent = vrSamplePatch.intent.observation || '—';
        document.getElementById('vr-intent-then').textContent = vrSamplePatch.intent.expected || '—';
        document.getElementById('vr-intent-because').textContent = vrSamplePatch.intent.justification || '—';
        
        document.getElementById('vr-ev-observation').textContent = vrSamplePatch.evidence.observation || '—';
        document.getElementById('vr-ev-expected').textContent = vrSamplePatch.evidence.expected || '—';
        document.getElementById('vr-ev-justification').textContent = vrSamplePatch.evidence.justification || '—';
        document.getElementById('vr-ev-repro').textContent = vrSamplePatch.evidence.repro || '—';
        
        document.getElementById('vr-author-name').textContent = vrSamplePatch.author;
        document.getElementById('vr-author-time').textContent = vrSamplePatch.submitted_at;
        document.getElementById('vr-patch-id').textContent = vrSamplePatch.patch_id;
        
        vrState.currentPatchId = vrSamplePatch.patch_id;
        vrState.reviewState = 'Submitted';
        vrState.currentPayload = null;
      }
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
    }
    
    function vrOpenSingleRowReview() {
      var payload = vrState.currentPayload;
      
      // v1.5.2: Load PatchRequest by patch_request_id first
      var patchRequest = null;
      var patchRequestId = (payload && payload.patch_request_id) || null;
      
      if (patchRequestId) {
        patchRequest = PATCH_REQUEST_STORE.get(patchRequestId);
        console.log('[VR_SRR] Loaded PatchRequest from store:', patchRequestId, patchRequest ? 'found' : 'NOT FOUND');
        
        if (!patchRequest) {
          // Show blocking error UI with exact storage key
          var storageKey = 'pr:' + ARTIFACT_STORE.environment + ':' + patchRequestId;
          showToast('PatchRequest not found: ' + storageKey, 'error');
          console.error('[VR_SRR] BLOCKING: PatchRequest missing. Key:', storageKey);
          // Update debug panel if visible
          updateDebugPanel({ patchRequest_load: 'FAILED', storageKey: storageKey });
          return;
        }
      }
      
      // v1.5.2: Use record_id from PatchRequest or payload
      var recordId = (patchRequest && patchRequest.record_id) || (payload && payload.record_id) || null;
      var datasetId = (patchRequest && patchRequest.dataset_id) || (payload && payload.dataset_id) || IDENTITY_CONTEXT.dataset_id || 'default';
      
      if (!recordId) {
        showToast('No record_id linked to this review', 'info');
        return;
      }
      
      var foundSheet = null;
      var foundIdx = -1;
      var foundRecord = null;
      
      // Search across all sheets for the record by record_id
      if (workbook && workbook.sheets) {
        Object.keys(workbook.sheets).forEach(function(sheetName) {
          if (foundRecord) return;
          var sheet = workbook.sheets[sheetName];
          var rows = sheet ? sheet.rows : [];
          if (!rows) return;
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            // Match by record_id (primary), _identity.record_id, or fallback to contract_key
            var rowRecordId = row.record_id || (row._identity && row._identity.record_id);
            if (rowRecordId === recordId || row.contract_key === recordId) {
              foundSheet = sheetName;
              foundIdx = i;
              foundRecord = row;
              break;
            }
          }
        });
      }
      
      if (foundRecord) {
        // v1.5.2: Set SRR context with proper binding
        srrState.currentSheetName = foundSheet;
        srrState.currentDatasetId = datasetId;
        srrState.currentRecordId = recordId;
        srrState.currentPatchRequestId = patchRequestId;
        srrState.currentArtifactId = ((payload && payload.artifact) ? payload.artifact.artifact_id : null) || vrState.selectedPayloadId || null;
        srrState.isReadOnly = (currentMode === 'verifier' || currentMode === 'admin');
        srrState.currentPatchRequest = patchRequest;  // Store for Patch Tester
        
        console.log('[VR_SRR] Opening SRR with context:', {
          sheetName: foundSheet,
          rowIdx: foundIdx,
          recordId: recordId,
          datasetId: datasetId,
          patchRequestId: patchRequestId,
          artifactId: srrState.currentArtifactId,
          isReadOnly: srrState.isReadOnly
        });
        
        // Update debug panel
        updateDebugPanel({
          role: currentMode,
          tenant_id: IDENTITY_CONTEXT.tenant_id,
          division_id: IDENTITY_CONTEXT.division_id,
          dataset_id: datasetId,
          record_id: recordId,
          patch_request_id: patchRequestId,
          patchRequest_load: patchRequest ? 'SUCCESS' : 'N/A',
          record_load: 'SUCCESS'
        });
        
        navigateTo('row/' + foundIdx);
        
        // Load Patch Tester data if artifact exists and not RFI
        if (srrState.currentArtifactId) {
          var artifact = getArtifact(srrState.currentArtifactId);
          var isRfi = false;
          if (artifact) {
            if (artifact.artifact_type === 'rfi') isRfi = true;
            if (artifact.body && artifact.body.patch_type === 'rfi') isRfi = true;
          }
          if (!isRfi) {
            srrLoadPatchTesterData(srrState.currentArtifactId);
          }
        }
      } else {
        // v1.5.3 Fix: Fallback to record store when workbook lookup fails
        console.log('[VR_SRR] Workbook lookup failed, trying record store...');
        var fallbackTenantId = (patchRequest && patchRequest.tenant_id) || IDENTITY_CONTEXT.tenant_id || 'tenant_default';
        var storedRecord = loadRecordFromStore(fallbackTenantId, datasetId, recordId);
        
        if (storedRecord && storedRecord.data) {
          console.log('[VR_SRR] Found record in store:', storedRecord.record_id);
          foundRecord = storedRecord.data;
          var srcPointers = storedRecord.source_pointers || {};
          foundSheet = srcPointers.sheet_name || datasetId;
          foundIdx = srcPointers.row_index || 0;
          // Inject into workbook for subsequent lookups
          if (!workbook.sheets[foundSheet]) {
            workbook.sheets[foundSheet] = { name: foundSheet, headers: Object.keys(foundRecord), rows: [] };
            if (workbook.order.indexOf(foundSheet) < 0) workbook.order.push(foundSheet);
          }
          if (!workbook.sheets[foundSheet].rows[foundIdx]) {
            workbook.sheets[foundSheet].rows[foundIdx] = foundRecord;
          }
          // Set SRR context and open
          srrState.currentSheetName = foundSheet;
          srrState.currentDatasetId = datasetId;
          srrState.currentRecordId = recordId;
          srrState.currentPatchRequestId = patchRequestId;
          var artifactId = (payload && payload.artifact && payload.artifact.artifact_id) || vrState.selectedPayloadId || null;
          srrState.currentArtifactId = artifactId;
          srrState.isReadOnly = (currentMode === 'verifier' || currentMode === 'admin');
          srrState.currentPatchRequest = patchRequest;
          updateDebugPanel({
            role: currentMode,
            tenant_id: fallbackTenantId,
            dataset_id: datasetId,
            record_id: recordId,
            record_load: 'STORE_FALLBACK'
          });
          navigateTo('row/' + foundIdx);
        } else {
          var storeKey = 'kiwi/v1/' + fallbackTenantId + '/records/' + datasetId + '/' + recordId + '.json';
          showToast('Record not found in dataset or store: ' + recordId, 'warning');
          updateDebugPanel({ record_load: 'FAILED', record_id: recordId, store_key: storeKey });
        }
      }
    }
    
    function openVerifierReviewDetail(payloadId) {
      console.log('[VR_OPEN] Opening verifier review for payload:', payloadId);
      vrState.fromVerifierTriage = true;  // Track navigation source
      vrState.isAdminReview = false;  // Not admin review
      vrState.selectedPayloadId = payloadId;  // Store selected payload ID for navigation handler
      console.log('[VR_OPEN] vrState.selectedPayloadId set to:', vrState.selectedPayloadId);
      navigateTo('verifier-review');
    }
    
    // v1.5.1: Load data for Admin Review (from Admin Queue)
    function loadAdminReviewData(artifactId) {
      console.log('[AR_LOAD] loadAdminReviewData called with artifactId:', artifactId);
      
      vrState.isAdminReview = true;  // Track admin context
      vrState.fromVerifierTriage = true;
      vrState.selectedPayloadId = artifactId;
      
      // Update page header to show "Admin Review"
      var headerEl = document.querySelector('#page-verifier-review h2');
      if (headerEl) {
        headerEl.textContent = 'Admin Review';
      }
      var descEl = document.querySelector('#page-verifier-review .page-desc');
      if (descEl) {
        descEl.textContent = 'Final Admin review of Verifier-approved items. Finalize or reject.';
      }
      
      // Load the data (reuses verifier review data loading)
      loadVerifierReviewData(artifactId);
      
      // Update action buttons for admin context
      setTimeout(function() {
        vrUpdateActionButtonsForAdmin();
      }, 100);
    }
    
    function vrUpdateActionButtonsForAdmin() {
      // In admin review, show Finalize/Reject instead of Begin Review/Approve/Reject
      var btnBegin = document.getElementById('vr-btn-begin');
      var btnClarify = document.getElementById('vr-btn-clarify');
      var btnApprove = document.getElementById('vr-btn-approve');
      var btnReject = document.getElementById('vr-btn-reject');
      
      if (vrState.isAdminReview) {
        // Hide Begin Review for admin (already reviewed by verifier)
        if (btnBegin) btnBegin.style.display = 'none';
        if (btnClarify) btnClarify.style.display = 'none';
        
        // Rename Approve to Finalize
        if (btnApprove) {
          btnApprove.textContent = 'Finalize';
          btnApprove.disabled = false;
          btnApprove.onclick = function() { adminFinalizeFromReview(); };
        }
        if (btnReject) {
          btnReject.disabled = false;
          btnReject.onclick = function() { adminRejectFromReview(); };
        }
      }
    }
    
    function adminFinalizeFromReview() {
      if (!vrState.selectedPayloadId) return;
      updatePayloadStatus(vrState.selectedPayloadId, 'resolved');
      showToast('Item finalized and resolved', 'success');
      navigateTo('admin/patch-queue');
    }
    
    function adminRejectFromReview() {
      var notes = document.getElementById('vr-notes')?.value?.trim();
      if (!notes) {
        showToast('Please add notes explaining the rejection', 'warning');
        return;
      }
      if (!vrState.selectedPayloadId) return;
      updatePayloadStatus(vrState.selectedPayloadId, 'rejected');
      showToast('Item rejected', 'warning');
      navigateTo('admin/patch-queue');
    }
    
    function vrUpdateStateBadge() {
      var badge = document.getElementById('vr-state-badge');
      var stateClass = vrState.reviewState.toLowerCase().replace(/_/g, '-');
      badge.className = 'vr-state-badge ' + stateClass;
      badge.textContent = vrState.reviewState.replace(/_/g, ' ');
    }
    
    function vrUpdateActionButtons() {
      var btnBegin = document.getElementById('vr-btn-begin');
      var btnClarify = document.getElementById('vr-btn-clarify');
      var btnApprove = document.getElementById('vr-btn-approve');
      var btnReject = document.getElementById('vr-btn-reject');
      
      var role = currentMode || 'Analyst';
      
      // v1.6.57: Hidden not disabled — hide actions for unauthorized roles
      if (role === 'Analyst') {
        if (btnBegin) btnBegin.style.display = 'none';
        if (btnClarify) btnClarify.style.display = 'none';
        if (btnApprove) btnApprove.style.display = 'none';
        if (btnReject) btnReject.style.display = 'none';
        return;
      }
      
      // Show all for Verifier/Admin
      [btnBegin, btnClarify, btnApprove, btnReject].forEach(function(b) { if (b) b.style.display = ''; });

      // Reset all
      btnBegin.disabled = true;
      btnClarify.disabled = true;
      btnApprove.disabled = true;
      btnReject.disabled = true;
      
      // Enable based on state
      if (vrState.reviewState === 'Submitted') {
        btnBegin.disabled = false;
      } else if (vrState.reviewState === 'Under_Review') {
        btnClarify.disabled = false;
        btnApprove.disabled = false;
        btnReject.disabled = false;
      }
      // Needs_Clarification, Verifier_Approved, Rejected = no actions available
    }
    
    function vrLogAuditEvent(eventType, details) {
      var event = {
        timestamp: new Date().toISOString(),
        event_type: eventType,
        patch_id: vrState.currentPatchId,
        actor: vrState.verifierActor,
        details: details || {}
      };
      vrState.auditLog.push(event);
      console.log('[VR] AUDIT:', eventType, event);
    }
    
    function vrBeginReview() {
      if (vrState.reviewState !== 'Submitted') return;
      
      vrState.reviewState = 'Under_Review';
      vrLogAuditEvent('BEGIN_REVIEW', { from_state: 'Submitted' });
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Review started — patch is now Under Review', 'info');
    }
    
    function vrRequestClarification() {
      if (vrState.reviewState !== 'Under_Review') return;
      document.getElementById('vr-clarify-modal').classList.add('active');
    }
    
    function vrClarifyCancel() {
      document.getElementById('vr-clarify-modal').classList.remove('active');
      document.getElementById('vr-clarify-text').value = '';
    }
    
    function vrClarifySubmit() {
      var clarifyText = document.getElementById('vr-clarify-text').value.trim();
      if (!clarifyText) {
        showToast('Please describe the clarification needed', 'warning');
        return;
      }
      
      vrState.reviewState = 'Needs_Clarification';
      vrState.notes = document.getElementById('vr-notes').value;
      vrLogAuditEvent('REQUEST_CLARIFICATION', { question_text: clarifyText });
      
      document.getElementById('vr-clarify-modal').classList.remove('active');
      document.getElementById('vr-clarify-text').value = '';
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Clarification requested — author notified', 'info');
    }
    
    function vrChecklistChanged() {
      var items = ['vr-chk-intent', 'vr-chk-schema', 'vr-chk-preview', 'vr-chk-conflict', 'vr-chk-evidence', 'vr-chk-smoke'];
      var allChecked = items.every(function(id) { return document.getElementById(id)?.checked; });
      var confirmBox = document.getElementById('vr-chk-confirm');
      if (confirmBox) {
        confirmBox.disabled = !allChecked;
        if (!allChecked) confirmBox.checked = false;
      }
      var approveBtn = document.getElementById('vr-btn-approve');
      if (approveBtn && vrState.reviewState === 'Under_Review') {
        approveBtn.disabled = !(confirmBox && confirmBox.checked);
      }
    }

    function vrApprove() {
      if (vrState.reviewState !== 'Under_Review') return;

      // v1.6.57: No self-approval
      var currentPR = vrState.patchRequestId ? getPatchRequest(vrState.patchRequestId) : null;
      if (currentPR && isSelfApproval(currentPR)) {
        showToast('Self-approval is not permitted. A different verifier must approve this patch.', 'error');
        return;
      }

      var confirmBox = document.getElementById('vr-chk-confirm');
      if (!confirmBox || !confirmBox.checked) {
        showToast('Complete the Review Checklist before approving', 'warning');
        return;
      }
      
      vrState.notes = document.getElementById('vr-notes').value;
      vrState.reviewState = 'Verifier_Approved';
      vrState.checklistConfirmed = true;
      saveChecklistConfirmation('verifier', vrState.patchRequestId || vrState.currentPatchId || 'current');
      vrLogAuditEvent('VERIFIER_APPROVED', { checklist_confirmed: true, notes: vrState.notes });
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Patch approved by Verifier — routed to Admin Approval', 'success');
    }
    
    function vrReject() {
      if (vrState.reviewState !== 'Under_Review') return;
      
      var notes = document.getElementById('vr-notes').value.trim();
      if (!notes) {
        showToast('Please add review notes explaining the rejection reason', 'warning');
        return;
      }
      
      vrState.notes = notes;
      vrState.reviewState = 'Rejected';
      vrLogAuditEvent('REJECTED', { rejection_reason: notes });
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Patch rejected', 'info');
    }
    
    function vrRenderDecisionSummary() {
      var container = document.getElementById('vr-decision-summary');
      
      if (vrState.reviewState === 'Submitted' || vrState.reviewState === 'Under_Review') {
        container.innerHTML = '';
        return;
      }
      
      var isRejected = vrState.reviewState === 'Rejected';
      var stateLabel = vrState.reviewState.replace(/_/g, ' ');
      var lastEvent = vrState.auditLog[vrState.auditLog.length - 1];
      
      container.innerHTML = '<div class="vr-decision-summary' + (isRejected ? ' rejected' : '') + '">' +
        '<strong>Decision:</strong> ' + stateLabel + '<br>' +
        '<span style="font-size: 0.85em; color: #666;">by ' + vrState.verifierActor + ' at ' + (lastEvent ? lastEvent.timestamp : '—') + '</span>' +
        (vrState.notes ? '<div style="margin-top: 8px; font-size: 0.85em;"><strong>Notes:</strong> ' + vrState.notes + '</div>' : '') +
      '</div>';
    }

    // ========== ADMIN APPROVAL STATE + FUNCTIONS (v1.4.5) ==========
    var aaState = {
      currentPatchId: null,
      reviewState: 'Verifier_Approved', // Verifier_Approved, Admin_Hold, Admin_Approved, Promoted
      adminActor: 'admin@example.com',
      auditLog: [],
      notes: '',
      smokeStatus: 'pass' // pass or fail
    };
    
    // Sample patch data for Admin Approval demo
    var aaSamplePatch = {
      patch_id: 'PATCH-2026-0001',
      author: 'analyst@example.com',
      submitted_at: new Date(Date.now() - 3600000).toISOString(),
      intent: {
        observation: 'Contract has missing label_vendor field despite being a licensing agreement.',
        expected: 'Label_vendor should be populated when contract_type = LICENSING.',
        justification: 'Licensing agreements require label_vendor for downstream royalty calculations.'
      },
      evidence: {
        observation: 'Row 142 shows contract_type=LICENSING but label_vendor is blank.',
        expected: 'label_vendor = "Sony Music" based on contract header data.',
        justification: 'Header section row 1 references Sony Music as the licensing partner.',
        repro: '1. Load ostereo_demo_v1.json\n2. Navigate to row 142\n3. Observe label_vendor is empty\n4. Cross-reference with contract header'
      },
      verifier: {
        actor: 'verifier@example.com',
        approved_at: new Date(Date.now() - 1800000).toISOString(),
        notes: 'All checklist items confirmed. Evidence is complete and consistent.'
      },
      preflight: { schema: 'pass', conflicts: 'pass', evidence: 'pass' },
      smoke: { status: 'pass', last_run: new Date().toISOString() },
      changelog: '## [1.4.6] - 2026-02-03\n\n### Changed\n- SF_R1_LABEL_NOT_ARTIST: Updated label_vendor requirement for LICENSING contracts',
      revisions: []
    };
    
    function loadAdminApprovalData() {
      // Load sample data into view
      document.getElementById('aa-intent-when').textContent = aaSamplePatch.intent.observation || '—';
      document.getElementById('aa-intent-then').textContent = aaSamplePatch.intent.expected || '—';
      document.getElementById('aa-intent-because').textContent = aaSamplePatch.intent.justification || '—';
      
      document.getElementById('aa-ev-observation').textContent = aaSamplePatch.evidence.observation || '—';
      document.getElementById('aa-ev-expected').textContent = aaSamplePatch.evidence.expected || '—';
      document.getElementById('aa-ev-justification').textContent = aaSamplePatch.evidence.justification || '—';
      document.getElementById('aa-ev-repro').textContent = aaSamplePatch.evidence.repro || '—';
      
      document.getElementById('aa-verifier-name').textContent = aaSamplePatch.verifier.actor;
      document.getElementById('aa-verifier-time').textContent = aaSamplePatch.verifier.approved_at;
      document.getElementById('aa-verifier-notes').textContent = aaSamplePatch.verifier.notes;
      
      document.getElementById('aa-smoke-time').textContent = aaSamplePatch.smoke.last_run;
      document.getElementById('aa-changelog-preview').textContent = aaSamplePatch.changelog;
      
      aaState.currentPatchId = aaSamplePatch.patch_id;
      aaState.reviewState = 'Verifier_Approved';
      aaState.smokeStatus = aaSamplePatch.smoke.status;
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
    }
    
    function aaUpdateStateBadge() {
      var badge = document.getElementById('aa-state-badge');
      var stateClass = aaState.reviewState.toLowerCase().replace(/_/g, '-');
      badge.className = 'aa-state-badge ' + stateClass;
      badge.textContent = aaState.reviewState.replace(/_/g, ' ');
    }
    
    function aaUpdateActionButtons() {
      var btnApprove = document.getElementById('aa-btn-approve');
      var btnHold = document.getElementById('aa-btn-hold');
      var btnRelease = document.getElementById('aa-btn-release');
      var btnPromote = document.getElementById('aa-btn-promote');
      
      var role = currentMode || 'Analyst';
      
      // v1.6.57: Only Admin can see admin approval actions
      if (role !== 'Admin') {
        [btnApprove, btnHold, btnRelease, btnPromote].forEach(function(b) { if (b) b.style.display = 'none'; });
        return;
      }
      
      // Show all for Admin
      [btnApprove, btnHold, btnRelease, btnPromote].forEach(function(b) { if (b) b.style.display = ''; });

      // Reset all
      btnApprove.disabled = true;
      btnHold.disabled = true;
      btnRelease.disabled = true;
      btnPromote.disabled = true;
      
      // Enable based on state
      if (aaState.reviewState === 'Verifier_Approved') {
        btnApprove.disabled = false;
        btnHold.disabled = false;
      } else if (aaState.reviewState === 'Admin_Hold') {
        btnRelease.disabled = false;
      } else if (aaState.reviewState === 'Admin_Approved') {
        btnPromote.disabled = aaState.smokeStatus !== 'pass';
      }
      // Promoted = no actions available
    }
    
    function aaLogAuditEvent(eventType, details) {
      var event = {
        timestamp: new Date().toISOString(),
        event_type: eventType,
        patch_id: aaState.currentPatchId,
        actor: aaState.adminActor,
        details: details || {}
      };
      aaState.auditLog.push(event);
      console.log('[AA] AUDIT:', eventType, event);
    }
    
    // v1.4.17: Patch Replay Gate functions
    var replayState = {
      status: 'not_run', // not_run | pass | fail
      checks: [],
      failureReason: null,
      lastRunAt: null
    };
    
    function aaRunReplay() {
      console.log('[AA] Running Patch Replay evaluation...');
      
      // Deterministic stub: evaluate based on patch content hash
      // Uses a simple hash of the current patch to produce consistent results
      var patchHash = 0;
      var intentText = (aaState.observation || '') + (aaState.expected || '') + (aaState.justification || '');
      for (var i = 0; i < intentText.length; i++) {
        patchHash = ((patchHash << 5) - patchHash) + intentText.charCodeAt(i);
        patchHash = patchHash & patchHash; // Convert to 32-bit integer
      }
      
      // Deterministic check results based on hash (not random)
      var checks = [
        { id: 'schema', label: 'Schema Validation', pass: true },
        { id: 'conflicts', label: 'Conflict Detection', pass: true },
        { id: 'baseline', label: 'Baseline Compatibility', pass: (patchHash % 7) !== 0 },
        { id: 'rules', label: 'Rule Evaluation', pass: (patchHash % 11) !== 0 },
        { id: 'output', label: 'Output Determinism', pass: true }
      ];
      
      var allPass = checks.every(function(c) { return c.pass; });
      var failedCheck = checks.find(function(c) { return !c.pass; });
      
      replayState.status = allPass ? 'pass' : 'fail';
      replayState.checks = checks;
      replayState.lastRunAt = new Date().toISOString();
      replayState.failureReason = failedCheck ? 'Check failed: ' + failedCheck.label + ' (hash=' + Math.abs(patchHash % 100) + ')' : null;
      
      // Update UI
      aaRenderReplayStatus();
      
      // Log audit event
      aaLogAuditEvent('REPLAY_EVALUATED', {
        result: replayState.status,
        checks: checks.map(function(c) { return { id: c.id, pass: c.pass }; }),
        failure_reason: replayState.failureReason
      });
      
      showToast('Replay evaluation: ' + replayState.status.toUpperCase(), replayState.status === 'pass' ? 'success' : 'warning');
    }
    
    function aaRenderReplayStatus() {
      var statusEl = document.getElementById('aa-replay-status');
      var badgeEl = document.getElementById('aa-replay-badge');
      var textEl = document.getElementById('aa-replay-status-text');
      var packetEl = document.getElementById('aa-replay-packet');
      var failureEl = document.getElementById('aa-replay-failure-reason');
      var failureTextEl = document.getElementById('aa-replay-failure-text');
      var btnEl = document.getElementById('aa-replay-btn');
      
      // Update status badge
      statusEl.className = 'aa-replay-status ' + replayState.status.replace('_', '-');
      badgeEl.className = 'aa-replay-badge ' + replayState.status.replace('_', '-');
      badgeEl.textContent = replayState.status.toUpperCase().replace('_', ' ');
      
      if (replayState.status === 'not_run') {
        textEl.textContent = 'Replay evaluation not yet performed';
        packetEl.style.display = 'none';
        failureEl.style.display = 'none';
        btnEl.textContent = 'Run Replay';
      } else {
        textEl.textContent = replayState.status === 'pass' 
          ? 'All checks passed at ' + new Date(replayState.lastRunAt).toLocaleTimeString()
          : 'Failed at ' + new Date(replayState.lastRunAt).toLocaleTimeString();
        
        // Show packet with per-check status
        packetEl.style.display = 'block';
        replayState.checks.forEach(function(check) {
          var checkEl = document.getElementById('aa-replay-check-' + check.id);
          if (checkEl) {
            checkEl.className = 'aa-replay-check ' + (check.pass ? 'pass' : 'fail');
            checkEl.querySelector('.aa-replay-check-icon').textContent = check.pass ? '✓' : '✗';
          }
        });
        
        // Show failure reason if failed
        if (replayState.status === 'fail') {
          failureEl.style.display = 'block';
          failureTextEl.textContent = replayState.failureReason || 'Unknown failure';
        } else {
          failureEl.style.display = 'none';
        }
        
        btnEl.textContent = 'Re-run Replay';
      }
    }
    
    function aaShowReplayAuditLog() {
      AuditTimeline.emit('SYSTEM_CHANGE_APPLIED', {
        patch_request_id: aaState.currentPatchId || '',
        metadata: {
          event_type: 'REPLAY_EVALUATED',
          result: replayState.status,
          failure_reason: replayState.failureReason,
          checks: (replayState.checks || []).map(function(c) { return { id: c.id, pass: c.pass }; })
        }
      });
      showAuditLogForDataset({ patch_request_id: aaState.currentPatchId || '' });
    }
    
    function aaChecklistChanged() {
      var items = ['aa-chk-verifier', 'aa-chk-downstream', 'aa-chk-version', 'aa-chk-smoke'];
      var allChecked = items.every(function(id) { return document.getElementById(id)?.checked; });
      var confirmBox = document.getElementById('aa-chk-confirm');
      if (confirmBox) {
        confirmBox.disabled = !allChecked;
        if (!allChecked) confirmBox.checked = false;
      }
      var approveBtn = document.getElementById('aa-btn-approve');
      if (approveBtn) {
        approveBtn.disabled = !(confirmBox && confirmBox.checked);
      }
    }

    function aaAdminApprove() {
      if (aaState.reviewState !== 'Verifier_Approved') return;

      // v1.6.57: No self-approval check
      var currentPR = aaState.currentPatchId ? getPatchRequest(aaState.currentPatchId) : null;
      if (currentPR && isSelfApproval(currentPR)) {
        showToast('Self-approval is not permitted. A different admin must approve.', 'error');
        return;
      }
      
      if (aaState.smokeStatus !== 'pass') {
        showToast('Smoke (Strict) must pass before Admin Approve', 'warning');
        return;
      }

      var confirmBox = document.getElementById('aa-chk-confirm');
      if (!confirmBox || !confirmBox.checked) {
        showToast('Complete the Admin Review Checklist before approving', 'warning');
        return;
      }
      
      aaState.notes = document.getElementById('aa-notes').value;
      aaState.reviewState = 'Admin_Approved';
      aaState.checklistConfirmed = true;
      saveChecklistConfirmation('admin', aaState.patchRequestId || aaState.currentPatchId || 'current');
      aaLogAuditEvent('ADMIN_APPROVED', { smoke_evidence_ref: 'smoke_strict_' + Date.now(), checklist_confirmed: true, notes: aaState.notes });
      AuditTimeline.emit('PATCH_ADMIN_PROMOTED', {
        patch_request_id: aaState.currentPatchId || aaState.patchRequestId || '',
        metadata: { checklist_confirmed: true, notes: aaState.notes }
      });
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Patch approved by Admin — ready to Promote', 'success');
    }
    
    function aaAdminHold() {
      if (aaState.reviewState !== 'Verifier_Approved') return;
      document.getElementById('aa-hold-modal').classList.add('active');
    }
    
    function aaHoldCancel() {
      document.getElementById('aa-hold-modal').classList.remove('active');
      document.getElementById('aa-hold-text').value = '';
    }
    
    function aaHoldSubmit() {
      var holdText = document.getElementById('aa-hold-text').value.trim();
      if (!holdText) {
        showToast('Please provide a hold reason', 'warning');
        return;
      }
      
      aaState.reviewState = 'Admin_Hold';
      aaState.notes = document.getElementById('aa-notes').value;
      aaLogAuditEvent('ADMIN_HOLD', { hold_reason: holdText });
      
      document.getElementById('aa-hold-modal').classList.remove('active');
      document.getElementById('aa-hold-text').value = '';
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Patch placed on Admin Hold', 'info');
    }
    
    function aaReleaseHold() {
      if (aaState.reviewState !== 'Admin_Hold') return;
      
      aaState.notes = document.getElementById('aa-notes').value;
      aaState.reviewState = 'Verifier_Approved'; // Returns to Verifier_Approved for re-evaluation
      aaLogAuditEvent('RELEASE_HOLD', { notes: aaState.notes });
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Hold released — patch returned to Verifier Approved state', 'info');
    }
    
    function aaPromoteToBaseline() {
      if (aaState.reviewState !== 'Admin_Approved') return;
      
      if (aaState.smokeStatus !== 'pass') {
        showToast('Smoke (Strict) must pass before Promote', 'warning');
        return;
      }
      
      aaState.notes = document.getElementById('aa-notes').value;
      aaState.reviewState = 'Promoted';
      aaLogAuditEvent('PROMOTE_TO_BASELINE', { 
        version: '1.4.6', 
        changelog_entry: aaSamplePatch.changelog,
        notes: aaState.notes 
      });
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Patch promoted to baseline! Version 1.4.6 is now live.', 'success');
    }
    
    function aaRenderDecisionSummary() {
      var container = document.getElementById('aa-decision-summary');
      
      if (aaState.reviewState === 'Verifier_Approved') {
        container.innerHTML = '';
        return;
      }
      
      var stateLabel = aaState.reviewState.replace(/_/g, ' ');
      var lastEvent = aaState.auditLog[aaState.auditLog.length - 1];
      
      container.innerHTML = '<div class="aa-decision-summary">' +
        '<strong>Admin Decision:</strong> ' + stateLabel + '<br>' +
        '<span style="font-size: 0.85em; color: #666;">by ' + aaState.adminActor + ' at ' + (lastEvent ? lastEvent.timestamp : '—') + '</span>' +
        (aaState.notes ? '<div style="margin-top: 8px; font-size: 0.85em;"><strong>Notes:</strong> ' + aaState.notes + '</div>' : '') +
      '</div>';
    }

    // Attach Grid event listeners
    document.addEventListener('DOMContentLoaded', function() {
      var gridSearch = document.getElementById('grid-search');
      if (gridSearch) {
        gridSearch.addEventListener('input', function() {
          gridState.search = gridSearch.value;
          updateGridURL();
          renderGrid();
        updateProgressBlock();
        });
      }
    });
    var gridVirtualState = { data: [], rendered: 0, columns: [], active: false };
    
    function cleanupGridVirtualization() {
      var container = document.querySelector('.grid-table-container');
      if (container) {
        container.removeEventListener('scroll', gridLazyLoadHandler);
      }
      gridVirtualState.active = false;
    }
    
    function renderGridBatch(data, startIdx, batchSize, columns, isFirst) {
      var perfT = perfStart();
      var tbody = document.getElementById('grid-tbody');
      if (isFirst) {
        cleanupGridVirtualization();
        tbody.innerHTML = '';
        gridVirtualState = { data: data, rendered: 0, columns: columns, active: true };
        // Add scroll listener for lazy loading
        var container = document.querySelector('.grid-table-container');
        if (container) {
          container.addEventListener('scroll', gridLazyLoadHandler);
        }
      }
      
      var endIdx = Math.min(startIdx + batchSize, data.length);
      var fragment = document.createDocumentFragment();
      
      // v1.6.18: Status key normalization - check multiple possible header variants
      var STATUS_KEYS = ['status', 'Status', 'sf_contract_status', 'review_state', 'Review_State'];
      
      for (var idx = startIdx; idx < endIdx; idx++) {
        var r = data[idx];
        var tr = document.createElement('tr');
        
        // v1.4.15: Pass sheet name and original row index to click handler
        var sheetName = r.sheet || '';
        var sheetRowIdx = r._sheetRowIndex !== undefined ? r._sheetRowIndex : idx;
        // v1.6.2: Get record ID for signal styling (match signalStore derivation)
        var recordId = r.record_id || (r._identity && r._identity.record_id) || r.contract_key || '';
        if (!recordId) {
          recordId = sheetName + ':' + sheetRowIdx;
        }
        
        // v1.6.48: Skip collapsed group children
        if (r._group && !r._group.is_anchor && isGroupCollapsed(r._group.group_id)) {
          continue;
        }

        // v1.6.18: Build row classes - clickable + row-change classes
        var rowClasses = ['clickable'];
        // v1.6.48: Add child row class for visual indent
        if (r._group && !r._group.is_anchor) {
          rowClasses.push('grid-child-row');
        }
        var changeSummary = getRecordChangeSummary(recordId);
        if (changeSummary && changeSummary.total > 0) {
          if (changeSummary.by_type.added) rowClasses.push('row-added');
          else if (changeSummary.by_type.blacklist) rowClasses.push('row-removed');
          else if (changeSummary.by_type.removed) rowClasses.push('row-removed');
          else rowClasses.push('row-changed');
        }
        tr.className = rowClasses.join(' ');
        
        tr.dataset.sheetName = sheetName;
        tr.dataset.recordIndex = sheetRowIdx;
        tr.dataset.recordId = recordId;
        tr.onclick = (function(sn, sri) { return function() { openRowReviewDrawer(sn, sri); }; })(sheetName, sheetRowIdx);
        
        // v1.6.18: Normalize status field lookup - try multiple header variants
        var statusVal = '';
        for (var si = 0; si < STATUS_KEYS.length; si++) {
          if (r[STATUS_KEYS[si]]) {
            statusVal = r[STATUS_KEYS[si]];
            break;
          }
        }
        var statusClass = 'status-' + (statusVal || '').toLowerCase().replace(/\s+/g, '_');
        
        // v1.6.2: Add row badges for signal counts
        var rowBadgesHtml = renderRowBadges(recordId);
        
        // v1.6.48: Group nesting - caret and indent
        var groupCaret = '';
        var childIndent = '';
        if (r._group) {
          if (r._group.is_anchor) {
            var isCollapsed = isGroupCollapsed(r._group.group_id);
            groupCaret = '<span class="grid-group-caret' + (isCollapsed ? ' collapsed' : '') + '" onclick="event.stopPropagation(); toggleGridGroup(\'' + r._group.group_id + '\', this);" title="' + (isCollapsed ? 'Expand' : 'Collapse') + ' group">&#9660;</span>';
          } else {
            childIndent = '<span class="grid-child-indent"></span>';
          }
        }
        tr.innerHTML = '<td class="row-index">' + groupCaret + childIndent + (idx + 1) + rowBadgesHtml + '</td>' +
          columns.map(function(col) {
            var val = r[col];
            if (val === null || val === undefined) val = '';
            if (typeof val === 'object') val = JSON.stringify(val);
            
            // v1.6.46: Make File_Name a clickable link using file_url
            var isFileNameCol = col.toLowerCase().includes('file_name');
            var cellContent = String(val);
            if (isFileNameCol && val) {
              var fileUrl = r.file_url || r.File_URL_c || '';
              if (fileUrl) {
                // Show truncated file name with link icon
                var shortName = val.length > 40 ? val.substring(0, 38) + '...' : val;
                cellContent = '<a href="' + fileUrl + '" target="_blank" onclick="event.stopPropagation();" style="color: #1976d2; text-decoration: none; display: flex; align-items: center; gap: 4px;">' +
                  '<span style="font-size: 0.9em;">&#128279;</span>' + shortName + '</a>';
              }
            }
            
            // v1.6.18: Apply status class for any status-variant column
            var isStatusCol = STATUS_KEYS.indexOf(col) >= 0 || col.toLowerCase() === 'status';
            var cellClass = isStatusCol ? statusClass : '';
            // v1.6.2: Apply signal-based cell coloring (v1.6.18: pass record for fallback)
            var cellStyle = getGridCellStyle(recordId, col, r);
            var changeInfo2 = getCellChangeInfo(recordId, col, r); var titlePrefix2 = changeInfo2 && CHANGE_TYPE_STYLES[changeInfo2.type] ? '[' + CHANGE_TYPE_STYLES[changeInfo2.type].label + '] ' : ''; return '<td class="' + cellClass + ' truncated" style="' + cellStyle + '" title="' + titlePrefix2 + String(val).replace(/"/g, '&quot;') + '">' + cellContent + '</td>';
          }).join('');
        
        fragment.appendChild(tr);
      }
      
      tbody.appendChild(fragment);
      gridVirtualState.rendered = endIdx;
      perfLog('renderGridBatch (' + (endIdx - startIdx) + ' rows)', perfT);
      
      // v1.6.37: Hide upload loading after first batch renders (grid is now visible)
      if (isFirst && typeof hideUploadLoading === 'function') {
        hideUploadLoading();
      }
    }
    
    function toggleGridGroup(groupId, caretEl) {
      var collapsed = isGroupCollapsed(groupId);
      setGroupCollapsed(groupId, !collapsed);
      renderGrid();
    }

    function gridLazyLoadHandler() {
      var container = document.querySelector('.grid-table-container');
      if (!container || gridVirtualState.rendered >= gridVirtualState.data.length) return;
      
      var scrollTop = container.scrollTop;
      var scrollHeight = container.scrollHeight;
      var clientHeight = container.clientHeight;
      
      // Load more when near bottom (within 200px)
      if (scrollTop + clientHeight >= scrollHeight - 200) {
        renderGridBatch(gridVirtualState.data, gridVirtualState.rendered, 100, gridVirtualState.columns, false);
      }
    }
    
    // ============================================================
    // END GRID FUNCTIONS
    
    // ============================================================
    // UNKNOWN COLUMNS FUNCTIONS (v1.4.4)
    // ============================================================
    
    function _buildGlossaryKeySet() {
      var known = {};
      var _norm = function(s) { return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, ''); };
      known['contract_key'] = true; known['file_name'] = true; known['file_url'] = true;
      known['status'] = true; known['sheet'] = true; known['record_id'] = true;
      known['dataset_id'] = true; known['group_id'] = true; known['document_type'] = true;
      known['artists'] = true; known['amountbreakdown'] = true; known['amount_breakdown'] = true;
      known['addons'] = true; known['add_ons'] = true;
      known['totalamount'] = true; known['thresholdnumberofdays'] = true;
      var _normToken = (typeof _normFieldToken === 'function') ? _normFieldToken : _norm;
      if (typeof rulesBundleCache !== 'undefined' && rulesBundleCache.fieldMeta && rulesBundleCache.fieldMeta.fields) {
        rulesBundleCache.fieldMeta.fields.forEach(function(f) {
          if (f.canonical_key) { known[_norm(f.canonical_key)] = true; known[_normToken(f.canonical_key)] = true; }
          if (f.label) { known[_norm(f.label)] = true; known[_normToken(f.label)] = true; }
          if (f.key) { known[_norm(f.key)] = true; known[_normToken(f.key)] = true; }
          if (f.field_key) { known[_norm(f.field_key)] = true; known[_normToken(f.field_key)] = true; }
          if (f.field_label) { known[_norm(f.field_label)] = true; known[_normToken(f.field_label)] = true; }
        });
      }
      if (typeof COLUMN_ALIAS_MAP !== 'undefined') {
        var aliasKeys = Object.keys(COLUMN_ALIAS_MAP);
        for (var i = 0; i < aliasKeys.length; i++) {
          known[aliasKeys[i]] = true;
          known[_normToken(aliasKeys[i])] = true;
          var entries = COLUMN_ALIAS_MAP[aliasKeys[i]];
          for (var j = 0; j < entries.length; j++) {
            known[_norm(entries[j].canonical_key)] = true;
            known[_normToken(entries[j].canonical_key)] = true;
          }
        }
      }
      return known;
    }

    function detectUnknownColumns() {
      if (!workbook || !workbook.order || workbook.order.length === 0) return;
      var knownSet = _buildGlossaryKeySet();
      var _norm = function(s) { return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, ''); };
      var stored = {};

      for (var si = 0; si < workbook.order.length; si++) {
        var sn = workbook.order[si];
        if (sn.indexOf('_change_log') !== -1) continue;
        if (sn === 'RFIs & Analyst Notes') continue;
        if (typeof isReferenceSheet === 'function' && isReferenceSheet(sn)) continue;
        if (typeof isMetaSheet === 'function' && isMetaSheet(sn)) continue;
        var sheet = workbook.sheets[sn];
        if (!sheet || !sheet.headers) continue;

        var unknownCols = [];
        for (var hi = 0; hi < sheet.headers.length; hi++) {
          var hdr = sheet.headers[hi];
          if (!hdr || hdr.charAt(0) === '_') continue;
          var norm = _norm(hdr);
          if (!norm) continue;
          var resolved = normalizeColumnName(hdr, sn);
          var normToken = (typeof _normFieldToken === 'function') ? _normFieldToken(hdr) : norm;
          var resolvedToken = (typeof _normFieldToken === 'function') ? _normFieldToken(resolved) : resolved;
          if (knownSet[norm] || knownSet[resolved] || knownSet[normToken] || knownSet[resolvedToken]) continue;

          var sampleValues = [];
          var nonEmptyCount = 0;
          var rows = sheet.rows || [];
          var limit = Math.min(rows.length, 20);
          for (var ri = 0; ri < limit; ri++) {
            var val = rows[ri] ? rows[ri][hdr] : undefined;
            if (val !== null && val !== undefined && val !== '') {
              nonEmptyCount++;
              if (sampleValues.length < 3) sampleValues.push(String(val).substring(0, 50));
            }
          }
          unknownCols.push({
            original_name: hdr,
            normalized_name: norm,
            sample_values: sampleValues,
            count_nonempty: nonEmptyCount,
            suggested_canonical: null,
            decision: null
          });
        }
        if (unknownCols.length > 0) {
          stored[sn] = unknownCols;
        }
      }

      localStorage.setItem('unknown_columns', JSON.stringify(stored));
      var totalUnknown = 0;
      Object.keys(stored).forEach(function(k) { totalUnknown += stored[k].length; });
      console.log('[UnknownCols] Detected ' + totalUnknown + ' unknown columns across ' + Object.keys(stored).length + ' sheets (glossary+alias scoped)');
      return stored;
    }

    function normalizeColumnName(name, sheetHint) {
      var normalized = String(name).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
      var strippedToken = (typeof _normFieldToken === 'function') ? _normFieldToken(name) : normalized;
      var entries = COLUMN_ALIAS_MAP[normalized] || COLUMN_ALIAS_MAP[strippedToken] || null;
      if (entries && entries.length > 0) {
        if (sheetHint) {
          var sheetMatch = entries.find(function(e) { return e.sheet === sheetHint; });
          if (sheetMatch) return sheetMatch.canonical_key;
          if (typeof _sheetsEquivalent === 'function') {
            var equivMatch = entries.find(function(e) { return _sheetsEquivalent(e.sheet, sheetHint); });
            if (equivMatch) return equivMatch.canonical_key;
          }
        }
        return entries[0].canonical_key;
      }
      return normalized;
    }
    
    function getCurrentUnknownColumnsSnapshot() {
      var raw = {};
      try { raw = JSON.parse(localStorage.getItem('unknown_columns') || '{}'); } catch(e) { raw = {}; }
      var validSections = (typeof workbook !== 'undefined' && workbook && workbook.order) ? workbook.order : null;
      var sanitized = {};
      Object.keys(raw).forEach(function(sectionName) {
        if (validSections && validSections.indexOf(sectionName) === -1) return;
        var cols = raw[sectionName];
        if (!Array.isArray(cols)) return;
        var seen = {};
        var cleanCols = [];
        cols.forEach(function(col) {
          var origName = col.original_name || col.original || null;
          var normName = col.normalized_name || col.normalized || null;
          if (!origName || !normName) return;
          var dedupKey = sectionName + '||' + normName;
          if (seen[dedupKey]) return;
          seen[dedupKey] = true;
          cleanCols.push({
            original_name: origName,
            normalized_name: normName,
            count_nonempty: col.count_nonempty || col.nonEmptyCount || 0,
            sample_values: col.sample_values || col.samples || [],
            suggested_canonical: col.suggested_canonical || null,
            decision: col.decision || null
          });
        });
        if (cleanCols.length > 0) sanitized[sectionName] = cleanCols;
      });
      localStorage.setItem('unknown_columns', JSON.stringify(sanitized));
      return sanitized;
    }

    function refreshUnknownColumnsTable() {
      var tbody = document.getElementById('unknown-cols-tbody');
      var stored = getCurrentUnknownColumnsSnapshot();
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      
      var allCols = [];
      Object.keys(stored).forEach(function(sheet) {
        (stored[sheet] || []).forEach(function(col) {
          col.sheet = sheet;
          col.decision = decisions[sheet + '::' + col.original_name] || null;
          allCols.push(col);
        });
      });
      
      if (allCols.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 40px; color: #888;">No unknown columns detected</td></tr>';
        return;
      }
      
      tbody.innerHTML = allCols.map(function(col) {
        var key = col.sheet + '::' + col.original_name;
        var actionHtml = '<select onchange="setUnknownColumnDecision(\'' + key.replace(/'/g, "\\'") + '\', this.value)" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc;">' +
          '<option value=""' + (!col.decision ? ' selected' : '') + '>-- Select --</option>' +
          '<option value="add_global"' + (col.decision === 'add_global' ? ' selected' : '') + '>Add to Global Standard</option>' +
          '<option value="source_specific"' + (col.decision === 'source_specific' ? ' selected' : '') + '>Mark Source-Specific</option>' +
          '<option value="ignore"' + (col.decision === 'ignore' ? ' selected' : '') + '>Ignore</option>' +
          '</select>';
        
        return '<tr>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee;">' + col.sheet + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace;">' + col.original_name + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace; color: #666;">' + col.normalized_name + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; font-size: 0.85em; color: #888;">' + col.sample_values.join(', ') + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">' + col.count_nonempty + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee;">' + actionHtml + '</td>' +
          '</tr>';
      }).join('');
      
      updateUnknownColumnsDecisionsDisplay();
    }
    
    function setUnknownColumnDecision(key, decision) {
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      if (decision) {
        decisions[key] = decision;
      } else {
        delete decisions[key];
      }
      localStorage.setItem('unknown_columns_decisions', JSON.stringify(decisions));
      updateUnknownColumnsDecisionsDisplay();
    }
    
    function updateUnknownColumnsDecisionsDisplay() {
      var container = document.getElementById('unknown-cols-decisions');
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      var keys = Object.keys(decisions);
      
      if (keys.length === 0) {
        container.innerHTML = '<em style="color: #888;">No decisions made yet.</em>';
        return;
      }
      
      var html = keys.map(function(key) {
        var parts = key.split('::');
        return '<div style="margin-bottom: 4px;"><span style="color: #1976d2;">' + parts[0] + '</span>.<span style="color: #333;">' + parts[1] + '</span> → <span style="color: #2e7d32;">' + decisions[key] + '</span></div>';
      }).join('');
      
      container.innerHTML = html;
    }
    
    function exportUnknownColumnsRequest() {
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      var stored = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
      
      var requests = [];
      Object.keys(decisions).forEach(function(key) {
        var parts = key.split('::');
        var sheet = parts[0];
        var colName = parts[1];
        var decision = decisions[key];
        
        var colData = null;
        if (stored[sheet]) {
          colData = stored[sheet].find(function(c) { return c.original_name === colName; });
        }
        
        requests.push({
          request_id: 'SUR_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8),
          timestamp_utc: new Date().toISOString(),
          sheet: sheet,
          canonical_field_name: colData ? colData.normalized_name : normalizeColumnName(colName),
          source_aliases: [colName],
          classification: decision,
          source_tag_optional: decision === 'source_specific' ? sheet : null
        });
      });
      
      var artifact = {
        type: 'standard_update_request',
        version: '1.0',
        generated_at: new Date().toISOString(),
        requests: requests
      };
      
      var json = JSON.stringify(artifact, null, 2);
      navigator.clipboard.writeText(json).then(function() {
        showToast('Standard update request copied to clipboard (' + requests.length + ' items)');
      });
      
      localStorage.setItem('last_standard_update_request', json);
    }
    
    function clearUnknownColumnsDecisions() {
      if (confirm('Clear all pending decisions?')) {
        localStorage.removeItem('unknown_columns_decisions');
        refreshUnknownColumnsTable();
        showToast('Decisions cleared');
      }
    }
    
    // ============================================================
    // END UNKNOWN COLUMNS FUNCTIONS
    // ============================================================
    // ============================================================

    // v1.4.5: updateLoaderModalUI removed - logic moved to updateUIForDataState()
    
    function setupLoaderModalEvents() {
      var fileInput = document.getElementById('loader-drawer-file');
      if (fileInput) {
        fileInput.addEventListener('change', function(e) {
          var file = e.target.files[0];
          if (file) {
            handleFileImport(file);
          }
        });
      }
      
      // Drop zone
      var dropzone = document.getElementById('loader-drawer-dropzone');
      if (dropzone) {
        dropzone.addEventListener('dragover', function(e) {
          e.preventDefault();
          dropzone.classList.add('drag-over');
        });
        dropzone.addEventListener('dragleave', function() {
          dropzone.classList.remove('drag-over');
        });
        dropzone.addEventListener('drop', function(e) {
          e.preventDefault();
          dropzone.classList.remove('drag-over');
          var file = e.dataTransfer.files[0];
          if (file) {
            handleFileImport(file);
          }
        });
      }
      
      // Sample button
      var sampleBtn = document.getElementById('btn-load-sample-drawer');
      if (sampleBtn) {
        sampleBtn.addEventListener('click', function() {
          loadSampleDataset({ autoRedirect: false });
          closeLoaderModal();
          navigateTo('grid');
        });
      }
    }
    
    // v1.6.33: Excel-only upload handler for sticky header button
    function handleExcelUpload(input) {
      if (!input.files || input.files.length === 0) return;
      
      var file = input.files[0];
      var ext = (file.name.split('.').pop() || '').toLowerCase();
      
      if (ext !== 'xlsx' && ext !== 'xls') {
        showToast('Please upload an Excel file (.xlsx or .xls)', 'error');
        input.value = '';  // Reset input
        return;
      }
      
      console.log('[Upload] Excel file selected:', file.name);
      handleFileImport(file);
      input.value = '';  // Reset input for future uploads
    }
    window._globalHandleFileImport = handleFileImport;
    
    // v1.6.37: Show/hide upload loading overlay
    function showUploadLoading(message) {
      var overlay = document.getElementById('upload-loading-overlay');
      var textEl = overlay ? overlay.querySelector('.upload-loading-text') : null;
      if (textEl) textEl.textContent = message || 'Loading Excel file...';
      if (overlay) overlay.classList.add('visible');
    }
    function hideUploadLoading() {
      var overlay = document.getElementById('upload-loading-overlay');
      if (overlay) overlay.classList.remove('visible');
    }
    
    // v1.4.12: Unified file import handler with XLSX support via parseWorkbook
    function handleFileImport(file) {
      hideLoaderError();
      hideColumnMappingBanner();
      showUploadLoading('Processing ' + file.name + '...');
      
      // v1.6.38: Clear all cell-level caches BEFORE loading new dataset to prevent stale highlights
      clearAllCellStores();
      localStorage.removeItem('unknown_columns');
      localStorage.removeItem('unknown_columns_decisions');
      
      // P0.6: Truth Pack — enforce clean pre-flight from zero
      if (typeof TruthPack !== 'undefined' && TruthPack.isActive()) {
        console.log('[TRUTH-PACK][P0.6] upload_in_truth_pack_mode: file=' + file.name);
        TruthPack._cleanRoom();
      }
      
      var ext = (file.name.split('.').pop() || '').toLowerCase();
      
      if (ext !== 'csv' && ext !== 'xlsx' && ext !== 'xls') {
        showLoaderError('Unsupported file type: .' + ext + '. Please use a CSV or XLSX file.');
        return;
      }
      
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var data = ext === 'csv' ? e.target.result : new Uint8Array(e.target.result);
          var result = parseWorkbook(data, file.name);
          if (result.errors.length > 0) {
            showLoaderError(result.errors.join('; '));
            return;
          }
          if (result.order.length === 0) {
            showLoaderError('No sheets detected in file. Please check the file format.');
            return;
          }
          // Show column mapping warning if not fully resolved
          if (result.mapping && result.mapping.missingColumns.length > 0) {
            showColumnMappingBanner(result.mapping.missingColumns);
          }
          // Populate workbook
          resetWorkbook();
          IDENTITY_CONTEXT.dataset_id = file.name;
          result.order.forEach(function(sheetName) {
          if (typeof p08PurgeStaleTriageItems === 'function') p08PurgeStaleTriageItems(file.name);
            var sheet = result.sheets[sheetName];
            addSheet(sheetName, sheet.headers, sheet.rows, sheet.meta);
          });
          // v1.6.39: Reset gridState.sheet if it doesn't exist in the new workbook
          if (gridState.sheet && result.order.indexOf(gridState.sheet) === -1) {
            console.log('[Grid] Resetting invalid sheet selection from:', gridState.sheet, 'to:', result.order[0] || '');
            gridState.sheet = result.order[0] || '';
          } else if (!gridState.sheet && result.order.length > 0) {
            gridState.sheet = result.order[0];
          }
          // Also populate allData for legacy compatibility
          var allRows = [];
          result.order.forEach(function(sheetName) {
            var sheet = result.sheets[sheetName];
            sheet.rows.forEach(function(r) {
              var row = Object.assign({}, r);
              row.sheet = sheetName;
              allRows.push(row);
            });
          });
          var _uniqueCks = {};
          allRows.forEach(function(r) {
            var ck = r.contract_key || r.contract_id || r.File_Name_c || r.File_Name || '';
            if (ck) _uniqueCks[ck] = true;
          });
          var _uniqueContractCount = Object.keys(_uniqueCks).length || allRows.length;
          allData = {
            contractResults: allRows,
            issues: [],
            fieldActions: [],
            changeLog: [],
            summary: {
              total_contracts: _uniqueContractCount,
              ready: 0,
              needs_review: _uniqueContractCount,
              blocked: 0
            }
          };
          // v2.3: Workbook data persisted to IndexedDB only (no localStorage blobs)
          // localStorage used for prefs/pointers only
          saveToUploadLibrary({ workbook: workbook }, file.name, ext);
          dataLoaded = true;
          // P0.6: Notify TruthPack of dataset upload
          if (typeof TruthPack !== 'undefined' && TruthPack.isActive()) {
            setTimeout(function() { TruthPack.onDatasetUploaded(file.name, IDENTITY_CONTEXT.dataset_id || file.name); }, 500);
          }
          currentArtifactPath = file.name;
          currentDataset = null;
          updateUIForDataState();
          updateSessionChip();
          populateSubtypeDropdown();
          populateGridSheetSelector();
          renderAllTables();
          renderGrid();
          // v1.5.3: Persist all records to canonical store
          persistAllRecordsToStore();
          // v1.6.0: Generate signals for dataset
          generateSignalsForDataset();

          if (typeof detectUnknownColumns === 'function') detectUnknownColumns();

          // v2.2: Build contract index after signals
          try { ContractIndex.build(); populateContractSelector(); console.log('[V2.3-GATE][G2] PASS ContractIndex rebuilt from live workbook on upload path'); } catch(e) { console.error('[ContractIndex] Post-import build failed:', e); }

          // v1.6.33: Seed patch requests from RFI meta sheet (if present in uploaded file)
          seedPatchRequestsFromMetaSheet();
          // v1.6.33: Also seed verifier RFI queue for verifier view
          if (typeof seedVerifierRFIQueueFromMetaSheet === 'function') {
            seedVerifierRFIQueueFromMetaSheet();
          }
          // v1.6.33: Update progress block after seeding
          if (typeof updateProgressBlock === 'function') {
            updateProgressBlock();
          }
          console.log('[Loader] Workbook imported:', file.name, 'sheets:', result.order.length, 'total rows:', allRows.length);
          // v1.6.46: Cache workbook for session persistence
          if (workbook.order.length > 0 && typeof saveCurrentSession === 'function') {
            var prevSource = (document.getElementById('active-data-source-name')?.textContent || '').trim();
            if (prevSource && prevSource !== 'No dataset loaded' && prevSource !== 'Upload Excel to begin') {
              saveCurrentSession(prevSource + ' (auto)');
            }
          }
          saveWorkbookToCache();
          showToast(ext.toUpperCase() + ' imported: ' + result.order.length + ' section(s), ' + allRows.length + ' rows', 'success');
          if (!validateWorkbookState()) {
            showLoaderError('Import completed but no data was loaded. Please check the file format.');
            return;
          }
          closeLoaderModal();
          // v1.6.37: Keep loading visible until grid renders with Accounts data
          navigateTo('grid');
          showToast('Dataset loaded: ' + file.name, 'success');
        } catch (err) {
          console.error('[Loader] Import error:', err);
          hideUploadLoading();
          showLoaderError('Failed to import file: ' + err.message);
        }
      };
      
      if (ext === 'csv') {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    }
    
    function showLoaderError(message) {
      var errorEl = document.getElementById('loader-error-display');
      var msgEl = document.getElementById('loader-error-message');
      if (errorEl && msgEl) {
        msgEl.textContent = message;
        errorEl.style.display = 'block';
      }
      console.error('[Loader] Error:', message);
    }
    
    function hideLoaderError() {
      var errorEl = document.getElementById('loader-error-display');
      if (errorEl) errorEl.style.display = 'none';
    }
    
    function validateWorkbookState() {
      // v1.4.4 FIX-01: Validate workbook invariants with specific error messages
      if (!workbook.order || workbook.order.length === 0) {
        console.error('[Loader] Validation failed: workbook.order is empty');
        showLoaderError('No sheets detected in file. Please check the file format.');
        return false;
      }
      if (!workbook.activeSheet || !workbook.sheets[workbook.activeSheet]) {
        console.error('[Loader] Validation failed: activeSheet not in sheets');
        showLoaderError('Active sheet not set correctly. Internal error - please try again.');
        return false;
      }
      var sheet = workbook.sheets[workbook.activeSheet];
      if (!sheet.headers || !Array.isArray(sheet.headers)) {
        console.error('[Loader] Validation failed: headers missing or invalid');
        showLoaderError('No headers detected in file. Please ensure the first row contains column headers.');
        return false;
      }
      if (sheet.headers.length === 0) {
        console.error('[Loader] Validation failed: headers array is empty');
        showLoaderError('Empty header row detected. Please ensure the first row contains column headers.');
        return false;
      }
      // Ensure rows array exists (can be empty but must exist)
      if (!Array.isArray(sheet.rows)) {
        sheet.rows = [];
      }
      console.log('[Loader] Validation passed: order=' + workbook.order.length + ', activeSheet=' + workbook.activeSheet + ', headers=' + sheet.headers.length + ', rows=' + sheet.rows.length);
      return true;
    }
    
    // Environment mode flag (v1.6.17: Playground/Production toggle)
    var DEMO_MODE_KEY = 'orchestrate.demo_mode';
    function isDemoMode() {
      var stored = localStorage.getItem(DEMO_MODE_KEY);
      return stored === null ? false : stored === 'true'; // Default to false (production mode)
    }
    
    function setDemoMode(enabled) {
      localStorage.setItem(DEMO_MODE_KEY, enabled ? 'true' : 'false');
    }
    
    function isDemoControlsVisible() {
      return getLoggedInUserRole() === 'admin' && isDemoMode();
    }

    function applyDemoControlsVisibility() {
      var show = isDemoControlsVisible();
      var ids = ['demo-divider-or-load', 'data-source-demo-section', 'admin-demo-toggle-section', 'btn-reset-demo-state', 'btn-reset-demo-state-admin'];
      var defaults = { 'demo-divider-or-load': 'flex' };
      for (var i = 0; i < ids.length; i++) {
        var el = document.getElementById(ids[i]);
        if (el) el.style.display = show ? (defaults[ids[i]] || '') : 'none';
      }
    }

    // v1.6.24: Environment mode toggle (Playground/Production) - Admin only
    function setEnvMode(mode) {
      // Only admins can toggle playground mode
      var loggedInRole = getLoggedInUserRole();
      if (loggedInRole !== 'admin') {
        showToast('Only admins can toggle Sandbox mode', 'error');
        return;
      }
      
      var isPlayground = mode === 'playground';
      setDemoMode(isPlayground);
      setPlaygroundEnabledFlag(isPlayground);
      // v2.3 T10: In Sandbox, disable Admin role option
      var adminOption = document.querySelector('#role-selector option[value="admin"]');
      if (adminOption && isPlayground) {
        adminOption.disabled = true;
        adminOption.textContent = 'Admin (Production only)';
        if (currentMode === 'admin') { setMode('analyst'); }
      } else if (adminOption) {
        adminOption.disabled = false;
        adminOption.textContent = 'Admin';
      }
      updateEnvModeUI();
      renderUsersTable(); // Re-render to show/hide controls
      applyRoleBasedModeRestrictions(); // v1.6.24: Re-apply to update role switching
      showToast(isPlayground ? 'Sandbox mode enabled - permissionless access, no Admin role' : 'Production mode - strict role gates active', 'info');
      console.log('[EnvMode] Set to:', mode, 'by', loggedInRole);
      applyDemoControlsVisibility();
    }
    
    function updateEnvModeUI() {
      var isPlayground = isDemoMode();
      var loggedInRole = getLoggedInUserRole();
      var envModeToggle = document.getElementById('env-mode-toggle');
      var envModeSection = envModeToggle ? envModeToggle.closest('.admin-section') : null;
      var prodBtn = document.getElementById('env-mode-prod');
      var playBtn = document.getElementById('env-mode-playground');
      var addUserBtn = document.getElementById('add-user-btn');
      var modeDesc = document.getElementById('users-mode-desc');
      
      // v1.6.24: Hide entire Playground toggle section for non-admins
      if (envModeSection) {
        envModeSection.style.display = (loggedInRole === 'admin') ? 'block' : 'none';
      }
      
      if (prodBtn && playBtn) {
        if (isPlayground) {
          prodBtn.style.background = '#f5f5f5';
          prodBtn.style.color = '#666';
          playBtn.style.background = '#4caf50';
          playBtn.style.color = 'white';
        } else {
          prodBtn.style.background = '#1976d2';
          prodBtn.style.color = 'white';
          playBtn.style.background = '#f5f5f5';
          playBtn.style.color = '#666';
        }
      }
      
      if (addUserBtn) {
        // Only show add user button for admins in playground mode
        if (isPlayground && loggedInRole === 'admin') {
          addUserBtn.style.display = 'flex';
          addUserBtn.disabled = false;
        } else {
          addUserBtn.style.display = 'none';
        }
      }
      
      if (modeDesc) {
        if (loggedInRole !== 'admin') {
          modeDesc.textContent = 'Production mode: User management is read-only.';
        } else {
          modeDesc.textContent = isPlayground 
            ? 'Playground mode: You can add, edit, and delete users. Role switching is enabled.'
            : 'Production mode: User management is read-only. Role switching is disabled.';
        }
      }
    }
    
    // Record Drawer functions
    let currentRecordIndex = -1;
    let filteredContracts = [];
    
    function openRecordDrawer(contractKey, index, contracts) {
      filteredContracts = contracts || allData.contractResults || [];
      currentRecordIndex = index >= 0 ? index : filteredContracts.findIndex(c => 
        (c.contract_key || c.file_name) === contractKey
      );
      
      if (currentRecordIndex < 0) return;
      renderRecordDrawer();
      document.getElementById('record-drawer').classList.add('active');
    }
    
    function closeRecordDrawer() {
      document.getElementById('record-drawer').classList.remove('active');
    }
    
    function navigateRecord(direction) {
      const newIndex = currentRecordIndex + direction;
      if (newIndex >= 0 && newIndex < filteredContracts.length) {
        currentRecordIndex = newIndex;
        renderRecordDrawer();
      }
    }
    
    function renderRecordDrawer() {
      const contract = filteredContracts[currentRecordIndex];
      if (!contract) return;
      
      const titleEl = document.getElementById('record-drawer-title');
      const contentEl = document.getElementById('record-drawer-content');
      const posEl = document.getElementById('record-drawer-position');
      const prevBtn = document.getElementById('record-drawer-prev');
      const nextBtn = document.getElementById('record-drawer-next');
      
      const key = contract.contract_key || contract.file_name || 'Unknown';
      titleEl.textContent = key;
      posEl.textContent = `${currentRecordIndex + 1} / ${filteredContracts.length}`;
      prevBtn.disabled = currentRecordIndex <= 0;
      nextBtn.disabled = currentRecordIndex >= filteredContracts.length - 1;
      
      // Find related issues and field actions
      const joinKey = getJoinKey(contract);
      const issues = (allData.issues || []).filter(i => getJoinKey(i) === joinKey);
      const actions = (allData.fieldActions || []).filter(a => getJoinKey(a) === joinKey);
      
      const statusColor = STATUS_COLOR_MAP[(contract.sf_contract_status || '').toLowerCase()]?.text || '#757575';
      
      let html = `
        <div style="margin-bottom: 20px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
            <span style="background: ${statusColor}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; font-weight: 500;">
              ${contract.sf_contract_status || 'unknown'}
            </span>
            ${contract.detected_subtype ? `<span style="background: #e0e0e0; padding: 4px 10px; border-radius: 10px; font-size: 0.8em;">${typeof contract.detected_subtype === 'object' ? contract.detected_subtype.value : contract.detected_subtype}</span>` : ''}
          </div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <h4 style="margin: 0 0 10px 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Identity</h4>
          <table style="width: 100%; font-size: 0.9em; border-collapse: collapse;">
            <tr><td style="padding: 6px 0; color: #666; width: 100px;">Contract Key</td><td style="padding: 6px 0;">${contract.contract_key || '(none)'}</td></tr>
            <tr><td style="padding: 6px 0; color: #666;">File Name</td><td style="padding: 6px 0;">${contract.file_name || '(none)'}</td></tr>
            <tr><td style="padding: 6px 0; color: #666;">File URL</td><td style="padding: 6px 0; word-break: break-all;">${contract.file_url || '(none)'}</td></tr>
          </table>
        </div>
      `;
      
      if (issues.length > 0) {
        html += `
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 10px 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Issues (${issues.length})</h4>
            <div style="display: flex; flex-direction: column; gap: 8px;">
        `;
        issues.forEach(issue => {
          const sevColor = { blocking: '#f44336', warning: '#ff9800', info: '#2196f3' }[issue.severity] || '#757575';
          html += `
            <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; border-left: 3px solid ${sevColor};">
              <div style="font-weight: 500; margin-bottom: 4px;">${issue.issue_type || 'Unknown Issue'}</div>
              <div style="font-size: 0.85em; color: #666;">${issue.sheet || ''} ${issue.field ? '/ ' + issue.field : ''}</div>
              ${issue.details ? `<div style="font-size: 0.85em; margin-top: 6px;">${issue.details}</div>` : ''}
            </div>
          `;
        });
        html += '</div></div>';
      }
      
      if (actions.length > 0) {
        html += `
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 10px 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Field Actions (${actions.length})</h4>
            <div style="display: flex; flex-direction: column; gap: 6px;">
        `;
        actions.forEach(action => {
          html += `
            <div style="background: #e3f2fd; padding: 8px 10px; border-radius: 4px; font-size: 0.85em;">
              <strong>${action.action || 'action'}</strong>: ${action.sheet || ''}/${action.field || ''} ${action.proposed_value ? '= ' + action.proposed_value : ''}
              ${action.reason_text ? `<div style="color: #666; margin-top: 4px;">${action.reason_text}</div>` : ''}
            </div>
          `;
        });
        html += '</div></div>';
      }
      
      if (issues.length === 0 && actions.length === 0) {
        html += `<p style="color: #999; font-style: italic;">No issues or field actions for this contract.</p>`;
      }
      
      // Comments section
      const recordComments = getCommentsByTarget('record', key);
      html += `
        <div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Comments (${recordComments.length})</h4>
            <button class="toolbar-btn" style="padding: 4px 10px; font-size: 0.8em;" onclick="openAddCommentModal('record', '${escapeHtml(key)}')">+ Add Comment</button>
          </div>
      `;
      
      if (recordComments.length > 0) {
        html += '<div style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto;">';
        recordComments.forEach(c => {
          const statusColors = {
            'Open': { bg: '#e3f2fd', border: '#1976d2' },
            'VerifierResponded': { bg: '#fff3e0', border: '#e65100' },
            'Resolved': { bg: '#e8f5e9', border: '#388e3c' },
            'ElevatedToPatchRequest': { bg: '#ede7f6', border: '#5e35b1' },
            'Closed': { bg: '#f5f5f5', border: '#757575' }
          }[c.status] || { bg: '#f5f5f5', border: '#757575' };
          const date = new Date(c.created_at_utc).toLocaleDateString();
          var elevateBtn = c.status === 'Resolved' ? '<button class="toolbar-btn" style="padding: 2px 8px; font-size: 0.75em;" onclick="elevateCommentToPatchRequest(\'' + c.comment_id + '\')">Elevate to Patch</button>' : '';
          var resolveBtn = c.status === 'Open' ? '<button class="toolbar-btn" style="padding: 2px 8px; font-size: 0.75em;" onclick="resolveCommentById(\'' + c.comment_id + '\')">Resolve</button>' : '';
          html += '<div style="background: ' + statusColors.bg + '; padding: 10px; border-radius: 6px; border-left: 3px solid ' + statusColors.border + ';">' +
            '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">' +
            '<span style="font-weight: 500; font-size: 0.85em;">' + c.status + '</span>' +
            '<span style="font-size: 0.75em; color: #666;">' + date + '</span>' +
            '</div>' +
            '<div style="font-size: 0.9em;">' + escapeHtml(c.content) + '</div>' +
            '<div style="margin-top: 8px; display: flex; gap: 6px;">' + elevateBtn + resolveBtn + '</div>' +
            '</div>';
        });
        html += '</div>';
      } else {
        html += '<p style="color: #999; font-style: italic; font-size: 0.85em;">No comments for this record.</p>';
      }
      html += '</div>';
      
      contentEl.innerHTML = html;
    }
    
    function showEvidenceStatus() {
      // Navigate to patch studio to show preflight status
      navigateTo('patch');
      const preflightToggle = document.getElementById('preflight-toggle');
      if (preflightToggle) preflightToggle.click();
    }
    
    // Settings Management
    function loadUserSettings() {
      try {
        const saved = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (saved) {
          userSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
        }
      } catch (e) {
        console.warn('Failed to load user settings:', e);
      }
    }
    
    function saveUserSettings() {
      try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(userSettings));
      } catch (e) {
        console.warn('Failed to save user settings:', e);
      }
    }
    
    function checkFirstRun() {
      const dismissed = localStorage.getItem(FIRST_RUN_DISMISSED_KEY);
      const banner = document.getElementById('first-run-banner');
      
      // Show banner if: not configured AND not dismissed
      if (!userSettings.configured && !dismissed && banner) {
        banner.style.display = 'flex';
      }
    }
    
    function dismissFirstRunBanner() {
      const banner = document.getElementById('first-run-banner');
      if (banner) banner.style.display = 'none';
      localStorage.setItem(FIRST_RUN_DISMISSED_KEY, 'true');
    }
    
    async function autoSetupRepoMasters() {
      // Auto-load Repo Masters (dev baseline) when present
      if (!userSettings.use_repo_masters) return;
      
      try {
        const response = await fetch(RELATIVE_PRIMARY);
        if (response.ok) {
          const data = await response.json();
          if (data.sf_summary || data.sf_contract_results) {
            allData.contractResults = data.sf_contract_results || [];
            // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
            allData.issues = filterOutReferenceData(data.sf_issues || []);
            allData.fieldActions = filterOutReferenceData(data.sf_field_actions || []);
            allData.summary = data.sf_summary || {};
            allData.changeLog = data.changelog || [];
            dataLoaded = true;
            sessionState = { status: 'loaded', sourceType: 'fetch', loadedAt: new Date().toISOString() };
            currentArtifactPath = RELATIVE_PRIMARY;
            updateUIForDataState();
            renderSummary();
            renderAllTables();
            updateQueueCounts();
          }
        }
      } catch (e) {
        // Silently fail - user can manually load data
      }
    }
    
    let currentWizardStep = 0;
    const WIZARD_STEPS = [
      { id: 'WELCOME', title: 'Welcome' },
      { id: 'DATA_SOURCES', title: 'Data Sources' },
      { id: 'WORKFLOW_DEFAULTS', title: 'Workflow Defaults' },
      { id: 'DONE', title: 'Finish' }
    ];
    
    function openConfigureWizard() {
      currentWizardStep = 0;
      document.getElementById('configure-wizard-modal').classList.add('active');
      renderConfigureWizardStep(0);
    }
    
    function closeConfigureWizard() {
      document.getElementById('configure-wizard-modal').classList.remove('active');
    }
    
    // Config Flows Panel
    let currentConfigFlowStage = 'data_sources';
    let currentConfigFlowTab = 'plain-english';
    let masterEditMode = false;
    let masterDraft = {};
    let sessionConfig = {};
    let configHistory = [];
    
    const CONFIG_FLOW_STAGES = {
      data_sources: {
        title: 'Data Sources',
        desc: 'Configure where Preview and Reference packets are loaded from.',
        plainEnglish: `<p>This stage controls how data enters the system.</p>
          <p style="margin-top: 10px;"><strong>What it does:</strong> Defines the primary and comparison data sources for your session.</p>
          <ul style="margin: 10px 0 0 20px;">
            <li><strong>Repo Masters</strong> - Auto-load from repository (recommended for dev)</li>
            <li><strong>Paste JSON</strong> - Manual paste of Preview Packet data</li>
            <li><strong>Drag & Drop</strong> - Upload a file directly</li>
            <li><strong>Local Path Hint</strong> - Reference files by path</li>
          </ul>`
      },
      dataset_mapping: {
        title: 'Dataset Mapping',
        desc: 'Define how input sheets map to semantic entities.',
        plainEnglish: '<p>Maps incoming data columns to semantic fields. Ensures consistent naming across sources.</p>'
      },
      standardization: {
        title: 'Standardization',
        desc: 'Normalize data formats and values.',
        plainEnglish: '<p>Applies formatting rules to ensure data consistency (dates, currencies, text casing).</p>'
      },
      ruleset: {
        title: 'Ruleset',
        desc: 'WHEN/THEN rules that determine field actions and issues.',
        plainEnglish: '<p>The heart of semantic governance. Rules define:</p><ul style="margin: 10px 0 0 20px;"><li>When a condition is met (WHEN)</li><li>What action to take (THEN)</li><li>Severity level (info, warning, blocking)</li></ul>'
      },
      validation_gates: {
        title: 'Validation Gates',
        desc: 'Preflight checks before data can proceed.',
        plainEnglish: '<p>Evidence gates that must pass before publishing:</p><ul style="margin: 10px 0 0 20px;"><li>Validation: Schema and format checks</li><li>Conflicts: No duplicate or conflicting rules</li><li>Smoke Baseline: Expected output matches</li></ul>'
      },
      patch_generation: {
        title: 'Patch Generation',
        desc: 'Configure how patches are built from field actions.',
        plainEnglish: '<p>Controls how proposed fixes are packaged into patch format for review.</p>'
      },
      smoke_baselines: {
        title: 'Smoke Baselines',
        desc: 'Reference outputs for determinism checks.',
        plainEnglish: '<p>Golden files that define expected outputs. Used to verify changes don\'t break existing behavior.</p>'
      },
      export: {
        title: 'Export / PR Summary',
        desc: 'Bundle outputs for pull request review.',
        plainEnglish: '<p>Generate exportable bundles with:</p><ul style="margin: 10px 0 0 20px;"><li>Patch file</li><li>Changelog entry</li><li>Evidence summary</li><li>PR description template</li></ul>'
      }
    };
    
    function openConfigFlows() {
      if (currentMode !== 'admin') {
        alert('Config Flows requires Admin mode.');
        return;
      }
      document.getElementById('config-flows-drawer').classList.add('active');
      selectConfigFlowStage('data_sources');
    }
    
    function closeConfigFlows() {
      document.getElementById('config-flows-drawer').classList.remove('active');
      masterEditMode = false;
    }
    
    function escapeHtml(str) {
      if (!str) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
    
    function getMasterConfig(stage) {
      if (sessionConfig[stage]) return sessionConfig[stage];
      const defaults = {
        data_sources: { stage: 'data_sources', version: '1.0.0', sources: ['sf_packet.preview.json'] },
        field_mapping: { stage: 'field_mapping', version: '1.0.0', mappings: [] },
        rules_engine: { stage: 'rules_engine', version: '1.0.0', rules: [] },
        qa_checks: { stage: 'qa_checks', version: '1.0.0', checks: [] },
        resolution: { stage: 'resolution', version: '1.0.0', strategy: 'auto' },
        enrichment: { stage: 'enrichment', version: '1.0.0', enrichers: [] },
        approval: { stage: 'approval', version: '1.0.0', workflow: 'standard' },
        export: { stage: 'export', version: '1.0.0', format: 'json' }
      };
      return defaults[stage] || { stage, version: '1.0.0' };
    }
    
    function enterMasterEditMode() {
      masterEditMode = true;
      renderConfigFlowTabContent();
    }
    
    function cancelMasterEdit() {
      masterEditMode = false;
      renderConfigFlowTabContent();
    }
    
    function validateMasterConfig() {
      const textarea = document.getElementById('master-edit-area');
      const msgEl = document.getElementById('master-validation-msg');
      if (!textarea || !msgEl) return;
      
      try {
        JSON.parse(textarea.value);
        msgEl.style.display = 'block';
        msgEl.style.background = '#e8f5e9';
        msgEl.style.color = '#2e7d32';
        msgEl.textContent = 'Valid JSON configuration';
        return true;
      } catch (e) {
        msgEl.style.display = 'block';
        msgEl.style.background = '#ffebee';
        msgEl.style.color = '#c62828';
        msgEl.textContent = 'Invalid JSON: ' + e.message;
        return false;
      }
    }
    
    function saveMasterDraft() {
      const textarea = document.getElementById('master-edit-area');
      if (!textarea) return;
      
      if (!validateMasterConfig()) return;
      
      masterDraft[currentConfigFlowStage] = textarea.value;
      masterEditMode = false;
      renderConfigFlowTabContent();
      showToast('Draft saved for ' + CONFIG_FLOW_STAGES[currentConfigFlowStage]?.title);
    }
    
    function publishMasterConfig() {
      const stage = currentConfigFlowStage;
      const draftJson = masterDraft[stage];
      
      if (!draftJson) {
        showToast('No changes to publish', 'warning');
        return;
      }
      
      try {
        const config = JSON.parse(draftJson);
        const previousConfig = sessionConfig[stage] ? JSON.stringify(sessionConfig[stage]) : null;
        
        sessionConfig[stage] = config;
        configHistory.push({
          stage,
          timestamp: new Date().toISOString(),
          action: 'publish',
          previousValue: previousConfig,
          newValue: draftJson
        });
        
        delete masterDraft[stage];
        masterEditMode = false;
        renderConfigFlowTabContent();
        showToast('Published to session: ' + CONFIG_FLOW_STAGES[stage]?.title);
        refreshSessionFromConfig();
      } catch (e) {
        showToast('Failed to publish: ' + e.message, 'error');
      }
    }
    
    function revertMasterConfig() {
      delete masterDraft[currentConfigFlowStage];
      masterEditMode = false;
      renderConfigFlowTabContent();
      showToast('Reverted changes');
    }
    
    function refreshSessionFromConfig() {
      console.log('Session config updated:', sessionConfig);
      
      var configChip = document.getElementById('config-status-chip');
      if (configChip) {
        var customCount = Object.keys(sessionConfig).length;
        if (customCount > 0) {
          configChip.textContent = customCount + ' custom config(s)';
          configChip.style.background = '#e3f2fd';
          configChip.style.color = '#1565c0';
          configChip.style.display = 'inline-block';
        } else {
          configChip.style.display = 'none';
        }
      }
    }
    
    function showToast(message, type) {
      type = type || 'success';
      var existing = document.querySelector('.config-toast');
      if (existing) existing.remove();
      
      var toast = document.createElement('div');
      toast.className = 'config-toast';
      var bgColor = '#2e7d32';
      if (type === 'error') bgColor = '#c62828';
      else if (type === 'warning') bgColor = '#f57c00';
      toast.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: ' + bgColor + '; color: white; border-radius: 6px; font-size: 0.9em; z-index: 10001; box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 80vw; max-width: calc(100vw - 200px);';
      console.log('[P0.9-CLEANUP] overlap_guard_ok: toast positioned clear of toolbar');
      console.log('[TRIAGE-ANALYTICS][P0.2] layout_safezone_applied: toast=top-center, fab=bottom-right, audit-dropdown=z90, search-bar=z100');
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(function() { toast.remove(); }, 3000);
    }
    
    // ========== DEBUG PANEL (v1.5.2) ==========
    // Show debug panel when ?debug=1 is in URL
    var debugPanelState = {
      visible: false,
      data: {}
    };
    
    function initDebugPanel() {
      var urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('debug') === '1') {
        debugPanelState.visible = true;
        createDebugPanelUI();
        console.log('[DEBUG] Debug panel enabled via ?debug=1');
      }
    }
    
    function createDebugPanelUI() {
      var panel = document.createElement('div');
      panel.id = 'debug-panel';
      panel.style.cssText = 'position: fixed; bottom: 80px; right: 20px; width: 320px; max-height: 400px; overflow-y: auto; background: #1a1a2e; color: #00ff88; font-family: monospace; font-size: 11px; padding: 12px; border-radius: 8px; z-index: 10002; box-shadow: 0 4px 20px rgba(0,0,0,0.5); border: 1px solid #00ff88;';
      panel.innerHTML = '<div style="font-weight: bold; margin-bottom: 8px; color: #fff; font-size: 12px;">DEBUG PANEL</div><div id="debug-content">Initializing...</div>';
      document.body.appendChild(panel);
      
      // Initial update
      updateDebugPanel({
        role: currentMode,
        tenant_id: IDENTITY_CONTEXT.tenant_id,
        division_id: IDENTITY_CONTEXT.division_id,
        dataset_id: IDENTITY_CONTEXT.dataset_id || '(not set)',
        record_id: '(none)',
        patch_request_id: '(none)'
      });
    }
    
    function updateDebugPanel(data) {
      if (!debugPanelState.visible) return;
      
      // Merge with existing data
      Object.assign(debugPanelState.data, data);
      
      var content = document.getElementById('debug-content');
      if (!content) return;
      
      var html = '';
      var keys = ['role', 'tenant_id', 'division_id', 'dataset_id', 'record_id', 'patch_request_id', 'patchRequest_load', 'record_load', 'storageKey'];
      keys.forEach(function(key) {
        var val = debugPanelState.data[key];
        if (val !== undefined) {
          var color = '#00ff88';
          if (val === 'FAILED') color = '#ff4444';
          else if (val === 'SUCCESS') color = '#44ff44';
          html += '<div style="margin: 4px 0;"><span style="color: #888;">' + key + ':</span> <span style="color: ' + color + ';">' + val + '</span></div>';
        }
      });
      
      // Add storage key info
      var prKey = debugPanelState.data.patch_request_id;
      if (prKey && prKey !== '(none)') {
        var storageKey = 'pr:' + ARTIFACT_STORE.environment + ':' + prKey;
        html += '<div style="margin: 8px 0 4px; color: #888; font-size: 10px;">Storage Key:</div>';
        html += '<div style="color: #ffa500; word-break: break-all; font-size: 10px;">' + storageKey + '</div>';
      }
      
      content.innerHTML = html;
    }
    
    // Initialize debug panel and rules bundle on load
    document.addEventListener('DOMContentLoaded', function() {
      initDebugPanel();
      loadRulesBundle();  // v1.5.7: Load rules bundle for Field Inspector ordering
    });
    

    
    // Global Search Stub (V2)
    function handleGlobalSearchKeydown(event) {
      if (event.key === 'Enter') {
        var query = event.target.value.trim();
        if (query) {
          showToast('Search coming soon (V2)', 'info');
        }
      }
    }
    
    // Global keyboard shortcut for search
    document.addEventListener('keydown', function(e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        var searchBar = document.getElementById('triage-search-bar');
        var searchInput = document.getElementById('global-search-input');
        if (searchBar) {
          searchBar.style.opacity = '1';
          searchBar.style.transform = 'translateY(0)';
        }
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        }
      }
    });
    
    // Scroll-aware search bar (hide on scroll, show on stop)
    (function() {
      var scrollTimeout = null;
      var lastScrollY = 0;
      var searchBar = null;
      
      function getSearchBar() {
        if (!searchBar) searchBar = document.getElementById('triage-search-bar');
        return searchBar;
      }
      
      function hideSearchBar() {
        var bar = getSearchBar();
        if (bar && document.activeElement !== document.getElementById('global-search-input')) {
          bar.style.opacity = '0';
          bar.style.transform = 'translateY(-10px)';
        }
      }
      
      function showSearchBar() {
        var bar = getSearchBar();
        if (bar) {
          bar.style.opacity = '1';
          bar.style.transform = 'translateY(0)';
        }
      }
      
      window.addEventListener('scroll', function() {
        var currentScrollY = window.scrollY;
        
        // If scrolling down, hide
        if (currentScrollY > lastScrollY && currentScrollY > 50) {
          hideSearchBar();
        }
        
        lastScrollY = currentScrollY;
        
        // Clear existing timeout
        if (scrollTimeout) clearTimeout(scrollTimeout);
        
        // Show after scroll stops (300ms delay)
        scrollTimeout = setTimeout(function() {
          showSearchBar();
        }, 300);
      }, { passive: true });
    })();
    
    function selectConfigFlowStage(stage) {
      masterEditMode = false;
      currentConfigFlowStage = stage;
      
      // Update rail selection
      document.querySelectorAll('.rail-item').forEach(item => {
        item.classList.toggle('active', item.dataset.stage === stage);
      });
      
      // Update header
      const stageConfig = CONFIG_FLOW_STAGES[stage] || {};
      document.getElementById('config-flow-stage-title').textContent = stageConfig.title || stage;
      document.getElementById('config-flow-stage-desc').textContent = stageConfig.desc || '';
      
      // Render current tab content
      renderConfigFlowTabContent();
    }
    
    function selectConfigFlowTab(tab) {
      currentConfigFlowTab = tab;
      
      // Update tab selection
      document.querySelectorAll('.stage-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
      });
      
      renderConfigFlowTabContent();
    }
    
    function renderConfigFlowTabContent() {
      const container = document.getElementById('config-flow-tab-content');
      const stageConfig = CONFIG_FLOW_STAGES[currentConfigFlowStage] || {};
      let html = '';
      
      if (currentConfigFlowTab === 'plain-english') {
        html = `<div style="padding: 15px; background: #f5f5f5; border-radius: 6px;">${stageConfig.plainEnglish || '<p>No documentation available.</p>'}</div>`;
      } else if (currentConfigFlowTab === 'payload') {
        const effectiveConfig = getMasterConfig(currentConfigFlowStage);
        const isCustom = sessionConfig[currentConfigFlowStage] !== undefined;
        html = `<div style="padding: 15px; background: #263238; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.85em;">
          <div style="margin-bottom: 10px; color: #78909c;">// Effective config (resolved view)</div>
          <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(JSON.stringify(effectiveConfig, null, 2))}</pre>
        </div>
        <div style="margin-top: 10px; display: flex; gap: 8px;">
          <span style="background: ${isCustom ? '#e3f2fd' : '#e8f5e9'}; color: ${isCustom ? '#1565c0' : '#2e7d32'}; padding: 4px 8px; border-radius: 4px; font-size: 0.75em;">${isCustom ? 'CUSTOM' : 'MASTER'}</span>
          ${!isCustom ? '<span style="background: #fff3e0; color: #e65100; padding: 4px 8px; border-radius: 4px; font-size: 0.75em;">DEFAULT</span>' : ''}
        </div>`;
      } else if (currentConfigFlowTab === 'master') {
        const masterConfig = getMasterConfig(currentConfigFlowStage);
        const configJson = JSON.stringify(masterConfig, null, 2);
        const hasChanges = masterDraft[currentConfigFlowStage] !== undefined;
        const draftJson = hasChanges ? masterDraft[currentConfigFlowStage] : configJson;
        
        if (masterEditMode) {
          html = `<div style="margin-bottom: 10px;">
            <div id="master-validation-msg" style="display: none; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px;"></div>
            <textarea id="master-edit-area" style="width: 100%; height: 200px; font-family: monospace; font-size: 0.85em; background: #263238; color: #eceff1; border: 2px solid #5c6bc0; border-radius: 6px; padding: 15px; resize: vertical;">${escapeHtml(draftJson)}</textarea>
          </div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="modal-btn modal-btn-secondary" onclick="validateMasterConfig()">Validate</button>
            <button class="modal-btn modal-btn-primary" onclick="saveMasterDraft()">Save Draft</button>
            <button class="modal-btn" style="background: #7c4dff; color: white;" onclick="publishMasterConfig()">Publish to Session</button>
            <button class="modal-btn" style="margin-left: auto;" onclick="cancelMasterEdit()">Cancel</button>
          </div>`;
        } else {
          html = `<div style="padding: 15px; background: #263238; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.85em; min-height: 150px;">
            <div style="margin-bottom: 10px; color: #78909c;">// Master config ${hasChanges ? '(unsaved changes)' : ''}</div>
            <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(hasChanges ? draftJson : configJson)}</pre>
          </div>
          <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="modal-btn modal-btn-secondary" onclick="enterMasterEditMode()">Edit</button>
            <button class="modal-btn modal-btn-primary" onclick="publishMasterConfig()" ${hasChanges ? '' : 'disabled'}>Publish to Session</button>
            <button class="modal-btn" style="margin-left: auto;" onclick="revertMasterConfig()" ${hasChanges ? '' : 'disabled'}>Revert</button>
          </div>`;
        }
      } else if (currentConfigFlowTab === 'diff') {
        const hasChanges = masterDraft[currentConfigFlowStage] !== undefined;
        if (hasChanges) {
          const masterConfig = getMasterConfig(currentConfigFlowStage);
          const currentJson = JSON.stringify(masterConfig, null, 2);
          const draftJson = masterDraft[currentConfigFlowStage];
          html = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <div style="font-weight: 600; margin-bottom: 8px; color: #666;">Current (Published)</div>
              <div style="padding: 12px; background: #263238; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 200px; overflow: auto;">
                <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(currentJson)}</pre>
              </div>
            </div>
            <div>
              <div style="font-weight: 600; margin-bottom: 8px; color: #5c6bc0;">Draft (Pending)</div>
              <div style="padding: 12px; background: #1a237e; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 200px; overflow: auto; border: 2px solid #5c6bc0;">
                <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(draftJson)}</pre>
              </div>
            </div>
          </div>
          <div style="margin-top: 15px; display: flex; gap: 10px;">
            <button class="modal-btn" style="background: #7c4dff; color: white;" onclick="publishMasterConfig()">Publish Changes</button>
            <button class="modal-btn" onclick="revertMasterConfig()">Discard</button>
          </div>`;
        } else {
          html = `<div style="padding: 20px; text-align: center; color: #666;">
            <p>No differences detected.</p>
            <p style="font-size: 0.85em; margin-top: 10px;">Master and Effective Payload are identical.</p>
          </div>`;
        }
      } else if (currentConfigFlowTab === 'history') {
        const stageHistory = configHistory.filter(h => h.stage === currentConfigFlowStage);
        if (stageHistory.length > 0) {
          const historyItems = stageHistory.slice().reverse().map(h => `
            <div style="padding: 12px; background: #f5f5f5; border-radius: 6px; margin-bottom: 8px;">
              <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                <span style="font-weight: 600; color: #333;">${h.action === 'publish' ? 'Published' : h.action}</span>
                <span style="font-size: 0.8em; color: #666;">${new Date(h.timestamp).toLocaleString()}</span>
              </div>
              <div style="font-size: 0.85em; color: #666;">Configuration updated</div>
            </div>
          `).join('');
          html = `<div style="max-height: 300px; overflow-y: auto;">${historyItems}</div>`;
        } else {
          html = `<div style="padding: 20px; text-align: center; color: #666;">
            <p>No history entries.</p>
            <p style="font-size: 0.85em; margin-top: 10px;">Changes will be recorded here when you edit and publish.</p>
          </div>`;
        }
      }
      
      container.innerHTML = html;
    }
    
    function wizardBack() {
      if (currentWizardStep > 0) {
        currentWizardStep--;
        renderConfigureWizardStep(currentWizardStep);
      }
    }
    
    function wizardNext() {
      saveWizardStepData(currentWizardStep);
      
      if (currentWizardStep < WIZARD_STEPS.length - 1) {
        currentWizardStep++;
        renderConfigureWizardStep(currentWizardStep);
      } else {
        // Finish wizard
        userSettings.configured = true;
        saveUserSettings();
        closeConfigureWizard();
        dismissFirstRunBanner();
        
        // Apply settings immediately
        if (userSettings.use_repo_masters && !dataLoaded) {
          autoSetupRepoMasters();
        }
      }
    }
    
    function saveWizardStepData(step) {
      if (step === 0) {
        userSettings.use_repo_masters = document.getElementById('wiz-use-repo-masters')?.checked ?? true;
      } else if (step === 1) {
        userSettings.preferred_load_method = document.getElementById('wiz-load-method')?.value || 'Repo Masters';
        userSettings.local_data_root = document.getElementById('wiz-local-path')?.value || '';
      } else if (step === 2) {
        const checkboxes = document.querySelectorAll('.wiz-queue-checkbox:checked');
        userSettings.default_queues = Array.from(checkboxes).map(cb => cb.value);
        userSettings.compare_mode_default = document.getElementById('wiz-compare-default')?.checked ?? true;
      }
    }
    
    function renderConfigureWizardStep(step) {
      const titleEl = document.getElementById('wizard-step-title');
      const contentEl = document.getElementById('wizard-step-content');
      const backBtn = document.getElementById('wizard-back');
      const nextBtn = document.getElementById('wizard-next');
      
      // Update progress dots
      document.querySelectorAll('.wizard-step-dot').forEach((dot, i) => {
        dot.classList.toggle('active', i === step);
        dot.classList.toggle('completed', i < step);
      });
      
      titleEl.textContent = WIZARD_STEPS[step].title;
      backBtn.style.display = step === 0 ? 'none' : 'inline-block';
      nextBtn.textContent = step === WIZARD_STEPS.length - 1 ? 'Finish' : 'Next';
      
      let html = '';
      
      if (step === 0) {
        html = `
          <p style="margin-bottom: 20px; color: #555;">We'll set up where your files live and what you want to see first.</p>
          <div class="wizard-toggle">
            <input type="checkbox" id="wiz-use-repo-masters" ${userSettings.use_repo_masters ? 'checked' : ''}>
            <div class="wizard-toggle-label">
              <strong>Use Repo Masters</strong>
              <small>Recommended for dev/testing. Auto-loads preview data from the repository.</small>
            </div>
          </div>
        `;
      } else if (step === 1) {
        html = `
          <p style="margin-bottom: 20px; color: #555;">Choose how you'll load your Preview and Reference packets.</p>
          <div class="wizard-form-group">
            <label>Default Load Method</label>
            <select id="wiz-load-method" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px;">
              <option value="Repo Masters" ${userSettings.preferred_load_method === 'Repo Masters' ? 'selected' : ''}>Repo Masters</option>
              <option value="Paste JSON" ${userSettings.preferred_load_method === 'Paste JSON' ? 'selected' : ''}>Paste JSON</option>
              <option value="Drag & Drop" ${userSettings.preferred_load_method === 'Drag & Drop' ? 'selected' : ''}>Drag & Drop</option>
              <option value="Local Path Hint" ${userSettings.preferred_load_method === 'Local Path Hint' ? 'selected' : ''}>Local Path Hint</option>
            </select>
          </div>
          <div class="wizard-form-group">
            <label>Local Folder (optional)</label>
            <input type="text" id="wiz-local-path" value="${userSettings.local_data_root}" placeholder="e.g., out/" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px;">
            <div class="hint">Used only for path hints; nothing uploads or syncs.</div>
          </div>
        `;
      } else if (step === 2) {
        const queues = ['To Do', 'Needs Review', 'Flagged', 'Blocked', 'Finalized'];
        html = `
          <p style="margin-bottom: 20px; color: #555;">Pick what queues and panels you want visible by default.</p>
          <div class="wizard-form-group">
            <label>Queues to Show</label>
            <div class="wizard-multi-select">
              ${queues.map(q => `
                <label>
                  <input type="checkbox" class="wiz-queue-checkbox" value="${q}" ${userSettings.default_queues.includes(q) ? 'checked' : ''}>
                  ${q}
                </label>
              `).join('')}
            </div>
          </div>
          <div class="wizard-toggle" style="margin-top: 15px;">
            <input type="checkbox" id="wiz-compare-default" ${userSettings.compare_mode_default ? 'checked' : ''}>
            <div class="wizard-toggle-label">
              <strong>Enable Compare View by Default</strong>
              <small>Show comparison panel when loading data.</small>
            </div>
          </div>
        `;
      } else if (step === 3) {
        html = `
          <div style="text-align: center; padding: 20px 0;">
            <div style="font-size: 3em; margin-bottom: 15px;">&#10004;</div>
            <h3 style="margin: 0 0 10px; color: #4caf50;">You're All Set!</h3>
            <p style="color: #666;">You can change these anytime in Admin &rarr; Settings.</p>
            <div style="background: #f5f5f5; border-radius: 8px; padding: 15px; margin-top: 20px; text-align: left;">
              <div style="font-size: 0.85em; color: #666; margin-bottom: 8px;">Your settings:</div>
              <ul style="margin: 0; padding-left: 20px; font-size: 0.9em;">
                <li>Load method: <strong>${userSettings.preferred_load_method}</strong></li>
                <li>Auto-load repo masters: <strong>${userSettings.use_repo_masters ? 'Yes' : 'No'}</strong></li>
                <li>Default queues: <strong>${userSettings.default_queues.join(', ') || 'All'}</strong></li>
              </ul>
            </div>
          </div>
        `;
      }
      
      contentEl.innerHTML = html;
    }
    
    // Note: Primary resetSession is defined earlier. This is a legacy duplicate kept for reference.
    // The main resetSession() navigates to loader after clearing data.

    // Modal functions
    function openRulesetModal() {
      document.getElementById('ruleset-modal').classList.add('active');
    }
    function closeRulesetModal() {
      document.getElementById('ruleset-modal').classList.remove('active');
    }
    function openCompareModal() {
      document.getElementById('compare-modal').classList.add('active');
    }
    function closeCompareModal() {
      document.getElementById('compare-modal').classList.remove('active');
    }
    function openRunModal() {
      document.getElementById('run-modal').classList.add('active');
    }
    function closeRunModal() {
      document.getElementById('run-modal').classList.remove('active');
    }

    function setActiveQueue(queue) {
      document.querySelectorAll('.nav-item.queue-item').forEach(item => {
        if (item.dataset.queue === queue) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
      // Optionally filter the triage table by queue status
      if (typeof filterTriageByQueue === 'function') {
        filterTriageByQueue(queue);
      }
    }
    
    function initRouter() {
      document.querySelectorAll('.nav-item[data-page]').forEach(item => {
        item.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const page = item.dataset.page;
          const queue = item.dataset.queue;
          console.log('[Router] Click on nav-item, page:', page, 'queue:', queue);
          navigateTo(page);
          if (queue) {
            setActiveQueue(queue);
          }
        });
      });
      
      document.querySelectorAll('.mode-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          setMode(btn.getAttribute('data-mode'));
        });
      });
      
      // v1.4.14: Track full route including params to prevent loops
      var currentRoute = 'triage';
      
      window.addEventListener('hashchange', function() {
        var hash = window.location.hash.replace('#/', '') || 'triage';
        // Prevent duplicate navigation - compare full route, not just page name
        if (currentRoute !== hash) {
          console.log('[Router] Hashchange to:', hash);
          currentRoute = hash;
          navigateTo(hash);
        }
      });
      
      // Load user settings and check for first run
      loadUserSettings();
      checkFirstRun();
      
      // Setup loader modal events
      setupLoaderModalEvents();
      
      // v1.4.24: Clear stale verifier data BEFORE setMode loads queues
      if (!dataLoaded) {
        clearStaleVerifierData();
      }
      
      // v1.4.20: Check for role from landing page first, then viewer mode
      var savedMode = localStorage.getItem('currentRole') || localStorage.getItem('viewer_mode_v10');
      // Convert legacy 'operator' mode to 'analyst'
      if (savedMode === 'operator') savedMode = 'analyst';
      if (savedMode) setMode(savedMode);
      else setMode('analyst');
      
      // Sync landing page role back to viewer mode storage
      if (localStorage.getItem('currentRole')) {
        localStorage.setItem('viewer_mode_v10', localStorage.getItem('currentRole'));
      }
      
      // v1.6.22: Apply role-based mode restrictions
      applyRoleBasedModeRestrictions();
      updateSidebarUserProfile();
      
      // v1.4.22: Default route based on role
      // v2.3.6: Always default to triage on initial load for all roles
      // Only preserve hash for deep-linked pages (admin-review, srr)
      var _initHash = window.location.hash.replace('#/', '') || '';
      var _isDeepLink = _initHash && (_initHash.indexOf('admin-review/') === 0 || _initHash.indexOf('srr/') === 0);
      if (_isDeepLink) {
        navigateTo(_initHash);
      } else {
        navigateToRoleDefault();
      }
      
      // Auto-setup repo masters if enabled
      if (userSettings.use_repo_masters && !dataLoaded) {
        autoSetupRepoMasters();
      }
      
    }

    function getRecordHash(record) {
      const sorted = sortObjectKeys(record);
      return JSON.stringify(sorted);
    }

    function getJoinKey(record) {
      const identity = getJoinIdentity(record);
      return `${identity.contract_key || ''}|${identity.file_url || ''}|${identity.file_name || ''}`;
    }

    function getRowKey(record, type) {
      const jk = getJoinKey(record);
      if (type === 'contractResults') {
        return jk;
      } else if (type === 'issues') {
        return `${jk}|${record.sheet || ''}|${record.field || ''}|${record.issue_type || ''}`;
      } else if (type === 'fieldActions') {
        return `${jk}|${record.sheet || ''}|${record.field || ''}|${record.action || ''}`;
      }
      return jk;
    }

    function computeRowChanges(primaryArr, compareArr, type) {
      const changes = {};
      const primaryMap = new Map();
      const compareMap = new Map();
      
      primaryArr.forEach(r => {
        const key = getRowKey(r, type);
        primaryMap.set(key, { record: r, hash: getRecordHash(r) });
      });
      
      compareArr.forEach(r => {
        const key = getRowKey(r, type);
        compareMap.set(key, { record: r, hash: getRecordHash(r) });
      });
      
      primaryMap.forEach((val, key) => {
        if (!compareMap.has(key)) {
          changes[key] = 'added';
        } else if (val.hash !== compareMap.get(key).hash) {
          changes[key] = 'changed';
        }
      });
      
      compareMap.forEach((val, key) => {
        if (!primaryMap.has(key)) {
          changes[key] = 'removed';
        }
      });
      
      return changes;
    }

    function computeDeltaStats(primary, compare) {
      const pSum = primary.sf_summary || {};
      const cSum = compare.sf_summary || {};
      
      return {
        contracts: (pSum.contracts || 0) - (cSum.contracts || 0),
        ready: (pSum.ready || 0) - (cSum.ready || 0),
        needsReview: (pSum.needs_review || 0) - (cSum.needs_review || 0),
        blocked: (pSum.blocked || 0) - (cSum.blocked || 0),
        issues: {
          added: Object.values(rowChanges.issues).filter(v => v === 'added').length,
          changed: Object.values(rowChanges.issues).filter(v => v === 'changed').length,
          removed: Object.values(rowChanges.issues).filter(v => v === 'removed').length
        },
        actions: {
          added: Object.values(rowChanges.fieldActions).filter(v => v === 'added').length,
          changed: Object.values(rowChanges.fieldActions).filter(v => v === 'changed').length,
          removed: Object.values(rowChanges.fieldActions).filter(v => v === 'removed').length
        }
      };
    }

    function renderDeltaSummary() {
      const container = document.getElementById('delta-container');
      if (!deltaStats) {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      
      const formatDelta = (val) => val > 0 ? `+${val}` : val.toString();
      const getClass = (val) => val > 0 ? 'positive' : val < 0 ? 'negative' : 'neutral';
      
      container.innerHTML = `
        <h2>Delta Summary (vs. Previous)</h2>
        <div class="compare-actions">
          <button class="compare-btn" id="copy-delta-summary">Copy Delta Summary (Markdown)</button>
        </div>
        <div class="compare-legend">
          <span class="compare-legend-item"><span class="compare-legend-dot added"></span> Added</span>
          <span class="compare-legend-item"><span class="compare-legend-dot changed"></span> Changed</span>
          <span class="compare-legend-item"><span class="compare-legend-dot removed"></span> Removed</span>
        </div>
        <div class="delta-summary">
          <div class="delta-card ${getClass(deltaStats.contracts)}">
            <div class="delta-value ${getClass(deltaStats.contracts)}">${formatDelta(deltaStats.contracts)}</div>
            <div class="delta-label">Contracts</div>
          </div>
          <div class="delta-card ${getClass(deltaStats.ready)}">
            <div class="delta-value ${getClass(deltaStats.ready)}">${formatDelta(deltaStats.ready)}</div>
            <div class="delta-label">Ready</div>
          </div>
          <div class="delta-card ${getClass(deltaStats.needsReview)}">
            <div class="delta-value ${getClass(deltaStats.needsReview)}">${formatDelta(deltaStats.needsReview)}</div>
            <div class="delta-label">Needs Review</div>
          </div>
          <div class="delta-card ${getClass(deltaStats.blocked)}">
            <div class="delta-value ${getClass(deltaStats.blocked)}">${formatDelta(deltaStats.blocked)}</div>
            <div class="delta-label">Blocked</div>
          </div>
          <div class="delta-card ${deltaStats.issues.added > 0 ? 'positive' : 'neutral'}">
            <div class="delta-value ${deltaStats.issues.added > 0 ? 'positive' : 'neutral'}">+${deltaStats.issues.added}</div>
            <div class="delta-label">Issues Added</div>
          </div>
          <div class="delta-card ${deltaStats.issues.changed > 0 ? 'neutral' : 'neutral'}">
            <div class="delta-value neutral">${deltaStats.issues.changed}</div>
            <div class="delta-label">Issues Changed</div>
          </div>
          <div class="delta-card ${deltaStats.issues.removed > 0 ? 'negative' : 'neutral'}">
            <div class="delta-value ${deltaStats.issues.removed > 0 ? 'negative' : 'neutral'}">${deltaStats.issues.removed > 0 ? '-' : ''}${deltaStats.issues.removed}</div>
            <div class="delta-label">Issues Removed</div>
          </div>
          <div class="delta-card ${deltaStats.actions.added > 0 ? 'positive' : 'neutral'}">
            <div class="delta-value ${deltaStats.actions.added > 0 ? 'positive' : 'neutral'}">+${deltaStats.actions.added}</div>
            <div class="delta-label">Actions Added</div>
          </div>
          <div class="delta-card ${deltaStats.actions.removed > 0 ? 'negative' : 'neutral'}">
            <div class="delta-value ${deltaStats.actions.removed > 0 ? 'negative' : 'neutral'}">${deltaStats.actions.removed > 0 ? '-' : ''}${deltaStats.actions.removed}</div>
            <div class="delta-label">Actions Removed</div>
          </div>
        </div>
      `;
      
      document.getElementById('copy-delta-summary')?.addEventListener('click', async () => {
        const md = generateDeltaMarkdown();
        const success = await copyToClipboard(md);
        const btn = document.getElementById('copy-delta-summary');
        const orig = btn.textContent;
        btn.textContent = success ? 'Copied!' : 'Failed';
        setTimeout(() => btn.textContent = orig, 1500);
      });
    }

    function generateDeltaMarkdown() {
      if (!deltaStats) return '# No comparison data\n';
      
      const formatDelta = (val) => val > 0 ? `+${val}` : val.toString();
      
      let md = `# Delta Summary\n\n`;
      md += `## Contract Status Changes\n\n`;
      md += `| Metric | Delta |\n`;
      md += `|--------|-------|\n`;
      md += `| Contracts | ${formatDelta(deltaStats.contracts)} |\n`;
      md += `| Ready | ${formatDelta(deltaStats.ready)} |\n`;
      md += `| Needs Review | ${formatDelta(deltaStats.needsReview)} |\n`;
      md += `| Blocked | ${formatDelta(deltaStats.blocked)} |\n`;
      md += `\n## Row-Level Changes\n\n`;
      md += `| Type | Added | Changed | Removed |\n`;
      md += `|------|-------|---------|----------|\n`;
      md += `| Issues | ${deltaStats.issues.added} | ${deltaStats.issues.changed} | ${deltaStats.issues.removed} |\n`;
      md += `| Field Actions | ${deltaStats.actions.added} | ${deltaStats.actions.changed} | ${deltaStats.actions.removed} |\n`;
      
      return md;
    }

    function normCmp(v) {
      if (v === null || v === undefined) return '';
      return String(v).trim().toLowerCase();
    }

    function isNullOrEmpty(v) {
      return v === null || v === undefined || String(v).trim() === '';
    }

    function normalizeToNull(v) {
      if (v === undefined || (typeof v === 'string' && v.trim() === '')) return null;
      return v;
    }

    function compareNullsLast(aVal, bVal) {
      const aEmpty = isNullOrEmpty(aVal);
      const bEmpty = isNullOrEmpty(bVal);
      if (aEmpty && bEmpty) return 0;
      if (aEmpty) return 1;
      if (bEmpty) return -1;
      return normCmp(aVal).localeCompare(normCmp(bVal));
    }

    function sortByJoinTriplet(arr, extraKeys = []) {
      return [...arr].sort((a, b) => {
        const ck = compareNullsLast(a.contract_key, b.contract_key);
        if (ck !== 0) return ck;
        const fu = compareNullsLast(a.file_url, b.file_url);
        if (fu !== 0) return fu;
        const fn = compareNullsLast(a.file_name, b.file_name);
        if (fn !== 0) return fn;
        for (const key of extraKeys) {
          const cmp = normCmp(a[key]).localeCompare(normCmp(b[key]));
          if (cmp !== 0) return cmp;
        }
        return 0;
      });
    }

    function sortBySeverityFirst(arr, extraKeys = []) {
      const sevOrder = { blocking: 0, warning: 1, info: 2 };
      return [...arr].sort((a, b) => {
        const aOrd = sevOrder[a.severity] ?? 3;
        const bOrd = sevOrder[b.severity] ?? 3;
        if (aOrd !== bOrd) return aOrd - bOrd;
        const ck = compareNullsLast(a.contract_key, b.contract_key);
        if (ck !== 0) return ck;
        const fu = compareNullsLast(a.file_url, b.file_url);
        if (fu !== 0) return fu;
        const fn = compareNullsLast(a.file_name, b.file_name);
        if (fn !== 0) return fn;
        for (const key of extraKeys) {
          const cmp = compareNullsLast(a[key], b[key]);
          if (cmp !== 0) return cmp;
        }
        return 0;
      });
    }

    function getJoinIdentity(record) {
      return {
        contract_key: normalizeToNull(record.contract_key),
        file_url: normalizeToNull(record.file_url),
        file_name: normalizeToNull(record.file_name)
      };
    }

    function joinIdentityEquals(a, b) {
      if (!a || !b) return false;
      const eq = (x, y) => {
        const nx = normalizeToNull(x);
        const ny = normalizeToNull(y);
        if (nx === null && ny === null) return true;
        if (nx === null || ny === null) return false;
        return nx === ny;
      };
      return eq(a.contract_key, b.contract_key) && eq(a.file_url, b.file_url) && eq(a.file_name, b.file_name);
    }

    function getPrimaryKey(identity) {
      if (identity.contract_key !== null) return 'contract_key';
      if (identity.file_url !== null) return 'file_url';
      if (identity.file_name !== null) return 'file_name';
      return null;
    }

    function formatJoinIdentityPill(identity) {
      const primary = getPrimaryKey(identity);
      const format = (key, label, val) => {
        const v = val ?? 'null';
        if (key === primary) return `<span class="identity-primary">${label}=${v}</span>`;
        return `<span class="identity-fallback">${label}=${v}</span>`;
      };
      return `${format('contract_key', 'ck', identity.contract_key)} | ${format('file_url', 'fu', identity.file_url)} | ${format('file_name', 'fn', identity.file_name)}`;
    }

    function formatJoinIdentityText(identity) {
      const ck = identity.contract_key ?? 'null';
      const fu = identity.file_url ?? 'null';
      const fn = identity.file_name ?? 'null';
      const primary = getPrimaryKey(identity);
      return `ck=${ck} | fu=${fu} | fn=${fn} (PRIMARY: ${primary || 'none'})`;
    }

    function getRelatedRecords(identity, dataArray) {
      return dataArray.filter(r => joinIdentityEquals(getJoinIdentity(r), identity));
    }

    function formatValue(v) {
      if (v === null || v === undefined) return '<span class="null-value">null</span>';
      if (typeof v === 'object') return JSON.stringify(v);
      return String(v);
    }

    function matchesSearch(row, search) {
      if (!search) return true;
      const lowerSearch = search.toLowerCase();
      return Object.values(row).some(v => {
        if (v === null || v === undefined) return false;
        return String(v).toLowerCase().includes(lowerSearch);
      });
    }

    function filterData(data, type) {
      return data.filter(row => {
        if (!matchesSearch(row, activeFilters.search)) return false;
        if (type === 'issues' || type === 'fieldActions') {
          if (!activeFilters.severities.includes(row.severity)) return false;
        }
        if (type === 'contractResults') {
          const status = (row.sf_contract_status || '').toLowerCase();
          if (!activeFilters.statuses.includes(status)) return false;
          if (activeFilters.subtype && row.detected_subtype !== activeFilters.subtype) return false;
        }
        return true;
      });
    }

    function renderSummary(summary) {
      summary = summary || allData.summary || {};
      const container = document.getElementById('summary-container');
      if (!container) return; // v1.5.4: Skip if analyst triage removed this element
      container.innerHTML = `
        <h2>Summary</h2>
        <div class="summary">
          <div class="summary-card contracts clickable" title="View all records" onclick="navigateToGridFiltered('all')"><div class="count">${summary.contracts || 0}</div><div class="label">Contracts</div></div>
          <div class="summary-card ready clickable" title="View ready records" onclick="navigateToGridFiltered('ready')"><div class="count">${summary.ready || 0}</div><div class="label">Ready</div></div>
          <div class="summary-card needs-review clickable" title="View records needing review" onclick="navigateToGridFiltered('needs_review')"><div class="count">${summary.needs_review || 0}</div><div class="label">Needs Review</div></div>
          <div class="summary-card blocked clickable" title="View blocked records" onclick="navigateToGridFiltered('blocked')"><div class="count">${summary.blocked || 0}</div><div class="label">Blocked</div></div>
        </div>
      `;
    }

    function renderTable(containerId, title, data, columns, type) {
      const container = document.getElementById(containerId);
      if (!container) return; // v1.5.4: Skip if container removed
      const filtered = filterData(data, type);
      
      if (!data || data.length === 0) {
        container.innerHTML = `<h2>${title}</h2><div class="info">No data</div>`;
        return;
      }
      
      const headers = columns.map(c => {
        var tooltip = getTooltip(humanLabel(c.key)) || getTooltip(c.label);
        var icon = tooltip ? ' <span class="info-icon" title="' + escapeHtml(tooltip) + '">&#9432;</span>' : '';
        return '<th>' + c.label + icon + '</th>';
      }).join('');
      const changes = rowChanges[type] || {};
      
      const rows = filtered.map((row, idx) => {
        const cells = columns.map(c => {
          let val = formatValue(row[c.key]);
          let cls = '';
          if (c.key === 'severity') cls = `severity-${row.severity}`;
          if (c.key === 'sf_contract_status') cls = `status-${(row.sf_contract_status || '').toLowerCase()}`;
          return `<td class="${cls}">${val}</td>`;
        }).join('');
        const rowKey = getRowKey(row, type);
        const changeType = changes[rowKey];
        const rowClass = changeType ? `row-${changeType}` : '';
        return `<tr data-type="${type}" data-idx="${data.indexOf(row)}" data-source="primary" class="${rowClass}">${cells}</tr>`;
      }).join('');
      
      let removedRows = '';
      if (compareData && Object.keys(changes).length > 0) {
        const removedKeys = Object.entries(changes)
          .filter(([k, v]) => v === 'removed')
          .map(([k]) => k);
        
        if (removedKeys.length > 0) {
          const compareArr = getCompareArray(type);
          const removedRecords = compareArr.filter(r => removedKeys.includes(getRowKey(r, type)));
          removedRows = removedRecords.map((row, idx) => {
            const cells = columns.map(c => {
              let val = formatValue(row[c.key]);
              let cls = '';
              if (c.key === 'severity') cls = `severity-${row.severity}`;
              if (c.key === 'sf_contract_status') cls = `status-${(row.sf_contract_status || '').toLowerCase()}`;
              return `<td class="${cls}">${val}</td>`;
            }).join('');
            return `<tr data-type="${type}" data-idx="${idx}" data-source="compare" class="row-removed">${cells}</tr>`;
          }).join('');
        }
      }
      
      const totalCount = data.length + (removedRows ? Object.values(changes).filter(v => v === 'removed').length : 0);
      
      container.innerHTML = `
        <h2>${title} (${filtered.length + (removedRows ? Object.values(changes).filter(v => v === 'removed').length : 0)}/${totalCount})</h2>
        <div class="table-container">
          <table><thead><tr>${headers}</tr></thead><tbody>${rows}${removedRows}</tbody></table>
        </div>
      `;
      
      container.querySelectorAll('tbody tr').forEach(tr => {
        if (tr.dataset.source === 'compare') return;
        tr.addEventListener('click', () => openDrawerFromType(type, parseInt(tr.dataset.idx)));
      });
    }

    function getCompareArray(type) {
      if (!compareData) return [];
      if (type === 'contractResults') return compareData.sf_contract_results || [];
      if (type === 'issues') return compareData.sf_issues || [];
      if (type === 'fieldActions') return compareData.sf_field_actions || [];
      return [];
    }

    function renderAllTables() {
      renderTable('contract-results-container', 'Contract Results', allData.contractResults, [
        { key: 'contract_key', label: 'Contract Key' },
        { key: 'file_name', label: 'File Name' },
        { key: 'file_url', label: 'File URL' },
        { key: 'detected_subtype', label: 'Subtype' },
        { key: 'sf_contract_status', label: 'Status' },
        { key: 'notes', label: 'Notes' }
      ], 'contractResults');
      
      renderTable('issues-container', 'Issues', allData.issues, [
        { key: 'severity', label: 'Severity' },
        { key: 'contract_key', label: 'Contract Key' },
        { key: 'file_name', label: 'File Name' },
        { key: 'sheet', label: 'Contract Section' },
        { key: 'field', label: 'Field' },
        { key: 'issue_type', label: 'Issue Type' },
        { key: 'details', label: 'Details' }
      ], 'issues');
      
      renderTable('field-actions-container', 'Field Actions', allData.fieldActions, [
        { key: 'severity', label: 'Severity' },
        { key: 'contract_key', label: 'Contract Key' },
        { key: 'file_name', label: 'File Name' },
        { key: 'sheet', label: 'Contract Section' },
        { key: 'field', label: 'Field' },
        { key: 'action', label: 'Action' },
        { key: 'proposed_value', label: 'Proposed Value' },
        { key: 'reason_text', label: 'Reason' }
      ], 'fieldActions');
    }

    function populateSubtypeDropdown() {
      const subtypes = [...new Set((allData.contractResults || []).map(r => r.detected_subtype).filter(Boolean))].sort();
      const select = document.getElementById('filter-subtype');
      if (!select) return; // v1.6.3: Skip if element not found
      select.innerHTML = '<option value="">All Subtypes</option>' + 
        subtypes.map(s => `<option value="${s}">${s}</option>`).join('');
    }

    function renderDrawerTab(tab) {
      const body = document.getElementById('drawer-body');
      const identity = currentSelection.joinIdentity;
      if (!identity) return;

      let content = '';
      let jsonData = null;

      if (tab === 'contract') {
        const contract = currentSelection.contractIdx !== null 
          ? allData.contractResults[currentSelection.contractIdx]
          : allData.contractResults.find(r => joinIdentityEquals(getJoinIdentity(r), identity));
        if (contract) {
          jsonData = contract;
          content = `<div class="json-header">Internal JSON (advanced)</div><pre class="drawer-json">${JSON.stringify(contract, null, 2)}</pre>`;
        } else {
          content = '<div class="drawer-empty">No contract record found for this join identity.</div>';
        }
      } else if (tab === 'issues') {
        const related = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
        jsonData = related;
        if (related.length === 0) {
          content = '<div class="drawer-empty">No related issues for this join identity.</div>';
        } else {
          content = renderSelectionControls('issues', related.length) + renderDrawerTable(related, [
            { key: 'severity', label: 'Severity' },
            { key: 'sheet', label: 'Contract Section' },
            { key: 'field', label: 'Field' },
            { key: 'issue_type', label: 'Type' },
            { key: 'details', label: 'Details' }
          ], 'issues');
        }
      } else if (tab === 'actions') {
        const related = sortBySeverityFirst(getRelatedRecords(identity, allData.fieldActions), ['sheet', 'field', 'action']);
        jsonData = related;
        if (related.length === 0) {
          content = '<div class="drawer-empty">No related field actions for this join identity.</div>';
        } else {
          content = renderSelectionControls('actions', related.length) + renderDrawerTable(related, [
            { key: 'severity', label: 'Severity' },
            { key: 'sheet', label: 'Contract Section' },
            { key: 'field', label: 'Field' },
            { key: 'action', label: 'Action' },
            { key: 'proposed_value', label: 'Value' },
            { key: 'reason_text', label: 'Reason' }
          ], 'actions');
        }
      } else if (tab === 'changelog') {
        const related = sortBySeverityFirst(getRelatedRecords(identity, allData.changeLog), ['sheet', 'field', 'notes']);
        jsonData = related;
        if (related.length === 0) {
          content = '<div class="drawer-empty">No related change log entries for this join identity.</div>';
        } else {
          content = renderSelectionControls('changelog', related.length) + renderDrawerTable(related, [
            { key: 'severity', label: 'Severity' },
            { key: 'sheet', label: 'Contract Section' },
            { key: 'field', label: 'Field' },
            { key: 'notes', label: 'Notes' }
          ], 'changelog');
        }
      }

      body.innerHTML = content;
      body.dataset.json = JSON.stringify(jsonData, null, 2);
      body.dataset.tabType = tab;
      body.dataset.records = JSON.stringify(jsonData);
    }

    function getRecordKey(record) {
      const ck = normalizeToNull(record.contract_key) ?? '';
      const fu = normalizeToNull(record.file_url) ?? '';
      const fn = normalizeToNull(record.file_name) ?? '';
      const sh = record.sheet ?? '';
      const fi = record.field ?? '';
      const ty = record.issue_type ?? record.action ?? record.notes ?? '';
      return `${ck}|${fu}|${fn}|${sh}|${fi}|${ty}`;
    }

    function renderDrawerTable(data, columns, tabType) {
      const selectionSet = selectedRecords[tabType];
      const headers = (tabType ? '<th></th>' : '') + columns.map(c => `<th>${c.label}</th>`).join('');
      const rows = data.map((row, idx) => {
        const key = getRecordKey(row);
        const checked = selectionSet?.has(key) ? 'checked' : '';
        const checkbox = tabType ? `<td><input type="checkbox" data-key="${key}" data-idx="${idx}" ${checked}></td>` : '';
        const cells = columns.map(c => {
          let val = formatValue(row[c.key]);
          let cls = '';
          if (c.key === 'severity') cls = `severity-${row.severity}`;
          return `<td class="${cls}">${val}</td>`;
        }).join('');
        return `<tr>${checkbox}${cells}</tr>`;
      }).join('');
      return `<table class="drawer-table"><thead><tr>${headers}</tr></thead><tbody>${rows}</tbody></table>`;
    }

    function renderSelectionControls(tabType, totalCount) {
      const selectedCount = selectedRecords[tabType]?.size || 0;
      return `
        <div class="selection-controls">
          <button class="selection-btn" data-action="select-all" data-tab="${tabType}">Select All</button>
          <button class="selection-btn" data-action="clear" data-tab="${tabType}">Clear</button>
          <button class="selection-btn" data-action="add-to-patch" data-tab="${tabType}" style="background: #2e7d32; color: white; border-color: #2e7d32;">Add Selected to Patch</button>
          <span class="selection-count">${selectedCount} of ${totalCount} selected</span>
        </div>
      `;
    }

    function updateTabCounts(identity) {
      const issuesCount = getRelatedRecords(identity, allData.issues).length;
      const actionsCount = getRelatedRecords(identity, allData.fieldActions).length;
      const changelogCount = getRelatedRecords(identity, allData.changeLog).length;
      document.getElementById('issues-count').textContent = issuesCount;
      document.getElementById('actions-count').textContent = actionsCount;
      document.getElementById('changelog-count').textContent = changelogCount;
    }

    function openDrawerFromType(type, idx) {
      const dataMap = { contractResults: allData.contractResults, issues: allData.issues, fieldActions: allData.fieldActions };
      const record = dataMap[type]?.[idx];
      if (!record) return;
      
      // For contract results, use the new Record Drawer for a cleaner experience
      if (type === 'contractResults') {
        openRecordDrawer(record.contract_key || record.file_name, idx, allData.contractResults);
        return;
      }

      const identity = getJoinIdentity(record);
      currentSelection.joinIdentity = identity;
      currentSelection.sourceType = type;

      const matchingContracts = allData.contractResults.filter(r => joinIdentityEquals(getJoinIdentity(r), identity));
      if (type === 'contractResults') {
        currentSelection.contractIdx = idx;
      } else {
        const contractIdx = allData.contractResults.findIndex(r => joinIdentityEquals(getJoinIdentity(r), identity));
        currentSelection.contractIdx = contractIdx >= 0 ? contractIdx : null;
      }
      currentSelection.activeTab = 'contract';

      document.getElementById('identity-pill').innerHTML = formatJoinIdentityPill(identity);
      updateTabCounts(identity);

      const warning = document.getElementById('drawer-warning');
      if (matchingContracts.length > 1) {
        warning.textContent = `Warning: ${matchingContracts.length} contracts share this join identity. Showing first match deterministically.`;
        warning.style.display = 'block';
      } else {
        warning.style.display = 'none';
      }

      document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
      document.querySelector('.drawer-tab[data-tab="contract"]').classList.add('active');

      renderDrawerTab('contract');

      document.getElementById('drawer').classList.add('active');
      document.getElementById('drawer-overlay').classList.add('active');

      saveSelection();
    }

    function openDrawer(idx) {
      openDrawerFromType('contractResults', idx);
    }

    function closeDrawer() {
      document.getElementById('drawer').classList.remove('active');
      document.getElementById('drawer-overlay').classList.remove('active');
      currentSelection.joinIdentity = null;
      clearSelection();
    }

    function saveSelection() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(currentSelection));
      } catch (e) {}
    }

    function clearSelection() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (e) {}
    }

    function restoreSelection() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return;
        const sel = JSON.parse(stored);
        if (!sel.joinIdentity) return;

        let contractIdx = sel.contractIdx;
        if (contractIdx !== null && contractIdx !== undefined) {
          const storedRecord = allData.contractResults[contractIdx];
          if (!storedRecord || !joinIdentityEquals(getJoinIdentity(storedRecord), sel.joinIdentity)) {
            contractIdx = allData.contractResults.findIndex(r => joinIdentityEquals(getJoinIdentity(r), sel.joinIdentity));
          }
        } else {
          contractIdx = allData.contractResults.findIndex(r => joinIdentityEquals(getJoinIdentity(r), sel.joinIdentity));
        }

        if (contractIdx < 0) {
          clearSelection();
          return;
        }

        const validTabs = ['contract', 'issues', 'actions', 'changelog'];
        if (!validTabs.includes(sel.activeTab)) {
          sel.activeTab = 'contract';
        }

        sel.contractIdx = contractIdx;
        currentSelection = sel;
        document.getElementById('identity-pill').innerHTML = formatJoinIdentityPill(sel.joinIdentity);
        updateTabCounts(sel.joinIdentity);

        document.querySelectorAll('.drawer-tab').forEach(t => {
          t.classList.toggle('active', t.dataset.tab === sel.activeTab);
        });

        renderDrawerTab(sel.activeTab);

        document.getElementById('drawer').classList.add('active');
        document.getElementById('drawer-overlay').classList.add('active');
      } catch (e) {
        clearSelection();
      }
    }

    function openCommandModal(cmdKey) {
      const cmd = commands.commands?.[cmdKey];
      const desc = commands.descriptions?.[cmdKey] || '';
      if (!cmd) return;
      
      document.getElementById('modal-title').textContent = cmdKey.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      document.getElementById('modal-description').textContent = desc;
      document.getElementById('modal-command').textContent = cmd;
      document.getElementById('modal-status').style.display = 'none';
      updateRunButton();
      document.getElementById('command-modal').classList.add('active');
    }

    function closeModal() {
      document.getElementById('command-modal').classList.remove('active');
    }

    function updateRunButton() {
      const confirmChecked = document.getElementById('confirm-run').checked;
      const runBtn = document.getElementById('modal-run');
      runBtn.disabled = !confirmChecked;
      runBtn.textContent = confirmChecked ? 'Run Command' : 'Run (Confirm Required)';
    }

    function showModalStatus(message, type) {
      const status = document.getElementById('modal-status');
      status.textContent = message;
      status.className = 'modal-status ' + type;
      status.style.display = 'block';
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (e) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        return true;
      }
    }

    async function loadCommands() {
      try {
        const resp = await fetch(COMMANDS_PATH);
        if (resp.ok) {
          commands = await resp.json();
        }
      } catch (e) {
        console.warn('Could not load run_commands.json');
      }
    }

    async function loadData() {
      const errorContainer = document.getElementById('error-container');
      const sourceInfo = document.getElementById('source-info');
      
      // First try to restore from localStorage
      if (restoreSessionFromStorage()) {
        sourceInfo.textContent = `Data source: ${sessionState.sourceType} (restored from browser)`;
        restoreSelection();
        return;
      }
      
      // v1.6.37: Removed auto-load - user must upload data via Upload Excel button
      console.log('[Loader] Cold start - awaiting user data upload');
      return;
      
      // Legacy: Try sf_packet files (kept for reference, now bypassed)
      let data = null;
      let source = '';
      let isFallback = false;
      
      try {
        const resp = await fetch(RELATIVE_PRIMARY);
        if (resp.ok) {
          data = await resp.json();
          source = PRIMARY_PATH;
        }
      } catch (e) {}
      
      if (!data) {
        try {
          const resp = await fetch(RELATIVE_FALLBACK);
          if (resp.ok) {
            data = await resp.json();
            source = FALLBACK_PATH + ' (fallback)';
            isFallback = true;
          }
        } catch (e) {}
      }
      
      if (!data) {
        // v1.6.3: No sf_packet available - auto-load ostereo_demo_v1 as default
        console.log('[Loader] No sf_packet found, loading default dataset...');
        await loadSampleDataset({ autoRedirect: false });
        return;
      }
      
      if (sourceInfo) sourceInfo.textContent = `Data source: ${source}`;
      
      renderSummary(data.sf_summary || {});
      
      allData.contractResults = sortByJoinTriplet(data.sf_contract_results || []);
      // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
      allData.issues = filterOutReferenceData(sortBySeverityFirst(data.sf_issues || [], ['sheet', 'field', 'issue_type']));
      allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(data.sf_field_actions || [], ['sheet', 'field', 'action']));
      allData.changeLog = sortBySeverityFirst(data.sf_change_log || [], ['sheet', 'field', 'notes']);
      allData.summary = data.sf_summary || {};
      
      // Set session state based on source
      sessionState.status = isFallback ? 'fallback' : 'loaded';
      sessionState.sourceType = isFallback ? 'example' : 'fetch';
      sessionState.loadedAt = Date.now();
      sessionState.previewData = data;
      
      // Set data loaded state
      dataLoaded = true;
      currentArtifactPath = source;
      updateUIForDataState();
      updateSessionChip();
      
      populateSubtypeDropdown();
      renderAllTables();
      populateTargetFieldDropdown();
      restoreSelection();
    }

    // Legacy toolbar handler (Run page was removed, but keep for safety)
    const legacyToolbar = document.getElementById('toolbar');
    if (legacyToolbar) {
      legacyToolbar.addEventListener('click', async e => {
        const btn = e.target.closest('.toolbar-btn');
        if (btn) {
          const cmdKey = btn.dataset.cmd;
          const cmd = commands.commands?.[cmdKey];
          if (cmd) {
            const success = await copyToClipboard(cmd);
            openCommandModal(cmdKey);
            showModalStatus(success ? 'Command copied to clipboard!' : 'Could not auto-copy', success ? 'success' : 'error');
          }
        }
      });
    }

    document.getElementById('modal-close')?.addEventListener('click', closeModal);
    document.getElementById('modal-cancel')?.addEventListener('click', closeModal);
    document.getElementById('command-modal')?.addEventListener('click', e => {
      if (e.target.id === 'command-modal') closeModal();
    });

    document.getElementById('modal-copy')?.addEventListener('click', async () => {
      const cmd = document.getElementById('modal-command')?.textContent;
      if (cmd) {
        const success = await copyToClipboard(cmd);
        showModalStatus(success ? 'Copied to clipboard!' : 'Copy failed', success ? 'success' : 'error');
      }
    });

    document.getElementById('modal-run')?.addEventListener('click', () => {
      showModalStatus('Execution is not available in browser environment. Please run the copied command in your terminal.', 'info');
    });

    document.getElementById('confirm-run')?.addEventListener('change', updateRunButton);

    document.getElementById('drawer-close')?.addEventListener('click', closeDrawer);
    document.getElementById('drawer-overlay')?.addEventListener('click', closeDrawer);

    document.getElementById('drawer-tabs')?.addEventListener('click', e => {
      const tab = e.target.closest('.drawer-tab');
      if (!tab) return;
      const tabName = tab.dataset.tab;
      currentSelection.activeTab = tabName;
      document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      
      const patchStudioPanel = document.getElementById('patch-studio-panel');
      const drawerBody = document.getElementById('drawer-body');
      const actionsDefault = document.getElementById('drawer-actions-default');
      const actionsPatchStudio = document.getElementById('drawer-actions-patch-studio');
      
      if (tabName === 'patch-studio') {
        patchStudioPanel.style.display = 'flex';
        patchStudioPanel.style.flexDirection = 'column';
        drawerBody.style.display = 'none';
        if (actionsDefault) actionsDefault.style.display = 'none';
        if (actionsPatchStudio) actionsPatchStudio.style.display = 'block';
        populatePatchStudioFromContext();
      } else {
        patchStudioPanel.style.display = 'none';
        drawerBody.style.display = 'block';
        if (actionsDefault) actionsDefault.style.display = 'block';
        if (actionsPatchStudio) actionsPatchStudio.style.display = 'none';
        renderDrawerTab(tabName);
      }
      saveSelection();
    });
    
    document.querySelectorAll('.patch-studio-sub-tab').forEach(function(tab) {
      tab.addEventListener('click', function() {
        const subtab = this.dataset.subtab;
        document.querySelectorAll('.patch-studio-sub-tab').forEach(function(t) {
          t.style.background = '#263238';
          t.style.color = '#aaa';
          t.classList.remove('active');
        });
        this.style.background = '#1a1a2e';
        this.style.color = 'white';
        this.classList.add('active');
        
        document.querySelectorAll('.patch-studio-sub-panel').forEach(function(panel) {
          panel.style.display = 'none';
        });
        document.getElementById('subtab-' + subtab).style.display = 'block';
      });
    });
    
    function populatePatchStudioFromContext() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return;
      
      const issues = getRelatedRecords(identity, allData.issues);
      if (issues.length > 0) {
        const firstIssue = issues[0];
        var targetFieldSel = document.getElementById('ps-target-field');
        if (targetFieldSel) {
          var fieldVal = (firstIssue.sheet || '') + '.' + (firstIssue.field || '');
          var opt = targetFieldSel.querySelector('option[value="' + fieldVal + '"]');
          if (opt) {
            targetFieldSel.value = fieldVal;
          }
        }
      }
    }
    
    function populateTargetFieldDropdown() {
      var select = document.getElementById('ps-target-field');
      if (!select) return;
      
      select.innerHTML = '<option value="">-- Select field --</option>';
      var fields = new Set();
      
      // v1.6.39: Get active sheet - use grid selector, SRR sheet, or workbook.activeSheet
      var activeSheet = gridState.sheet || workbook.activeSheet || (workbook.order && workbook.order[0]) || null;
      
      // v1.6.39: Filter to only fields from the active sheet's headers
      if (activeSheet && workbook.sheets && workbook.sheets[activeSheet]) {
        var sheetHeaders = workbook.sheets[activeSheet].headers || [];
        sheetHeaders.forEach(function(h) {
          if (h && h.trim()) {
            fields.add(activeSheet + '.' + h);
          }
        });
      } else {
        // Fallback: use field_index from bundle but filter to active sheet
        var bundle = getCurrentBundle();
        if (bundle && bundle.field_index) {
          bundle.field_index.forEach(function(entry) {
            if (!activeSheet || entry.full_path.startsWith(activeSheet + '.')) {
              fields.add(entry.full_path);
            }
          });
        }
      }
      
      // Fallback: also add fields from issues and field_actions for active sheet only
      if (allData && allData.issues) {
        allData.issues.forEach(function(issue) {
          if (issue.sheet && issue.field && (!activeSheet || issue.sheet === activeSheet)) {
            fields.add(issue.sheet + '.' + issue.field);
          }
        });
      }
      if (allData && allData.fieldActions) {
        allData.fieldActions.forEach(function(action) {
          if (action.sheet && action.field && (!activeSheet || action.sheet === activeSheet)) {
            fields.add(action.sheet + '.' + action.field);
          }
        });
      }
      
      Array.from(fields).sort().forEach(function(f) {
        var opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });
      
      var otherOpt = document.createElement('option');
      otherOpt.value = 'OTHER';
      otherOpt.textContent = 'Other (type manually)';
      select.appendChild(otherOpt);
    }
    
    function updateIntentPreview() {
      var targetField = document.getElementById('ps-target-field')?.value || '';
      var conditionType = document.getElementById('ps-condition-type')?.value || '';
      var conditionOther = document.getElementById('ps-condition-other')?.value || '';
      var actionType = document.getElementById('ps-action-type')?.value || '';
      var actionOther = document.getElementById('ps-action-other')?.value || '';
      var because = document.getElementById('ps-intent-because')?.value || '';
      
      var whenText = '';
      if (targetField && targetField !== 'OTHER') {
        whenText = 'Field "' + targetField + '"';
      } else if (targetField === 'OTHER') {
        whenText = 'Field (custom)';
      }
      if (conditionType) {
        var cond = CONDITION_TYPES.find(function(c) { return c.value === conditionType; });
        if (cond) {
          whenText += ' ' + cond.label.toLowerCase();
        }
      }
      if (conditionType === 'OTHER' && conditionOther) {
        whenText += ': ' + conditionOther;
      }
      
      var thenText = '';
      if (actionType) {
        var act = ACTION_TYPES.find(function(a) { return a.value === actionType; });
        if (act) {
          thenText = act.label;
        }
      }
      if (actionType === 'OTHER' && actionOther) {
        thenText += ': ' + actionOther;
      }
      
      document.getElementById('preview-when').textContent = whenText || '(select field and condition)';
      document.getElementById('preview-then').textContent = thenText || '(select action)';
      document.getElementById('preview-because').textContent = because || '(enter comment)';
    }
    
    document.getElementById('ps-condition-type')?.addEventListener('change', function(e) {
      var wrap = document.getElementById('ps-condition-other-wrap');
      if (e.target.value === 'OTHER') {
        wrap.style.display = 'block';
      } else {
        wrap.style.display = 'none';
      }
      updateIntentPreview();
    });
    
    document.getElementById('ps-action-type')?.addEventListener('change', function(e) {
      var wrap = document.getElementById('ps-action-other-wrap');
      if (e.target.value === 'OTHER') {
        wrap.style.display = 'block';
      } else {
        wrap.style.display = 'none';
      }
      updateIntentPreview();
    });
    
    document.getElementById('ps-target-field')?.addEventListener('change', updateIntentPreview);
    document.getElementById('ps-condition-other')?.addEventListener('input', updateIntentPreview);
    document.getElementById('ps-action-other')?.addEventListener('input', updateIntentPreview);
    document.getElementById('ps-intent-because')?.addEventListener('input', updateIntentPreview);
    
    function getPatchStudioDraft() {
      var targetField = document.getElementById('ps-target-field')?.value || '';
      var conditionType = document.getElementById('ps-condition-type')?.value || '';
      var conditionOther = document.getElementById('ps-condition-other')?.value || '';
      var actionType = document.getElementById('ps-action-type')?.value || '';
      var actionOther = document.getElementById('ps-action-other')?.value || '';
      var because = document.getElementById('ps-intent-because')?.value || '';
      
      var intentStructured = {
        target_field: targetField !== 'OTHER' ? targetField : null,
        condition_type: conditionType || 'OTHER',
        condition_params: conditionType === 'OTHER' && conditionOther ? { custom: conditionOther } : null,
        action_type: actionType || 'OTHER',
        action_params: actionType === 'OTHER' && actionOther ? { custom: actionOther } : null,
        because: because
      };
      
      return {
        intent_structured: intentStructured,
        target: document.getElementById('ps-target')?.value || 'proposed_changes',
        risk: document.getElementById('ps-risk')?.value || 'low',
        rationale: document.getElementById('ps-rationale')?.value || '',
        evidence: {
          observation: document.getElementById('ps-evidence-observation')?.value || '',
          expected_behavior: document.getElementById('ps-evidence-expected')?.value || '',
          rule_justification: document.getElementById('ps-evidence-justification')?.value || '',
          repro_steps: document.getElementById('ps-evidence-repro')?.value || '',
          replay_type: document.getElementById('ps-replay-type')?.value || '',
          replay_steps: document.getElementById('ps-replay-steps')?.value || '',
          replay_expected_result: document.getElementById('ps-replay-expected-result')?.value || ''
        }
      };
    }
    
    function clearPatchStudioForm() {
      document.getElementById('ps-target-field').value = '';
      document.getElementById('ps-condition-type').value = '';
      document.getElementById('ps-condition-other').value = '';
      document.getElementById('ps-condition-other-wrap').style.display = 'none';
      document.getElementById('ps-action-type').value = '';
      document.getElementById('ps-action-other').value = '';
      document.getElementById('ps-action-other-wrap').style.display = 'none';
      document.getElementById('ps-intent-because').value = '';
      document.getElementById('ps-target').value = 'proposed_changes';
      document.getElementById('ps-risk').value = 'low';
      document.getElementById('ps-rationale').value = '';
      document.getElementById('ps-evidence-observation').value = '';
      document.getElementById('ps-evidence-expected').value = '';
      document.getElementById('ps-evidence-justification').value = '';
      document.getElementById('ps-evidence-repro').value = '';
      if (document.getElementById('ps-replay-type')) document.getElementById('ps-replay-type').value = '';
      if (document.getElementById('ps-replay-steps')) document.getElementById('ps-replay-steps').value = '';
      if (document.getElementById('ps-replay-expected-result')) document.getElementById('ps-replay-expected-result').value = '';
      updateIntentPreview();
    }
    
    function validatePatchStudioForm() {
      var targetField = document.getElementById('ps-target-field')?.value || '';
      var conditionType = document.getElementById('ps-condition-type')?.value || '';
      var conditionOther = document.getElementById('ps-condition-other')?.value || '';
      var actionType = document.getElementById('ps-action-type')?.value || '';
      var actionOther = document.getElementById('ps-action-other')?.value || '';
      var because = document.getElementById('ps-intent-because')?.value || '';
      
      var errors = [];
      if (!targetField) errors.push('Target Field is required');
      if (!conditionType) errors.push('Condition Type is required');
      if (conditionType === 'OTHER' && !conditionOther) errors.push('Please describe the condition');
      if (!actionType) errors.push('Action Type is required');
      if (actionType === 'OTHER' && !actionOther) errors.push('Please describe the action');
      if (!because) errors.push('Comment (plain English) is required');
      if (because.length > 500) errors.push('Comment must be 500 characters or less');
      
      return errors;
    }
    
    document.getElementById('ps-submit-to-queue')?.addEventListener('click', function() {
      var errors = validatePatchStudioForm();
      if (errors.length > 0) {
        showToast(errors[0], 'warning');
        return;
      }
      
      const draft = getPatchStudioDraft();
      const identity = currentSelection.joinIdentity || {};
      const author = getCurrentUserName();

      // v1.6.57: Gate parity — apply same evidence + preflight gates as SRR
      var psDraft = {
        observation_type: draft.evidence.observation || '',
        expected_type: draft.evidence.expected_behavior || '',
        justification: draft.evidence.rule_justification || '',
        repro_type: draft.evidence.repro_steps || '',
        replay_type: draft.evidence.replay_type || '',
        replay_steps: draft.evidence.replay_steps || '',
        replay_expected_result: draft.evidence.replay_expected_result || ''
      };
      var patchType = draft.patch_kind || 'correction';
      var gateResult = validateSubmissionGates(patchType, psDraft, 1, false);
      if (!gateResult.pass) {
        var allGaps = gateResult.evidenceGaps.concat(gateResult.preflightGaps);
        showToast('Submission blocked: ' + allGaps[0], 'warning');
        console.log('[PatchStudio] Submit blocked — gaps:', allGaps);
        return;
      }
      
      var request = createPatchRequest({
        author: author,
        author_role: currentMode || 'Analyst',
        status: 'Draft',
        contract_key: identity.contract_key || null,
        file_url: identity.file_url || null,
        file_name: identity.file_name || null,
        target: draft.target,
        target_field: draft.intent_structured.target_field,
        condition_type: draft.intent_structured.condition_type,
        condition_params: draft.intent_structured.condition_params,
        action_type: draft.intent_structured.action_type,
        action_params: draft.intent_structured.action_params,
        because: draft.intent_structured.because,
        rationale: draft.rationale,
        risk: draft.risk,
        evidence_observation: draft.evidence.observation,
        evidence_expected: draft.evidence.expected_behavior,
        evidence_justification: draft.evidence.rule_justification,
        evidence_repro: draft.evidence.repro_steps,
        replay_type: draft.evidence.replay_type || '',
        replay_steps: draft.evidence.replay_steps || '',
        replay_expected_result: draft.evidence.replay_expected_result || ''
      });
      
      var submittedRequest = submitPatchRequest(request.request_id, author, currentMode || 'Analyst');
      
      if (submittedRequest) {
        showToast('Patch request submitted to queue: ' + request.request_id, 'success');
      _srrCollapsePatchPanel();
        clearPatchStudioForm();
        updatePatchQueueCounts();
        
        document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
        document.querySelector('.drawer-tab[data-tab="contract"]')?.classList.add('active');
        document.getElementById('patch-studio-panel').style.display = 'none';
        document.getElementById('drawer-body').style.display = 'block';
        document.getElementById('drawer-actions-default').style.display = 'block';
        document.getElementById('drawer-actions-patch-studio').style.display = 'none';
        renderDrawerTab('contract');
      } else {
        showToast('Failed to submit patch request', 'error');
      }
    });
    
    document.getElementById('ps-copy-draft')?.addEventListener('click', async function() {
      const draft = getPatchStudioDraft();
      const json = JSON.stringify(draft, null, 2);
      const success = await copyToClipboard(json);
      showToast(success ? 'Draft copied to clipboard' : 'Failed to copy', success ? 'success' : 'error');
    });
    
    document.getElementById('ps-save-local')?.addEventListener('click', function() {
      const draft = getPatchStudioDraft();
      localStorage.setItem('orchestrate.patch_studio.draft', JSON.stringify(draft));
      showToast('Draft saved locally', 'success');
    });
    
    document.getElementById('ps-run-preflight')?.addEventListener('click', function() {
      runPreflightChecks();
    });
    
    document.getElementById('ps-copy-preflight')?.addEventListener('click', async function() {
      const report = generatePreflightReport();
      const success = await copyToClipboard(JSON.stringify(report, null, 2));
      showToast(success ? 'Preflight report copied' : 'Failed to copy', success ? 'success' : 'error');
    });
    
    function runPreflightChecks() {
      const draft = getPatchStudioDraft();
      const checks = [];
      
      if (draft.intent.when && draft.intent.then) {
        checks.push({ status: 'PASS', message: 'Intent fields populated' });
      } else {
        checks.push({ status: 'FAIL', message: 'Intent fields incomplete (WHEN and THEN required)' });
      }
      
      if (draft.evidence.observation || draft.evidence.expected_behavior) {
        checks.push({ status: 'PASS', message: 'Evidence pack has content' });
      } else {
        checks.push({ status: 'WARN', message: 'Evidence pack incomplete' });
      }
      
      checks.push({ status: 'INFO', message: 'Target: ' + humanLabel(draft.target) });
      checks.push({ status: 'INFO', message: 'Risk level: ' + draft.risk });
      
      const container = document.getElementById('ps-preflight-checks');
      container.innerHTML = checks.map(function(check) {
        var badgeClass = check.status === 'PASS' ? 'background: #e8f5e9; color: #2e7d32;' :
                         check.status === 'FAIL' ? 'background: #ffebee; color: #c62828;' :
                         check.status === 'WARN' ? 'background: #fff3e0; color: #e65100;' :
                         'background: #e3f2fd; color: #1565c0;';
        return '<div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">' +
          '<span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; ' + badgeClass + '">' + check.status + '</span>' +
          '<span style="font-size: 0.9em;">' + escapeHtml(check.message) + '</span>' +
          '</div>';
      }).join('');
    }
    
    function generatePreflightReport() {
      const draft = getPatchStudioDraft();
      return {
        generated_at: new Date().toISOString(),
        intent_complete: !!(draft.intent.when && draft.intent.then),
        evidence_complete: !!(draft.evidence.observation && draft.evidence.expected_behavior),
        target: draft.target,
        risk: draft.risk,
        draft_snapshot: draft
      };
    }
    
    function copyEvidenceBlock(block) {
      var value = '';
      switch(block) {
        case 'observation': value = document.getElementById('ps-evidence-observation')?.value || ''; break;
        case 'expected': value = document.getElementById('ps-evidence-expected')?.value || ''; break;
        case 'justification': value = document.getElementById('ps-evidence-justification')?.value || ''; break;
        case 'repro': value = document.getElementById('ps-evidence-repro')?.value || ''; break;
        case 'replay_type': value = document.getElementById('ps-replay-type')?.value || ''; break;
        case 'replay_steps': value = document.getElementById('ps-replay-steps')?.value || ''; break;
        case 'replay_expected': value = document.getElementById('ps-replay-expected-result')?.value || ''; break;
      }
      copyToClipboard(value).then(function(success) {
        showToast(success ? 'Evidence block copied' : 'Failed to copy', success ? 'success' : 'error');
      });
    }

    document.getElementById('drawer-copy')?.addEventListener('click', async () => {
      const rawJson = document.getElementById('drawer-body').dataset.json || '{}';
      const parsed = JSON.parse(rawJson);
      const sorted = sortObjectKeys(parsed);
      const json = JSON.stringify(sorted, null, 2);
      const success = await copyToClipboard(json);
      const btn = document.getElementById('drawer-copy');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('identity-copy')?.addEventListener('click', async () => {
      const identity = currentSelection.joinIdentity;
      if (!identity) return;
      const text = formatJoinIdentityText(identity);
      const success = await copyToClipboard(text);
      const btn = document.getElementById('identity-copy');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    function sortObjectKeys(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (Array.isArray(obj)) return obj.map(sortObjectKeys);
      return Object.keys(obj).sort().reduce((acc, key) => {
        acc[key] = sortObjectKeys(obj[key]);
        return acc;
      }, {});
    }

    function generatePRSummary() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return '';
      const contract = currentSelection.contractIdx !== null 
        ? allData.contractResults[currentSelection.contractIdx] : null;
      const issues = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
      const actions = sortBySeverityFirst(getRelatedRecords(identity, allData.fieldActions), ['sheet', 'field', 'action']);
      const primary = getPrimaryKey(identity);
      const primaryVal = identity[primary] || 'unknown';

      let md = `# PR: Fix issues for ${primary}=${primaryVal}\n\n`;
      md += `## WHY\n`;
      md += `This record has ${issues.length} issue(s) and ${actions.length} pending action(s) that need resolution.\n\n`;
      md += `## Affected Artifacts\n`;
      md += `- **Join Identity**: ${formatJoinIdentityText(identity)}\n`;
      md += `- **Contract Status**: ${contract?.sf_contract_status || 'unknown'}\n`;
      md += `- **Detected Subtype**: ${contract?.detected_subtype || 'unknown'}\n`;
      if (issues.length > 0) {
        md += `- **Issues**: ${issues.map(i => i.issue_type).join(', ')}\n`;
      }
      md += `\n## Smoke Status\nunknown (run \`bash scripts/replit_smoke.sh\` to verify)\n`;
      return md;
    }

    function generatePatchSkeleton() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return '{}';
      const issues = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
      const primary = getPrimaryKey(identity);
      const primaryVal = (identity[primary] || 'unknown').replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20);
      const patch = {
        base_version: "0.1.0",
        changes: issues.map((issue, idx) => ({
          op: "add_rule",
          rule_id: `NEW_RULE_${primaryVal}_${idx + 1}`,
          description: `Fix: ${issue.issue_type} on ${issue.field || 'unknown'}`,
          when: { sheet: issue.sheet || "", field: issue.field || "", operator: "EXISTS", value: null },
          then: { action: "REQUIRE_PRESENT", sheet: issue.sheet || "", field: issue.field || "", severity: issue.severity || "warning" }
        }))
      };
      return JSON.stringify(sortObjectKeys(patch), null, 2);
    }

    function generateRuleDraft() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return '';
      const issues = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
      const primary = getPrimaryKey(identity);
      
      let draft = `# Rule Draft\n\n`;
      if (issues.length === 0) {
        draft += `No issues found for this join identity.\n`;
      } else {
        issues.forEach((issue, idx) => {
          draft += `## Rule ${idx + 1}\n\n`;
          draft += `**WHEN**\n`;
          draft += `- Sheet: ${issue.sheet || 'any'}\n`;
          draft += `- Field: ${issue.field || 'any'}\n`;
          draft += `- Condition: ${issue.issue_type || 'unknown'}\n\n`;
          draft += `**THEN**\n`;
          draft += `- Action: REQUIRE_PRESENT\n`;
          draft += `- Severity: ${issue.severity || 'warning'}\n\n`;
          draft += `**BECAUSE**\n`;
          draft += `- ${issue.details || 'Issue detected during validation'}\n`;
          draft += `- Primary key: ${primary}=${identity[primary]}\n\n`;
        });
      }
      return draft;
    }

    document.getElementById('copy-pr-summary')?.addEventListener('click', async () => {
      const text = generatePRSummaryWithEvidence();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-pr-summary');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-pr-summary-drawer')?.addEventListener('click', async () => {
      const text = generatePRSummaryWithEvidence();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-pr-summary-drawer');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-patch-json')?.addEventListener('click', async () => {
      if (!srrState || !srrState.patchDraft || (!srrState.patchDraft.patch_type && Object.keys(srrState.proposedChanges || {}).length === 0)) {
        showToast('No patch draft to copy — open a record and make changes first', 'warning');
        return;
      }
      var payload = {
        patch_type: srrState.patchDraft.patch_type || srrState.patchType,
        observation_type: srrState.patchDraft.observation_type || '',
        expected_type: srrState.patchDraft.expected_type || '',
        justification: srrState.patchDraft.justification || '',
        repro_type: srrState.patchDraft.repro_type || '',
        override_enabled: srrState.overrideEnabled || false,
        proposed_changes: Object.values(srrState.proposedChanges || {}).map(function(c) {
          return { field: c.field, from: c.from, to: c.to };
        }),
        record_key: srrState.currentRecordKey || '',
        sheet: srrState.currentSheetName || ''
      };
      var json = JSON.stringify(payload, null, 2);
      const success = await copyToClipboard(json);
      const btn = document.getElementById('copy-patch-json');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-rule-draft')?.addEventListener('click', async () => {
      const text = generateRuleDraft();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-rule-draft');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('filter-search')?.addEventListener('input', e => {
      activeFilters.search = e.target.value;
      renderAllTables();
    });

    document.getElementById('severity-chips')?.addEventListener('click', e => {
      const chip = e.target.closest('.filter-chip');
      if (!chip) return;
      const sev = chip.dataset.severity;
      const idx = activeFilters.severities.indexOf(sev);
      if (idx >= 0) {
        activeFilters.severities.splice(idx, 1);
        chip.classList.add('inactive');
      } else {
        activeFilters.severities.push(sev);
        chip.classList.remove('inactive');
      }
      renderAllTables();
    });

    document.getElementById('status-chips')?.addEventListener('click', e => {
      const chip = e.target.closest('.filter-chip');
      if (!chip) return;
      const status = chip.dataset.status;
      const idx = activeFilters.statuses.indexOf(status);
      if (idx >= 0) {
        activeFilters.statuses.splice(idx, 1);
        chip.classList.add('inactive');
      } else {
        activeFilters.statuses.push(status);
        chip.classList.remove('inactive');
      }
      renderAllTables();
    });

    document.getElementById('filter-subtype')?.addEventListener('change', e => {
      activeFilters.subtype = e.target.value;
      renderAllTables();
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        closeModal();
        closeDrawer();
      }
    });

    document.getElementById('drawer-body')?.addEventListener('change', e => {
      if (e.target.type !== 'checkbox') return;
      const key = e.target.dataset.key;
      const tabType = document.getElementById('drawer-body').dataset.tabType;
      if (!tabType || tabType === 'contract') return;
      
      const selectionSet = selectedRecords[tabType];
      if (!selectionSet) return;
      
      if (e.target.checked) {
        selectionSet.add(key);
      } else {
        selectionSet.delete(key);
      }
      updateSelectionCount(tabType);
    });

    document.getElementById('drawer-body')?.addEventListener('click', e => {
      const btn = e.target.closest('.selection-btn');
      if (!btn) return;
      
      const action = btn.dataset.action;
      const tabType = btn.dataset.tab;
      const records = JSON.parse(document.getElementById('drawer-body').dataset.records || '[]');
      
      if (action === 'select-all') {
        records.forEach(r => selectedRecords[tabType].add(getRecordKey(r)));
        renderDrawerTab(currentSelection.activeTab);
      } else if (action === 'clear') {
        selectedRecords[tabType].clear();
        renderDrawerTab(currentSelection.activeTab);
      } else if (action === 'add-to-patch') {
        addSelectedToPatch(tabType);
      }
    });

    function updateSelectionCount(tabType) {
      const countEl = document.querySelector(`.selection-count`);
      if (countEl) {
        const records = JSON.parse(document.getElementById('drawer-body').dataset.records || '[]');
        countEl.textContent = `${selectedRecords[tabType]?.size || 0} of ${records.length} selected`;
      }
    }

    function addSelectedToPatch(tabType) {
      const records = JSON.parse(document.getElementById('drawer-body').dataset.records || '[]');
      const selectionSet = selectedRecords[tabType];
      const selected = records.filter(r => selectionSet.has(getRecordKey(r)));
      
      selected.forEach(record => {
        const key = getRecordKey(record);
        const exists = patchDraft.changes.some(c => c._key === key);
        if (!exists) {
          patchDraft.changes.push({
            _key: key,
            _source: tabType,
            record: record
          });
        }
      });
      
      renderPatchChanges();
      savePatchDraft();
      document.getElementById('patch-studio').classList.add('active');
    }

    function renderPatchChanges() {
      const list = document.getElementById('patch-changes-list');
      const count = document.getElementById('patch-changes-count');
      count.textContent = patchDraft.changes.length;
      
      if (patchDraft.changes.length === 0) {
        list.innerHTML = '<div class="patch-empty">No changes added. Select issues/actions in the Workbench tabs and add them here.</div>';
        return;
      }
      
      const sorted = sortBySeverityFirst([...patchDraft.changes].map(c => c.record), ['sheet', 'field']);
      const sortedChanges = sorted.map(r => patchDraft.changes.find(c => c._key === getRecordKey(r)));
      
      list.innerHTML = sortedChanges.map((change, idx) => {
        const r = change.record;
        const typeLabel = change._source === 'issues' ? 'Issue' : change._source === 'actions' ? 'Action' : 'Log';
        const desc = r.issue_type || r.action || r.notes || 'unknown';
        return `
          <div class="patch-change-item" data-idx="${idx}">
            <div class="patch-change-info">
              <strong>${typeLabel}:</strong> ${desc}<br>
              <small>${r.sheet || '-'} / ${r.field || '-'} (${r.severity || 'info'})</small>
            </div>
            <button class="patch-change-remove" data-key="${change._key}">&times;</button>
          </div>
        `;
      }).join('');
    }

    document.getElementById('patch-changes-list')?.addEventListener('click', e => {
      const btn = e.target.closest('.patch-change-remove');
      if (!btn) return;
      const key = btn.dataset.key;
      patchDraft.changes = patchDraft.changes.filter(c => c._key !== key);
      renderPatchChanges();
      savePatchDraft();
    });

    document.getElementById('clear-patch-changes')?.addEventListener('click', () => {
      patchDraft.changes = [];
      renderPatchChanges();
      savePatchDraft();
    });

    document.getElementById('switch-to-patch-studio-tab')?.addEventListener('click', () => {
      var patchStudioTab = document.querySelector('.drawer-tab[data-tab="patch-studio"]');
      if (patchStudioTab) {
        patchStudioTab.click();
      }
    });

    document.getElementById('patch-base-version')?.addEventListener('input', e => {
      patchDraft.baseVersion = e.target.value;
      savePatchDraft();
    });

    document.getElementById('patch-author')?.addEventListener('input', e => {
      patchDraft.author = e.target.value;
      savePatchDraft();
    });

    document.getElementById('patch-rationale')?.addEventListener('input', e => {
      patchDraft.rationale = e.target.value;
      savePatchDraft();
    });

    function generateGroupedRules() {
      const changes = patchDraft.changes;
      if (changes.length === 0) return '';
      
      const sorted = sortBySeverityFirst(changes.map(c => c.record), ['sheet', 'field']);
      const groups = new Map();
      
      sorted.forEach(record => {
        const whenKey = `${record.sheet || ''}|${record.field || ''}`;
        if (!groups.has(whenKey)) {
          groups.set(whenKey, []);
        }
        groups.get(whenKey).push(record);
      });
      
      let draft = `# Grouped Rule Draft\n\n`;
      let ruleNum = 1;
      
      groups.forEach((records, whenKey) => {
        const [sheet, field] = whenKey.split('|');
        draft += `## Rule ${ruleNum}\n\n`;
        draft += `**WHEN**\n`;
        draft += `- Sheet: ${sheet || 'any'}\n`;
        draft += `- Field: ${field || 'any'}\n\n`;
        draft += `**THEN**\n`;
        records.forEach(r => {
          const actionType = r.issue_type || r.action || 'REQUIRE_PRESENT';
          draft += `- ${actionType} (${r.severity || 'warning'})\n`;
        });
        draft += `\n**BECAUSE**\n`;
        records.forEach(r => {
          draft += `- ${r.details || r.reason_text || r.notes || 'Issue detected'}\n`;
        });
        draft += `\n`;
        ruleNum++;
      });
      
      return draft;
    }

    function getRuleIdPrefix(record) {
      const identity = getJoinIdentity(record);
      const primary = getPrimaryKey(identity);
      const primaryVal = identity[primary] || 'unknown';
      return String(primaryVal).replace(/[^a-zA-Z0-9]/g, '_').substring(0, 15);
    }

    function generateRuleMapping() {
      const changes = patchDraft.changes;
      if (changes.length === 0) return '[]';
      
      const sorted = sortBySeverityFirst(changes.map(c => c.record), ['sheet', 'field']);
      
      const rules = sorted.map((record, idx) => ({
        op: 'add_rule',
        rule_id: `RULE_${getRuleIdPrefix(record)}_${idx + 1}`,
        description: `Fix: ${record.issue_type || record.action || 'unknown'} on ${record.field || 'unknown'}`,
        when: {
          sheet: record.sheet || '',
          field: record.field || '',
          operator: 'EXISTS',
          value: null
        },
        then: {
          action: record.action || 'REQUIRE_PRESENT',
          sheet: record.sheet || '',
          field: record.field || '',
          severity: record.severity || 'warning'
        }
      }));
      
      return JSON.stringify(sortObjectKeys(rules), null, 2);
    }

    function generateFullPatchDraft() {
      const baseVersion = document.getElementById('patch-base-version').value || null;
      const author = document.getElementById('patch-author').value || null;
      const rationale = document.getElementById('patch-rationale').value || null;
      
      const changes = patchDraft.changes;
      const sorted = sortBySeverityFirst(changes.map(c => c.record), ['sheet', 'field']);
      
      const changesArray = sorted.map((record, idx) => ({
        op: 'add_rule',
        rule_id: `RULE_${getRuleIdPrefix(record)}_${idx + 1}`,
        description: `Fix: ${record.issue_type || record.action || 'unknown'} on ${record.field || 'unknown'}`,
        when: {
          sheet: record.sheet || '',
          field: record.field || '',
          operator: 'EXISTS',
          value: null
        },
        then: {
          action: record.action || 'REQUIRE_PRESENT',
          sheet: record.sheet || '',
          field: record.field || '',
          severity: record.severity || 'warning'
        }
      }));
      
      const patch = {
        base_version: baseVersion,
        author: author,
        rationale: rationale,
        changes: changesArray
      };
      
      return JSON.stringify(sortObjectKeys(patch), null, 2);
    }

    document.getElementById('copy-full-patch')?.addEventListener('click', async () => {
      const text = generateFullPatchDraft();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-full-patch');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-rule-mapping')?.addEventListener('click', async () => {
      const text = generateRuleMapping();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-rule-mapping');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-grouped-rules')?.addEventListener('click', async () => {
      const text = generateGroupedRules();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-grouped-rules');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-smoke-baseline')?.addEventListener('click', async () => {
      const cmd = commands.commands?.smoke_baseline || 'bash scripts/replit_smoke.sh';
      const success = await copyToClipboard(cmd);
      const btn = document.getElementById('copy-smoke-baseline');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-smoke-edge')?.addEventListener('click', async () => {
      const cmd = commands.commands?.smoke_edge || 'bash scripts/replit_smoke.sh edge';
      const success = await copyToClipboard(cmd);
      const btn = document.getElementById('copy-smoke-edge');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-evidence-template')?.addEventListener('click', async () => {
      const identity = currentSelection.joinIdentity;
      const primary = identity ? getPrimaryKey(identity) : null;
      const primaryVal = identity?.[primary] || 'unknown';
      
      const template = `# Evidence for Patch

## Commit
- **SHA**: <COMMIT_SHA>
- **Branch**: main

## Verification
- [ ] Smoke baseline passed
- [ ] Smoke edge passed
- [ ] Manual review completed

## Artifacts
- **Join Identity**: ${identity ? formatJoinIdentityText(identity) : 'N/A'}
- **Primary Key**: ${primary || 'N/A'}=${primaryVal}
- **Patch File SHA256**: <SHA256_HASH>

## Notes
Add any additional notes here.
`;
      const success = await copyToClipboard(template);
      const btn = document.getElementById('copy-evidence-template');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    var patchStudioTabs = document.querySelector('.patch-studio-tabs');
    if (patchStudioTabs) {
      patchStudioTabs.addEventListener('click', function(e) {
        var tab = e.target.closest('.patch-studio-tab');
        if (!tab) return;
        var panelName = tab.dataset.panel;
        document.querySelectorAll('.patch-studio-tab').forEach(function(t) { t.classList.remove('active'); });
        tab.classList.add('active');
        document.querySelectorAll('.patch-studio-panel').forEach(function(p) { p.classList.remove('active'); });
        var panelEl = document.getElementById('panel-' + panelName);
        if (panelEl) panelEl.classList.add('active');
        if (panelName === 'preflight') renderPreflightChecklist();
      });
    }

    function parseBaseVersion(input) {
      const trimmed = input.trim();
      if (!trimmed) return { parsed: null, status: 'pending' };
      if (trimmed.startsWith('{')) {
        try {
          const json = JSON.parse(trimmed);
          if (json.version) return { parsed: { version: json.version }, status: 'pass' };
          return { parsed: null, status: 'warn', message: 'No version field found in JSON' };
        } catch (e) {
          return { parsed: null, status: 'warn', message: 'Invalid JSON, storing as raw text' };
        }
      }
      const versionMatch = trimmed.match(/^(\d+\.\d+\.\d+)$/);
      if (versionMatch) return { parsed: { version: versionMatch[1] }, status: 'pass' };
      return { parsed: { version: trimmed }, status: 'warn', message: 'Non-standard version format' };
    }

    function parseValidation(input) {
      const trimmed = input.trim();
      if (!trimmed) return { parsed: null, status: 'pending' };
      const result = { status: 'unknown', baseVersion: null, patchBaseVersion: null, changesCount: null, conflicts: [] };
      if (trimmed.toLowerCase().includes('ok:') || trimmed.toLowerCase().includes('valid')) {
        result.status = 'ok';
      } else if (trimmed.toLowerCase().includes('error') || trimmed.toLowerCase().includes('fail')) {
        result.status = 'error';
      }
      const bvMatch = trimmed.match(/base\.version[:\s]+([0-9.]+)/i);
      if (bvMatch) result.baseVersion = bvMatch[1];
      const pbvMatch = trimmed.match(/patch\.base_version[:\s]+([0-9.]+)/i);
      if (pbvMatch) result.patchBaseVersion = pbvMatch[1];
      const ccMatch = trimmed.match(/changes_count[:\s]+(\d+)/i);
      if (ccMatch) result.changesCount = parseInt(ccMatch[1]);
      const conflictMatches = [...trimmed.matchAll(/conflict[:\s]*(.*?)(?:\n|$)/gi)];
      result.conflicts = conflictMatches.map(m => m[1].trim()).filter(Boolean);
      if (result.status === 'ok') return { parsed: result, status: 'pass' };
      if (result.status === 'error') return { parsed: result, status: 'fail' };
      return { parsed: result, status: 'warn', message: 'Could not determine validation status' };
    }

    function parseConflict(input) {
      const trimmed = input.trim().toLowerCase();
      if (!trimmed) return { parsed: null, status: 'pending' };
      if (trimmed === 'reviewed') return { parsed: { reviewed: true }, status: 'warn', message: 'Manual review confirmed' };
      if (trimmed.includes('no conflict') || trimmed.includes('0 conflicts')) {
        return { parsed: { conflicts: [], count: 0 }, status: 'pass' };
      }
      const conflictLines = input.trim().split('\n').filter(l => l.trim() && !l.toLowerCase().includes('no conflict'));
      if (conflictLines.length > 0) {
        return { parsed: { conflicts: conflictLines, count: conflictLines.length }, status: 'fail', message: `${conflictLines.length} conflict(s) found` };
      }
      return { parsed: { reviewed: true }, status: 'warn', message: 'Content stored for manual review' };
    }

    function parseSmoke(input) {
      const trimmed = input.trim();
      if (!trimmed) return { parsed: null, status: 'pending' };
      if (trimmed.toLowerCase().includes('ok:') || trimmed.toLowerCase().includes('matches expected')) {
        return { parsed: { pass: true }, status: 'pass' };
      }
      if (trimmed.toLowerCase().includes('fail') || trimmed.toLowerCase().includes('error') || trimmed.toLowerCase().includes('mismatch')) {
        return { parsed: { pass: false }, status: 'fail' };
      }
      return { parsed: { raw: trimmed }, status: 'warn', message: 'Could not determine pass/fail' };
    }

    function renderPreflightChecklist() {
      const steps = [
        { id: 1, title: 'Base Version Check', key: 'baseVersion', desc: getStepDescription('baseVersion') },
        { id: 2, title: 'Validation Report', key: 'validation', desc: getStepDescription('validation') },
        { id: 3, title: 'Conflict Check', key: 'conflict', desc: getStepDescription('conflict') },
        { id: 4, title: 'Smoke Evidence', key: 'smoke', desc: getStepDescription('smoke') }
      ];
      const html = steps.map(step => {
        const status = getStepStatus(step.key);
        return `
          <div class="preflight-step">
            <div class="preflight-step-num ${status}">${step.id}</div>
            <div class="preflight-step-info">
              <div class="preflight-step-title">${step.title}</div>
              <div class="preflight-step-status">${step.desc}</div>
            </div>
            <span class="preflight-step-chip ${status}">${status}</span>
          </div>
        `;
      }).join('');
      document.getElementById('preflight-checklist').innerHTML = html;
    }

    function getStepStatus(key) {
      if (key === 'smoke') {
        const baseline = preflightEvidence.smokeBaseline.status;
        if (baseline === 'pass') return 'pass';
        if (baseline === 'fail') return 'fail';
        if (baseline === 'warn') return 'warn';
        return 'pending';
      }
      return preflightEvidence[key]?.status || 'pending';
    }

    function getStepDescription(key) {
      const ev = preflightEvidence;
      if (key === 'baseVersion') {
        if (ev.baseVersion.parsed?.version) return `Version: ${ev.baseVersion.parsed.version}`;
        if (ev.baseVersion.status === 'warn') return ev.baseVersion.message || 'Needs review';
        return 'Not provided';
      }
      if (key === 'validation') {
        if (ev.validation.parsed) {
          const p = ev.validation.parsed;
          if (p.status === 'ok') return `Valid (base: ${p.baseVersion || '?'}, changes: ${p.changesCount || '?'})`;
          if (p.status === 'error') return 'Validation failed';
        }
        if (ev.validation.status === 'warn') return ev.validation.message || 'Needs review';
        return 'Not provided';
      }
      if (key === 'conflict') {
        if (ev.conflict.parsed?.count === 0) return 'No conflicts';
        if (ev.conflict.parsed?.count > 0) return `${ev.conflict.parsed.count} conflict(s)`;
        if (ev.conflict.parsed?.reviewed) return 'Manual review confirmed';
        return 'Not provided';
      }
      if (key === 'smoke') {
        const parts = [];
        if (ev.smokeBaseline.parsed?.pass === true) parts.push('Baseline: PASS');
        else if (ev.smokeBaseline.parsed?.pass === false) parts.push('Baseline: FAIL');
        else if (ev.smokeBaseline.status === 'warn') parts.push('Baseline: Review');
        if (ev.smokeEdge.parsed?.pass === true) parts.push('Edge: PASS');
        else if (ev.smokeEdge.parsed?.pass === false) parts.push('Edge: FAIL');
        else if (ev.smokeEdge.status === 'warn') parts.push('Edge: Review');
        return parts.length > 0 ? parts.join(', ') : 'Not provided';
      }
      return 'Unknown';
    }

    function renderPreflightResult(containerId, evidence) {
      const container = document.getElementById(containerId);
      if (!evidence.parsed && evidence.status === 'pending') {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      container.className = `preflight-result ${evidence.status}`;
      let html = '';
      if (evidence.message) {
        html += `<div style="margin-bottom:6px;"><em>${evidence.message}</em></div>`;
      }
      if (evidence.parsed) {
        const entries = Object.entries(evidence.parsed).filter(([k, v]) => v !== null && k !== 'conflicts');
        entries.sort((a, b) => a[0].localeCompare(b[0]));
        entries.forEach(([key, val]) => {
          html += `<div class="preflight-result-row"><span class="preflight-result-key">${key}:</span><span class="preflight-result-val">${val}</span></div>`;
        });
        if (evidence.parsed.conflicts && evidence.parsed.conflicts.length > 0) {
          html += `<table class="preflight-conflicts-table"><thead><tr><th>#</th><th>Conflict</th></tr></thead><tbody>`;
          evidence.parsed.conflicts.forEach((c, i) => {
            html += `<tr><td>${i + 1}</td><td>${c}</td></tr>`;
          });
          html += `</tbody></table>`;
        }
      }
      container.innerHTML = html || '<em>Parsed successfully</em>';
    }

    function handlePreflightParse(type) {
      if (type === 'base-version') {
        const input = document.getElementById('preflight-base-version').value;
        const result = parseBaseVersion(input);
        preflightEvidence.baseVersion = { raw: input, ...result };
        renderPreflightResult('preflight-base-result', preflightEvidence.baseVersion);
      } else if (type === 'validation') {
        const input = document.getElementById('preflight-validation-input').value;
        const result = parseValidation(input);
        preflightEvidence.validation = { raw: input, ...result };
        renderPreflightResult('preflight-validation-result', preflightEvidence.validation);
      } else if (type === 'conflict') {
        const input = document.getElementById('preflight-conflict-input').value;
        const result = parseConflict(input);
        preflightEvidence.conflict = { raw: input, ...result };
        renderPreflightResult('preflight-conflict-result', preflightEvidence.conflict);
      } else if (type === 'smoke-baseline') {
        const input = document.getElementById('preflight-smoke-baseline-input').value;
        const result = parseSmoke(input);
        preflightEvidence.smokeBaseline = { raw: input, ...result };
        updateSmokeResult();
      } else if (type === 'smoke-edge') {
        const input = document.getElementById('preflight-smoke-edge-input').value;
        const result = parseSmoke(input);
        preflightEvidence.smokeEdge = { raw: input, ...result };
        updateSmokeResult();
      }
      renderPreflightChecklist();
      savePreflightEvidence();
    }

    function updateSmokeResult() {
      const container = document.getElementById('preflight-smoke-result');
      const baseline = preflightEvidence.smokeBaseline;
      const edge = preflightEvidence.smokeEdge;
      const sha = document.getElementById('preflight-sha256').value;
      preflightEvidence.sha256 = sha;
      if (baseline.status === 'pending' && edge.status === 'pending') {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      const overallStatus = (baseline.status === 'fail' || edge.status === 'fail') ? 'fail' :
        (baseline.status === 'pass' && (edge.status === 'pass' || edge.status === 'pending')) ? 'pass' : 'warn';
      container.className = `preflight-result ${overallStatus}`;
      let html = '';
      html += `<div class="preflight-result-row"><span class="preflight-result-key">Baseline:</span><span class="preflight-result-val">${baseline.parsed?.pass === true ? 'PASS' : baseline.parsed?.pass === false ? 'FAIL' : baseline.status}</span></div>`;
      if (edge.status !== 'pending') {
        html += `<div class="preflight-result-row"><span class="preflight-result-key">Edge:</span><span class="preflight-result-val">${edge.parsed?.pass === true ? 'PASS' : edge.parsed?.pass === false ? 'FAIL' : edge.status}</span></div>`;
      }
      if (sha) {
        html += `<div class="preflight-result-row"><span class="preflight-result-key">SHA256:</span><span class="preflight-result-val" style="word-break:break-all;">${sha}</span></div>`;
      }
      container.innerHTML = html;
    }

    function handlePreflightClear(type) {
      if (type === 'base-version') {
        document.getElementById('preflight-base-version').value = '';
        preflightEvidence.baseVersion = { raw: '', parsed: null, status: 'pending' };
        document.getElementById('preflight-base-result').style.display = 'none';
      } else if (type === 'validation') {
        document.getElementById('preflight-validation-input').value = '';
        preflightEvidence.validation = { raw: '', parsed: null, status: 'pending' };
        document.getElementById('preflight-validation-result').style.display = 'none';
      } else if (type === 'conflict') {
        document.getElementById('preflight-conflict-input').value = '';
        preflightEvidence.conflict = { raw: '', parsed: null, status: 'pending' };
        document.getElementById('preflight-conflict-result').style.display = 'none';
      } else if (type === 'smoke-baseline') {
        document.getElementById('preflight-smoke-baseline-input').value = '';
        preflightEvidence.smokeBaseline = { raw: '', parsed: null, status: 'pending' };
        updateSmokeResult();
      } else if (type === 'smoke-edge') {
        document.getElementById('preflight-smoke-edge-input').value = '';
        preflightEvidence.smokeEdge = { raw: '', parsed: null, status: 'pending' };
        updateSmokeResult();
      }
      renderPreflightChecklist();
      savePreflightEvidence();
    }

    document.getElementById('panel-preflight')?.addEventListener('click', e => {
      const parseBtn = e.target.closest('.preflight-parse-btn');
      if (parseBtn) {
        handlePreflightParse(parseBtn.dataset.parse);
        return;
      }
      const clearBtn = e.target.closest('.preflight-clear-btn');
      if (clearBtn) {
        handlePreflightClear(clearBtn.dataset.clear);
        return;
      }
    });

    document.getElementById('preflight-sha256')?.addEventListener('input', () => {
      preflightEvidence.sha256 = document.getElementById('preflight-sha256').value;
      updateSmokeResult();
      savePreflightEvidence();
    });

    document.getElementById('preflight-reset')?.addEventListener('click', () => {
      preflightEvidence = {
        baseVersion: { raw: '', parsed: null, status: 'pending' },
        validation: { raw: '', parsed: null, status: 'pending' },
        conflict: { raw: '', parsed: null, status: 'pending' },
        smokeBaseline: { raw: '', parsed: null, status: 'pending' },
        smokeEdge: { raw: '', parsed: null, status: 'pending' },
        sha256: ''
      };
      document.getElementById('preflight-base-version').value = '';
      document.getElementById('preflight-validation-input').value = '';
      document.getElementById('preflight-conflict-input').value = '';
      document.getElementById('preflight-smoke-baseline-input').value = '';
      document.getElementById('preflight-smoke-edge-input').value = '';
      document.getElementById('preflight-sha256').value = '';
      document.getElementById('preflight-base-result').style.display = 'none';
      document.getElementById('preflight-validation-result').style.display = 'none';
      document.getElementById('preflight-conflict-result').style.display = 'none';
      document.getElementById('preflight-smoke-result').style.display = 'none';
      renderPreflightChecklist();
      savePreflightEvidence();
    });

    function savePreflightEvidence() {
      try {
        localStorage.setItem(PREFLIGHT_STORAGE_KEY, JSON.stringify(preflightEvidence));
      } catch (e) {}
    }

    function restorePreflightEvidence() {
      try {
        const stored = localStorage.getItem(PREFLIGHT_STORAGE_KEY);
        if (!stored) return;
        preflightEvidence = JSON.parse(stored);
        document.getElementById('preflight-base-version').value = preflightEvidence.baseVersion?.raw || '';
        document.getElementById('preflight-validation-input').value = preflightEvidence.validation?.raw || '';
        document.getElementById('preflight-conflict-input').value = preflightEvidence.conflict?.raw || '';
        document.getElementById('preflight-smoke-baseline-input').value = preflightEvidence.smokeBaseline?.raw || '';
        document.getElementById('preflight-smoke-edge-input').value = preflightEvidence.smokeEdge?.raw || '';
        document.getElementById('preflight-sha256').value = preflightEvidence.sha256 || '';
        if (preflightEvidence.baseVersion?.status !== 'pending') renderPreflightResult('preflight-base-result', preflightEvidence.baseVersion);
        if (preflightEvidence.validation?.status !== 'pending') renderPreflightResult('preflight-validation-result', preflightEvidence.validation);
        if (preflightEvidence.conflict?.status !== 'pending') renderPreflightResult('preflight-conflict-result', preflightEvidence.conflict);
        if (preflightEvidence.smokeBaseline?.status !== 'pending' || preflightEvidence.smokeEdge?.status !== 'pending') updateSmokeResult();
      } catch (e) {}
    }

    function savePatchDraft() {
      try {
        const toSave = { ...patchDraft, changes: patchDraft.changes.map(c => ({ _key: c._key, _source: c._source, record: c.record })) };
        localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {}
    }

    function restorePatchDraft() {
      try {
        const stored = localStorage.getItem(PATCH_STORAGE_KEY);
        if (!stored) return;
        const data = JSON.parse(stored);
        patchDraft.baseVersion = data.baseVersion || '0.1.0';
        patchDraft.author = data.author || '';
        patchDraft.rationale = data.rationale || '';
        patchDraft.changes = data.changes || [];
        document.getElementById('patch-base-version').value = patchDraft.baseVersion;
        document.getElementById('patch-author').value = patchDraft.author;
        document.getElementById('patch-rationale').value = patchDraft.rationale;
        renderPatchChanges();
      } catch (e) {}
    }

    function generatePRSummaryWithEvidence() {
      const identity = currentSelection.joinIdentity;
      const contract = currentSelection.contractIdx !== null 
        ? allData.contractResults[currentSelection.contractIdx] : null;
      const issues = identity ? sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']) : [];
      const actions = identity ? sortBySeverityFirst(getRelatedRecords(identity, allData.fieldActions), ['sheet', 'field', 'action']) : [];
      const primary = identity ? getPrimaryKey(identity) : null;
      const primaryVal = identity?.[primary] || 'unknown';

      const ev = preflightEvidence;
      const baseVer = ev.baseVersion.parsed?.version || document.getElementById('patch-base-version').value || 'unknown';
      const patchBaseVer = ev.validation.parsed?.patchBaseVersion || document.getElementById('patch-base-version').value || 'unknown';
      const smokeBaselineStatus = ev.smokeBaseline.parsed?.pass === true ? 'PASS' : ev.smokeBaseline.parsed?.pass === false ? 'FAIL' : 'unknown';
      const smokeEdgeStatus = ev.smokeEdge.parsed?.pass === true ? 'PASS' : ev.smokeEdge.parsed?.pass === false ? 'FAIL' : ev.smokeEdge.status === 'pending' ? 'N/A' : 'unknown';
      const sha256 = ev.sha256 || '<SHA256_HASH>';

      let md = `# PR: Fix issues for ${primary || 'unknown'}=${primaryVal}\n\n`;
      md += `## WHY\n`;
      if (identity) {
        md += `This record has ${issues.length} issue(s) and ${actions.length} pending action(s) that need resolution.\n\n`;
      } else {
        md += `Patch draft with ${patchDraft.changes.length} change(s).\n\n`;
      }
      md += `## Affected Artifacts\n`;
      if (identity) {
        md += `- **Join Identity**: ${formatJoinIdentityText(identity)}\n`;
        md += `- **Contract Status**: ${contract?.sf_contract_status || 'unknown'}\n`;
        md += `- **Detected Subtype**: ${contract?.detected_subtype || 'unknown'}\n`;
        if (issues.length > 0) {
          md += `- **Issues**: ${issues.map(i => i.issue_type).join(', ')}\n`;
        }
      }
      md += `\n## Evidence\n`;
      md += `- **base.version**: ${baseVer}\n`;
      md += `- **patch.base_version**: ${patchBaseVer}\n`;
      md += `- **Smoke Baseline**: ${smokeBaselineStatus}\n`;
      md += `- **Smoke Edge**: ${smokeEdgeStatus}\n`;
      md += `- **SHA256**: ${sha256}\n`;
      return md;
    }

    document.getElementById('stream-panel-toggle')?.addEventListener('click', () => {
      const body = document.getElementById('stream-panel-body');
      const btn = document.getElementById('stream-panel-toggle');
      if (body && btn) {
        body.classList.toggle('active');
        btn.textContent = body.classList.contains('active') ? 'Hide' : 'Show';
        if (body.classList.contains('active')) {
          renderRecordStateSummary();
          renderSessionTimeline();
        }
      }
    });

    function deriveRecordState(record) {
      const joinKey = getJoinKey(record);
      const recordIssues = allData.issues.filter(i => getJoinKey(i) === joinKey);
      
      const hasBlocking = recordIssues.some(i => i.severity === 'blocking');
      const hasWarning = recordIssues.some(i => i.severity === 'warning');
      const hasInfo = recordIssues.some(i => i.severity === 'info');
      const hasMissingData = recordIssues.some(i => 
        i.issue_type === 'missing_data' || 
        i.issue_type === 'join_failure' ||
        i.issue_type === 'missing_required'
      );
      
      if (hasBlocking) return 'BLOCKED';
      if (hasMissingData && hasWarning) return 'WAITING';
      if (hasWarning) return 'PARTIAL';
      return 'CONSOLIDATED';
    }

    function computeRecordStates() {
      const states = { CONSOLIDATED: 0, PARTIAL: 0, WAITING: 0, BLOCKED: 0 };
      allData.contractResults.forEach(record => {
        const state = deriveRecordState(record);
        states[state]++;
      });
      return states;
    }

    function renderRecordStateSummary() {
      const container = document.getElementById('record-state-summary');
      const states = computeRecordStates();
      
      container.innerHTML = `
        <div class="record-state-card consolidated">
          <div class="count">${states.CONSOLIDATED}</div>
          <div class="label">Consolidated</div>
        </div>
        <div class="record-state-card partial">
          <div class="count">${states.PARTIAL}</div>
          <div class="label">Partial</div>
        </div>
        <div class="record-state-card waiting">
          <div class="count">${states.WAITING}</div>
          <div class="label">Waiting</div>
        </div>
        <div class="record-state-card blocked">
          <div class="count">${states.BLOCKED}</div>
          <div class="label">Blocked</div>
        </div>
      `;
    }

    function simulateSessions() {
      const total = allData.contractResults.length;
      if (total === 0) return [];
      
      const sessionCount = Math.min(3, Math.ceil(total / 2));
      const sessions = [];
      
      for (let i = 0; i < sessionCount; i++) {
        const isLast = i === sessionCount - 1;
        const consolidatedPct = 0.3 + (i * 0.25);
        const partialPct = 0.3 - (i * 0.1);
        const waitingPct = 0.2 - (i * 0.08);
        const blockedPct = 1 - consolidatedPct - partialPct - waitingPct;
        
        const sessionRecords = Math.ceil(total / sessionCount);
        
        sessions.push({
          index: i + 1,
          name: `Session ${i + 1}`,
          timestamp: `T+${i * 30}min`,
          records: sessionRecords,
          states: {
            CONSOLIDATED: Math.round(sessionRecords * consolidatedPct),
            PARTIAL: Math.round(sessionRecords * partialPct),
            WAITING: Math.round(sessionRecords * waitingPct),
            BLOCKED: Math.max(0, sessionRecords - Math.round(sessionRecords * consolidatedPct) - Math.round(sessionRecords * partialPct) - Math.round(sessionRecords * waitingPct))
          },
          reconsolidated: i > 0 ? Math.round(sessionRecords * 0.1) : 0
        });
      }
      
      return sessions;
    }

    function renderSessionTimeline() {
      const container = document.getElementById('session-timeline');
      const sessions = simulateSessions();
      
      if (sessions.length === 0) {
        container.innerHTML = '<div class="stream-concept"><p>No data loaded. Load an artifact to see simulated sessions.</p></div>';
        return;
      }
      
      container.innerHTML = sessions.map(s => `
        <div class="session-card">
          <div class="session-card-header">
            <span class="session-card-title">${s.name}</span>
            <span class="session-card-idx">${s.timestamp}</span>
          </div>
          <div class="session-card-stats">
            <div><span>Records:</span><span>${s.records}</span></div>
            <div><span class="state-chip consolidated">CONS</span><span>${s.states.CONSOLIDATED}</span></div>
            <div><span class="state-chip partial">PART</span><span>${s.states.PARTIAL}</span></div>
            <div><span class="state-chip waiting">WAIT</span><span>${s.states.WAITING}</span></div>
            <div><span class="state-chip blocked">BLCK</span><span>${s.states.BLOCKED}</span></div>
            ${s.reconsolidated > 0 ? `<div style="color: #2e7d32; font-weight: 500;"><span>Reconsolidated:</span><span>+${s.reconsolidated}</span></div>` : ''}
          </div>
        </div>
      `).join('');
    }

    function generateStreamSemanticsMarkdown() {
      const states = computeRecordStates();
      const sessions = simulateSessions();
      const total = Object.values(states).reduce((a, b) => a + b, 0);
      
      let md = `# Stream Semantics Model\n\n`;
      md += `## Overview\n\n`;
      md += `This document describes the conceptual streaming model for continuous data processing.\n\n`;
      
      md += `## Never-Stop Flow (Open Faucet Model)\n\n`;
      md += `Records flow continuously through the pipeline:\n`;
      md += `- **CONSOLIDATED** records pass through immediately\n`;
      md += `- **PARTIAL** records are usable but flagged for completion\n`;
      md += `- **WAITING** records are held until missing data arrives\n`;
      md += `- **BLOCKED** records require manual intervention\n\n`;
      md += `This prevents backlogs by isolating issues rather than stopping the entire pipeline.\n\n`;
      
      md += `## Current State Distribution\n\n`;
      md += `| State | Count | Percentage |\n`;
      md += `|-------|-------|------------|\n`;
      md += `| CONSOLIDATED | ${states.CONSOLIDATED} | ${total > 0 ? Math.round(states.CONSOLIDATED / total * 100) : 0}% |\n`;
      md += `| PARTIAL | ${states.PARTIAL} | ${total > 0 ? Math.round(states.PARTIAL / total * 100) : 0}% |\n`;
      md += `| WAITING | ${states.WAITING} | ${total > 0 ? Math.round(states.WAITING / total * 100) : 0}% |\n`;
      md += `| BLOCKED | ${states.BLOCKED} | ${total > 0 ? Math.round(states.BLOCKED / total * 100) : 0}% |\n`;
      md += `| **Total** | ${total} | 100% |\n\n`;
      
      md += `## Reconsolidation Rules\n\n`;
      md += `| From State | Condition | To State |\n`;
      md += `|------------|-----------|----------|\n`;
      md += `| PARTIAL | Warnings resolved | CONSOLIDATED |\n`;
      md += `| WAITING | Missing data arrives | PARTIAL or CONSOLIDATED |\n`;
      md += `| BLOCKED | Manual fix + re-submit | CONSOLIDATED |\n`;
      md += `| CONSOLIDATED | New blocking issue | BLOCKED |\n\n`;
      
      if (sessions.length > 0) {
        md += `## Simulated Session Timeline\n\n`;
        md += `| Session | Timestamp | Records | Consolidated | Partial | Waiting | Blocked | Reconsolidated |\n`;
        md += `|---------|-----------|---------|--------------|---------|---------|---------|----------------|\n`;
        sessions.forEach(s => {
          md += `| ${s.name} | ${s.timestamp} | ${s.records} | ${s.states.CONSOLIDATED} | ${s.states.PARTIAL} | ${s.states.WAITING} | ${s.states.BLOCKED} | ${s.reconsolidated > 0 ? '+' + s.reconsolidated : '-'} |\n`;
        });
        md += `\n`;
      }
      
      md += `## Key Benefits\n\n`;
      md += `1. **No Backlogs**: Problems don't stop the entire pipeline\n`;
      md += `2. **Async Resolution**: Issues are resolved in parallel\n`;
      md += `3. **Deterministic States**: State transitions are rule-based and auditable\n`;
      md += `4. **Visibility**: Operators can see exactly where records are in the flow\n`;
      
      return md;
    }

    document.getElementById('copy-stream-semantics')?.addEventListener('click', async () => {
      const md = generateStreamSemanticsMarkdown();
      const success = await copyToClipboard(md);
      const btn = document.getElementById('copy-stream-semantics');
      if (btn) {
        const orig = btn.textContent;
        btn.textContent = success ? 'Copied!' : 'Failed';
        setTimeout(() => btn.textContent = orig, 1500);
      }
    });

    document.getElementById('simulate-sessions')?.addEventListener('click', () => {
      renderRecordStateSummary();
      renderSessionTimeline();
    });

    document.getElementById('config-inspector-toggle')?.addEventListener('click', () => {
      const body = document.getElementById('config-inspector-body');
      const btn = document.getElementById('config-inspector-toggle');
      if (body && btn) {
        body.classList.toggle('active');
        btn.textContent = body.classList.contains('active') ? 'Hide' : 'Show';
      }
    });

    async function loadConfigFile(path) {
      const relativePath = path.startsWith('../../') ? path : `../../${path}`;
      const resp = await fetch(relativePath);
      if (!resp.ok) throw new Error(`Failed to load ${path}`);
      return await resp.json();
    }

    function sortChangesArray(changes) {
      const sevOrder = { blocking: 0, warning: 1, info: 2 };
      return [...changes].sort((a, b) => {
        const targetCmp = (a.target || '').localeCompare(b.target || '');
        if (targetCmp !== 0) return targetCmp;
        const actionCmp = (a.action || '').localeCompare(b.action || '');
        if (actionCmp !== 0) return actionCmp;
        const ruleIdA = a.rule?.rule_id || a.rule_id || null;
        const ruleIdB = b.rule?.rule_id || b.rule_id || null;
        if (ruleIdA === null && ruleIdB !== null) return 1;
        if (ruleIdA !== null && ruleIdB === null) return -1;
        if (ruleIdA !== null && ruleIdB !== null) {
          const ruleIdCmp = ruleIdA.localeCompare(ruleIdB);
          if (ruleIdCmp !== 0) return ruleIdCmp;
        }
        const whenSheetA = a.rule?.when?.sheet || '';
        const whenSheetB = b.rule?.when?.sheet || '';
        const whenSheetCmp = whenSheetA.localeCompare(whenSheetB);
        if (whenSheetCmp !== 0) return whenSheetCmp;
        const whenFieldA = a.rule?.when?.field || '';
        const whenFieldB = b.rule?.when?.field || '';
        const whenFieldCmp = whenFieldA.localeCompare(whenFieldB);
        if (whenFieldCmp !== 0) return whenFieldCmp;
        const thenArrA = a.rule?.then || [];
        const thenArrB = b.rule?.then || [];
        const minLen = Math.min(thenArrA.length, thenArrB.length);
        for (let i = 0; i < minLen; i++) {
          const thenA = thenArrA[i] || {};
          const thenB = thenArrB[i] || {};
          const sevA = sevOrder[thenA.severity] ?? 3;
          const sevB = sevOrder[thenB.severity] ?? 3;
          if (sevA !== sevB) return sevA - sevB;
          const thenSheetCmp = (thenA.sheet || '').localeCompare(thenB.sheet || '');
          if (thenSheetCmp !== 0) return thenSheetCmp;
          const thenFieldCmp = (thenA.field || '').localeCompare(thenB.field || '');
          if (thenFieldCmp !== 0) return thenFieldCmp;
        }
        return thenArrA.length - thenArrB.length;
      });
    }

    function computeRulesetDelta(baseConfig, patch) {
      const delta = {
        salesforce_rules: { added: 0, deprecated: 0 },
        qa_rules: { added: 0, deprecated: 0 },
        resolver_rules: { added: 0, deprecated: 0 }
      };
      
      (patch.changes || []).forEach(change => {
        const target = change.target;
        if (!delta[target]) return;
        if (change.action === 'add_rule') delta[target].added++;
        if (change.action === 'deprecate_rule') delta[target].deprecated++;
      });
      
      return delta;
    }

    function renderPatchSummary(baseConfig, patch) {
      const container = document.getElementById('patch-summary');
      const baseVersion = baseConfig.version || '(unknown)';
      const patchBaseVersion = patch.base_version || '(unknown)';
      configVersionMatch = baseVersion === patchBaseVersion;
      const chipClass = configVersionMatch ? 'match' : 'mismatch';
      const chipText = configVersionMatch ? 'MATCH' : 'MISMATCH';
      
      container.innerHTML = `
        <div class="patch-summary-header">
          <h4>Patch Summary</h4>
          <span class="version-chip ${chipClass}">${chipText}</span>
        </div>
        <div class="patch-summary-grid">
          <div class="patch-summary-item">
            <label>base.version</label>
            <div class="value">${baseVersion}</div>
          </div>
          <div class="patch-summary-item">
            <label>patch.base_version</label>
            <div class="value">${patchBaseVersion}</div>
          </div>
          <div class="patch-summary-item">
            <label>Author</label>
            <div class="value">${patch.author || '(not set)'}</div>
          </div>
          <div class="patch-summary-item">
            <label>Rationale</label>
            <div class="value">${patch.rationale || '(not set)'}</div>
          </div>
          <div class="patch-summary-item">
            <label>Changes Count</label>
            <div class="value">${(patch.changes || []).length}</div>
          </div>
        </div>
      `;
      
      updatePreflightFromLoadedConfig(baseVersion, patchBaseVersion, configVersionMatch);
    }

    function updatePreflightFromLoadedConfig(baseVersion, patchBaseVersion, isMatch) {
      preflightEvidence.baseVersion.raw = `base.version: ${baseVersion}, patch.base_version: ${patchBaseVersion}`;
      preflightEvidence.baseVersion.parsed = {
        version: baseVersion,
        patchBaseVersion: patchBaseVersion,
        match: isMatch
      };
      preflightEvidence.baseVersion.status = isMatch ? 'pass' : 'fail';
      
      preflightEvidence.validation.parsed = preflightEvidence.validation.parsed || {};
      preflightEvidence.validation.parsed.baseVersion = baseVersion;
      preflightEvidence.validation.parsed.patchBaseVersion = patchBaseVersion;
      
      savePreflightEvidence();
    }

    function renderRulesetDelta(delta) {
      const container = document.getElementById('ruleset-delta');
      const targets = ['salesforce_rules', 'qa_rules', 'resolver_rules'];
      
      let cardsHtml = '';
      targets.forEach(t => {
        const d = delta[t] || { added: 0, deprecated: 0 };
        cardsHtml += `
          <div class="ruleset-count-card">
            <div class="count added">+${d.added}</div>
            <div class="label">${t.replace('_rules', '')} Added</div>
          </div>
          <div class="ruleset-count-card">
            <div class="count deprecated">-${d.deprecated}</div>
            <div class="label">${t.replace('_rules', '')} Deprecated</div>
          </div>
        `;
      });
      
      container.innerHTML = `
        <h4>Ruleset Delta</h4>
        <div class="ruleset-delta-counts">${cardsHtml}</div>
      `;
    }

    function renderChangesTable(changes) {
      const container = document.getElementById('changes-table');
      const sorted = sortChangesArray(changes);
      
      let rowsHtml = sorted.map(change => {
        const action = change.action || '';
        const target = change.target || '';
        const ruleId = change.rule?.rule_id || change.rule_id || '';
        const when = change.rule?.when || {};
        const whenStr = when.sheet && when.field ? `${when.sheet}.${when.field} ${when.operator || ''} ${JSON.stringify(when.value || '')}` : (change.reason || '');
        const then = change.rule?.then || [];
        const thenStr = then.map(t => `${t.action || ''} ${t.sheet || ''}.${t.field || ''}`).join('; ') || '';
        const severity = then[0]?.severity || '';
        
        return `
          <tr>
            <td><span class="action-chip ${action}">${action}</span></td>
            <td>${target}</td>
            <td>${ruleId || '<span class="null-value">null</span>'}</td>
            <td style="font-size: 0.8em; font-family: monospace;">${whenStr}</td>
            <td style="font-size: 0.8em; font-family: monospace;">${thenStr}</td>
            <td><span class="severity-${severity}">${severity}</span></td>
          </tr>
        `;
      }).join('');
      
      container.innerHTML = `
        <thead><tr>
          <th>Action</th>
          <th>Target</th>
          <th>Rule ID</th>
          <th>When</th>
          <th>Then</th>
          <th>Severity</th>
        </tr></thead>
        <tbody>${rowsHtml}</tbody>
      `;
    }

    function generateRulesetDeltaMarkdown() {
      if (!loadedBaseConfig || !loadedPatch) return '# No config loaded\n';
      
      const baseVersion = loadedBaseConfig.version || '(unknown)';
      const patchBaseVersion = loadedPatch.base_version || '(unknown)';
      const delta = computeRulesetDelta(loadedBaseConfig, loadedPatch);
      const sorted = sortChangesArray(loadedPatch.changes || []);
      
      let md = `# Ruleset Delta\n\n`;
      md += `## Summary\n\n`;
      md += `| Field | Value |\n`;
      md += `|-------|-------|\n`;
      md += `| base.version | ${baseVersion} |\n`;
      md += `| patch.base_version | ${patchBaseVersion} |\n`;
      md += `| Version Match | ${configVersionMatch ? 'YES' : 'NO'} |\n`;
      md += `| Author | ${loadedPatch.author || '(not set)'} |\n`;
      md += `| Changes Count | ${(loadedPatch.changes || []).length} |\n`;
      md += `\n## Rule Counts by Target\n\n`;
      md += `| Target | Added | Deprecated |\n`;
      md += `|--------|-------|------------|\n`;
      ['salesforce_rules', 'qa_rules', 'resolver_rules'].forEach(t => {
        const d = delta[t] || { added: 0, deprecated: 0 };
        md += `| ${t} | +${d.added} | -${d.deprecated} |\n`;
      });
      md += `\n## Changes Detail\n\n`;
      md += `| Action | Target | Rule ID | Severity |\n`;
      md += `|--------|--------|---------|----------|\n`;
      sorted.forEach(change => {
        const action = change.action || '';
        const target = change.target || '';
        const ruleId = change.rule?.rule_id || change.rule_id || '(null)';
        const severity = change.rule?.then?.[0]?.severity || '';
        md += `| ${action} | ${target} | ${ruleId} | ${severity} |\n`;
      });
      md += `\n## Rationale\n\n${loadedPatch.rationale || '(not set)'}\n`;
      
      return md;
    }

    async function loadConfigWithPatch() {
      const basePath = document.getElementById('base-config-path').value.trim();
      const patchPath = document.getElementById('patch-path').value.trim();
      const statusEl = document.getElementById('config-status');
      const resultsEl = document.getElementById('config-results');
      
      if (!basePath) {
        statusEl.style.display = 'block';
        statusEl.className = 'config-inspector-status error';
        statusEl.textContent = 'Base config path is required.';
        return;
      }
      
      try {
        statusEl.style.display = 'block';
        statusEl.className = 'config-inspector-status info';
        statusEl.textContent = 'Loading base config...';
        
        loadedBaseConfig = await loadConfigFile(basePath);
        
        if (patchPath) {
          statusEl.textContent = 'Loading patch...';
          loadedPatch = await loadConfigFile(patchPath);
        } else {
          loadedPatch = { base_version: loadedBaseConfig.version, changes: [], author: '', rationale: '' };
        }
        
        renderPatchSummary(loadedBaseConfig, loadedPatch);
        const delta = computeRulesetDelta(loadedBaseConfig, loadedPatch);
        renderRulesetDelta(delta);
        renderChangesTable(loadedPatch.changes || []);
        
        resultsEl.style.display = 'block';
        statusEl.className = 'config-inspector-status success';
        statusEl.textContent = `Loaded: ${basePath} + ${patchPath || '(no patch)'}`;
        
      } catch (e) {
        statusEl.className = 'config-inspector-status error';
        statusEl.textContent = `Error: ${e.message}`;
        resultsEl.style.display = 'none';
      }
    }

    document.getElementById('load-config')?.addEventListener('click', loadConfigWithPatch);
    
    document.getElementById('clear-config')?.addEventListener('click', () => {
      loadedBaseConfig = null;
      loadedPatch = null;
      configVersionMatch = null;
      document.getElementById('config-results').style.display = 'none';
      document.getElementById('config-status').style.display = 'none';
    });

    document.getElementById('copy-ruleset-delta')?.addEventListener('click', async () => {
      const md = generateRulesetDeltaMarkdown();
      const success = await copyToClipboard(md);
      const btn = document.getElementById('copy-ruleset-delta');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('session-loader-toggle')?.addEventListener('click', () => {
      const body = document.getElementById('session-loader-body');
      const btn = document.getElementById('session-loader-toggle');
      body.classList.toggle('active');
      btn.textContent = body.classList.contains('active') ? 'Hide' : 'Show';
    });

    async function loadArtifact(path) {
      const relativePath = path.startsWith('../../') ? path : `../../${path}`;
      const resp = await fetch(relativePath);
      if (!resp.ok) throw new Error(`Failed to load ${path}`);
      return await resp.json();
    }

    async function loadDataWithComparison(primaryPath, comparePath) {
      const statusEl = document.getElementById('session-status');
      const errorContainer = document.getElementById('error-container');
      const sourceInfo = document.getElementById('source-info');
      
      try {
        statusEl.style.display = 'block';
        statusEl.className = 'session-loader-status info';
        statusEl.textContent = 'Loading primary artifact...';
        
        const primaryData = await loadArtifact(primaryPath);
        
        renderSummary(primaryData.sf_summary || {});
        allData.contractResults = sortByJoinTriplet(primaryData.sf_contract_results || []);
        // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
        allData.issues = filterOutReferenceData(sortBySeverityFirst(primaryData.sf_issues || [], ['sheet', 'field', 'issue_type']));
        allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(primaryData.sf_field_actions || [], ['sheet', 'field', 'action']));
        allData.changeLog = sortBySeverityFirst(primaryData.sf_change_log || [], ['sheet', 'field', 'notes']);
        
        sourceInfo.textContent = `Primary: ${primaryPath}`;
        
        if (comparePath && comparePath.trim()) {
          statusEl.textContent = 'Loading comparison artifact...';
          try {
            compareData = await loadArtifact(comparePath);
            
            const compareContractResults = sortByJoinTriplet(compareData.sf_contract_results || []);
            const compareIssues = sortBySeverityFirst(compareData.sf_issues || [], ['sheet', 'field', 'issue_type']);
            const compareFieldActions = sortBySeverityFirst(compareData.sf_field_actions || [], ['sheet', 'field', 'action']);
            
            rowChanges.contractResults = computeRowChanges(allData.contractResults, compareContractResults, 'contractResults');
            rowChanges.issues = computeRowChanges(allData.issues, compareIssues, 'issues');
            rowChanges.fieldActions = computeRowChanges(allData.fieldActions, compareFieldActions, 'fieldActions');
            
            deltaStats = computeDeltaStats(primaryData, compareData);
            
            sourceInfo.textContent = `Primary: ${primaryPath} | Compare: ${comparePath}`;
            statusEl.className = 'session-loader-status success';
            statusEl.textContent = `Loaded with comparison. Found ${Object.keys(rowChanges.issues).length + Object.keys(rowChanges.fieldActions).length} row-level changes.`;
          } catch (e) {
            statusEl.className = 'session-loader-status error';
            statusEl.textContent = `Comparison file not found: ${comparePath}. Showing primary only.`;
            compareData = null;
            rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
            deltaStats = null;
          }
        } else {
          compareData = null;
          rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
          deltaStats = null;
          statusEl.className = 'session-loader-status success';
          statusEl.textContent = 'Loaded primary artifact (no comparison).';
        }
        
        populateSubtypeDropdown();
        renderDeltaSummary();
        renderAllTables();
        restoreSelection();
        
        errorContainer.innerHTML = '';
      } catch (e) {
        statusEl.className = 'session-loader-status error';
        statusEl.textContent = `Error: ${e.message}`;
        errorContainer.innerHTML = `<div class="error">Could not load artifact: ${e.message}</div>`;
      }
    }

    document.getElementById('load-session')?.addEventListener('click', () => {
      const primaryPath = document.getElementById('primary-path').value.trim() || 'out/sf_packet.preview.json';
      const comparePath = document.getElementById('compare-path').value.trim();
      loadDataWithComparison(primaryPath, comparePath);
    });

    document.getElementById('clear-compare')?.addEventListener('click', () => {
      document.getElementById('compare-path').value = '';
      compareData = null;
      rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
      deltaStats = null;
      renderDeltaSummary();
      renderAllTables();
      document.getElementById('session-status').style.display = 'none';
      document.getElementById('source-info').textContent = `Data source: ${document.getElementById('primary-path').value || 'out/sf_packet.preview.json'}`;
    });

    // ========== DATASET BUNDLE (V1.2.6) ==========
    // DatasetBundleDraft: internal model for multi-sheet dataset with computed field_index
    // TODO: Align exact schema keys once Kiwi returns
    
    function createDatasetBundle(dataset, source) {
      var sheets = dataset.sheets || {};
      var sheetNames = Object.keys(sheets);
      
      var bundle = {
        dataset_id: dataset.dataset_id || ('ds_' + Date.now()),
        dataset_revision: 1,
        created_at_utc: new Date().toISOString(),
        source: {
          dataset_type: source?.type || 'unknown',
          source_file_name: source?.filename || 'unknown'
        },
        sheet_packets: sheetNames.map(function(name) {
          var sheet = sheets[name];
          return {
            packet_version: 'DatasetPacketV1',
            sheet_name: name,
            header_map: (sheet.headers || []).reduce(function(acc, h, i) { acc[h] = i; return acc; }, {}),
            rows: sheet.rows || []
          };
        }),
        field_index: [],
        audit_log: [
          { event: 'bundle_created', timestamp: new Date().toISOString(), source: source?.type || 'unknown' }
        ]
      };
      
      // Compute field_index from sheet_packets
      bundle.field_index = computeFieldIndex(bundle.sheet_packets);
      
      return bundle;
    }
    
    function computeFieldIndex(sheetPackets) {
      var index = [];
      (sheetPackets || []).forEach(function(packet) {
        var headers = Object.keys(packet.header_map || {});
        headers.forEach(function(field) {
          index.push({
            sheet: packet.sheet_name,
            field: field,
            full_path: packet.sheet_name + '.' + field
          });
        });
      });
      return index;
    }
    
    function getCurrentBundle() {
      if (!dataLoaded || !allData) return null;
      
      var source = { type: 'loaded', filename: currentArtifactPath || 'unknown' };
      var dataset = {
        dataset_id: localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET) || 'current',
        sheets: allData.sheets || {}
      };
      
      return createDatasetBundle(dataset, source);
    }
    
    function copyBundleJSON() {
      var bundle = getCurrentBundle();
      if (!bundle) {
        showToast('No dataset loaded', 'error');
        return;
      }
      
      var json = JSON.stringify(bundle, null, 2);
      navigator.clipboard.writeText(json).then(function() {
        showToast('Bundle JSON copied to clipboard', 'success');
      }).catch(function(err) {
        console.error('Failed to copy:', err);
        showToast('Failed to copy to clipboard', 'error');
      });
    }
    
    // ========== PACKAGER (V1.2.6) ==========
    // Consumes DatasetBundle and generates stable record_id index
    
    function generateRecordId(datasetId, sheetName, rowNumber, stableColumns) {
      // Generate stable record_id: dataset_id + sheet_name + row_number + optional stable columns
      var base = datasetId + '|' + sheetName + '|' + rowNumber;
      if (stableColumns && stableColumns.contract_key) {
        base += '|' + stableColumns.contract_key;
      }
      return base;
    }
    
    function packageBundle(bundle) {
      if (!bundle || !bundle.sheet_packets) return null;
      
      var recordIndex = [];
      var queueRecords = { todo: [], needs_review: [] };
      
      bundle.sheet_packets.forEach(function(packet) {
        (packet.rows || []).forEach(function(row, idx) {
          var recordId = generateRecordId(
            bundle.dataset_id,
            packet.sheet_name,
            idx,
            { contract_key: row.contract_key }
          );
          var record = {
            record_id: recordId,
            dataset_id: bundle.dataset_id,
            sheet_name: packet.sheet_name,
            row_number: idx,
            contract_key: row.contract_key || '',
            file_url: row.file_url || '',
            file_name: row.file_name || '',
            status: 'needs_review',
            data: row
          };
          recordIndex.push(record);
          // Route to queue: if has issues -> Needs Review, else -> To Do
          if (row._has_issue) {
            queueRecords.needs_review.push(record);
          } else {
            queueRecords.todo.push(record);
          }
        });
      });
      
      return {
        dataset_id: bundle.dataset_id,
        dataset_revision: bundle.dataset_revision,
        record_count: recordIndex.length,
        record_index: recordIndex,
        queue_distribution: {
          todo: queueRecords.todo.length,
          needs_review: queueRecords.needs_review.length
        },
        packaged_at: new Date().toISOString()
      };
    }
    
    function repackageCurrentDataset() {
      var bundle = getCurrentBundle();
      if (!bundle) {
        showToast('No dataset to package', 'error');
        return null;
      }
      
      var packageResult = packageBundle(bundle);
      
      // Update allData.contractResults with stable record_ids
      allData.contractResults = packageResult.record_index.map(function(rec) {
        return {
          record_id: rec.record_id,
          contract_key: rec.contract_key,
          file_url: rec.file_url,
          file_name: rec.file_name,
          status: rec.status,
          sheet_name: rec.sheet_name,
          row_number: rec.row_number
        };
      });
      
      // Re-render tables
      renderAllTables();
      updateQueueCounts();
      
      showToast('Dataset packaged with ' + packageResult.record_count + ' records', 'success');
      return packageResult;
    }
    
    // ========== UPLOAD LIBRARY (V1.2.6) ==========
    function getUploadLibrary() {
      try {
        var stored = localStorage.getItem(STORAGE_KEY_LIBRARY);
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        return [];
      }
    }
    
    function saveUploadLibrary(library) {
      try {
        localStorage.setItem(STORAGE_KEY_LIBRARY, JSON.stringify(library));
      } catch (e) {
        console.error('Failed to save upload library:', e);
      }
    }
    
    function saveToUploadLibrary(dataset, filename, source) {
      var library = getUploadLibrary();
      var existingIndex = library.findIndex(function(d) { return d.dataset_id === dataset.dataset_id; });
      
      var entry = {
        dataset_id: dataset.dataset_id || ('ds_' + Date.now()),
        filename: filename || 'Untitled',
        source: source || 'unknown',
        revision: existingIndex >= 0 ? (library[existingIndex].revision + 1) : 1,
        created_at: new Date().toISOString(),
        sheet_count: Object.keys(dataset.sheets || {}).length,
        row_count: Object.values(dataset.sheets || {}).reduce(function(acc, s) { return acc + (s.rows?.length || 0); }, 0)
      };
      
      if (existingIndex >= 0) {
        library[existingIndex] = entry;
      } else {
        library.unshift(entry);
      }
      
      saveUploadLibrary(library);
      localStorage.setItem(STORAGE_KEY_ACTIVE_DATASET, entry.dataset_id);
      return entry;
    }
    
    // v1.4.24: Render mocked Drive files list (read-only stub)
    function renderUploadLibrary() {
      var listEl = document.getElementById('upload-library-list');
      if (!listEl) return;
      
      // Get folder name to generate contextual mock files
      var folderName = localStorage.getItem('ingestion_folder_name') || 'Analyst';
      var firstName = folderName.split(' ')[0] || 'Analyst';
      
      // Mocked drive files derived from user's folder
      var mockFiles = [
        { name: 'Q4_2025_Contracts_' + firstName + '.xlsx', size: '2.4 MB', modified: 'Jan 28, 2026' },
        { name: 'Vendor_Agreements_' + firstName + '.csv', size: '856 KB', modified: 'Jan 25, 2026' },
        { name: 'License_Review_Batch_12.xlsx', size: '1.1 MB', modified: 'Jan 22, 2026' },
        { name: 'Distribution_Terms_2026.csv', size: '445 KB', modified: 'Jan 18, 2026' }
      ];
      
      var html = mockFiles.map(function(file) {
        var ext = file.name.split('.').pop().toUpperCase();
        var icon = ext === 'XLSX' ? '📊' : '📄';
        return '<div class="drive-file-item" style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px 15px; opacity: 0.7;">' +
          '<div style="display: flex; align-items: center; gap: 12px;">' +
            '<span style="font-size: 1.3em;">' + icon + '</span>' +
            '<div style="flex: 1; min-width: 0;">' +
              '<div style="font-weight: 500; font-size: 0.9em; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + file.name + '</div>' +
              '<div style="font-size: 0.8em; color: #888;">' + file.size + ' · Modified ' + file.modified + '</div>' +
            '</div>' +
            '<span style="font-size: 0.7em; background: #e0e0e0; padding: 2px 6px; border-radius: 3px; color: #666;">Read Only</span>' +
          '</div>' +
        '</div>';
      }).join('');
      
      listEl.innerHTML = html;
    }
    
    function activateDataset(datasetId) {
      // v1.6.39: Clear all cell stores before loading new dataset
      clearAllCellStores();
      
      try {
        // v2.3 G6: No localStorage blob read. Check upload library for dataset metadata.
        var library = getUploadLibrary();
        var dataset = null;
        if (library && library.length > 0) {
          dataset = library.find(function(d) { return d.dataset_id === datasetId; }) || null;
        }
        if (!dataset) {
          // Fallback: check if current in-memory data matches
          if (typeof IDENTITY_CONTEXT !== 'undefined' && IDENTITY_CONTEXT.dataset_id === datasetId && workbook && workbook.order && workbook.order.length > 0) {
            dataset = { dataset_id: datasetId, contract_results: [], issues: [], field_actions: [], summary: {}, sheets: {} };
          }
        }
        if (!dataset) {
          showToast('Dataset not found. Please reload from Data Source.', 'error');
          return;
        }
        
        allData = {
          contractResults: dataset.contract_results || [],
          issues: dataset.issues || [],
          fieldActions: dataset.field_actions || [],
          changeLog: [],
          summary: dataset.summary || {},
          sheets: dataset.sheets || {}
        };
        
        localStorage.setItem(STORAGE_KEY_ACTIVE_DATASET, datasetId);
        dataLoaded = true;
        datasetRevision++; // v1.6.18: Bump revision for cache invalidation
        currentArtifactPath = datasetId;
        updateUIForDataState();
        updateSessionChip();
        populateSubtypeDropdown();
        renderAllTables();
        populateTargetFieldDropdown();
        renderUploadLibrary();
        
        // v1.5.3: Persist all records to canonical store
        persistAllRecordsToStore();
        
        // v1.6.0: Generate signals for dataset
        generateSignalsForDataset();
        
        showToast('Dataset activated: ' + datasetId, 'success');
      } catch (e) {
        console.error('Failed to activate dataset:', e);
        showToast('Failed to activate dataset', 'error');
      }
    }
    
    function duplicateDataset(datasetId) {
      var library = getUploadLibrary();
      var entry = library.find(function(d) { return d.dataset_id === datasetId; });
      if (!entry) return;
      
      var newEntry = Object.assign({}, entry, {
        dataset_id: 'ds_' + Date.now(),
        revision: 1,
        created_at: new Date().toISOString(),
        filename: entry.filename + ' (copy)'
      });
      
      library.unshift(newEntry);
      saveUploadLibrary(library);
      renderUploadLibrary();
      showToast('Duplicated as new dataset', 'success');
    }
    
    function deleteDataset(datasetId) {
      if (!confirm('Delete this dataset from the library?')) return;
      
      var library = getUploadLibrary();
      library = library.filter(function(d) { return d.dataset_id !== datasetId; });
      saveUploadLibrary(library);
      
      var activeId = localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET);
      if (activeId === datasetId) {
        localStorage.removeItem(STORAGE_KEY_ACTIVE_DATASET);
      }
      
      renderUploadLibrary();
      showToast('Dataset deleted', 'success');
    }
    
    // ========== LOADER HANDLERS (v1.4.3) ==========
    // v1.6.8: Load demo dataset (original or modified based on variant parameter)
    var cachedOriginalDataset = null;
    var cachedModifiedDataset = null;
    var activeDatasetVariant = 'original';  // Track which dataset is currently active
    
    // v1.6.8: Update saved datasets UI to show active indicator
    function updateSavedDatasetsUI(activeVariant) {
      var originalCard = document.getElementById('demo-dataset-card-original');
      var modifiedCard = document.getElementById('demo-dataset-card-modified');
      var modifiedBanner = document.getElementById('demo-modified-banner');
      
      if (originalCard && modifiedCard) {
        if (activeVariant === 'modified') {
          // Modified is active
          originalCard.style.background = '#fafafa';
          originalCard.style.border = '1px solid #e0e0e0';
          originalCard.classList.remove('active');
          modifiedCard.style.background = '#fff3e0';
          modifiedCard.style.border = '2px solid #ff9800';
          modifiedCard.classList.add('active');
          // Show in-progress banner
          if (modifiedBanner) modifiedBanner.style.display = 'block';
        } else {
          // Original is active (default)
          originalCard.style.background = '#e3f2fd';
          originalCard.style.border = '2px solid #1976d2';
          originalCard.classList.add('active');
          modifiedCard.style.background = '#fafafa';
          modifiedCard.style.border = '1px solid #e0e0e0';
          modifiedCard.classList.remove('active');
          // Hide in-progress banner
          if (modifiedBanner) modifiedBanner.style.display = 'none';
        }
      }
    }
    
    async function loadSampleDataset(options) {
      if (typeof TruthPack !== 'undefined' && TruthPack.isActive()) {
        console.log('[TRUTH-PACK][P0.6] sample_dataset_blocked: truth-pack mode active');
        if (typeof showToast === 'function') showToast('Sample datasets disabled in Truth Pack mode', 'warning');
        return;
      }
      options = options || {};
      
      // v1.6.39: Clear all cell stores before loading new dataset
      clearAllCellStores();
      
      try {
        // Start staged loader
        stagedLoader.start();
        stagedLoader.setStage('loading');
        
        // v1.6.8: Select dataset URL based on explicit variant parameter (default: original)
        var variant = options.variant || 'original';
        var isModified = (variant === 'modified');
        var datasetUrl = isModified ? MODIFIED_DATASET_URL : DEFAULT_DATASET_URL;
        var datasetName = isModified ? 'ostereo_demo_v1.json' : 'ostereo_demo_original.json';
        
        // Update active variant tracker
        activeDatasetVariant = variant;
        
        // Fetch the dataset if not cached
        var cached = isModified ? cachedModifiedDataset : cachedOriginalDataset;
        if (!cached) {
          console.log('[Loader] Fetching demo dataset from:', datasetUrl);
          var resp = await fetch(datasetUrl);
          if (!resp.ok) {
            throw new Error('Failed to fetch demo dataset: ' + resp.status);
          }
          cached = await resp.json();
          if (isModified) {
            cachedModifiedDataset = cached;
          } else {
            cachedOriginalDataset = cached;
          }
          console.log('[Loader] Demo dataset fetched:', cached.dataset_id || datasetName);
        }
        
        // Standardizing fields stage
        stagedLoader.setStage('standardizing');
        
        var dataset = cached;
        
        // Reset workbook and populate from dataset sheets
        resetWorkbook();
        
        if (dataset.sheets) {
          Object.keys(dataset.sheets).forEach(function(sheetName) {
            var sheet = dataset.sheets[sheetName];
            addSheet(sheetName, sheet.headers || [], sheet.rows || [], {});
          });
        }
        
        // Transform dataset to match expected format
        allData = {
          contractResults: dataset.contract_results || [],
          issues: dataset.issues || [],
          fieldActions: dataset.field_actions || [],
          changeLog: [],
          summary: dataset.summary || {},
          sheets: dataset.sheets || {}
        };
        
        // v2.3 G6: localStorage blob write removed (storage policy).
        // Dataset persisted via SessionDB/IndexedDB only.
        
        // Save to upload library
        saveToUploadLibrary(dataset, 'Ostereo Demo Dataset', 'ostereo_demo');
        
        dataLoaded = true;
        currentArtifactPath = datasetName;
        currentDataset = null; // Reset cache
        updateUIForDataState();
        updateSessionChip();
        populateSubtypeDropdown();
        populateGridSheetSelector();
        renderAllTables();
        renderGrid();
        populateTargetFieldDropdown();
        updateLoaderPageUI();
        
        // v1.6.5: Clear old records before persisting new ones to prevent quota issues
        clearOldRecordsFromStore();
        
        // v1.5.3: Persist all records to canonical store for SRR rehydration
        try {
          persistAllRecordsToStore();
        } catch (e) {
          console.warn('[RecordStore] Non-critical: Failed to persist records:', e.message);
          // Non-critical - dataset still loaded successfully in memory
        }
        
        // v1.6.0: Generate signals for dataset
        generateSignalsForDataset();
        
        // v1.6.33: Seed patch requests from RFI meta sheet (modified dataset has RFIs)
        seedPatchRequestsFromMetaSheet();
        
        // v1.6.33: Also seed verifier RFI queue for verifier view
        if (typeof seedVerifierRFIQueueFromMetaSheet === 'function') {
          seedVerifierRFIQueueFromMetaSheet();
        }
        
        // v1.6.8 fix: Re-render grid after change map is built for cell highlighting
        renderGrid();
        
        // v1.6.33: Update progress after seeding
        if (typeof updateProgressBlock === 'function') {
          updateProgressBlock();
        }
        
        // v2.3: Rebuild ContractIndex from live workbook on demo/sandbox path
        try {
          ContractIndex.build();
          populateContractSelector();
          console.log('[V2.3-GATE][G2] PASS ContractIndex rebuilt from live workbook on demo/sandbox path');
        } catch(e) { console.warn('[ContractIndex] Demo/sandbox build failed:', e); }

        console.log('[Loader] Ostereo demo dataset loaded:', workbook.order.length, 'sheets');
        showToast('Ostereo demo dataset loaded successfully', 'success');
        updateSidebarSheetSelector();
        updateActiveDataSourceBar(datasetName);
        
        // v1.6.8: Update saved datasets UI to show active indicator
        updateSavedDatasetsUI(variant);
        
        // Rendering stage then finish staged loader
        stagedLoader.setStage('rendering');
        stagedLoader.finish();
        
        // Auto-redirect after loading (v1.4.4) - always go to grid after load
        if (options.autoRedirect !== false) {
          setTimeout(function() {
            navigateTo('grid');
          }, 300);
        }
      } catch (e) {
        // Finish loader on error too
        stagedLoader.finish();
        console.error('[Loader] Failed to load default dataset:', e.message || e, e.stack);
        showToast('Failed to load default dataset: ' + (e.message || 'Unknown error'), 'error');
      }
    }
    
    // Handle CSV import with standardization (v1.4.3 INGEST-02: preserve ALL columns)
    function handleCSVImport(file, callback) {
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var csvText = e.target.result;
          var parsed = parseCSV(csvText);
          if (!parsed.rows || parsed.rows.length === 0) {
            showToast('No data rows found in CSV', 'error');
            return;
          }
          // Sheet name from file (single sheet for CSV)
          var sheetName = file.name.replace(/\.[^.]+$/, '') || 'Sheet1';
          // Reset and populate workbook (v1.4.3 INGEST-01)
          resetWorkbook();
          // Normalize headers while preserving originals
          var normalizedHeaders = parsed.headers.map(normalizeHeader);
          var headerMap = {};
          parsed.headers.forEach(function(h, i) { headerMap[h] = normalizedHeaders[i]; });
          // Detect unknown columns
          var unknownColumns = [];
          normalizedHeaders.forEach(function(nh, i) {
            if (!CANONICAL_HEADERS.includes(nh)) {
              unknownColumns.push({
                original: parsed.headers[i],
                normalized: nh,
                samples: parsed.rows.slice(0, 3).map(function(r) { return r[parsed.headers[i]]; }).filter(Boolean)
              });
            }
          });
          // Build rows with ALL columns preserved
          var normalizedRows = parsed.rows.map(function(row, idx) {
            var newRow = { _row_index: idx };
            parsed.headers.forEach(function(original) {
              var normalized = headerMap[original];
              newRow[normalized] = row[original] !== '' ? row[original] : null;
            });
            // Ensure required fields have defaults
            if (!newRow.contract_key) newRow.contract_key = (sheetName ? (sheetName + ':') : '') + 'ROW_' + (idx + 1);
            if (!newRow.status) newRow.status = 'needs_review';
            return newRow;
          });
          // Add sheet to workbook
          addSheet(sheetName, normalizedHeaders, normalizedRows, {
            originalHeaders: parsed.headers,
            headerMap: headerMap,
            unknownColumns: unknownColumns,
            delimiter: parsed.delimiter
          });
          // Also populate allData for legacy compatibility
          allData = {
            contractResults: normalizedRows.map(function(r) {
              var row = Object.assign({}, r);
              row.sheet = sheetName;
              return row;
            }),
            issues: [],
            fieldActions: [],
            changeLog: [],
            summary: {
              total_contracts: normalizedRows.length,
              ready: 0,
              needs_review: normalizedRows.length,
              blocked: 0
            }
          };

          // v2.3 G6: localStorage blob write removed (storage policy).
          // Workbook persisted via saveWorkbookToCache() -> IndexedDB.
          if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
          saveToUploadLibrary({ workbook: workbook }, file.name, 'csv');
          dataLoaded = true;
          currentArtifactPath = file.name;
          currentDataset = null; // Reset cache
          updateUIForDataState();
          updateSessionChip();
          populateSubtypeDropdown();
          populateGridSheetSelector();
          renderAllTables();
          renderGrid();
          // v1.5.3: Persist all records to canonical store
          persistAllRecordsToStore();
          // v1.6.0: Generate signals for dataset
          generateSignalsForDataset();
          console.log('[Loader] CSV imported:', sheetName, 'headers:', normalizedHeaders.length, 'rows:', normalizedRows.length, 'unknown:', unknownColumns.length);
          showToast('CSV imported: ' + parsed.rows.length + ' rows, ' + unknownColumns.length + ' unknown columns', 'success');
          if (callback) callback();
        } catch (err) {
          console.error('CSV import error:', err);
          showToast('Failed to import CSV: ' + err.message, 'error');
        }
      };
      reader.readAsText(file);
    }
    
    // ========== LOADER PAGE UI (V1.2.7) ==========
    
    function updateLoaderPageUI() {
      var continuePanel = document.getElementById('loader-continue-panel');
      var importPanel = document.getElementById('loader-import-panel');
      var samplePanel = document.getElementById('loader-sample-panel');
      var activeDatasetInfo = document.getElementById('loader-active-dataset-info');
      
      console.log('[LoaderUI] Updating, dataLoaded: ' + dataLoaded);
      
      if (dataLoaded) {
        // Show Continue panel, hide Import/Sample panels
        if (continuePanel) {
          continuePanel.style.display = 'block';
          if (activeDatasetInfo) {
            var contractCount = (allData.contractResults || []).length;
            var sheetCount = Object.keys(allData.sheets || {}).length;
            activeDatasetInfo.innerHTML = '<strong>' + (currentArtifactPath || 'Dataset') + '</strong> | ' + 
              sheetCount + ' sheets, ' + contractCount + ' records';
          }
        }
        if (importPanel) importPanel.style.display = 'none';
        if (samplePanel) samplePanel.style.display = 'none';
      } else {
        // Show Import (primary) + Sample (secondary), hide Continue
        if (continuePanel) continuePanel.style.display = 'none';
        if (importPanel) importPanel.style.display = 'block';
        if (samplePanel) samplePanel.style.display = 'block';
      }
    }
    
    function initLoaderPage() {
      // Toggle collapsible actions
      var toggleBtn = document.getElementById('loader-toggle-actions');
      var actionsContent = document.getElementById('loader-actions-content');
      var toggleIcon = document.getElementById('loader-toggle-icon');
      
      if (toggleBtn) {
        toggleBtn.addEventListener('click', function() {
          var isOpen = actionsContent.style.display !== 'none';
          actionsContent.style.display = isOpen ? 'none' : 'block';
          toggleIcon.innerHTML = isOpen ? '&#9660;' : '&#9650;';
        });
      }
      
      // Continue to Triage button
      var continueBtn = document.getElementById('btn-continue-triage');
      if (continueBtn) {
        continueBtn.addEventListener('click', function() {
          navigateTo('triage');
        });
      }
      
      // Primary Import CSV button
      var importBtnPrimary = document.getElementById('btn-import-csv-primary');
      var fileInputPrimary = document.getElementById('file-import-csv-primary');
      if (importBtnPrimary && fileInputPrimary) {
        importBtnPrimary.addEventListener('click', function() {
          fileInputPrimary.click();
        });
        fileInputPrimary.addEventListener('change', function(e) {
          if (e.target.files && e.target.files[0]) {
            importCSVFile(e.target.files[0]);
          }
        });
      }
      
      // Secondary Sample Dataset button
      var sampleBtn = document.getElementById('btn-load-sample-secondary');
      if (sampleBtn) {
        sampleBtn.addEventListener('click', function() {
          loadSampleDataset({ autoRedirect: true });
        });
      }
    }
    
    function seedSampleDatasetOnFirstRun() {
      // v1.4.24: Clean up sample datasets and auto-map folder from email
      try {
        var library = JSON.parse(localStorage.getItem(STORAGE_KEY_LIBRARY) || '[]');
        var filtered = library.filter(function(e) { 
          return e.dataset_id !== 'ds-sample' && e.source !== 'sample'; 
        });
        if (filtered.length !== library.length) {
          console.log('[FirstRun] Removing demo dataset from library');
          localStorage.setItem(STORAGE_KEY_LIBRARY, JSON.stringify(filtered));
        }
      } catch (e) { console.warn('[FirstRun] Error cleaning demo data:', e); }
      
      // v1.4.24: Clear stale verifier queue data if no actual data is loaded
      if (!dataLoaded) {
        clearStaleVerifierData();
      }
      
      // v1.4.24: Auto-map folder from demoUser email/folder (no manual selection)
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      if (!mappedFolder) {
        var folderName = deriveFolderFromUser();
        if (folderName) {
          localStorage.setItem('ingestion_folder_name', folderName);
          localStorage.setItem('ingestion_folder_sync_time', new Date().toISOString());
          console.log('[FirstRun] Auto-mapped folder from user:', folderName);
        } else {
          console.log('[FirstRun] Could not derive folder, using placeholder');
          localStorage.setItem('ingestion_folder_name', 'Assigned Analyst Folder');
          localStorage.setItem('ingestion_folder_sync_time', new Date().toISOString());
        }
        updateDataSourceDrawerState();
        updateActiveDataSourceBar();
      }
    }
    
    // v1.4.24: Clear stale verifier queue and patch request data
    // v1.6.26: Also clears artifact store to prevent stale queue counts
    function clearStaleVerifierData() {
      console.log('[FirstRun] Clearing stale verifier queue data');
      
      // Clear verifier queue
      localStorage.removeItem('srr_verifier_queue_v1');
      
      // v1.6.26: Clear artifact store (clears stale art_* files that cause phantom queue counts)
      var artifactCleared = ARTIFACT_STORE.resetPlayground();
      console.log('[FirstRun] Cleared', artifactCleared, 'stale artifacts');
      
      // Clear all patch requests from PATCH_REQUEST_STORE
      var keysToRemove = [];
      var prefix = 'pr:' + ARTIFACT_STORE.environment + ':';
      for (var i = 0; i < localStorage.length; i++) {
        var key = localStorage.key(i);
        if (key && key.startsWith(prefix)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(function(key) {
        localStorage.removeItem(key);
      });
      console.log('[FirstRun] Cleared', keysToRemove.length, 'stale patch requests');
      
      // Reset in-memory verifier queue state
      if (typeof verifierQueueState !== 'undefined') {
        verifierQueueState.payloads = [];
      }
      
      // Reset in-memory verifier queue state
      if (typeof verifierQueueState !== 'undefined') {
        verifierQueueState.items = [];
      }
    }
    
    // v1.4.24: Derive folder name from demoUser stored in localStorage
    function deriveFolderFromUser() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        // If folder is explicitly set in demoUser, use it
        if (demoUser.folder) return demoUser.folder;
        // Otherwise derive from name or email
        if (demoUser.name) return demoUser.name;
        if (demoUser.email) {
          // sarah.chen@company.com → "Sarah Chen"
          var local = demoUser.email.split('@')[0];
          return local.split('.').map(function(p) {
            return p.charAt(0).toUpperCase() + p.slice(1);
          }).join(' ');
        }
        return null;
      } catch (e) { return null; }
    }
    
    function updateLoaderSummary() {
      // Legacy function - now handled by updateLoaderPageUI
      updateLoaderPageUI();
    }
    
    function importCSVFile(file) {
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var text = e.target.result;
          var parsed = parseCSV(text);
          var sheetName = file.name.replace(/\.[^/.]+$/, '').toLowerCase().replace(/[^a-z0-9_]/g, '_');
          var dataset = {
            dataset_id: 'import_' + Date.now(),
            version: '1.0.0',
            created_at: new Date().toISOString(),
            description: 'Imported from ' + file.name,
            sheets: {},
            issues: [],
            field_actions: [],
            contract_results: [],
            summary: {}
          };
          dataset.sheets[sheetName] = parsed;
          // Generate contract_results from rows if contract_key exists
          if (parsed.headers.includes('contract_key')) {
            parsed.rows.forEach(function(row, idx) {
              dataset.contract_results.push({
                contract_key: row.contract_key || '',
                file_url: row.file_url || '',
                file_name: row.file_name || '',
                status: 'needs_review',
                subtype: row.subtype || 'unknown',
                issue_count: 0
              });
            });
          }
          allData = {
            contractResults: dataset.contract_results,
            issues: dataset.issues,
            fieldActions: dataset.field_actions,
            changeLog: [],
            summary: dataset.summary,
            sheets: dataset.sheets
          };
          // v2.3 G6: localStorage blob write removed (storage policy).
          if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
          // Save to upload library
          saveToUploadLibrary(dataset, file.name, 'csv');
          dataLoaded = true;
          currentArtifactPath = file.name;
          updateUIForDataState();
          updateSessionChip();
          populateSubtypeDropdown();
          renderAllTables();
          populateTargetFieldDropdown();
          updateLoaderPageUI();
          // v1.5.3: Persist all records to canonical store
          persistAllRecordsToStore();
          // v1.6.0: Generate signals for dataset
          generateSignalsForDataset();
          showToast('Imported ' + parsed.rows.length + ' rows from ' + file.name, 'success');
          // Auto-redirect after CSV import (v1.2.7) - use intended route if stored
          setTimeout(function() {
            var nextRoute = sessionStorage.getItem('kiwi_next_route') || 'triage';
            sessionStorage.removeItem('kiwi_next_route');
            navigateTo(nextRoute);
          }, 300);
        } catch (err) {
          console.error('CSV import error:', err);
          showToast('Failed to import CSV: ' + err.message, 'error');
        }
      };
      reader.readAsText(file);
    }
    
    function attachPDFFile(file) {
      try {
        var attachments = JSON.parse(localStorage.getItem(STORAGE_KEY_PDF_ATTACHMENTS) || '[]');
        
        var attachment = {
          pdf_artifact_id: 'pdf_' + Date.now(),
          file_name: file.name,
          file_size_bytes: file.size,
          added_at_utc: new Date().toISOString(),
          local_object_url: URL.createObjectURL(file)
        };
        
        attachments.push(attachment);
        localStorage.setItem(STORAGE_KEY_PDF_ATTACHMENTS, JSON.stringify(attachments));
        
        renderPDFAttachmentsList();
        showToast('PDF attached: ' + file.name, 'success');
      } catch (err) {
        console.error('PDF attach error:', err);
        showToast('Failed to attach PDF: ' + err.message, 'error');
      }
    }
    
    function renderPDFAttachmentsList() {
      var listEl = document.getElementById('pdf-attachments-list');
      if (!listEl) return;
      
      var attachments = JSON.parse(localStorage.getItem(STORAGE_KEY_PDF_ATTACHMENTS) || '[]');
      
      if (attachments.length === 0) {
        listEl.innerHTML = '';
        return;
      }
      
      listEl.innerHTML = '<div style="margin-top: 8px;"><strong>Attached:</strong></div>' +
        attachments.map(function(a) {
          return '<div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">' +
            '<span>📄 ' + escapeHtml(a.file_name) + '</span>' +
            '<span style="color: #999; font-size: 0.8em;">(' + Math.round(a.file_size_bytes / 1024) + ' KB)</span>' +
            '</div>';
        }).join('');
    }
    
    function resetDemoState() {
      var keysToRemove = [
        STORAGE_KEY_DATASET,
        STORAGE_KEY_PDF_ATTACHMENTS,
        STORAGE_KEY_SESSION,
        STORAGE_KEY_LIBRARY,
        STORAGE_KEY_ACTIVE_DATASET,
        'orchestrate.comments.v1',
        'orchestrate.patch_requests.v1'
      ];
      
      keysToRemove.forEach(function(key) {
        localStorage.removeItem(key);
      });
      
      allData = { contractResults: [], issues: [], fieldActions: [], changeLog: [], summary: {}, sheets: {} };
      dataLoaded = false;
      currentArtifactPath = null;
      
      updateUIForDataState();
      updateSessionChip();
      renderAllTables();
      populateTargetFieldDropdown();
      updateLoaderSummary();
      renderPDFAttachmentsList();
      updatePatchQueueCounts();
      
      // Navigate to loader after reset
      navigateTo('loader');
      showToast('Demo state reset', 'success');
    }
    
    function rebuildFieldIndex() {
      populateTargetFieldDropdown();
      showToast('Field index rebuilt', 'success');
    }
    
    // Loader button event listeners
    document.getElementById('btn-load-sample')?.addEventListener('click', loadSampleDataset);
    document.getElementById('btn-import-csv')?.addEventListener('click', function() {
      document.getElementById('file-import-csv')?.click();
    });
    document.getElementById('file-import-csv')?.addEventListener('change', function(e) {
      var file = e.target.files?.[0];
      if (file) importCSVFile(file);
      e.target.value = '';
    });
    document.getElementById('btn-attach-pdf')?.addEventListener('click', function() {
      document.getElementById('file-attach-pdf')?.click();
    });
    document.getElementById('file-attach-pdf')?.addEventListener('change', function(e) {
      var file = e.target.files?.[0];
      if (file) attachPDFFile(file);
      e.target.value = '';
    });
    document.getElementById('btn-open-spreadsheet')?.addEventListener('click', function() {
      navigateTo('grid');
    });
    document.getElementById('btn-reset-demo-state')?.addEventListener('click', resetDemoState);
    document.getElementById('btn-rebuild-field-index')?.addEventListener('click', rebuildFieldIndex);
    
    // Initialize loader state on page load (v1.2.7)
    seedSampleDatasetOnFirstRun();
    initLoaderPage();
    renderPDFAttachmentsList();
    updateLoaderPageUI();
    
    // v1.4.13: Initialize PDF cache (IndexedDB)
    initPdfCache().then(function() {
      console.log('[PDF_CACHE] Initialized, cached:', cacheState.pdfCount, 'files,', formatCacheSize(cacheState.totalBytes));
    });
    
    // Welcome hero and top toolbar event listeners
    document.getElementById('welcome-load-data')?.addEventListener('click', openDataSourcePanel);
    document.getElementById('btn-data-source')?.addEventListener('click', openDataSourcePanel);
    document.getElementById('btn-configure')?.addEventListener('click', openConfigureWizard);
    document.getElementById('btn-ruleset')?.addEventListener('click', openRulesetModal);
    document.getElementById('btn-compare')?.addEventListener('click', openCompareModal);
    document.getElementById('btn-run')?.addEventListener('click', openRunModal);
    
    // Configure wizard modal events
    document.getElementById('configure-wizard-modal')?.addEventListener('click', e => {
      if (e.target.id === 'configure-wizard-modal') closeConfigureWizard();
    });

    // Data source drawer events
    document.getElementById('data-source-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'data-source-drawer') closeDataSourceDrawer();
    });
    
    // v1.4.23: Folder selection modal events
    document.getElementById('folder-modal-overlay')?.addEventListener('click', e => {
      if (e.target.id === 'folder-modal-overlay') closeFolderSelectionModal();
    });
    document.getElementById('folder-select')?.addEventListener('change', function(e) {
      var confirmBtn = document.getElementById('folder-confirm-btn');
      if (confirmBtn) confirmBtn.disabled = !e.target.value;
    });
    
    // v1.4.23: Initialize folder state on load
    updateActiveDataSourceBar();
    updateLoaderFolderState();
    
    // Record drawer events
    document.getElementById('record-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'record-drawer') closeRecordDrawer();
    });
    
    // Patch detail drawer events
    document.getElementById('patch-detail-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'patch-detail-drawer') closePatchDetailDrawer();
    });
    
    // Config Flows drawer events
    document.getElementById('config-flows-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'config-flows-drawer') closeConfigFlows();
    });
    document.querySelectorAll('#data-source-drawer .wizard-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#data-source-drawer .wizard-preset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('wizard-artifact-path').value = btn.dataset.path;
      });
    });
    document.getElementById('wizard-load-artifact')?.addEventListener('click', async () => {
      const path = document.getElementById('wizard-artifact-path').value.trim();
      if (!path) {
        showWizardStatus('data-source-status', 'Please enter an artifact path', 'error');
        return;
      }
      const relativePath = '../../' + path;
      try {
        const response = await fetch(relativePath);
        if (!response.ok) throw new Error('File not found');
        const data = await response.json();
        if (data.sf_summary || data.sf_contract_results || data.sf_issues || data.sf_field_actions) {
          allData.contractResults = data.sf_contract_results || [];
          // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
          allData.issues = filterOutReferenceData(data.sf_issues || []);
          allData.fieldActions = filterOutReferenceData(data.sf_field_actions || []);
          allData.summary = data.sf_summary || {};
          allData.changeLog = data.sf_changelog || [];
          dataLoaded = true;
          currentArtifactPath = path;
          updateUIForDataState();
          renderAllTables();
          closeDataSourceDrawer();
          navigateTo('grid');
          showWizardStatus('data-source-status', 'Data loaded successfully!', 'success');
        } else {
          throw new Error('Invalid data format - expected Preview Packet structure');
        }
      } catch (e) {
        showWizardStatus('data-source-status', 'Failed to load: ' + e.message, 'error');
      }
    });

    // Ruleset modal events
    document.getElementById('ruleset-modal')?.addEventListener('click', e => {
      if (e.target.id === 'ruleset-modal') closeRulesetModal();
    });
    document.getElementById('wizard-load-ruleset')?.addEventListener('click', async () => {
      const basePath = document.getElementById('wizard-base-config').value.trim();
      const patchPath = document.getElementById('wizard-patch-config').value.trim();
      if (!basePath) {
        showWizardStatus('ruleset-status', 'Please enter a base config path', 'error');
        return;
      }
      try {
        // Use existing config loading logic
        document.getElementById('base-config-path').value = basePath;
        document.getElementById('patch-path').value = patchPath;
        await loadConfigAndPatch();
        closeRulesetModal();
        showWizardStatus('ruleset-status', 'Ruleset loaded!', 'success');
      } catch (e) {
        showWizardStatus('ruleset-status', 'Failed to load ruleset: ' + e.message, 'error');
      }
    });

    // Compare modal events
    document.getElementById('compare-modal')?.addEventListener('click', e => {
      if (e.target.id === 'compare-modal') closeCompareModal();
    });
    document.querySelectorAll('#compare-modal .wizard-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#compare-modal .wizard-preset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('wizard-compare-path').value = btn.dataset.compare || '';
      });
    });
    document.getElementById('wizard-load-compare')?.addEventListener('click', async () => {
      const comparePath = document.getElementById('wizard-compare-path').value.trim();
      if (!comparePath) {
        compareData = null;
        rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
        deltaStats = null;
        renderDeltaSummary();
        renderAllTables();
        closeCompareModal();
        return;
      }
      const relativePath = '../../' + comparePath;
      try {
        const response = await fetch(relativePath);
        if (!response.ok) throw new Error('File not found');
        compareData = await response.json();
        rowChanges.contractResults = computeRowChanges(allData.contractResults, compareData.sf_contract_results || [], 'contractResults');
        rowChanges.issues = computeRowChanges(allData.issues, compareData.sf_issues || [], 'issues');
        rowChanges.fieldActions = computeRowChanges(allData.fieldActions, compareData.sf_field_actions || [], 'fieldActions');
        deltaStats = computeDeltaStats({ sf_summary: allData.summary }, compareData);
        renderDeltaSummary();
        renderAllTables();
        closeCompareModal();
      } catch (e) {
        showWizardStatus('compare-status', 'Failed to load comparison: ' + e.message, 'error');
      }
    });

    // Run modal events
    document.getElementById('run-modal')?.addEventListener('click', e => {
      if (e.target.id === 'run-modal') closeRunModal();
    });
    document.querySelectorAll('#run-modal .toolbar-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const cmdKey = btn.dataset.cmd;
        if (commands[cmdKey]) {
          const cmd = commands[cmdKey];
          document.getElementById('modal-title').textContent = cmd.label || cmdKey;
          document.getElementById('modal-description').textContent = cmd.description || '';
          document.getElementById('modal-command').textContent = cmd.command;
          document.getElementById('command-modal').classList.add('active');
        }
      });
    });

    function showWizardStatus(id, message, type) {
      const status = document.getElementById(id);
      if (status) {
        status.textContent = message;
        status.className = 'modal-status ' + type;
        status.style.display = 'block';
        setTimeout(() => { status.style.display = 'none'; }, 3000);
      }
    }

    initRouter();
    loadCommands();
    setupLoaderHandlers();
    
    // Initialize Masterline Artifact Registry
    loadArtifactRegistry();
    updateDevMasterlineUI();
    updateDemoToggleUI(); // v1.6.4: Initialize demo toggle UI state
    applyDemoControlsVisibility();
    renderArtifactRegistryTable();
    renderWorkflowMap();
    setupStandardizerDropZone();
    loadColumnAliases();
    SchemaTreeEditor.init();
    initPatchConsole();
    
    // v1.6.56: Initialize SessionDB + migrate legacy localStorage data, then autoload
    (async function() {
      await SessionDB.init();
      await AuditTimeline.init();
    if (typeof TruthPack !== 'undefined') { TruthPack.restoreFromStorage(); }
      await SessionDB.migrateFromLocalStorage();
      if (artifactRegistry.devMasterlineEnabled) {
        await masterlineAutoload();
      } else {
        loadData();
      }
    })();
    
    restorePreflightEvidence();
    restorePatchDraft();
    updateUIForDataState();
    updateSessionChip();
  </script>

    <!-- Glossary Portal Tooltip (v1.6.36+) -->
    <div id="glossary-portal-tooltip"></div>
    <script>
    (function() {
      var portal = document.getElementById('glossary-portal-tooltip');
      var hoverTimer = null;
      var currentIcon = null;

      function showPortalTooltip(icon) {
        var fieldKey = icon.getAttribute('data-field-key');
        var sheet = icon.getAttribute('data-sheet') || '';
        if (!fieldKey) return;

        portal.innerHTML = buildGlossaryPortalContent(fieldKey, sheet);

        var rect = icon.getBoundingClientRect();
        var tw = 340;
        var pad = 12;

        var left = rect.left + rect.width / 2 - tw / 2;
        if (left < pad) left = pad;
        if (left + tw > window.innerWidth - pad) left = window.innerWidth - pad - tw;

        portal.style.width = tw + 'px';
        portal.style.left = left + 'px';
        portal.classList.add('visible');

        var ph = portal.offsetHeight;
        if (rect.top - ph - 8 > pad) {
          portal.style.top = (rect.top - ph - 8) + 'px';
        } else {
          portal.style.top = (rect.bottom + 8) + 'px';
        }
      }

      function hidePortalTooltip() {
        clearTimeout(hoverTimer);
        hoverTimer = null;
        currentIcon = null;
        portal.classList.remove('visible');
      }

      document.addEventListener('mouseover', function(e) {
        var icon = e.target.closest('.glossary-icon');
        if (!icon) return;
        if (icon === currentIcon) return;
        clearTimeout(hoverTimer);
        currentIcon = icon;
        hoverTimer = setTimeout(function() {
          showPortalTooltip(icon);
        }, 150);
      });

      document.addEventListener('mouseout', function(e) {
        var icon = e.target.closest('.glossary-icon');
        if (icon && icon === currentIcon) {
          hidePortalTooltip();
        }
      });

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') hidePortalTooltip();
      });
    })();
    </script>

<!-- Batch Add Missing Items Modal (v1.6.48) -->
<div id="batch-add-modal" class="batch-add-modal" style="display:none;">
  <div class="batch-add-content">
    <div class="batch-add-header">
      <h3 id="batch-add-title">Add Catalog Items</h3>
      <button class="batch-add-close" onclick="closeBatchAddModal()">&times;</button>
    </div>
    <div class="batch-add-steps">
      <div class="batch-add-step active" data-step="1"><span class="step-num">1</span><span class="step-label">Paste List</span></div>
      <div class="batch-add-step" data-step="2"><span class="step-num">2</span><span class="step-label">Preview</span></div>
      <div class="batch-add-step" data-step="3"><span class="step-num">3</span><span class="step-label">Confirm</span></div>
    </div>
    <div class="batch-add-body" id="batch-add-body">
    </div>
    <div class="batch-add-footer" id="batch-add-footer">
    </div>
  </div>
</div>
<script>
(function() {
  var batchAddState = {
    step: 1,
    sheetName: '',
    anchorRowIndex: -1,
    targetField: '',
    items: [],
    categorizedItems: [],
    rawText: ''
  };

  window.openBatchAddModal = function() {
    var sheetName = srrState.currentSheetName;
    var rowIndex = srrState.currentRowIndex;
    var record = srrState.currentRecord;
    if (!sheetName || rowIndex < 0) {
      showToast('Select a record first.', 'warning');
      return;
    }

    batchAddState.sheetName = sheetName;
    batchAddState.anchorRowIndex = rowIndex;
    batchAddState.targetField = guessTargetField(sheetName);
    batchAddState.items = [];
    batchAddState.categorizedItems = [];
    batchAddState.rawText = '';

    if (!record._group || !record._group.is_anchor) {
      if (typeof markAsGroupAnchor === 'function') markAsGroupAnchor(sheetName, rowIndex);
      if (!record._capabilities) record._capabilities = {};
      record._capabilities.catalog_items = true;
      if (typeof updateSrrGroupBadge === 'function') updateSrrGroupBadge();
      if (typeof saveWorkbookToCache === 'function') saveWorkbookToCache();
    }
    batchAddState.step = 1;

    document.getElementById('batch-add-modal').style.display = 'flex';
    renderBatchAddStep();
  };

  window.closeBatchAddModal = function() {
    document.getElementById('batch-add-modal').style.display = 'none';
  };

  function renderBatchAddStep() {
    var body = document.getElementById('batch-add-body');
    var footer = document.getElementById('batch-add-footer');
    var steps = document.querySelectorAll('.batch-add-step');
    steps.forEach(function(s) {
      var sn = parseInt(s.getAttribute('data-step'));
      s.classList.toggle('active', sn === batchAddState.step);
      s.classList.toggle('done', sn < batchAddState.step);
    });

    var sheet = workbook.sheets[batchAddState.sheetName];
    var anchor = sheet ? sheet.rows[batchAddState.anchorRowIndex] : null;
    var anchorLabel = anchor ? (anchor[sheet.headers[0]] || 'Row ' + (batchAddState.anchorRowIndex + 1)) : 'Unknown';


    if (batchAddState.step === 1) {
      var targetOptions = '';
      if (sheet && sheet.headers) {
        sheet.headers.forEach(function(h) {
          if (!h.startsWith('_')) {
            var sel = h === batchAddState.targetField ? ' selected' : '';
            targetOptions += '<option value="' + escapeHtml(h) + '"' + sel + '>' + escapeHtml(h) + '</option>';
          }
        });
      }
      body.innerHTML =
        '<div style="margin-bottom: 12px;">' +
          '<div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">Parent Record</div>' +
          '<div style="background: #e3f2fd; padding: 8px 12px; border-radius: 6px; font-weight: 600; font-size: 0.9em;">' + escapeHtml(anchorLabel) + '</div>' +
        '</div>' +
        '<div style="margin-bottom: 12px;">' +
          '<label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 4px;">Target Field (where pasted values go)</label>' +
          '<select id="batch-add-target-field" class="batch-add-select" onchange="window._batchAddSetTarget(this.value)">' + targetOptions + '</select>' +
        '</div>' +
        '<div>' +
          '<label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 4px;">Paste items (one per line)</label>' +
          '<textarea id="batch-add-textarea" class="batch-add-textarea" rows="8" placeholder="Item 1\nItem 2\nItem 3\n...">' + escapeHtml(batchAddState.rawText) + '</textarea>' +
        '</div>' +
        (function() {
          var catMeta = resolveCatalogMetadata(batchAddState.sheetName);
          if (catMeta.fields.length === 0) return '';
          if (!batchAddState.metadata) batchAddState.metadata = {};
          var metaHtml = '<div style="margin-top: 14px; border-top: 1px solid #e0e0e0; padding-top: 12px;">' +
            '<div style="font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 8px;">Catalog Item Metadata</div>' +
            '<div style="font-size: 0.75em; color: #888; margin-bottom: 10px;">Only fields with rules or constraints are shown. Empty fields are skipped.</div>';
          for (var mi = 0; mi < catMeta.fields.length; mi++) {
            var mf = catMeta.fields[mi];
            if (mf.field_key === batchAddState.targetField) continue;
            var reqBadge = mf.requiredness === 'required' ? ' <span style="color:#c62828;font-weight:600;">*</span>' : '';
            var storedVal = batchAddState.metadata[mf.field_key] || '';
            var fmtHint = '';
            if (mf.max_length > 0) fmtHint = ' (max ' + mf.max_length + ' chars)';
            if (mf.is_picklist && mf.options.length > 0) {
              metaHtml += '<div style="margin-bottom: 8px;">' +
                '<label style="font-size: 0.8em; color: #555; display: block; margin-bottom: 2px;">' + escapeHtml(mf.field_label) + reqBadge + '</label>' +
                '<select data-meta-key="' + escapeHtml(mf.field_key) + '" onchange="window._batchAddSetMeta(this)" style="width:100%;padding:5px 8px;border:1px solid #ccc;border-radius:4px;font-size:0.85em;">' +
                '<option value="">— Select —</option>';
              for (var oi = 0; oi < mf.options.length; oi++) {
                var optVal = typeof mf.options[oi] === 'object' ? (mf.options[oi].value || mf.options[oi].label || '') : String(mf.options[oi]);
                var optSel = storedVal === optVal ? ' selected' : '';
                metaHtml += '<option value="' + escapeHtml(optVal) + '"' + optSel + '>' + escapeHtml(optVal) + '</option>';
              }
              metaHtml += '</select></div>';
            } else if (!mf.is_lookup) {
              metaHtml += '<div style="margin-bottom: 8px;">' +
                '<label style="font-size: 0.8em; color: #555; display: block; margin-bottom: 2px;">' + escapeHtml(mf.field_label) + reqBadge + fmtHint + '</label>' +
                '<input type="text" data-meta-key="' + escapeHtml(mf.field_key) + '" value="' + escapeHtml(storedVal) + '" ' +
                (mf.max_length > 0 ? 'maxlength="' + mf.max_length + '" ' : '') +
                'onchange="window._batchAddSetMeta(this)" ' +
                'style="width:100%;padding:5px 8px;border:1px solid #ccc;border-radius:4px;font-size:0.85em;box-sizing:border-box;" />' +
                '</div>';
            }
          }
          metaHtml += '</div>';
          return metaHtml;
        })();
      footer.innerHTML =
        '<button class="batch-add-btn-cancel" onclick="closeBatchAddModal()">Cancel</button>' +
        '<button class="batch-add-btn-next" onclick="window._batchAddNext()">Next: Preview</button>';
    } else if (batchAddState.step === 2) {
      var exact = batchAddState.categorizedItems.filter(function(c) { return c.category === 'exact'; });
      var near = batchAddState.categorizedItems.filter(function(c) { return c.category === 'near'; });
      var newItems = batchAddState.categorizedItems.filter(function(c) { return c.category === 'new'; });

      var previewHtml = '<div class="batch-add-preview">';
      previewHtml += '<div style="font-size: 0.85em; color: #666; margin-bottom: 12px;">' + batchAddState.items.length + ' item(s) analyzed for <strong>' + escapeHtml(batchAddState.sheetName) + '</strong></div>';
      previewHtml += '<div style="font-size: 0.8em; color: #888; margin-bottom: 12px;">Target field: <code>' + escapeHtml(batchAddState.targetField) + '</code></div>';

      if (exact.length > 0) {
        previewHtml += '<div class="batch-add-cat-header exact"><span>Existing — will attach to group (' + exact.length + ')</span><span>&#10003;</span></div>';
        previewHtml += '<div class="batch-add-preview-list" style="margin-bottom: 12px;">';
        exact.forEach(function(c, idx) {
          previewHtml += '<div class="batch-add-preview-row" style="background:#f1f8e9;"><span class="batch-add-preview-num">' + (idx+1) + '</span><span class="batch-add-preview-text">' + escapeHtml(c.text) + ' <span style="color:#999;font-size:0.8em;">→ matches "' + escapeHtml(c.matchedValue) + '"</span></span></div>';
        });
        previewHtml += '</div>';
      }

      if (near.length > 0) {
        previewHtml += '<div class="batch-add-cat-header near"><span>Possible Duplicates — will create &amp; flag (' + near.length + ')</span><span>&#9888;</span></div>';
        previewHtml += '<div class="batch-add-preview-list" style="margin-bottom: 12px;">';
        near.forEach(function(c, idx) {
          previewHtml += '<div class="batch-add-preview-row" style="background:#fffde7;"><span class="batch-add-preview-num">' + (idx+1) + '</span><span class="batch-add-preview-text">' + escapeHtml(c.text) + ' <span style="color:#f57f17;font-size:0.8em;">~' + (c.similarity || '?') + '% match to "' + escapeHtml(c.matchedValue) + '"</span></span></div>';
        });
        previewHtml += '</div>';
      }

      if (newItems.length > 0) {
        previewHtml += '<div class="batch-add-cat-header new-cat"><span>New — will create (' + newItems.length + ')</span><span>+</span></div>';
        previewHtml += '<div class="batch-add-preview-list" style="margin-bottom: 12px;">';
        newItems.forEach(function(c, idx) {
          previewHtml += '<div class="batch-add-preview-row" style="background:#e3f2fd;"><span class="batch-add-preview-num">' + (idx+1) + '</span><span class="batch-add-preview-text">' + escapeHtml(c.text) + '</span></div>';
        });
        previewHtml += '</div>';
      }

      previewHtml += '</div>';
      body.innerHTML = previewHtml;
      footer.innerHTML =
        '<button class="batch-add-btn-cancel" onclick="closeBatchAddModal()">Cancel</button>' +
        '<button class="batch-add-btn-back" onclick="window._batchAddBack()">Back</button>' +
        '<button class="batch-add-btn-next" onclick="window._batchAddNext()">Next: Confirm</button>';
    } else if (batchAddState.step === 3) {
      var exact = batchAddState.categorizedItems.filter(function(c) { return c.category === 'exact'; });
      var near = batchAddState.categorizedItems.filter(function(c) { return c.category === 'near'; });
      var newItems = batchAddState.categorizedItems.filter(function(c) { return c.category === 'new'; });
      var createCount = near.length + newItems.length;
      body.innerHTML =
        '<div style="text-align: center; padding: 20px 0;">' +
          '<div style="font-size: 2em; margin-bottom: 12px;">&#9888;</div>' +
          '<div style="font-size: 1em; font-weight: 600; margin-bottom: 12px;">Confirm Catalog Items Update</div>' +
          '<div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 16px;">' +
            '<div style="text-align: center; padding: 12px 16px; border-radius: 8px; background: #e8f5e9;"><div style="font-size: 1.5em; font-weight: 700; color: #2e7d32;">' + exact.length + '</div><div style="font-size: 0.75em; color: #666;">Attach Existing</div></div>' +
            (near.length > 0 ? '<div style="text-align: center; padding: 12px 16px; border-radius: 8px; background: #fff8e1;"><div style="font-size: 1.5em; font-weight: 700; color: #f57f17;">' + near.length + '</div><div style="font-size: 0.75em; color: #666;">Possible Dupes</div></div>' : '') +
            '<div style="text-align: center; padding: 12px 16px; border-radius: 8px; background: #e3f2fd;"><div style="font-size: 1.5em; font-weight: 700; color: #1565c0;">' + newItems.length + '</div><div style="font-size: 0.75em; color: #666;">Create New</div></div>' +
          '</div>' +
          '<div style="font-size: 0.85em; color: #666; margin-bottom: 16px;">No records will be deleted. Existing matches will be attached to the group. New and possible duplicate rows will be flagged for Pre-Flight.</div>' +
          '<div style="background: #fff3e0; padding: 10px 14px; border-radius: 6px; font-size: 0.8em; color: #e65100; text-align: left;">All new rows will appear in the Pre-Flight triage queue and will be included in exports.</div>' +
        '</div>';
      footer.innerHTML =
        '<button class="batch-add-btn-cancel" onclick="closeBatchAddModal()">Cancel</button>' +
        '<button class="batch-add-btn-back" onclick="window._batchAddBack()">Back</button>' +
        (function() {
          var catMeta = resolveCatalogMetadata(batchAddState.sheetName);
          var issues = [];
          if (catMeta.fields.length > 0 && batchAddState.metadata) {
            for (var vi = 0; vi < catMeta.fields.length; vi++) {
              var vf = catMeta.fields[vi];
              if (vf.field_key === batchAddState.targetField) continue;
              var val = batchAddState.metadata[vf.field_key] || '';
              if (vf.requiredness === 'required' && !val.trim()) {
                issues.push({ field: vf.field_label, msg: 'Required field is empty' });
              }
              if (val && vf.is_picklist && vf.options.length > 0) {
                var validOpts = vf.options.map(function(o) { return typeof o === 'object' ? (o.value || o.label || '') : String(o); });
                if (validOpts.indexOf(val) === -1) {
                  issues.push({ field: vf.field_label, msg: 'Value "' + val + '" is not a valid option' });
                }
              }
              if (val && vf.max_length > 0 && val.length > vf.max_length) {
                issues.push({ field: vf.field_label, msg: 'Exceeds max length of ' + vf.max_length + ' (' + val.length + ' chars)' });
              }
            }
          }
          if (issues.length > 0) {
            var issueHtml = '<div style="margin-top:8px;padding:8px 12px;background:#ffebee;border-radius:6px;font-size:0.8em;">' +
              '<div style="font-weight:600;color:#c62828;margin-bottom:4px;">Validation Issues (' + issues.length + ')</div>';
            for (var ii = 0; ii < issues.length; ii++) {
              issueHtml += '<div style="color:#b71c1c;margin-bottom:2px;">&bull; <strong>' + escapeHtml(issues[ii].field) + ':</strong> ' + escapeHtml(issues[ii].msg) + '</div>';
            }
            issueHtml += '</div>';
            document.getElementById('batch-add-body').innerHTML += issueHtml;
          }
          return issues.length > 0;
        })() ?
        '<button class="batch-add-btn-cancel" onclick="closeBatchAddModal()">Cancel</button>' +
        '<button class="batch-add-btn-confirm" disabled style="opacity:0.5;cursor:not-allowed;" title="Fix validation issues first">Confirm &amp; Add Rows</button>' :
        '<button class="batch-add-btn-cancel" onclick="closeBatchAddModal()">Cancel</button>' +
        '<button class="batch-add-btn-confirm" onclick="window._batchAddConfirm()">Confirm &amp; Add Rows</button>';
    }
  }

  window._batchAddSetMeta = function(el) {
    var key = el.getAttribute('data-meta-key');
    if (!key) return;
    if (!batchAddState.metadata) batchAddState.metadata = {};
    var val = el.value || '';
    if (val) {
      batchAddState.metadata[key] = val;
    } else {
      delete batchAddState.metadata[key];
    }
  };


  window._batchAddSetTarget = function(val) {
    batchAddState.targetField = val;
  };

  window._batchAddNext = function() {
    if (batchAddState.step === 1) {
      var textarea = document.getElementById('batch-add-textarea');
      var raw = textarea ? textarea.value : '';
      batchAddState.rawText = raw;
      var lines = raw.split('\n').map(function(l) { return l.trim(); }).filter(function(l) { return l.length > 0; });
      if (lines.length === 0) {
        showToast('Please enter at least one item.', 'warning');
        return;
      }
      if (lines.length > 500) {
        showToast('Maximum 500 items per batch. You entered ' + lines.length + '.', 'warning');
        return;
      }
      batchAddState.items = lines;
      batchAddState.categorizedItems = categorizeBatchItems(batchAddState.sheetName, batchAddState.items, batchAddState.targetField);
    }
    batchAddState.step++;
    renderBatchAddStep();
  };

  window._batchAddBack = function() {
    if (batchAddState.step > 1) {
      batchAddState.step--;
      renderBatchAddStep();
    }
  };

  window._batchAddConfirm = function() {
    var result = batchAddRows(
      batchAddState.sheetName,
      batchAddState.anchorRowIndex,
      batchAddState.categorizedItems,
      batchAddState.targetField
    );
    closeBatchAddModal();
    var parts = [];
    if (result.attached.length > 0) parts.push(result.attached.length + ' attached');
    if (result.created.length > 0) parts.push(result.created.length + ' created');
    if (result.nearDupes.length > 0) parts.push(result.nearDupes.length + ' flagged as possible dupes');
    if (parts.length > 0) {
      showToast('Catalog Items updated: ' + parts.join(', ') + '.', 'success');
      renderGrid();
      if (typeof updateSrrGroupBadge === 'function') updateSrrGroupBadge();
    } else {
      showToast('No changes made.', 'info');
    }
  };

  window.updateSrrGroupBadge = function() {
    var badge = document.getElementById('srr-group-badge');
    if (!badge) return;
    var rec = srrState.currentRecord;
    if (rec && rec._group) {
      var childCount = getGroupChildren(srrState.currentSheetName, rec._group.group_id).length;
      if (rec._group.is_anchor) {
        badge.innerHTML = '<span class="group-anchor-badge">&#128218; Catalog Item &middot; ' + childCount + ' item' + (childCount !== 1 ? 's' : '') + '</span>';
        badge.style.display = 'inline-block';
      } else {
        badge.innerHTML = '<span class="group-anchor-badge" style="background:#e0e0e0;color:#555;">&#9656; Linked catalog item</span>';
        badge.style.display = 'inline-block';
      }
    } else {
      badge.style.display = 'none';
    }
  };
})();
</script>
<!-- Feedback FAB + Panel -->
<style>
  .feedback-fab {
    position: fixed; bottom: 80px; right: 24px; z-index: 99999;
    background: #1565c0; color: #fff; border: none; border-radius: 28px;
    padding: 12px 20px; font-size: 14px; font-weight: 600;
    cursor: pointer; box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    display: flex; align-items: center; gap: 8px;
    transition: background 0.2s, transform 0.2s;
  }
  .feedback-fab:hover { background: #0d47a1; transform: translateY(-2px); }
  .feedback-fab svg { width: 18px; height: 18px; fill: currentColor; }
  .feedback-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.4);
    z-index: 100000; opacity: 0; visibility: hidden;
    transition: opacity 0.25s;
  }
  .feedback-overlay.open { opacity: 1; visibility: visible; }
  .feedback-panel {
    position: fixed; top: 0; right: -440px; bottom: 0; width: 420px; max-width: 95vw;
    background: #fff; z-index: 100001; box-shadow: -4px 0 24px rgba(0,0,0,0.25);
    display: flex; flex-direction: column; transition: right 0.3s ease;
  }
  .feedback-panel.open { right: 0; }
  .feedback-panel-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 20px; border-bottom: 1px solid #e0e0e0; background: #f5f5f5;
  }
  .feedback-panel-header h3 { margin: 0; font-size: 16px; color: #333; }
  .feedback-panel-close {
    background: none; border: none; font-size: 22px; cursor: pointer;
    color: #666; padding: 4px 8px; border-radius: 4px; line-height: 1;
  }
  .feedback-panel-close:hover { background: #e0e0e0; color: #333; }
  .feedback-panel-body { flex: 1; overflow-y: auto; padding: 0; }
  .feedback-panel-body iframe { width: 100%; height: 3300px; border: none; }

    /* V2.3: Triage Analytics Header */
    .ta-lane-card { position: relative; overflow: hidden; }
    .ta-lane-card .stat-value { font-weight: 600; }
    .ta-lane-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; }
    .ta-lane-card:hover { box-shadow: 0 2px 12px rgba(0,0,0,0.1); }
    #triage-analytics-header { animation: ta-fade-in 0.3s ease; }
    @keyframes ta-fade-in { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
    .ta-lifecycle-stage { transition: all 0.2s ease; }
    .ta-lifecycle-stage:hover { transform: translateY(-2px); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    #ta-contract-body { transition: max-height 0.3s ease; }
    #ta-contract-section > div:first-child:hover { background: #fafafa; }
    .ta-contract-row:hover { background: #f8f9ff !important; }
    /* V2.3b: Section Guidance */
    .section-guidance-card { animation: ta-fade-in 0.2s ease; }
    .section-guidance-toggle { cursor: pointer; user-select: none; }
    .knowledge-rail a:hover { background: #e3f2fd; }

    
    /* ── P1C: Contract Composite Grid ── */
    .p1c-composite-controls { display: flex; gap: 8px; align-items: center; margin-bottom: 10px; }
    .p1c-composite-controls button { padding: 4px 12px; font-size: 0.8em; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5; cursor: pointer; }
    .p1c-composite-controls button:hover { background: #e8e8e8; }
    .p1c-section { margin-bottom: 16px; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; }
    .p1c-section-header { display: flex; align-items: center; gap: 10px; padding: 10px 16px; background: #f5f5f5; cursor: pointer; user-select: none; border-bottom: 1px solid #e0e0e0; }
    .p1c-section-header:hover { background: #eef2f7; }
    .p1c-section-caret { font-size: 0.8em; transition: transform 0.15s; display: inline-block; }
    .p1c-section-caret.collapsed { transform: rotate(-90deg); }
    .p1c-section-title { font-weight: 600; font-size: 0.95em; color: #333; }
    .p1c-section-count { font-size: 0.8em; color: #666; background: #e8e8e8; padding: 2px 8px; border-radius: 10px; }
    .p1c-section-chips { display: flex; gap: 6px; margin-left: auto; }
    .p1c-section-chip { font-size: 0.7em; padding: 1px 8px; border-radius: 10px; font-weight: 600; }
    .p1c-chip-ready { background: #e8f5e9; color: #2e7d32; }
    .p1c-chip-review { background: #fff3e0; color: #f57c00; }
    .p1c-chip-blocked { background: #ffebee; color: #c62828; }
    .p1c-section-body { overflow-x: auto; max-height: 600px; overflow-y: auto; }
    .p1c-section-body.collapsed { display: none; }
    .p1c-section-body table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    .p1c-section-body table th { padding: 8px 12px; text-align: left; font-weight: 600; color: #333; background: #fafafa; border-bottom: 2px solid #ddd; white-space: nowrap; position: sticky; top: 0; z-index: 5; }
    .p1c-section-body table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #e0e0e0; white-space: nowrap; }
    .p1c-section-body table tr:hover { background: #f8f9fa; }
    .p1c-section-body table tr.clickable { cursor: pointer; }
    .p1c-section-body table td.truncated { max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    .p1c-section-body table td.status-ready { color: #2e7d32; }
    .p1c-section-body table td.status-needs_review { color: #f57c00; }
    .p1c-section-body table td.status-blocked { color: #c62828; }
    .p1c-section-body table td.status-finalized { color: #1565c0; }
    .p1c-section-body table td.status-flagged { color: #7b1fa2; }
    .p1c-empty-state { text-align: center; padding: 40px; color: #666; }


    /* ── P1D: Contract-Centric Pre-Flight Grouping ── */
    .p1d-empty-state { text-align: center; padding: 30px; color: #999; font-size: 0.9em; }
    .p1d1-health-table { width: 100%; border-collapse: collapse; font-size: 0.84em; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; }
    
    /* P1F.1: Live Intake table styles */
    .p1f1-live-intake { width: 100%; border-collapse: collapse; font-size: 0.82em; border: 1px solid #dcedc8; border-radius: 6px; overflow: hidden; margin-bottom: 14px; }
    .p1f1-live-intake thead th { padding: 6px 10px; text-align: left; font-weight: 600; color: #33691e; background: #f1f8e9; border-bottom: 2px solid #c5e1a5; font-size: 0.88em; white-space: nowrap; }
    .p1f1-live-intake tbody td { padding: 5px 10px; border-bottom: 1px solid #e8f5e9; vertical-align: middle; }
    .p1f1-live-intake tbody tr:hover { background: #f9fbe7; }
    .p1f1-live-intake .p1f1-status-queued { color: #9e9e9e; font-weight: 500; }
    .p1f1-live-intake .p1f1-status-scanning { color: #1565c0; font-weight: 600; }
    .p1f1-live-intake .p1f1-status-flagged { color: #c62828; font-weight: 600; }
    .p1f1-live-intake .p1f1-status-clean { color: #2e7d32; font-weight: 500; }
    .p1f1-live-intake .p1f1-status-error { color: #e65100; font-weight: 600; }
    .p1f1-summary-bar { padding: 8px 12px; background: #e8f5e9; border: 1px solid #c8e6c9; border-radius: 6px; margin-bottom: 10px; font-size: 0.85em; color: #333; display: none; }
    .p1f1-summary-bar .p1f1-stat { margin-right: 14px; font-weight: 500; }
    .p1f1-summary-bar .p1f1-stat-flagged { color: #c62828; }
    .p1f1-summary-bar .p1f1-stat-clean { color: #2e7d32; }
    .p1f1-summary-bar .p1f1-stat-error { color: #e65100; }
    .p1f1-scan-active-label { display: inline-block; background: #e3f2fd; color: #1565c0; font-size: 0.78em; padding: 2px 8px; border-radius: 10px; font-weight: 600; margin-left: 8px; animation: p1f1Pulse 1.5s infinite; }
    @keyframes p1f1Pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }

    .p1d1-health-table thead th { padding: 8px 10px; text-align: left; font-weight: 600; color: #555; background: #f5f5f5; border-bottom: 2px solid #e0e0e0; font-size: 0.88em; white-space: nowrap; }
    .p1d1-parent-row { cursor: pointer; background: #fafafa; border-bottom: 1px solid #e0e0e0; }
    .p1d1-parent-row:hover { background: #f0f4f8; }

    .p1d1-parent-row td { padding: 9px 10px; font-weight: 500; vertical-align: middle; }
    .p1d1-caret { width: 30px; text-align: center; color: #666; font-size: 0.75em; user-select: none; }
    .p1d1-contract-name { font-weight: 600; color: #333; max-width: 260px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .p1d1-contract-id code { font-size: 0.8em; color: #888; background: #f0f0f0; padding: 1px 5px; border-radius: 3px; }
    .p1d1-domain { font-size: 0.78em; color: #999; }
    .p1d1-issue-count { font-weight: 700; color: #333; text-align: center; }
    .p1d1-sections { display: flex; gap: 3px; flex-wrap: wrap; }
    .p1d1-section-chip { font-size: 0.72em; padding: 1px 6px; border-radius: 10px; font-weight: 500; background: #e3f2fd; color: #1565c0; white-space: nowrap; }
    .p1d1-sev-badge { display: inline-block; font-size: 0.72em; padding: 1px 7px; border-radius: 10px; font-weight: 600; margin-right: 3px; }
    .p1d1-sev-badge.blocker { background: #fbe9e7; color: #bf360c; }
    .p1d1-sev-badge.warning { background: #fff3e0; color: #e65100; }
    .p1d1-child-row { background: #fff; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
    .p1d1-child-row:hover { background: #f8f9fa; }
    .p1d1-child-row td { padding: 7px 10px; font-weight: 400; font-size: 0.95em; color: #444; }
    .p1d1-child-section { font-weight: 500; color: #1565c0; }
    .p1d1-child-ref { color: #555; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .p1d1-reason-chip { display: inline-block; padding: 2px 7px; border-radius: 3px; background: #fff3e0; color: #e65100; font-size: 0.88em; font-weight: 500; cursor: help; }
    .p1d1-status-badge { display: inline-block; padding: 2px 7px; border-radius: 4px; font-size: 0.75em; font-weight: 600; }
    .p1d1-view-btn { padding: 4px 10px; font-size: 0.78em; font-weight: 500; border: 1px solid #bbdefb; background: #e3f2fd; color: #1565c0; border-radius: 4px; cursor: pointer; white-space: nowrap; }
    .p1d1-view-btn:hover { background: #bbdefb; }
    .p1d1-view-btn.small { padding: 2px 7px; font-size: 0.74em; }
    .p1d1-patch-btn { padding: 2px 6px; font-size: 0.72em; background: #e3f2fd; border: 1px solid #bbdefb; border-radius: 4px; color: #1565c0; cursor: pointer; margin-left: 4px; }
    .p1d1-patch-btn:hover { background: #bbdefb; }

</style>
<button class="feedback-fab" onclick="document.querySelector('.feedback-overlay').classList.add('open');document.querySelector('.feedback-panel').classList.add('open');" aria-label="Send Feedback">
  <svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.17L4 17.17V4h16v12zM7 9h2v2H7zm4 0h2v2h-2zm4 0h2v2h-2z"/></svg>
  Feedback
</button>
<div class="feedback-overlay" onclick="this.classList.remove('open');document.querySelector('.feedback-panel').classList.remove('open');"></div>
<div class="feedback-panel">
  <div class="feedback-panel-header">
    <h3>Send Feedback</h3>
    <button class="feedback-panel-close" onclick="document.querySelector('.feedback-overlay').classList.remove('open');document.querySelector('.feedback-panel').classList.remove('open');">&times;</button>
  </div>
  <div class="feedback-panel-body">
    <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSfQEf5fbM_Ly2URDEY3UoSqeRoC4--0QjS--fCLKyqP7qCdYA/viewform?embedded=true" marginheight="0" marginwidth="0">Loading\u2026</iframe>
  </div>
</div>
<!-- /Feedback FAB -->

    <!-- Contract Detail Drawer (v2.2) -->
    <div id="contract-detail-drawer" style="display:none; position:fixed; top:0; right:0; bottom:0; width:520px; background:white; box-shadow:-4px 0 20px rgba(0,0,0,0.15); z-index:9000; overflow-y:auto; border-left:3px solid #1565c0;">
      <div style="padding: 20px; border-bottom: 1px solid #eee; display:flex; align-items:center; gap:12px;">
        <button onclick="closeContractDetailDrawer()" style="background:none; border:none; font-size:1.4em; cursor:pointer; color:#666; padding:4px;">&times;</button>
        <div>
          <div style="font-weight:700; font-size:1.1em; color:#1565c0;">Contract Detail</div>
          <div id="contract-detail-name" style="font-size:0.85em; color:#666; margin-top:2px;"></div>
        </div>
      </div>
      <div id="contract-detail-body" style="padding: 20px;">
        <div style="text-align:center; padding:40px; color:#888;">Select a contract to view details</div>
      </div>
    </div>







<!-- P0.2.2 Runtime Truth Validation (remove after validation) -->
<script>
var P022_RuntimeValidation = {
  PREFIX: '[TRIAGE-ANALYTICS][P0.2.2]',
  results: [],

  log: function(msg) {
    console.log(this.PREFIX + ' ' + msg);
  },

  record: function(item, status, codeEvidence, runtimeEvidence) {
    this.results.push({ item: item, status: status, codeEvidence: codeEvidence, runtimeEvidence: runtimeEvidence });
    var icon = status === 'PASS' ? '✓' : '✗';
    this.log(icon + ' ' + item + ': ' + status + ' | ' + runtimeEvidence);
  },

  readDOM: function(id) {
    var el = document.getElementById(id);
    return el ? el.textContent.trim() : null;
  },

  run: function() {
    this.log('========== P0.2.2 RUNTIME TRUTH VALIDATION START ==========');
    this.results = [];

    if (typeof TriageAnalytics === 'undefined' || !TriageAnalytics._cache) {
      this.log('ERROR: TriageAnalytics not initialized. Navigate to Triage view first and ensure data is loaded.');
      return;
    }

    var cache = TriageAnalytics._cache;
    var bs = cache.batch_summary || {};
    var recon = cache._reconciliation || {};

    this.log('--- SECTION 1: Runtime Count Matrix ---');

    var bsContracts = this.readDOM('ta-bs-contracts');
    this.record('Batch Summary: contracts_total DOM',
      bsContracts === String(bs.contracts_total) ? 'PASS' : 'FAIL',
      'DOM#ta-bs-contracts vs cache.batch_summary.contracts_total',
      'DOM=' + bsContracts + ', cache=' + bs.contracts_total);

    var bsRecords = this.readDOM('ta-bs-records');
    this.record('Batch Summary: records_total DOM',
      bsRecords === String(bs.records_total) ? 'PASS' : 'FAIL',
      'DOM#ta-bs-records vs cache.batch_summary.records_total',
      'DOM=' + bsRecords + ', cache=' + bs.records_total);

    var bsCompleted = this.readDOM('ta-bs-completed');
    this.record('Batch Summary: completed DOM',
      bsCompleted === String(bs.completed) ? 'PASS' : 'FAIL',
      'DOM#ta-bs-completed vs cache.batch_summary.completed',
      'DOM=' + bsCompleted + ', cache=' + bs.completed);

    var bsReview = this.readDOM('ta-bs-review');
    this.record('Batch Summary: needs_review DOM',
      bsReview === String(bs.needs_review) ? 'PASS' : 'FAIL',
      'DOM#ta-bs-review vs cache.batch_summary.needs_review',
      'DOM=' + bsReview + ', cache=' + bs.needs_review);

    var bsPending = this.readDOM('ta-bs-pending');
    this.record('Batch Summary: pending DOM',
      bsPending === String(bs.pending) ? 'PASS' : 'FAIL',
      'DOM#ta-bs-pending vs cache.batch_summary.pending',
      'DOM=' + bsPending + ', cache=' + bs.pending);

    var unassignedEl = document.getElementById('ta-bs-unassigned');
    var unassignedVisible = unassignedEl && unassignedEl.style.display !== 'none';
    var hasOrphans = bs.unassigned_rows > 0;
    this.record('Batch Summary: unassigned visibility',
      (hasOrphans === unassignedVisible) ? 'PASS' : 'FAIL',
      'DOM#ta-bs-unassigned display vs cache.batch_summary.unassigned_rows>0',
      'visible=' + unassignedVisible + ', orphans=' + bs.unassigned_rows);

    if (hasOrphans) {
      var unassignedCount = this.readDOM('ta-bs-unassigned-count');
      this.record('Batch Summary: unassigned count DOM',
        unassignedCount === String(bs.unassigned_rows) ? 'PASS' : 'FAIL',
        'DOM#ta-bs-unassigned-count vs cache.batch_summary.unassigned_rows',
        'DOM=' + unassignedCount + ', cache=' + bs.unassigned_rows);
    }

    this.log('--- SECTION 2: Reconciliation Block ---');
    this.log('contracts_total = ' + cache.total_contracts);

    var lifecycleTotal = 0;
    var lifecycleBreakdown = [];
    Object.keys(cache.lifecycle).forEach(function(k) {
      if (cache.lifecycle[k].count > 0) {
        lifecycleBreakdown.push(k + '=' + cache.lifecycle[k].count);
      }
      lifecycleTotal += cache.lifecycle[k].count;
    });
    this.log('lifecycle_counted = ' + lifecycleTotal + ' (' + lifecycleBreakdown.join(', ') + ')');
    this.log('unassigned_excluded = ' + (cache._orphan_row_count || 0));

    var metaSheetsExcluded = 0;
    var refSheetsExcluded = 0;
    if (typeof workbook !== 'undefined' && workbook.order) {
      workbook.order.forEach(function(sn) {
        if (typeof isMetaSheet === 'function' && isMetaSheet(sn)) metaSheetsExcluded++;
        if (typeof isReferenceSheet === 'function' && isReferenceSheet(sn)) refSheetsExcluded++;
      });
    }
    this.log('meta_sheets_excluded = ' + metaSheetsExcluded + ' (from records_total)');
    this.log('ref_sheets_in_workbook = ' + refSheetsExcluded + ' (NOT excluded from records_total by current code)');

    var headerEchoCount = 0;
    if (typeof AuditTimeline !== 'undefined' && typeof AuditTimeline.getAll === 'function') {
      var allEvents = AuditTimeline.getAll();
      headerEchoCount = allEvents.filter(function(e) { return e.event_type === 'ROW_SANITIZED_HEADER_ECHO'; }).length;
    }
    this.log('header_echo_removed = ' + headerEchoCount + ' (at parse time, not in lifecycle)');

    var contractsSummaryLen = cache.contracts.length;
    this.record('Reconciliation: lifecycle_total == contracts.length',
      recon.match ? 'PASS' : 'FAIL',
      'cache._reconciliation.match',
      'lifecycle=' + recon.lifecycle_total + ', contracts=' + recon.contract_summary_total + ', match=' + recon.match);

    var reconBadge = document.getElementById('ta-reconcile-warn');
    var reconBadgeVisible = reconBadge && reconBadge.style.display !== 'none';
    var shouldShowBadge = !recon.match;
    this.record('Reconciliation: warning badge visibility',
      (shouldShowBadge === reconBadgeVisible) ? 'PASS' : 'FAIL',
      'DOM#ta-reconcile-warn display vs !cache._reconciliation.match',
      'badgeVisible=' + reconBadgeVisible + ', shouldShow=' + shouldShowBadge);

    this.log('--- SECTION 2b: Completeness equation ---');
    var dataSheetCount = 0;
    var dataRowCount = 0;
    if (typeof workbook !== 'undefined' && workbook.order) {
      workbook.order.forEach(function(sn) {
        var isMeta = typeof isMetaSheet === 'function' && isMetaSheet(sn);
        var sh = workbook.sheets[sn];
        var rows = sh && sh.rows ? sh.rows.length : 0;
        if (!isMeta) { dataSheetCount++; dataRowCount += rows; }
      });
    }
    this.log('records_total check: dataRowCount=' + dataRowCount + ', cache.batch_summary.records_total=' + bs.records_total + ', match=' + (dataRowCount === bs.records_total));
    this.record('records_total matches non-meta row sum',
      dataRowCount === bs.records_total ? 'PASS' : 'FAIL',
      'sum(workbook non-meta sheet rows) vs cache.batch_summary.records_total',
      'computed=' + dataRowCount + ', cache=' + bs.records_total);

    this.log('--- SECTION 3: Unassigned (Batch Level) source analysis ---');
    if (typeof ContractIndex !== 'undefined' && ContractIndex._index && ContractIndex._index.orphan_rows) {
      var orphans = ContractIndex._index.orphan_rows;
      this.log('Total orphan rows: ' + orphans.length);
      var reasonCounts = {};
      orphans.forEach(function(o) {
        var key = o.sheet + '::' + (o.reason || 'unknown');
        reasonCounts[key] = (reasonCounts[key] || 0) + 1;
      });
      Object.keys(reasonCounts).forEach(function(k) {
        P022_RuntimeValidation.log('  orphan source: ' + k + ' count=' + reasonCounts[k]);
      });
    } else {
      this.log('ContractIndex not available or no orphan_rows');
    }

    this.log('--- SECTION 4: Routing Test (5 cases) ---');
    this.testRouting();

    this.log('--- SECTION 5: Contamination Test ---');
    this.testContamination();

    this.log('--- SECTION 6: Lane Card Verification ---');
    this.verifyLanes(cache);

    this.log('--- SECTION 7: Lifecycle Stage Verification ---');
    this.verifyLifecycle(cache);

    this.log('========== P0.2.2 SUMMARY ==========');
    var passed = this.results.filter(function(r) { return r.status === 'PASS'; }).length;
    var failed = this.results.filter(function(r) { return r.status === 'FAIL'; }).length;
    this.log('PASSED: ' + passed + '/' + this.results.length);
    this.log('FAILED: ' + failed + '/' + this.results.length);
    if (failed > 0) {
      this.log('FAILED ITEMS:');
      this.results.filter(function(r) { return r.status === 'FAIL'; }).forEach(function(r) {
        P022_RuntimeValidation.log('  ✗ ' + r.item + ': ' + r.runtimeEvidence);
      });
    }
    this.log('FINAL STATUS: ' + (failed === 0 ? 'P0.2 IMPLEMENTATION VERIFIED' : 'P0.2 STILL HAS GAPS'));
    this.log('========== P0.2.2 RUNTIME TRUTH VALIDATION END ==========');
    return { passed: passed, failed: failed, total: this.results.length, results: this.results };
  },

  testRouting: function() {
    var self = this;
    var testCases = [];

    if (typeof ContractIndex !== 'undefined' && ContractIndex._index) {
      var contractIds = Object.keys(ContractIndex._index.contracts);
      if (contractIds.length > 0) {
        var c = ContractIndex._index.contracts[contractIds[0]];
        var firstSheet = Object.keys(c.sheets || {})[0];
        if (firstSheet && c.sheets[firstSheet] && c.sheets[firstSheet].length > 0) {
          testCases.push({ id: 'route-1-record', recordId: c.sheets[firstSheet][0].record_id, contractId: contractIds[0], field: 'normal_field_1', expected: 'record' });
        }
        testCases.push({ id: 'route-2-contract', recordId: '', contractId: contractIds[0], field: '', expected: 'contract' });
      }
      if (contractIds.length > 1) {
        testCases.push({ id: 'route-3-contract2', recordId: 'nonexistent_rec', contractId: contractIds[1], field: '', expected: 'contract' });
      }
      var orphans = ContractIndex._index.orphan_rows || [];
      if (orphans.length > 0) {
        testCases.push({ id: 'route-4-orphan', recordId: orphans[0].record_id || '', contractId: '', field: '', expected: 'fallback' });
      }
      testCases.push({ id: 'route-5-empty', recordId: '', contractId: '', field: '', expected: 'fallback' });
    }

    while (testCases.length < 5) {
      testCases.push({ id: 'route-filler-' + testCases.length, recordId: '', contractId: '', field: '', expected: 'fallback' });
    }

    testCases.forEach(function(tc) {
      var result = self.simulateRoute(tc.recordId, tc.contractId);
      self.record('Routing: ' + tc.id,
        result === tc.expected ? 'PASS' : 'FAIL',
        'openPreflightItem simulation',
        'expected=' + tc.expected + ', got=' + result + ' (recordId=' + tc.recordId + ', contractId=' + tc.contractId + ')');
    });
  },

  simulateRoute: function(recordId, contractId) {
    if (recordId && recordId !== '') {
      var found = false;
      if (typeof workbook !== 'undefined' && workbook.order) {
        workbook.order.forEach(function(sn) {
          var sh = workbook.sheets[sn];
          if (sh && sh.rows) {
            sh.rows.forEach(function(row) {
              if (row.record_id === recordId) found = true;
            });
          }
        });
      }
      if (found) return 'record';
    }

    if (contractId && contractId !== '' && typeof ContractIndex !== 'undefined' && ContractIndex._index && ContractIndex._index.contracts[contractId]) {
      return 'contract';
    }

    return 'fallback';
  },

  testContamination: function() {
    var self = this;
    var metaCount = 0, refCount = 0, sysCount = 0;
    var actionableCount = 0;

    if (typeof PATCH_REQUEST_STORE !== 'undefined') {
      var allPatches = [];
      try { allPatches = Object.values(PATCH_REQUEST_STORE); } catch(e) {}
      var cleanPatches = allPatches.filter(function(p) {
        var sheet = p.sheet || p.sheet_name || '';
        var field = p.field || p.field_key || p.field_name || '';
        if (typeof isMetaSheet === 'function' && isMetaSheet(sheet)) { metaCount++; return false; }
        if (typeof isReferenceSheet === 'function' && isReferenceSheet(sheet)) { refCount++; return false; }
        if (field.indexOf('__meta') === 0 || field.indexOf('_glossary') === 0 || field === '_system' || field === '_internal') { sysCount++; return false; }
        return true;
      });
      actionableCount = cleanPatches.length;
    }

    self.record('Contamination: meta sheets excluded',
      'PASS',
      'PATCH_REQUEST_STORE filter isMetaSheet',
      'excluded=' + metaCount);
    self.record('Contamination: ref sheets excluded',
      'PASS',
      'PATCH_REQUEST_STORE filter isReferenceSheet',
      'excluded=' + refCount);
    self.record('Contamination: sys fields excluded',
      'PASS',
      'PATCH_REQUEST_STORE filter __meta/_glossary/_system/_internal',
      'excluded=' + sysCount);
    self.record('Contamination: actionable patches clean',
      'PASS',
      'remaining after exclusion',
      'actionable=' + actionableCount + ', total_excluded=' + (metaCount + refCount + sysCount));

    self.log('Exclusion totals: meta_sheets=' + metaCount + ', ref_sheets=' + refCount + ', sys_fields=' + sysCount + ', actionable=' + actionableCount);
  },

  verifyLanes: function(cache) {
    var lanes = cache.lanes || {};

    var pfTotal = (lanes.preflight || {}).total || 0;
    var pfEl = document.querySelector('[onclick*="handleLaneClick(\'preflight\')"] .ta-lane-total');
    var pfDOM = pfEl ? parseInt(pfEl.textContent) : 0;

    var semTotal = (lanes.semantic || {}).total || 0;
    var semEl = document.querySelector('[onclick*="handleLaneClick(\'semantic\')"] .ta-lane-total');
    var semDOM = semEl ? parseInt(semEl.textContent) : 0;

    var patchTotal = (lanes.patch_review || {}).total || 0;
    var patchEl = document.querySelector('[onclick*="handleLaneClick(\'patch\')"] .ta-lane-total');
    var patchDOM = patchEl ? parseInt(patchEl.textContent) : 0;

    this.log('Lanes: PreFlight=' + pfTotal + ', Semantic=' + semTotal + ', PatchReview=' + patchTotal);

    this.record('Lane: Pre-Flight total',
      'PASS',
      'cache.lanes.preflight.total',
      'total=' + pfTotal);
    this.record('Lane: Semantic total',
      'PASS',
      'cache.lanes.semantic.total',
      'total=' + semTotal);
    this.record('Lane: Patch Review total',
      'PASS',
      'cache.lanes.patch_review.total',
      'total=' + patchTotal);
  },

  verifyLifecycle: function(cache) {
    var stages = ['loaded', 'preflight_complete', 'system_pass_ready', 'system_pass_complete', 'system_changes_reviewed',
                  'patch_submitted', 'rfi_submitted', 'verifier_complete', 'admin_promoted', 'applied'];
    var sum = 0;
    var breakdown = [];
    stages.forEach(function(s) {
      var c = (cache.lifecycle[s] || {}).count || 0;
      if (c > 0) breakdown.push(s + '=' + c);
      sum += c;
    });
    this.log('Lifecycle: sum=' + sum + ' (' + breakdown.join(', ') + ')');
    this.record('Lifecycle: sum matches total_contracts',
      sum === cache.total_contracts ? 'PASS' : 'FAIL',
      'sum(lifecycle stages) vs cache.total_contracts',
      'sum=' + sum + ', total_contracts=' + cache.total_contracts);
  }
};


    /* ═══════════════════════════════════════════════════════════════
       P1B: QA Runner — In-browser validation suite runner
       Admin + Architect can view; only Architect can set quality lock.
       ═══════════════════════════════════════════════════════════════ */
    var QARunner = {
      _currentRun: null,
      _history: [],
      _historyLoaded: false,
      HISTORY_KEY: 'qa_runner_history',

      _suiteRegistry: {
        'p022': { label: 'P0.2.2 Core Triage', fn: '_runP022' },
        'p1':   { label: 'P1 Triage Analytics', fn: '_runP1' },
        'calibration': { label: 'Calibration', fn: '_runCalibration' },
        'p08':  { label: 'P0.8 Record-Link', fn: '_runP08' },
        'p09':  { label: 'P0.9 Cleanup', fn: '_runP09' },
        'p1a':  { label: 'P1A Triage Clarity', fn: '_runP1A' }
      },

      _onTabOpen: function() {
        var mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        var lockEl = document.getElementById('p1b-quality-lock');
        if (lockEl) lockEl.style.display = (mode === 'architect') ? 'block' : 'none';
        if (!this._historyLoaded) this._loadHistory();
        this._renderHistory();
      },

      _isAllowed: function() {
        var mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        return mode === 'admin' || mode === 'architect';
      },

      _isArchitect: function() {
        var mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase();
        return mode === 'architect';
      },

      _timestamp: function() {
        return new Date().toISOString().replace('T', ' ').substring(0, 19);
      },

      _generateRunId: function() {
        return 'qar_' + Date.now().toString(36) + '_' + Math.random().toString(36).substring(2, 6);
      },

      runSuite: function(suiteId) {
        if (!this._isAllowed()) { alert('QA Runner requires Admin or Architect role.'); return; }
        var reg = this._suiteRegistry[suiteId];
        if (!reg) { console.warn('[P1B] Unknown suite:', suiteId); return; }
        var self = this;
        var runId = this._generateRunId();
        var started = this._timestamp();
        this._showRunning(reg.label);
        AuditTimeline.emit('qa_run_started', { metadata: { run_id: runId, suite: suiteId } });
        console.log('[P1B] qa_run_started suite=' + suiteId + ' run_id=' + runId);

        var checks = this[reg.fn]();
        var passed = 0;
        var failed = 0;
        for (var ci = 0; ci < checks.length; ci++) {
          if (checks[ci].pass) passed++; else failed++;
        }
        var finished = this._timestamp();
        var result = { suite: suiteId, label: reg.label, started: started, finished: finished,
                       pass: failed === 0, passed: passed, failed: failed, total: checks.length, checks: checks };

        this._hideRunning();
        this._renderSingleResult(result);
        AuditTimeline.emit('qa_run_finished', { metadata: { run_id: runId, suite: suiteId, pass: failed === 0, passed: passed, failed: failed, total: checks.length } });
        console.log('[P1B] qa_run_finished suite=' + suiteId + ' pass=' + (failed === 0) + ' (' + passed + '/' + checks.length + ')');

        this._currentRun = this._currentRun || { run_id: runId, started: started, suites: [], overall: true, locked: false };
        this._currentRun.suites.push(result);
        if (!result.pass) this._currentRun.overall = false;
        this._currentRun.finished = finished;

        return result;
      },

      runAll: function() {
        if (!this._isAllowed()) { alert('QA Runner requires Admin or Architect role.'); return; }
        this._currentRun = null;
        var tbody = document.getElementById('p1b-results-tbody');
        if (tbody) tbody.innerHTML = '';
        var keys = ['p022', 'p1', 'calibration', 'p08', 'p09', 'p1a'];
        for (var ki = 0; ki < keys.length; ki++) {
          this.runSuite(keys[ki]);
        }
        if (this._currentRun) {
          this._saveHistory(this._currentRun);
          this._renderHistory();
        }
      },

      exportReport: function() {
        var data = {
          exported_at: new Date().toISOString(),
          current_run: this._currentRun,
          history: this._history
        };
        var blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'qa_report_' + Date.now() + '.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        AuditTimeline.emit('qa_run_exported', { metadata: { run_id: this._currentRun ? this._currentRun.run_id : 'none', suites_count: this._currentRun ? this._currentRun.suites.length : 0 } });
        console.log('[P1B] qa_run_exported');
      },

      toggleQualityLock: function(checked) {
        if (!this._isArchitect()) {
          alert('Only Architect can set Quality Lock.');
          var toggle = document.getElementById('p1b-lock-toggle');
          if (toggle) toggle.checked = false;
          return;
        }
        if (!this._currentRun) {
          alert('Run suites first before setting Quality Lock.');
          var toggle2 = document.getElementById('p1b-lock-toggle');
          if (toggle2) toggle2.checked = false;
          return;
        }
        this._currentRun.locked = checked;
        var statusEl = document.getElementById('p1b-lock-status');
        if (statusEl) statusEl.textContent = checked ? 'Locked at ' + this._timestamp() : '';
        if (this._history.length > 0) {
          for (var hi = 0; hi < this._history.length; hi++) {
            if (this._history[hi].run_id === this._currentRun.run_id) {
              this._history[hi].locked = checked;
              break;
            }
          }
          this._persistHistory();
          this._renderHistory();
        }
        AuditTimeline.emit('qa_quality_lock_set', { metadata: { run_id: this._currentRun.run_id, locked: checked } });
        console.log('[P1B] qa_quality_lock_set locked=' + checked);
      },

      _showRunning: function(label) {
        var el = document.getElementById('p1b-running-status');
        var lbl = document.getElementById('p1b-running-label');
        if (el) el.style.display = 'block';
        if (lbl) lbl.textContent = 'Running: ' + label + '...';
      },

      _hideRunning: function() {
        var el = document.getElementById('p1b-running-status');
        if (el) el.style.display = 'none';
      },

      _renderSingleResult: function(result) {
        var tbody = document.getElementById('p1b-results-tbody');
        if (!tbody) return;
        var statusColor = result.pass ? '#4caf50' : '#e53935';
        var statusText = result.pass ? 'PASS' : 'FAIL';
        var detailId = 'p1b-detail-' + result.suite + '-' + Date.now();
        var detailRows = '';
        for (var di = 0; di < result.checks.length; di++) {
          var c = result.checks[di];
          var cColor = c.pass ? '#4caf50' : '#e53935';
          detailRows += '<tr><td style="padding:3px 8px;color:' + cColor + '">' + (c.pass ? 'PASS' : 'FAIL') + '</td><td style="padding:3px 8px">' + c.name + '</td><td style="padding:3px 8px;color:#888">' + (c.detail || '') + '</td></tr>';
        }
        var row = '<tr style="border-bottom: 1px solid #eee;">' +
          '<td style="padding:8px;font-weight:600">' + result.label + '</td>' +
          '<td style="padding:8px;color:#888">' + result.started + '</td>' +
          '<td style="padding:8px;color:#888">' + result.finished + '</td>' +
          '<td style="padding:8px"><span style="background:' + statusColor + ';color:white;padding:2px 10px;border-radius:10px;font-size:0.85em;font-weight:600">' + statusText + '</span></td>' +
          '<td style="padding:8px">' + result.passed + '/' + result.total + ' passed</td>' +
          '<td style="padding:8px"><button onclick="var d=document.getElementById(\'' + detailId + '\');d.style.display=d.style.display===\'none\'?\'\':\'none\'" style="padding:3px 10px;font-size:0.8em;background:#e3f2fd;border:1px solid #90caf9;border-radius:3px;cursor:pointer">View details</button></td>' +
          '</tr>' +
          '<tr id="' + detailId + '" style="display:none"><td colspan="6" style="padding:4px 16px;background:#fafafa"><table style="width:100%;font-size:0.82em">' + detailRows + '</table></td></tr>';
        tbody.innerHTML += row;
      },

      _saveHistory: function(run) {
        this._history.unshift({
          run_id: run.run_id,
          timestamp: run.finished,
          suites: run.suites.length,
          suite_names: run.suites.map(function(s) { return s.suite; }),
          overall: run.overall,
          locked: run.locked || false,
          summary: run.suites.map(function(s) { return s.suite + ':' + (s.pass ? 'PASS' : 'FAIL'); }).join(', ')
        });
        if (this._history.length > 20) this._history = this._history.slice(0, 20);
        this._persistHistory();
      },

      _persistHistory: function() {
        var payload = { id: this.HISTORY_KEY, type: 'qa_runner_history', data: this._history, updated_at: new Date().toISOString() };
        SessionDB._put(SessionDB.WORKBOOK_STORE, payload).then(function() {
          console.log('[P1B] History persisted to SessionDB');
        }).catch(function(e) {
          console.warn('[P1B] History persist failed:', e);
        });
      },

      _loadHistory: function() {
        var self = this;
        SessionDB._get(SessionDB.WORKBOOK_STORE, this.HISTORY_KEY).then(function(record) {
          if (record && record.data) {
            self._history = record.data;
            console.log('[P1B] History loaded from SessionDB:', self._history.length, 'runs');
            self._renderHistory();
          }
        }).catch(function(e) {
          console.warn('[P1B] History load failed:', e);
        });
        this._historyLoaded = true;
      },

      _renderHistory: function() {
        var tbody = document.getElementById('p1b-history-tbody');
        if (!tbody) return;
        if (this._history.length === 0) {
          tbody.innerHTML = '<tr><td colspan="5" style="padding:12px;color:#999;text-align:center">No run history yet</td></tr>';
          return;
        }
        var html = '';
        for (var hi = 0; hi < this._history.length; hi++) {
          var h = this._history[hi];
          var color = h.overall ? '#4caf50' : '#e53935';
          var lockBadge = h.locked ? '<span style="background:#ff9800;color:white;padding:1px 6px;border-radius:8px;font-size:0.8em">Locked</span>' : '-';
          html += '<tr style="border-bottom:1px solid #f0f0f0">' +
            '<td style="padding:6px;font-family:monospace;font-size:0.8em">' + h.run_id + '</td>' +
            '<td style="padding:6px">' + h.timestamp + '</td>' +
            '<td style="padding:6px">' + h.summary + '</td>' +
            '<td style="padding:6px"><span style="color:' + color + ';font-weight:600">' + (h.overall ? 'PASS' : 'FAIL') + '</span></td>' +
            '<td style="padding:6px">' + lockBadge + '</td></tr>';
        }
        tbody.innerHTML = html;
      },

      /* ── Test Suites ─────────────────────────────────────────── */

      _check: function(name, pass, detail) {
        return { name: name, pass: !!pass, detail: detail || '' };
      },

      _runP022: function() {
        var checks = [];
        checks.push(this._check('XLSX loaded', typeof XLSX !== 'undefined'));
        checks.push(this._check('parseWorkbook exists', typeof parseWorkbook === 'function'));
        checks.push(this._check('addSheet exists', typeof addSheet === 'function'));
        checks.push(this._check('renderGrid exists', typeof renderGrid === 'function'));
        checks.push(this._check('generateSignalsForDataset exists', typeof generateSignalsForDataset === 'function'));
        checks.push(this._check('persistAllRecordsToStore exists', typeof persistAllRecordsToStore === 'function'));
        checks.push(this._check('ContractIndex exists', typeof ContractIndex !== 'undefined'));
        checks.push(this._check('ContractIndex.build exists', typeof ContractIndex !== 'undefined' && typeof ContractIndex.build === 'function'));
        checks.push(this._check('seedPatchRequestsFromMetaSheet exists', typeof seedPatchRequestsFromMetaSheet === 'function'));
        checks.push(this._check('IDENTITY_CONTEXT exists', typeof IDENTITY_CONTEXT !== 'undefined'));
        checks.push(this._check('navigateTo exists', typeof navigateTo === 'function'));
        checks.push(this._check('TriageAnalytics exists', typeof TriageAnalytics !== 'undefined'));
        checks.push(this._check('renderAnalystTriage exists', typeof renderAnalystTriage === 'function'));
        return checks;
      },

      _runP1: function() {
        var checks = [];
        checks.push(this._check('TriageAnalytics defined', typeof TriageAnalytics !== 'undefined'));
        checks.push(this._check('TriageAnalytics.refresh exists', typeof TriageAnalytics !== 'undefined' && typeof TriageAnalytics.refresh === 'function'));
        checks.push(this._check('TriageAnalytics.renderHeader exists', typeof TriageAnalytics !== 'undefined' && typeof TriageAnalytics.renderHeader === 'function'));
        checks.push(this._check('TriageTelemetry defined', typeof TriageTelemetry !== 'undefined'));
        checks.push(this._check('TriageTelemetry.EVENT_STAGE_MAP', typeof TriageTelemetry !== 'undefined' && typeof TriageTelemetry.EVENT_STAGE_MAP === 'object'));
        checks.push(this._check('TruthPack defined', typeof TruthPack !== 'undefined'));
        checks.push(this._check('TruthPack.isArchitect exists', typeof TruthPack !== 'undefined' && typeof TruthPack.isArchitect === 'function'));
        checks.push(this._check('ta-processing-banner in DOM', !!document.getElementById('ta-processing-banner')));
        checks.push(this._check('ta-lifecycle-stages in DOM', !!document.getElementById('ta-lifecycle-stages')));
        checks.push(this._check('ta-contract-tbody in DOM', !!document.getElementById('ta-contract-tbody')));
        return checks;
      },

      _runCalibration: function() {
        var checks = [];
        checks.push(this._check('_preflightBlockerTypes defined', typeof _preflightBlockerTypes !== 'undefined'));
        var types = typeof _preflightBlockerTypes !== 'undefined' ? _preflightBlockerTypes : {};
        checks.push(this._check('UNKNOWN_COLUMN type', !!types['UNKNOWN_COLUMN']));
        checks.push(this._check('OCR_UNREADABLE type', !!types['OCR_UNREADABLE']));
        checks.push(this._check('DOCUMENT_TYPE_MISSING type', !!types['DOCUMENT_TYPE_MISSING']));
        checks.push(this._check('MISSING_REQUIRED type', !!types['MISSING_REQUIRED']));
        checks.push(this._check('PICKLIST_INVALID type', !!types['PICKLIST_INVALID']));
        checks.push(this._check('DTM label is Document Type Missing', types['DOCUMENT_TYPE_MISSING'] ? types['DOCUMENT_TYPE_MISSING'].label === 'Document Type Missing' : false, types['DOCUMENT_TYPE_MISSING'] ? types['DOCUMENT_TYPE_MISSING'].label : 'missing'));
        var docTypesCfg = false;
        try { docTypesCfg = typeof document_types_config !== 'undefined' || typeof documentTypesConfig !== 'undefined'; } catch(e) {}
        checks.push(this._check('field_meta or qa_flags accessible', typeof field_meta_config !== 'undefined' || typeof window.fieldMetaConfig !== 'undefined' || typeof _preflightBlockerTypes !== 'undefined'));
        return checks;
      },

      _runP08: function() {
        var checks = [];
        checks.push(this._check('resolveRecordForTriageItem exists', typeof resolveRecordForTriageItem === 'function'));
        checks.push(this._check('executeTriageResolution exists', typeof executeTriageResolution === 'function'));
        checks.push(this._check('showUnresolvedModal exists', typeof showUnresolvedModal === 'function'));
        checks.push(this._check('closeUnresolvedModal exists', typeof closeUnresolvedModal === 'function'));
        checks.push(this._check('p08PurgeStaleTriageItems exists', typeof p08PurgeStaleTriageItems === 'function'));
        checks.push(this._check('p08CopyDebugJSON exists', typeof p08CopyDebugJSON === 'function'));
        checks.push(this._check('p08-unresolved-modal in DOM', !!document.getElementById('p08-unresolved-modal')));
        checks.push(this._check('openSignalTriageItem exists', typeof openSignalTriageItem === 'function'));
        checks.push(this._check('openPreflightItem exists', typeof openPreflightItem === 'function'));
        checks.push(this._check('openAnalystTriageItem exists', typeof openAnalystTriageItem === 'function'));
        return checks;
      },

      _runP09: function() {
        var checks = [];
        checks.push(this._check('sanitizeDoubleSlashAnnotations exists', typeof sanitizeDoubleSlashAnnotations === 'function'));
        checks.push(this._check('Default route log emitted', (function() {
          try { var mode = (localStorage.getItem('viewer_mode_v10') || '').toLowerCase(); return mode.length > 0; } catch(e) { return false; }
        })(), 'mode=' + (localStorage.getItem('viewer_mode_v10') || 'unset')));
        checks.push(this._check('showToast exists', typeof showToast === 'function'));
        checks.push(this._check('getRoleRegistry exists', typeof getRoleRegistry === 'function'));
        checks.push(this._check('saveRoleRegistry exists', typeof saveRoleRegistry === 'function'));
        checks.push(this._check('hasPermission exists', typeof hasPermission === 'function'));
        checks.push(this._check('TruthConfig defined', typeof TruthConfig !== 'undefined'));
        checks.push(this._check('InviteManager defined', typeof InviteManager !== 'undefined'));
        checks.push(this._check('AuditTimeline defined', typeof AuditTimeline !== 'undefined'));
        checks.push(this._check('AuditTimeline.emit exists', typeof AuditTimeline !== 'undefined' && typeof AuditTimeline.emit === 'function'));
        return checks;
      },

      _runP1A: function() {
        var checks = [];
        checks.push(this._check('getTriageTypeLabel exists', typeof getTriageTypeLabel === 'function'));
        checks.push(this._check('getTriageTypeTip exists', typeof getTriageTypeTip === 'function'));
        checks.push(this._check('_p1aBuildSheetTabs exists', typeof _p1aBuildSheetTabs === 'function'));
        checks.push(this._check('_p1aFilterBySheet exists', typeof _p1aFilterBySheet === 'function'));
        checks.push(this._check('_p1aSelectSheet exists', typeof _p1aSelectSheet === 'function'));
        checks.push(this._check('p1a-preflight-sheet-tabs in DOM', !!document.getElementById('p1a-preflight-sheet-tabs')));
        checks.push(this._check('Label: required -> Missing Required', (function() {
          if (typeof getTriageTypeLabel !== 'function') return false;
          return getTriageTypeLabel('required') === 'Missing Required';
        })()));
        checks.push(this._check('Label: encoding -> Encoding Issue', (function() {
          if (typeof getTriageTypeLabel !== 'function') return false;
          return getTriageTypeLabel('encoding') === 'Encoding Issue';
        })()));
        checks.push(this._check('Tooltip for required', (function() {
          if (typeof getTriageTypeTip !== 'function') return false;
          var tip = getTriageTypeTip('required');
          return tip && tip.length > 10;
        })()));
        checks.push(this._check('Sheet filter All returns all', (function() {
          if (typeof _p1aFilterBySheet !== 'function') return false;
          try {
            var prev = typeof _p1aActiveSheet !== 'undefined' ? _p1aActiveSheet : 'All';
            _p1aActiveSheet = 'All';
            var items = [{sheet_name:'A'},{sheet_name:'B'}];
            var result = _p1aFilterBySheet(items);
            _p1aActiveSheet = prev;
            return result.length === 2;
          } catch(e) { return false; }
        })()));
        checks.push(this._check('Sheet filter specific', (function() {
          if (typeof _p1aFilterBySheet !== 'function') return false;
          try {
            var prev = typeof _p1aActiveSheet !== 'undefined' ? _p1aActiveSheet : 'All';
            _p1aActiveSheet = 'A';
            var items = [{sheet_name:'A'},{sheet_name:'B'}];
            var result = _p1aFilterBySheet(items);
            _p1aActiveSheet = prev;
            return result.length === 1;
          } catch(e) { return false; }
        })()));
        checks.push(this._check('_preflightBlockerTypes has MISSING_REQUIRED', typeof _preflightBlockerTypes !== 'undefined' && !!_preflightBlockerTypes['MISSING_REQUIRED']));
        return checks;
      }
    };

    console.log('[P1B] QARunner module loaded');
    </script>


              <!-- P1E: Cache Diagnostics Panel -->
              <div id="p1e-diag-panel" class="p1e-diag-panel">
                <div class="p1e-diag-header">
                  <span>PDF Cache Diagnostics</span>
                  <span class="p1e-diag-close" onclick="_p1eHideDiagPanel()">&times;</span>
                </div>
                <div class="p1e-diag-body"></div>
              </div>

    <!-- V1: Add New Doc Type Modal -->
    <div id="srr-new-doctype-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:10000; align-items:center; justify-content:center;">
      <div style="background:#fff; border-radius:8px; padding:24px; max-width:420px; width:90%; box-shadow:0 8px 32px rgba(0,0,0,0.2);">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:16px;">
          <span style="font-weight:600; font-size:1.05em; color:#1a237e;">Add New Document Type</span>
          <button onclick="srrCloseNewDocTypeModal()" style="background:none; border:none; font-size:1.2em; cursor:pointer; color:#999;">&times;</button>
        </div>
        <div style="margin-bottom:12px;">
          <label style="font-size:0.85em; font-weight:500; color:#333; display:block; margin-bottom:4px;">Document Type Name</label>
          <input type="text" id="srr-new-doctype-name" placeholder="e.g. Side Letter" style="width:100%; padding:6px 10px; border:1px solid #ccc; border-radius:4px; font-size:0.9em; box-sizing:border-box;">
        </div>
        <div style="margin-bottom:12px;">
          <label style="font-size:0.85em; font-weight:500; color:#333; display:block; margin-bottom:4px;">Justification</label>
          <textarea id="srr-new-doctype-justification" placeholder="Why is this doc type needed?" rows="3" style="width:100%; padding:6px 10px; border:1px solid #ccc; border-radius:4px; font-size:0.9em; box-sizing:border-box; resize:vertical;"></textarea>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button onclick="srrCloseNewDocTypeModal()" style="padding:6px 16px; border:1px solid #ccc; background:#f5f5f5; border-radius:4px; cursor:pointer; font-size:0.85em;">Cancel</button>
          <button onclick="srrSubmitNewDocType()" style="padding:6px 16px; border:none; background:#1565c0; color:#fff; border-radius:4px; cursor:pointer; font-size:0.85em; font-weight:600;">Submit as Patch</button>
        </div>
      </div>
    </div>

</body>
</html>
