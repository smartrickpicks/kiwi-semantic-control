<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orchestrate OS â€” Semantic Control Board</title>
  <!-- SheetJS library for XLSX parsing (v1.4.12) -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; color: #333; margin: 0; padding: 0; }
    h1 { margin-bottom: 10px; color: #1a1a2e; }

    /* Staged Loader Overlay */
    .staged-loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 46, 0.95);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    .staged-loader-content {
      text-align: center;
      color: white;
    }
    .staged-loader-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: #64b5f6;
      border-radius: 50%;
      margin: 0 auto 20px;
      animation: staged-spin 1s linear infinite;
    }
    @keyframes staged-spin {
      to { transform: rotate(360deg); }
    }
    .staged-loader-title {
      font-size: 1.3em;
      font-weight: 600;
      margin-bottom: 24px;
      color: #fff;
    }
    .staged-loader-stages {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
      padding: 0 20px;
    }
    .staged-loader-stage {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95em;
      color: rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
    }
    .staged-loader-stage.active {
      color: #64b5f6;
    }
    .staged-loader-stage.active .stage-icon {
      color: #64b5f6;
      animation: pulse-icon 1s ease-in-out infinite;
    }
    .staged-loader-stage.completed {
      color: #81c784;
    }
    .staged-loader-stage.completed .stage-icon {
      color: #81c784;
    }
    .stage-icon {
      font-size: 1.1em;
      width: 18px;
      text-align: center;
    }
    @keyframes pulse-icon {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .app-layout { display: flex; min-height: 100vh; }
    .nav-sidebar { width: 280px; background: #1a1a2e; color: white; flex-shrink: 0; display: flex; flex-direction: column; overflow-y: auto; }
    .nav-header { padding: 16px 20px; border-bottom: 1px solid #2d2d4a; }
    .nav-header h1 { font-size: 1em; color: white; margin: 0; }
    .nav-header .version { font-size: 0.7em; color: #888; margin-top: 4px; }
    .nav-menu { flex: 1 1 auto; padding: 10px 0; overflow-y: auto; min-height: 0; }
    .nav-footer { flex-shrink: 0; background: #1a1a2e; border-top: 1px solid #333; }
    .nav-section { margin-bottom: 8px; }
    .nav-section-header { padding: 8px 20px 6px; font-size: 0.65em; color: #666; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
    .nav-item { display: flex; align-items: center; padding: 10px 20px; color: #aaa; text-decoration: none; cursor: pointer; transition: all 0.2s; border-left: 3px solid transparent; }
    .nav-item:hover { background: #2d2d4a; color: white; }
    .nav-item.active { background: #0f3460; color: white; border-left-color: #1565c0; }
    .nav-item.queue-item { padding: 8px 20px; }
    .nav-icon { width: 18px; margin-right: 10px; text-align: center; font-size: 0.9em; }
    .nav-label { font-size: 0.85em; flex-grow: 1; }
    .nav-count { background: #3d3d5c; color: #aaa; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; margin-left: 8px; }
    .nav-count.has-items { background: #1565c0; color: white; }
    .nav-count.blocking { background: #c62828; color: white; }
    .nav-severity-chips { display: flex; gap: 3px; margin-left: 8px; }
    .nav-severity-chip { width: 6px; height: 6px; border-radius: 50%; }
    .nav-severity-chip.blocking { background: #c62828; }
    .nav-severity-chip.warning { background: #f57c00; }
    .nav-severity-chip.info { background: #1565c0; }
    .nav-divider { height: 1px; background: #2d2d4a; margin: 8px 20px; }
    .nav-mode-section { padding: 12px 20px; border-top: 1px solid #2d2d4a; }
    .nav-mode-label { font-size: 0.65em; color: #666; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.5px; }
    .mode-toggle { display: flex; gap: 4px; flex-wrap: wrap; }
    .mode-btn { padding: 6px 12px; font-size: 0.75em; border: 1px solid #555; background: transparent; color: #aaa; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    .mode-btn:hover { border-color: #888; color: white; }
    .mode-btn.active { background: #1565c0; border-color: #1565c0; color: white; }
    .mode-btn.mode-analyst { }
    .mode-btn.mode-reviewer { }
    .mode-btn.mode-admin { }

    .main-content { flex-grow: 1; padding: 20px; overflow-y: auto; max-height: 100vh; }
    .page { display: none; }
    .page.active { display: block; }
    .page-header { margin-bottom: 20px; }
    .page-header h2 { color: #1a1a2e; font-size: 1.4em; margin-bottom: 5px; }
    .page-header .page-desc { color: #666; font-size: 0.9em; }

    .mode-hidden { display: none !important; }
    .mode-dimmed { opacity: 0.5; pointer-events: none; }
    h2 { margin: 20px 0 10px; color: #16213e; border-bottom: 2px solid #0f3460; padding-bottom: 5px; }
    .subtitle { color: #666; margin-bottom: 20px; font-size: 0.9em; }
    .summary { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
    .summary-card { background: white; padding: 15px 25px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; min-width: 100px; }
    .summary-card .count { font-size: 2em; font-weight: bold; }
    .summary-card .label { font-size: 0.85em; color: #666; text-transform: uppercase; }
    .summary-card.clickable { cursor: pointer; transition: transform 0.15s, box-shadow 0.15s; }
    .summary-card.clickable:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .ready .count { color: #2e7d32; }
    .needs-review .count { color: #f57c00; }
    .blocked .count { color: #c62828; }
    .contracts .count { color: #1565c0; }
    table { width: 100%; border-collapse: collapse; background: white; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #eee; font-size: 0.9em; }
    th { background: #1a1a2e; color: white; font-weight: 600; }
    tr:hover { background: #e8f4fd; cursor: pointer; }
    tr:last-child td { border-bottom: none; }
    .severity-blocking { background: #ffebee; color: #c62828; font-weight: bold; }
    .severity-warning { background: #fff3e0; color: #e65100; }
    .severity-info { background: #e3f2fd; color: #1565c0; }
    .status-ready { color: #2e7d32; font-weight: bold; }
    .status-needs_review { color: #f57c00; font-weight: bold; }
    .status-blocked { color: #c62828; font-weight: bold; }
    .diff-pane { background: #263238; color: #eceff1; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.85em; white-space: pre-wrap; margin-bottom: 20px; }
    .diff-pane code { display: block; background: #37474f; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .error { background: #ffebee; color: #c62828; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .info { background: #e3f2fd; color: #1565c0; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .source-info { font-size: 0.8em; color: #666; margin-bottom: 20px; }
    .null-value { color: #999; font-style: italic; }
    .table-container { overflow-x: auto; }
    .hidden-row { display: none; }

    .toolbar { background: #1a1a2e; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .toolbar-btn { background: #0f3460; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9em; transition: background 0.2s; }
    .toolbar-btn:hover { background: #1565c0; }
    .toolbar-confirm { display: flex; align-items: center; gap: 8px; color: #ffeb3b; font-size: 0.85em; margin-left: auto; }
    .toolbar-confirm input { width: 18px; height: 18px; cursor: pointer; }
    .toolbar-confirm label { cursor: pointer; }

    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 1000; }
    .modal-overlay.active { display: flex; }
    .modal { background: white; border-radius: 8px; max-width: 700px; width: 90%; max-height: 80vh; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
    
    /* Drawer (right-side slide-over panel) */
    .drawer-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4); display: none; z-index: 1000; }
    .drawer-overlay.active { display: block; }
    .drawer { position: fixed; top: 0; right: -420px; width: 400px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); transition: right 0.25s ease-out; z-index: 1001; display: flex; flex-direction: column; }
    .drawer-overlay.active .drawer { right: 0; }
    .drawer-header { background: #1a1a2e; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
    .drawer-header h3 { margin: 0; font-size: 1.1em; font-weight: 600; }
    .drawer-close { background: none; border: none; color: white; font-size: 1.4em; cursor: pointer; line-height: 1; padding: 0; opacity: 0.8; }
    .drawer-close:hover { opacity: 1; }
    .drawer-body { flex: 1; overflow-y: auto; padding: 20px; }
    .drawer-footer { padding: 15px 20px; border-top: 1px solid #e0e0e0; background: #f8f9fa; flex-shrink: 0; }
    
    /* First-Run Banner */
    .first-run-banner { display: flex; align-items: center; gap: 12px; padding: 10px 20px; background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border-bottom: 1px solid #bbdefb; font-size: 0.9em; }
    .first-run-banner .banner-icon { font-size: 1.2em; }
    .first-run-banner .banner-text { flex: 1; color: #1565c0; }
    .first-run-banner .banner-dismiss { background: none; border: none; font-size: 1.2em; color: #666; cursor: pointer; padding: 4px 8px; line-height: 1; }
    .first-run-banner .banner-dismiss:hover { color: #333; }
    
    /* Configure Button Style */
    .top-toolbar-btn.configure-btn { background: linear-gradient(135deg, #7c4dff 0%, #536dfe 100%); color: white; border: none; }
    .top-toolbar-btn.configure-btn:hover { background: linear-gradient(135deg, #651fff 0%, #304ffe 100%); }
    
    /* Wizard Progress Dots */
    .wizard-step-dot { width: 12px; height: 12px; border-radius: 50%; background: #e0e0e0; transition: background 0.2s; }
    .wizard-step-dot.active { background: #7c4dff; }
    .wizard-step-dot.completed { background: #4caf50; }
    
    /* Config Flows Rail */
    .rail-item { display: flex; align-items: center; gap: 10px; padding: 10px 15px; cursor: pointer; color: #555; text-decoration: none; transition: background 0.15s; }
    .rail-item:hover { background: #e8e8e8; }
    .rail-item.active { background: #e3f2fd; color: #1565c0; border-left: 3px solid #1565c0; }
    .rail-number { width: 22px; height: 22px; border-radius: 50%; background: #ddd; color: #666; display: flex; align-items: center; justify-content: center; font-size: 0.75em; font-weight: 600; flex-shrink: 0; }
    .rail-item.active .rail-number { background: #1565c0; color: white; }
    .rail-label { font-size: 0.85em; }
    
    /* Config Flows Tabs */
    .stage-tab { padding: 8px 16px; border: none; background: none; cursor: pointer; font-size: 0.85em; color: #666; border-bottom: 2px solid transparent; }
    .stage-tab:hover { color: #333; }
    .stage-tab.active { color: #1565c0; border-bottom-color: #1565c0; }
    
    /* Wizard Form Elements */
    .wizard-form-group { margin-bottom: 18px; }
    .wizard-form-group label { display: block; font-weight: 500; margin-bottom: 6px; color: #333; }
    .wizard-form-group .hint { font-size: 0.8em; color: #888; margin-top: 4px; }
    .wizard-toggle { display: flex; align-items: center; gap: 10px; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer; }
    .wizard-toggle input { width: 18px; height: 18px; }
    .wizard-toggle-label { flex: 1; }
    .wizard-toggle-label strong { display: block; margin-bottom: 2px; }
    .wizard-toggle-label small { color: #666; }
    .wizard-multi-select { display: flex; flex-wrap: wrap; gap: 8px; }
    .wizard-multi-select label { display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f5; border-radius: 6px; cursor: pointer; font-size: 0.9em; }
    .wizard-multi-select label:has(input:checked) { background: #e8eaf6; border: 1px solid #7c4dff; }
    .wizard-multi-select input { width: 16px; height: 16px; }
    .modal-header { background: #1a1a2e; color: white; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h3 { margin: 0; }
    .modal-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .modal-body { padding: 20px; overflow-y: auto; max-height: calc(80vh - 60px); }
    .modal-command { background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.9em; word-break: break-all; margin-bottom: 15px; }
    .modal-actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .modal-btn { padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer; font-size: 0.9em; }
    .modal-btn-primary { background: #1565c0; color: white; }
    .modal-btn-primary:hover { background: #1976d2; }
    .modal-btn-secondary { background: #e0e0e0; color: #333; }
    .modal-btn-secondary:hover { background: #bdbdbd; }
    .modal-btn-danger { background: #c62828; color: white; }
    .modal-btn-danger:hover { background: #d32f2f; }
    .modal-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .modal-status { margin-top: 15px; padding: 10px; border-radius: 4px; font-size: 0.85em; }
    .modal-status.success { background: #e8f5e9; color: #2e7d32; }
    .modal-status.error { background: #ffebee; color: #c62828; }
    .modal-status.info { background: #e3f2fd; color: #1565c0; }

    /* Welcome Hero (no data loaded) */
    .welcome-hero { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60vh; text-align: center; padding: 40px; }
    .welcome-hero.hidden { display: none; }
    .welcome-hero h2 { font-size: 1.8em; color: #1a1a2e; margin-bottom: 10px; }
    .welcome-hero p { color: #666; margin-bottom: 30px; max-width: 500px; }
    .welcome-cta { background: #1565c0; color: white; border: none; padding: 16px 32px; border-radius: 8px; font-size: 1.1em; cursor: pointer; transition: background 0.2s; }
    .welcome-cta:hover { background: #1976d2; }
    .welcome-hint { margin-top: 20px; font-size: 0.85em; color: #888; }

    /* Top Toolbar (fixed) */
    .top-toolbar { background: white; border-bottom: 1px solid #ddd; padding: 10px 20px; display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .top-toolbar-left { display: flex; align-items: center; gap: 10px; }
    .top-toolbar-right { margin-left: auto; display: flex; align-items: center; gap: 10px; }
    .top-toolbar-btn { background: #e8f4fd; color: #1565c0; border: 1px solid #bbdefb; padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 0.85em; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
    .top-toolbar-btn:hover { background: #1565c0; color: white; border-color: #1565c0; }
    .top-toolbar-btn.primary { background: #1565c0; color: white; border-color: #1565c0; }
    .top-toolbar-btn.primary:hover { background: #0d47a1; }
    .data-indicator { display: flex; align-items: center; gap: 8px; font-size: 0.85em; color: #666; }
    .data-indicator .dot { width: 10px; height: 10px; border-radius: 50%; background: #4caf50; }
    .data-indicator .dot.no-data { background: #ff9800; }
    .data-indicator-path { font-family: monospace; background: #f5f5f5; padding: 4px 8px; border-radius: 4px; max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    /* Wizard Modal */
    .wizard-modal { max-width: 600px; }
    .wizard-field { margin-bottom: 20px; }
    .wizard-field label { display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em; }
    .wizard-field input, .wizard-field select { width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; }
    .wizard-field input:focus, .wizard-field select:focus { border-color: #1565c0; outline: none; }
    .wizard-field .hint { font-size: 0.8em; color: #888; margin-top: 4px; }
    .wizard-section { background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .wizard-section h4 { margin: 0 0 10px; font-size: 0.95em; color: #1a1a2e; }
    .wizard-divider { border-top: 1px solid #eee; margin: 20px 0; }
    .wizard-row { display: flex; gap: 15px; }
    .wizard-row .wizard-field { flex: 1; }
    .wizard-preset { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .wizard-preset-btn { padding: 6px 12px; background: #e0e0e0; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer; transition: background 0.2s; }
    .wizard-preset-btn:hover { background: #bdbdbd; }
    .wizard-preset-btn.active { background: #1565c0; color: white; }

    /* Nav item mode visibility */
    .nav-item.analyst-only { display: flex; }
    .nav-item.reviewer-only { display: none; }
    .nav-item.admin-only { display: none; }
    .mode-analyst .nav-item.analyst-only { display: flex; }
    .mode-analyst .nav-item.reviewer-only { display: none; }
    .mode-analyst .nav-item.admin-only { display: none; }
    .mode-reviewer .nav-item.analyst-only { display: none; }
    .mode-reviewer .nav-item.reviewer-only { display: flex; }
    .mode-reviewer .nav-item.admin-only { display: none; }
    .mode-admin .nav-item.analyst-only { display: none; }
    .mode-admin .nav-item.reviewer-only { display: flex; }
    .mode-admin .nav-item.admin-only { display: flex; }

    /* Sidebar Action Buttons */
    .nav-action-btn { width: 100%; padding: 10px 14px; background: #1565c0; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; display: flex; align-items: center; gap: 8px; transition: background 0.2s; }
    .nav-action-btn:hover { background: #1976d2; }
    .nav-action-btn.export-btn { background: #2e7d32; }
    .nav-action-btn.export-btn:hover { background: #388e3c; }
    .nav-action-icon { font-size: 1.1em; }

    /* Progress Block */
    .progress-block { display: block; background: #2d2d4a; border-radius: 8px; padding: 12px; text-decoration: none; color: inherit; cursor: pointer; transition: background 0.2s; }
    .progress-block:hover { background: #3d3d5a; }
    .progress-header { font-size: 0.7em; text-transform: uppercase; letter-spacing: 0.5px; color: #888; margin-bottom: 8px; font-weight: 600; }
    .progress-stats { display: flex; justify-content: space-between; margin-bottom: 10px; }
    .progress-stat { text-align: center; flex: 1; }
    .progress-stat-count { display: block; font-size: 1.4em; font-weight: 600; color: white; }
    .progress-stat-label { font-size: 0.65em; color: #888; text-transform: uppercase; }
    .progress-bar-container { background: #1a1a2e; border-radius: 4px; height: 6px; overflow: hidden; }
    .progress-bar-fill { background: linear-gradient(90deg, #1565c0, #2196f3); height: 100%; transition: width 0.3s; }

    /* Active Data Source Bar */
    .active-data-source-bar { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: #252542; border-bottom: 1px solid #333; }
    .active-data-source-info { flex: 1; min-width: 0; }
    .active-data-source-label { font-size: 0.65em; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; }
    .active-data-source-name { font-size: 0.85em; color: #ddd; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .active-data-source-change { background: transparent; border: 1px solid #555; color: #aaa; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; cursor: pointer; transition: all 0.2s; flex-shrink: 0; margin-left: 12px; }
    .active-data-source-change:hover { background: #333; border-color: #777; color: white; }

    /* Sheet Selector */
    .sheet-selector { width: 100%; padding: 8px 10px; background: #2d2d4a; border: 1px solid #444; border-radius: 6px; color: #ddd; font-size: 0.85em; cursor: pointer; }
    .sheet-selector:focus { outline: none; border-color: #1565c0; }

    /* Cache Section */
    .cache-clear-btn { width: 100%; padding: 6px 10px; background: transparent; border: 1px solid #555; border-radius: 4px; color: #aaa; font-size: 0.75em; cursor: pointer; transition: all 0.2s; }
    .cache-clear-btn:hover { background: #333; border-color: #777; color: white; }
    
    /* Role-based visibility for any element */
    .admin-only-content { display: none !important; }
    .reviewer-only-content { display: none !important; }
    .mode-admin .admin-only-content { display: block !important; }
    .mode-admin .admin-only-content.flex { display: flex !important; }
    .mode-reviewer .reviewer-only-content { display: block !important; }
    .mode-admin .reviewer-only-content { display: block !important; }
    
    /* Loader Modal */
    .loader-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; z-index: 1001; justify-content: center; align-items: center; }
    .loader-modal-overlay.active { display: flex; }
    .loader-modal { background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.25); z-index: 1002; display: flex; flex-direction: column; max-width: 520px; width: 90%; max-height: 85vh; animation: modalFadeIn 0.2s ease-out; }
    @keyframes modalFadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    .loader-modal-header { background: #1565c0; color: white; padding: 16px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-radius: 12px 12px 0 0; }
    .loader-modal-header h3 { margin: 0; font-size: 1.1em; font-weight: 600; }
    .loader-modal-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; padding: 4px 10px; border-radius: 4px; line-height: 1; }
    .loader-modal-close:hover { background: rgba(255,255,255,0.2); }
    .loader-modal-body { flex: 1; overflow-y: auto; padding: 24px; }

    /* Session Status Chip */
    .session-chip { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; text-transform: uppercase; }
    .session-chip.not-loaded { background: #fff3e0; color: #e65100; }
    .session-chip.loaded { background: #e8f5e9; color: #2e7d32; }
    .session-chip.fallback { background: #e3f2fd; color: #1565c0; }
    .session-chip .chip-dot { width: 6px; height: 6px; border-radius: 50%; }
    .session-chip.not-loaded .chip-dot { background: #e65100; }
    .session-chip.loaded .chip-dot { background: #2e7d32; }
    .session-chip.fallback .chip-dot { background: #1565c0; }
    .session-meta { font-size: 0.75em; color: #888; margin-left: 10px; }

    /* Drop Zone */
    .drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 20px; text-align: center; background: #fafafa; transition: all 0.2s; cursor: pointer; margin-bottom: 10px; }
    .drop-zone:hover { border-color: #1565c0; background: #e8f4fd; }
    .drop-zone.drag-over { border-color: #1565c0; background: #bbdefb; }
    .drop-zone.has-file { border-color: #2e7d32; background: #e8f5e9; }
    .drop-zone-icon { font-size: 1.5em; margin-bottom: 8px; }
    .drop-zone-text { font-size: 0.85em; color: #666; }
    .drop-zone-file { font-size: 0.85em; color: #2e7d32; font-weight: 600; margin-top: 5px; }

    /* Paste Area */
    .paste-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.8em; resize: vertical; margin-bottom: 10px; }
    .paste-area:focus { border-color: #1565c0; outline: none; }
    .paste-area.valid { border-color: #2e7d32; background: #f1f8e9; }
    .paste-area.invalid { border-color: #c62828; background: #ffebee; }

    /* Path Hint */
    .path-hint-container { display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px; margin-bottom: 10px; }
    .path-hint-input { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85em; background: white; }
    .path-hint-label { font-size: 0.75em; color: #888; background: #eee; padding: 2px 6px; border-radius: 3px; }
    .path-hint-warning { font-size: 0.75em; color: #f57c00; margin-top: 5px; display: flex; align-items: center; gap: 5px; }

    /* Loader Tabs */
    .loader-tabs { display: flex; gap: 5px; margin-bottom: 15px; }
    .loader-tab { padding: 8px 16px; border: none; background: #e0e0e0; color: #666; border-radius: 6px 6px 0 0; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
    .loader-tab:hover { background: #ccc; }
    .loader-tab.active { background: #1565c0; color: white; }
    .loader-panel { display: none; }
    .loader-panel.active { display: block; }

    /* Loader Section */
    .loader-section { background: #f9f9f9; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
    .loader-section h4 { margin: 0 0 10px; font-size: 0.95em; color: #1a1a2e; display: flex; align-items: center; gap: 8px; }
    .loader-section h4 .required { color: #c62828; font-size: 0.8em; }
    .loader-section h4 .optional { color: #888; font-size: 0.8em; font-weight: normal; }
    .loader-section-status { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; margin-left: auto; }
    .loader-section-status.empty { background: #eee; color: #888; }
    .loader-section-status.loaded { background: #e8f5e9; color: #2e7d32; }

    /* Remember Toggle */
    .remember-toggle { display: flex; align-items: center; gap: 8px; margin-top: 15px; padding: 10px; background: #fff8e1; border-radius: 6px; }
    .remember-toggle input { width: 18px; height: 18px; cursor: pointer; }
    .remember-toggle label { font-size: 0.85em; color: #666; cursor: pointer; }

    /* Reset Button */
    .reset-session-btn { background: #fff3e0; color: #e65100; border: 1px solid #ffcc80; }

    /* Empty Queue Message */
    .empty-queue-message { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 50vh; text-align: center; padding: 40px; background: #fafafa; border-radius: 12px; margin: 20px 0; }
    .empty-queue-message.hidden { display: none; }
    .empty-queue-icon { font-size: 3em; margin-bottom: 15px; }
    .empty-queue-message h3 { font-size: 1.3em; color: #333; margin-bottom: 10px; }
    .empty-queue-message p { color: #666; margin-bottom: 20px; max-width: 400px; line-height: 1.5; }
    .empty-queue-cta { background: #1565c0; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 1em; cursor: pointer; transition: background 0.2s; }
    .empty-queue-cta:hover { background: #1976d2; }

    /* Data Sources Drawer (right-side slide-over) */
    .data-drawer { position: fixed; top: 0; right: -420px; width: 420px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 950; transition: right 0.3s ease; display: flex; flex-direction: column; }
    .data-drawer.active { right: 0; }
    .data-drawer-header { background: #1a1a2e; color: white; padding: 16px 20px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    .data-drawer-header h3 { margin: 0; font-size: 1.1em; }
    .data-drawer-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .data-drawer-body { padding: 20px; overflow-y: auto; flex-grow: 1; }
    .data-drawer-section { background: #f9f9f9; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
    .data-drawer-section h4 { margin: 0 0 8px; font-size: 0.95em; color: #333; display: flex; align-items: center; gap: 8px; }
    .data-drawer-section h4 .required { color: #c62828; font-size: 0.75em; font-weight: 600; }
    .data-drawer-section h4 .optional { color: #888; font-size: 0.75em; font-weight: normal; }
    .data-drawer-section p { font-size: 0.8em; color: #666; margin: 0 0 12px; line-height: 1.4; }
    .data-drawer-section .info-tooltip { display: inline-block; width: 14px; height: 14px; background: #1565c0; color: white; border-radius: 50%; font-size: 0.65em; text-align: center; line-height: 14px; cursor: help; margin-left: 4px; }
    .data-drawer-actions { padding: 16px 20px; border-top: 1px solid #eee; flex-shrink: 0; }
    .data-drawer-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); display: none; z-index: 940; }
    .data-drawer-overlay.active { display: block; }

    .filters { background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .filters-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: center; }
    .filter-group { display: flex; flex-direction: column; gap: 5px; }
    .filter-group label { font-size: 0.75em; color: #666; text-transform: uppercase; font-weight: 600; }
    .filter-search { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; width: 250px; }
    .filter-chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .filter-chip { padding: 6px 12px; border-radius: 20px; font-size: 0.8em; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; }
    .filter-chip.severity-blocking { background: #ffcdd2; border-color: #c62828; }
    .filter-chip.severity-warning { background: #ffe0b2; border-color: #e65100; }
    .filter-chip.severity-info { background: #bbdefb; border-color: #1565c0; }
    .filter-chip.status-ready { background: #c8e6c9; border-color: #2e7d32; }
    .filter-chip.status-needs_review { background: #ffe0b2; border-color: #f57c00; }
    .filter-chip.status-blocked { background: #ffcdd2; border-color: #c62828; }
    .filter-chip.inactive { opacity: 0.4; }
    .filter-chip:hover { opacity: 1; }
    .filter-chip.active { background: #1976d2; color: white; border-color: #1565c0; }

    /* Single Row Review - Three Panel Layout */
    .srr-layout { display: flex; height: calc(100vh - 200px); gap: 0; }
    /* v1.6.7: Footer with file name */
    .srr-footer { background: #f5f5f5; border-top: 1px solid #e0e0e0; padding: 8px 16px; text-align: center; }
    .srr-footer-filename { font-size: 0.85em; color: #666; font-weight: 500; }
    .srr-panel { background: white; border: 1px solid #e0e0e0; overflow-y: auto; }
    .srr-panel-left { flex: 0 0 320px; flex-shrink: 0; border-right: none; }
    .srr-panel-center { flex: 1; min-width: 300px; }
    .srr-panel-right { flex: 0 0 320px; flex-shrink: 0; border-left: none; }
    .srr-panel-header { background: #f5f5f5; padding: 12px 16px; border-bottom: 1px solid #e0e0e0; font-weight: 600; font-size: 0.9em; color: #333; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 5; }
    .srr-panel-tabs { display: flex; gap: 4px; }
    .srr-panel-tab { padding: 4px 10px; font-size: 0.75em; border: 1px solid #ccc; background: #fff; border-radius: 4px; cursor: pointer; color: #666; }
    .srr-panel-tab:hover { background: #f0f0f0; }
    .srr-panel-tab.active { background: #1565c0; color: white; border-color: #1565c0; }
    .srr-panel-body { padding: 12px; }
    .srr-top-bar { display: flex; align-items: center; gap: 16px; margin-bottom: 16px; padding: 12px 16px; background: #1a1a2e; border-radius: 8px; color: white; }
    .srr-identity { font-family: 'Courier New', monospace; font-size: 0.85em; background: #0f3460; padding: 6px 12px; border-radius: 4px; }
    .srr-state-badge { padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; text-transform: uppercase; }
    .srr-state-badge.ready { background: #c8e6c9; color: #2e7d32; }
    .srr-state-badge.needs_review { background: #ffe0b2; color: #e65100; }
    .srr-state-badge.blocked { background: #ffcdd2; color: #c62828; }
    .srr-state-badge.finalized { background: #bbdefb; color: #1565c0; }
    .srr-back-btn { background: #0f3460; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 0.85em; display: flex; align-items: center; gap: 6px; }
    .srr-back-btn:hover { background: #1565c0; }
    
    /* Field Inspector */
    .srr-field-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: background 0.15s; }
    .srr-field-item:hover { background: #f8f9fa; }
    .srr-field-item.active { background: #e3f2fd; border-left: 3px solid #1565c0; }
    .srr-field-name { flex: 1; font-size: 0.85em; font-weight: 500; word-break: break-word; }
    .srr-field-value { font-size: 0.8em; color: #666; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .srr-field-indicators { display: flex; gap: 4px; }
    .srr-indicator { width: 18px; height: 18px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.65em; }
    .srr-indicator.system { background: #e0e0e0; color: #666; }
    .srr-indicator.delta { background: #fff3e0; color: #e65100; }
    .srr-indicator.flag { background: #ffcdd2; color: #c62828; }
    .srr-indicator.evidence { background: #e3f2fd; color: #1565c0; }
    
    /* Document Viewer */
    .srr-doc-viewer { height: 100%; display: flex; flex-direction: column; }
    .srr-doc-controls { display: flex; gap: 8px; padding: 8px 12px; background: #263238; border-bottom: 1px solid #37474f; align-items: center; }
    .srr-doc-btn { background: #37474f; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em; }
    .srr-doc-btn:hover { background: #455a64; }
    .srr-doc-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .srr-page-indicator { color: #b0bec5; font-size: 0.8em; min-width: 80px; text-align: center; }
    .srr-zoom-indicator { color: #b0bec5; font-size: 0.8em; min-width: 50px; text-align: center; }
    .srr-doc-spacer { flex: 1; }
    .srr-doc-frame { flex: 1; background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #666; font-size: 0.9em; position: relative; min-height: 400px; overflow: hidden; }
    .srr-doc-empty-state { text-align: center; padding: 40px; }
    .srr-doc-container { width: 100%; height: 100%; overflow: auto; }
    .srr-pdf-iframe { width: 100%; height: 100%; border: none; transform-origin: top left; }
    .srr-pdf-object { width: 100%; height: 100%; border: none; transform-origin: top left; display: block; }
    .srr-pdf-fallback { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #f0f0f0; }
    .srr-anchor-overlay { position: absolute; border: 2px solid #1565c0; background: rgba(21, 101, 192, 0.1); pointer-events: auto; cursor: pointer; }
    .srr-anchor-overlay:hover { background: rgba(21, 101, 192, 0.25); }
    
    /* v1.6.12: Non-blocking PDF highlight overlay */
    .srr-pdf-highlight-toast {
      position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
      background: rgba(21, 101, 192, 0.95); color: white; padding: 10px 18px;
      border-radius: 8px; font-size: 0.85em; font-weight: 500;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 100;
      display: flex; align-items: center; gap: 10px;
      opacity: 1; transition: opacity 0.3s ease-out;
      pointer-events: auto; max-width: 80%;
    }
    .srr-pdf-highlight-toast.fading { opacity: 0; }
    .srr-pdf-highlight-toast .close-btn {
      cursor: pointer; opacity: 0.7; font-size: 1.1em; margin-left: 8px;
    }
    .srr-pdf-highlight-toast .close-btn:hover { opacity: 1; }
    .srr-pdf-highlight-box {
      position: absolute; border: 3px solid #1565c0; background: rgba(21, 101, 192, 0.15);
      border-radius: 4px; z-index: 50; pointer-events: none;
      opacity: 1; transition: opacity 0.3s ease-out;
      box-shadow: 0 0 12px rgba(21, 101, 192, 0.4);
    }
    .srr-pdf-highlight-box.fading { opacity: 0; }
    .srr-anchor-list { padding: 12px; border-top: 1px solid #e0e0e0; max-height: 150px; overflow-y: auto; }
    .srr-anchor-item { padding: 8px 10px; background: #f8f9fa; border-radius: 4px; margin-bottom: 6px; font-size: 0.8em; cursor: pointer; border-left: 3px solid #1565c0; }
    .srr-anchor-item:hover { background: #e3f2fd; }
    
    /* v1.4.18: Field Inspector Search + Filters */
    .srr-search-bar { padding: 8px 12px; border-bottom: 1px solid #e0e0e0; }
    .srr-search-input { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; }
    .srr-search-input:focus { border-color: #1565c0; outline: none; }
    .srr-filter-bar { display: flex; gap: 8px; padding: 8px 12px; border-bottom: 1px solid #e0e0e0; align-items: center; flex-wrap: wrap; }
    .srr-filter-chips { display: flex; gap: 4px; }
    .srr-filter-chip { padding: 4px 10px; font-size: 0.75em; border-radius: 12px; cursor: pointer; background: #f0f0f0; color: #666; }
    .srr-filter-chip:hover { background: #e0e0e0; }
    .srr-filter-chip.active { background: #1565c0; color: white; }
    
    /* v1.5.7: Field group headers for hinge-based grouping */
    .srr-field-group-header { font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.5px; padding: 12px 12px 6px; margin-top: 8px; border-bottom: 2px solid #e0e0e0; background: #f8f9fa; }
    .srr-field-group-header:first-child { margin-top: 0; }
    /* v1.6.7: Color-coded group headers */
    .srr-field-group-header.group-primary { background: #e8f5e9; border-bottom-color: #4caf50; color: #2e7d32; }
    .srr-field-group-header.group-secondary { background: #e3f2fd; border-bottom-color: #1976d2; color: #1565c0; }
    .srr-field-group-header.group-other { background: #fafafa; border-bottom-color: #9e9e9e; color: #616161; }
    .srr-group-count { font-weight: 400; color: #999; }
    
    /* v1.4.18: Field Card enhancements - locked, changed */
    .srr-field-card.locked { background: #f8f8f8; opacity: 0.9; }
    .srr-field-card.locked .srr-field-value-display { pointer-events: none; cursor: not-allowed; }
    .srr-field-card.changed { border-left: 3px solid #4caf50; }
    .srr-field-card.changed .srr-field-card-header { background: #e8f5e9; }
    .srr-chip-changed { background: #4caf50; color: white; }
    .srr-chip-locked { background: #9e9e9e; color: white; }
    
    /* v1.4.20: Field state styling */
    /* Field state styles */
    .srr-field-card.state-verified { border-left: 3px solid #4caf50; }
    .srr-field-card.state-verified .srr-field-card-header { background: #e8f5e9; }
    .srr-field-card.state-modified { border-left: 3px solid #1976d2; }
    .srr-field-card.state-modified .srr-field-card-header { background: #e3f2fd; }
    .srr-field-card.state-submitted { border-left: 3px solid #1565c0; }
    .srr-field-card.state-submitted .srr-field-card-header { background: #bbdefb; }
    .srr-field-card.state-rfi { border-left: 3px solid #ff9800; }
    .srr-field-card.state-rfi .srr-field-card-header { background: #fff3e0; }
    .srr-field-card.state-blocked { border-left: 3px solid #d32f2f; }
    .srr-field-card.state-blocked .srr-field-card-header { background: #ffebee; }
    /* Field state badges */
    .srr-chip-verified { background: #4caf50; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    .srr-chip-modified { background: #1976d2; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    .srr-chip-submitted { background: #1565c0; color: white; font-size: 0.65em; padding: 2px 5px; border-radius: 10px; white-space: nowrap; }
    .srr-chip-rfi { background: #ff9800; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    .srr-chip-blocked { background: #d32f2f; color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 10px; }
    
    /* v1.4.20: Field action buttons */
    /* v1.4.20: Field action icons - Heroicons outline SVGs */
    .srr-field-actions { display: flex; gap: 2px; margin-left: auto; }
    .srr-field-action { border: none; background: transparent; cursor: pointer; padding: 4px; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: color 0.15s, background 0.15s; }
    .srr-field-action svg { width: 16px; height: 16px; }
    .srr-field-action { color: #9e9e9e; }
    .srr-field-action.blacklist:hover { color: #e53935; background: #ffebee; }
    .srr-field-action.rfi:hover { color: #7b1fa2; background: #f3e5f5; }
    .srr-field-action.verify:hover { color: #2e7d32; background: #e8f5e9; }
    .srr-field-action.blacklist.active { color: #e53935; }
    .srr-field-action.rfi.active { color: #7b1fa2; }
    .srr-field-action.verify.active { color: #2e7d32; background: #e8f5e9; }
    .srr-field-action.reset:hover { color: #616161; background: #f5f5f5; }
    
    /* v1.4.20: Filter chip with count */
    .srr-filter-chip .chip-count { font-size: 0.85em; margin-left: 4px; opacity: 0.8; }
    .srr-lock-icon { font-size: 0.9em; margin-left: 4px; }
    
    /* v1.5.2: Patch Type chip selected field indicator */
    .srr-patch-type-selected-field { font-size: 0.75em; color: #666; margin-top: 6px; padding: 4px 8px; background: #f5f5f5; border-radius: 4px; text-align: center; }
    .srr-patch-type-chips.no-selection .srr-patch-type-chip { opacity: 0.6; }
    .srr-patch-type-chips.no-selection .srr-patch-type-chip:hover { opacity: 1; }

    /* v1.4.18: Patch Editor Block */
    .srr-patch-editor { background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    .srr-patch-editor-title { font-weight: 600; font-size: 0.9em; color: #333; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; }
    .srr-patch-editor-empty { color: #999; font-size: 0.85em; font-style: italic; text-align: center; padding: 20px; }
    .srr-patch-editor-field { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #e0e0e0; }
    .srr-patch-editor-field:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .srr-patch-editor-label { font-size: 0.8em; font-weight: 600; color: #333; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
    .srr-patch-editor-row { display: flex; gap: 8px; align-items: flex-start; margin-bottom: 4px; }
    .srr-patch-editor-row label { font-size: 0.75em; color: #666; min-width: 60px; }
    .srr-patch-editor-old { flex: 1; background: #f5f5f5; padding: 6px 8px; border-radius: 4px; font-size: 0.8em; color: #999; font-family: monospace; border: 1px dashed #ccc; }
    .srr-patch-editor-new { flex: 1; }
    .srr-patch-editor-new input { width: 100%; padding: 8px 10px; border: 2px solid #4caf50; border-radius: 4px; font-size: 0.85em; font-family: monospace; background: #e8f5e9; font-weight: 500; }
    .srr-patch-editor-new input:focus { outline: none; border-color: #2e7d32; box-shadow: 0 0 0 2px rgba(76,175,80,0.2); }
    .srr-patch-type-selector { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #e0e0e0; }
    .srr-patch-type-label { font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px; }
    .srr-patch-type-chips { display: flex; gap: 6px; overflow-x: auto; white-space: nowrap; }
    .srr-patch-type-chip { padding: 5px 10px; border-radius: 14px; font-size: 0.75em; font-weight: 500; cursor: pointer; border: 2px solid transparent; transition: all 0.15s; flex-shrink: 0; }
    .srr-patch-type-chip.correction { background: #e3f2fd; color: #1565c0; border-color: #bbdefb; }
    .srr-patch-type-chip.correction.active { background: #1565c0; color: white; border-color: #1565c0; }
    .srr-patch-type-chip.blacklist { background: #ffebee; color: #c62828; border-color: #ffcdd2; }
    .srr-patch-type-chip.blacklist.active { background: #c62828; color: white; border-color: #c62828; }
    .srr-patch-type-chip.rfi { background: #f3e5f5; color: #7b1fa2; border-color: #e1bee7; }
    .srr-patch-type-chip.rfi.active { background: #7b1fa2; color: white; border-color: #7b1fa2; }
    .srr-override-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #fff3e0; border-radius: 6px; margin-top: 12px; }
    .srr-override-toggle { width: 40px; height: 22px; background: #ccc; border-radius: 11px; position: relative; cursor: pointer; transition: background 0.2s; }
    .srr-override-toggle.active { background: #ff9800; }
    .srr-override-toggle::after { content: ''; position: absolute; width: 18px; height: 18px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: left 0.2s; }
    .srr-override-toggle.active::after { left: 20px; }
    .srr-override-label { font-size: 0.8em; color: #e65100; font-weight: 500; }
    .srr-override-badge { display: inline-block; padding: 2px 8px; background: #ff9800; color: white; font-size: 0.7em; font-weight: 600; border-radius: 4px; text-transform: uppercase; }
    .srr-blacklist-subject { background: #ffebee; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; color: #c62828; margin-top: 8px; }
    .srr-blacklist-subject-label { font-weight: 600; margin-bottom: 4px; }
    .srr-rfi-target { margin-top: 12px; }
    .srr-rfi-target input { width: 100%; padding: 8px 10px; border: 1px solid #e1bee7; border-radius: 6px; font-size: 0.85em; }
    .srr-section-hidden { display: none !important; }
    .srr-patch-remove-btn { background: none; border: none; color: #c62828; cursor: pointer; font-size: 0.9em; padding: 4px; }
    .srr-patch-remove-btn:hover { background: #ffebee; border-radius: 4px; }
    
    /* Evidence Pack + Patch Request */
    .srr-evidence-block { margin-bottom: 16px; }
    .srr-evidence-label { font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
    .srr-evidence-alias { font-weight: 400; color: #999; }
    .srr-evidence-select { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; }
    .srr-evidence-select:focus { border-color: #1565c0; outline: none; }
    .srr-evidence-textarea { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; font-family: inherit; resize: vertical; }
    .srr-evidence-textarea:focus { border-color: #1565c0; outline: none; }
    .srr-evidence-textarea::placeholder { color: #999; }
    .srr-evidence-file-input { margin-top: 8px; display: flex; align-items: center; gap: 8px; }
    .srr-repro-required { font-size: 0.7em; color: #f57c00; font-weight: 500; margin-left: 6px; }
    .srr-patch-section { margin-top: 20px; padding-top: 16px; border-top: 1px solid #e0e0e0; }
    .srr-patch-list { background: #f9f9f9; border-radius: 6px; max-height: 150px; overflow-y: auto; margin-bottom: 12px; }
    .srr-patch-header { padding: 8px 10px; font-weight: 600; font-size: 0.85em; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; }
    .srr-patch-status { font-size: 0.75em; padding: 2px 8px; border-radius: 10px; font-weight: 500; }
    .srr-patch-status.draft { background: #fff3e0; color: #e65100; }
    .srr-patch-status.submitted { background: #e3f2fd; color: #1565c0; }
    .srr-patch-item { padding: 8px 10px; border-bottom: 1px solid #eee; font-size: 0.8em; }
    .srr-patch-item:last-child { border-bottom: none; }
    .srr-patch-path { font-family: 'Courier New', monospace; color: #7b1fa2; }
    .srr-patch-change { display: flex; gap: 8px; margin-top: 4px; }
    .srr-patch-before { color: #c62828; text-decoration: line-through; }
    .srr-patch-after { color: #2e7d32; }
    .srr-actions { display: flex; gap: 8px; margin-top: 16px; }
    .srr-btn { flex: 1; padding: 10px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; }
    .srr-btn-secondary { background: #455a64; color: white; }
    .srr-btn-secondary:hover { background: #546e7a; }
    .srr-btn-primary { background: #1565c0; color: white; }
    .srr-btn-primary:hover { background: #1976d2; }
    .srr-empty-state { color: #999; font-style: italic; text-align: center; padding: 20px; }

    /* SRR Field Cards + Groups/Filters (v1.4.1) */
    .srr-filter-bar { display: flex; gap: 8px; padding: 8px 12px; border-bottom: 1px solid #e0e0e0; flex-wrap: wrap; background: #fafafa; }
    .srr-group-select { padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.8em; background: white; cursor: pointer; }
    .srr-filter-chips { display: flex; gap: 6px; flex-wrap: wrap; }
    .srr-filter-chip { padding: 3px 10px; border-radius: 12px; font-size: 0.75em; cursor: pointer; border: 1px solid #ddd; background: white; transition: all 0.15s; }
    .srr-filter-chip.active { background: #1565c0; color: white; border-color: #1565c0; }
    .srr-filter-chip:hover { background: #e3f2fd; }
    .srr-filter-chip.active:hover { background: #1976d2; }
    .srr-field-card { border: 1px solid #e0e0e0; border-radius: 8px; margin: 8px; padding: 0; background: white; transition: all 0.25s ease-out; overflow: hidden; }
    .srr-field-card:hover { box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    .srr-field-card.active { border-color: #1565c0; box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2); }
    .srr-field-card.removing { opacity: 0; transform: translateX(-20px); margin: 0; padding: 0; height: 0; overflow: hidden; }
    .srr-field-card.edited { border-color: #ff9800; background: #fff8e1; }
    .srr-field-card-header { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; background: #f5f5f5; border-bottom: 1px solid #eee; cursor: pointer; }
    .srr-field-card.edited .srr-field-card-header { background: #fff3e0; }
    .srr-field-card-label { font-weight: 600; font-size: 0.85em; color: #333; }
    .srr-field-card-api { font-size: 0.7em; color: #888; font-family: 'Courier New', monospace; }
    .srr-field-card-chips { display: flex; gap: 4px; }
    .srr-chip { padding: 2px 6px; border-radius: 8px; font-size: 0.65em; font-weight: 600; text-transform: uppercase; }
    .srr-chip-edited { background: #ff9800; color: white; }
    .srr-chip-needs-patch { background: #e91e63; color: white; }
    .srr-chip-required { background: #9c27b0; color: white; }
    /* v1.6.15: Asterisk markers for required/invalid fields (replaces pills) */
    .srr-required-marker { color: #9c27b0; font-weight: 700; margin-left: 2px; }
    .srr-invalid-marker { color: #ff5722; font-weight: 700; margin-left: 1px; }
    /* Legend for asterisk markers */
    .srr-field-legend { font-size: 0.7em; color: #888; padding: 6px 12px; background: #fafafa; border-bottom: 1px solid #e0e0e0; display: flex; gap: 12px; }
    .srr-field-legend span { display: flex; align-items: center; gap: 3px; }
    .srr-field-legend .legend-required { color: #9c27b0; }
    .srr-field-legend .legend-invalid { color: #ff5722; }
    /* v1.6.10: Dropdown field styling */
    .srr-field-value-display.is-dropdown { cursor: pointer; }
    .srr-field-value-display .dropdown-indicator { color: #666; font-size: 0.7em; margin-left: 4px; }
    .srr-field-card.has-invalid-value { border-left: 3px solid #ff5722; }
    .srr-field-card.is-picklist .srr-field-value-display:hover { background: rgba(2, 136, 209, 0.1); }
    .srr-field-value-select { 
      width: 100%; 
      padding: 6px 8px; 
      border: 1px solid #0288d1; 
      border-radius: 4px; 
      font-size: 0.9em; 
      background: white;
      outline: none;
    }
    .srr-field-value-select:focus { border-color: #01579b; box-shadow: 0 0 0 2px rgba(2, 136, 209, 0.2); }
    .srr-field-card-body { padding: 10px; }
    .srr-field-value-display { font-size: 0.85em; color: #333; word-break: break-word; padding: 6px 8px; background: #fafafa; border-radius: 4px; min-height: 24px; cursor: text; }
    .srr-field-value-display:hover { background: #f0f0f0; }
    .srr-field-card.edited .srr-field-value-display { background: #fff8e1; }
    .srr-field-value-input { width: 100%; padding: 6px 8px; border: 1px solid #1565c0; border-radius: 4px; font-size: 0.85em; font-family: inherit; box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2); }
    .srr-mini-patch { margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 6px; border: 1px solid #bbdefb; }
    .srr-mini-patch-label { font-size: 0.75em; font-weight: 600; color: #1565c0; margin-bottom: 6px; }
    .srr-mini-patch-input { width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.8em; margin-bottom: 6px; }
    .srr-mini-patch-actions { display: flex; gap: 6px; }
    .srr-mini-patch-btn { flex: 1; padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.75em; font-weight: 500; }
    .srr-mini-patch-btn.save { background: #1565c0; color: white; }
    .srr-mini-patch-btn.save:hover { background: #1976d2; }
    .srr-mini-patch-btn.undo { background: #f44336; color: white; }
    .srr-mini-patch-btn.undo:hover { background: #e53935; }
    .srr-patch-type { padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.75em; background: white; cursor: pointer; }
    .srr-proposed-change { padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; margin-bottom: 8px; background: #fafafa; }
    .srr-proposed-change-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .srr-proposed-change-field { font-weight: 600; font-size: 0.85em; color: #333; }
    .srr-proposed-change-values { font-size: 0.8em; display: flex; gap: 8px; flex-wrap: wrap; }
    .srr-proposed-change-from { color: #c62828; text-decoration: line-through; }
    .srr-proposed-change-to { color: #2e7d32; font-weight: 500; }

    /* Unsaved Changes Modal */
    .srr-guard-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .srr-guard-modal.active, .srr-guard-modal.visible { display: flex; }
    .srr-guard-dialog { background: white; border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.2); }
    .srr-guard-title { font-size: 1.1em; font-weight: 600; color: #333; margin-bottom: 12px; }
    .srr-guard-message { font-size: 0.9em; color: #666; line-height: 1.5; margin-bottom: 20px; }
    .srr-guard-actions { display: flex; gap: 8px; justify-content: flex-end; }
    .srr-guard-btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; }
    .srr-guard-btn.cancel { background: #e0e0e0; color: #333; }
    .srr-guard-btn.discard { background: #f44336; color: white; }
    .srr-guard-btn.save { background: #1565c0; color: white; }

    /* Verifier Review Styles (v1.4.5) */
    .vr-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 20px; }
    .vr-section { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; }
    .vr-section-header { font-weight: 600; font-size: 0.95em; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    .vr-section-header .icon { font-size: 1.1em; }
    .vr-intent-block { background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 8px; }
    .vr-intent-label { font-size: 0.75em; color: #666; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .vr-intent-value { font-size: 0.9em; color: #333; }
    .vr-evidence-block { background: #fafafa; padding: 10px 12px; border-left: 3px solid #1565c0; margin-bottom: 8px; }
    .vr-evidence-label { font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600; }
    .vr-evidence-text { font-size: 0.85em; color: #333; margin-top: 4px; white-space: pre-wrap; }
    .vr-preflight-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .vr-preflight-badge.pass { background: #e8f5e9; color: #2e7d32; }
    .vr-preflight-badge.warn { background: #fff3e0; color: #e65100; }
    .vr-preflight-badge.fail { background: #ffebee; color: #c62828; }
    .vr-revision-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; font-size: 0.85em; }
    .vr-revision-item:last-child { border-bottom: none; }
    .vr-author-info { display: flex; flex-direction: column; gap: 4px; font-size: 0.85em; }
    .vr-author-label { color: #666; }
    .vr-author-value { font-weight: 500; color: #333; }
    .vr-notes-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; resize: vertical; }
    .vr-actions-panel { background: #f5f5f5; padding: 16px; border-radius: 8px; margin-top: 16px; }
    .vr-actions-header { font-weight: 600; font-size: 0.9em; margin-bottom: 12px; color: #333; }
    .vr-actions-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
    .vr-action-btn { padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: all 0.15s; }
    .vr-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .vr-action-btn.begin { background: #1565c0; color: white; }
    .vr-action-btn.begin:hover:not(:disabled) { background: #1976d2; }
    .vr-action-btn.clarify { background: #ff9800; color: white; }
    .vr-action-btn.clarify:hover:not(:disabled) { background: #ffa726; }
    .vr-action-btn.approve { background: #2e7d32; color: white; }
    .vr-action-btn.approve:hover:not(:disabled) { background: #388e3c; }
    .vr-action-btn.reject { background: #c62828; color: white; }
    .vr-action-btn.reject:hover:not(:disabled) { background: #d32f2f; }
    .vr-state-badge { display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .vr-state-badge.submitted { background: #e3f2fd; color: #1565c0; }
    .vr-state-badge.under-review { background: #fff3e0; color: #e65100; }
    .vr-state-badge.needs-clarification { background: #fce4ec; color: #c2185b; }
    .vr-state-badge.approved { background: #e8f5e9; color: #2e7d32; }
    .vr-state-badge.rejected { background: #ffebee; color: #c62828; }
    .vr-decision-summary { background: #e8f5e9; border: 1px solid #c8e6c9; padding: 12px; border-radius: 6px; margin-top: 12px; }
    .vr-decision-summary.rejected { background: #ffebee; border-color: #ffcdd2; }
    .vr-empty-state { color: #666; font-style: italic; padding: 20px; text-align: center; background: #f9f9f9; border-radius: 6px; }
    .vr-full-width { grid-column: span 2; }
    .vr-clarify-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .vr-clarify-modal.active { display: flex; }
    .vr-clarify-modal-content { background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; }
    .vr-clarify-modal h4 { margin: 0 0 12px 0; }
    .vr-clarify-modal textarea { width: 100%; min-height: 100px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 12px; }
    .vr-clarify-modal-actions { display: flex; gap: 10px; justify-content: flex-end; }

    /* Admin Approval Styles (v1.4.5) */
    .aa-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 20px; }
    .aa-section { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; }
    .aa-section-header { font-weight: 600; font-size: 0.95em; color: #333; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    .aa-section-header .icon { font-size: 1.1em; }
    .aa-intent-block { background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 8px; }
    .aa-intent-label { font-size: 0.75em; color: #666; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .aa-intent-value { font-size: 0.9em; color: #333; }
    .aa-evidence-block { background: #fafafa; padding: 10px 12px; border-left: 3px solid #7b1fa2; margin-bottom: 8px; }
    .aa-evidence-label { font-size: 0.7em; color: #666; text-transform: uppercase; font-weight: 600; }
    .aa-evidence-text { font-size: 0.85em; color: #333; margin-top: 4px; white-space: pre-wrap; }
    .aa-preflight-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .aa-preflight-badge.pass { background: #e8f5e9; color: #2e7d32; }
    .aa-preflight-badge.warn { background: #fff3e0; color: #e65100; }
    .aa-preflight-badge.fail { background: #ffebee; color: #c62828; }
    .aa-verifier-decision { background: #e8f5e9; border: 1px solid #c8e6c9; padding: 12px; border-radius: 6px; }
    .aa-verifier-decision-header { font-weight: 600; color: #2e7d32; margin-bottom: 8px; }
    .aa-smoke-status { display: flex; align-items: center; gap: 8px; padding: 12px; border-radius: 6px; }
    .aa-smoke-status.pass { background: #e8f5e9; border: 1px solid #c8e6c9; }
    .aa-smoke-status.fail { background: #ffebee; border: 1px solid #ffcdd2; }
    .aa-smoke-icon { font-size: 1.5em; }
    .aa-smoke-label { font-weight: 600; }
    /* Patch Replay Styles (v1.4.17) */
    .aa-replay-status { display: flex; align-items: center; gap: 8px; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
    .aa-replay-status.not-run { background: #f5f5f5; border: 1px solid #e0e0e0; color: #666; }
    .aa-replay-status.pass { background: #e8f5e9; border: 1px solid #c8e6c9; color: #2e7d32; }
    .aa-replay-status.fail { background: #ffebee; border: 1px solid #ffcdd2; color: #c62828; }
    .aa-replay-badge { font-weight: 600; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; text-transform: uppercase; }
    .aa-replay-badge.not-run { background: #e0e0e0; color: #666; }
    .aa-replay-badge.pass { background: #4caf50; color: white; }
    .aa-replay-badge.fail { background: #f44336; color: white; }
    .aa-replay-packet { margin-top: 12px; }
    .aa-replay-check { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #fafafa; border-left: 3px solid #e0e0e0; margin-bottom: 4px; font-size: 0.85em; }
    .aa-replay-check.pass { border-left-color: #4caf50; }
    .aa-replay-check.fail { border-left-color: #f44336; }
    .aa-replay-check-icon { font-size: 1.1em; }
    .aa-replay-check-label { flex: 1; }
    .aa-replay-failure-reason { background: #fff8e1; border: 1px solid #ffcc80; padding: 12px; border-radius: 6px; margin-top: 12px; font-size: 0.85em; }
    .aa-replay-failure-reason-header { font-weight: 600; color: #e65100; margin-bottom: 6px; }
    .aa-replay-btn { background: #1976d2; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.85em; font-weight: 500; }
    .aa-replay-btn:hover { background: #1565c0; }
    .aa-replay-btn:disabled { background: #90caf9; cursor: not-allowed; }
    .aa-changelog-preview { background: #263238; color: #eceff1; padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; }
    .aa-actions-panel { background: #f3e5f5; padding: 16px; border-radius: 8px; margin-top: 16px; border: 1px solid #ce93d8; }
    .aa-actions-header { font-weight: 600; font-size: 0.9em; margin-bottom: 12px; color: #6a1b9a; }
    .aa-actions-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
    .aa-action-btn { padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: all 0.15s; }
    .aa-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .aa-action-btn.approve { background: #6a1b9a; color: white; }
    .aa-action-btn.approve:hover:not(:disabled) { background: #7b1fa2; }
    .aa-action-btn.hold { background: #ff9800; color: white; }
    .aa-action-btn.hold:hover:not(:disabled) { background: #ffa726; }
    .aa-action-btn.release { background: #1565c0; color: white; }
    .aa-action-btn.release:hover:not(:disabled) { background: #1976d2; }
    .aa-action-btn.promote { background: #2e7d32; color: white; grid-column: span 2; }
    .aa-action-btn.promote:hover:not(:disabled) { background: #388e3c; }
    .aa-state-badge { display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
    .aa-state-badge.verifier-approved { background: #e8f5e9; color: #2e7d32; }
    .aa-state-badge.admin-hold { background: #fff3e0; color: #e65100; }
    .aa-state-badge.admin-approved { background: #f3e5f5; color: #6a1b9a; }
    .aa-state-badge.promoted { background: #e3f2fd; color: #1565c0; }
    .aa-decision-summary { background: #f3e5f5; border: 1px solid #ce93d8; padding: 12px; border-radius: 6px; margin-top: 12px; }
    .aa-full-width { grid-column: span 2; }
    .aa-notes-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.85em; resize: vertical; }
    .aa-hold-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .aa-hold-modal.active { display: flex; }
    .aa-hold-modal-content { background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; }
    .aa-hold-modal h4 { margin: 0 0 12px 0; }
    .aa-hold-modal textarea { width: 100%; min-height: 100px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 12px; }
    .aa-hold-modal-actions { display: flex; gap: 10px; justify-content: flex-end; }

    /* Folder Selection Modal (v1.4.23) */
    .folder-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .folder-modal-overlay.active { display: flex; }
    .folder-modal { background: white; border-radius: 12px; width: 90%; max-width: 450px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); animation: folderModalSlide 0.2s ease; }
    @keyframes folderModalSlide { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    .folder-modal-header { padding: 20px 24px; border-bottom: 1px solid #e0e0e0; }
    .folder-modal-header h3 { margin: 0 0 6px 0; font-size: 1.1em; color: #1a1a2e; }
    .folder-modal-header p { margin: 0; font-size: 0.85em; color: #666; }
    .folder-modal-body { padding: 24px; }
    .folder-select-wrapper { margin-bottom: 16px; }
    .folder-select-label { font-size: 0.8em; color: #666; margin-bottom: 6px; font-weight: 500; }
    .folder-select { width: 100%; padding: 12px 14px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.95em; cursor: pointer; background: white; }
    .folder-select:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 0 3px rgba(25,118,210,0.1); }
    .folder-modal-footer { padding: 16px 24px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 10px; }
    .folder-modal-btn { padding: 10px 20px; border-radius: 6px; font-size: 0.9em; font-weight: 500; cursor: pointer; transition: all 0.15s; }
    .folder-modal-btn.primary { background: #1976d2; color: white; border: none; }
    .folder-modal-btn.primary:hover { background: #1565c0; }
    .folder-modal-btn.primary:disabled { background: #90caf9; cursor: not-allowed; }
    .folder-connected-card { background: #e8f5e9; border: 1px solid #81c784; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
    .folder-connected-icon { font-size: 1.5em; margin-bottom: 8px; }
    .folder-connected-label { font-size: 0.75em; color: #2e7d32; text-transform: uppercase; font-weight: 600; margin-bottom: 4px; }
    .folder-connected-name { font-size: 1em; color: #1b5e20; font-weight: 600; }
    .folder-sync-time { font-size: 0.8em; color: #558b2f; margin-top: 6px; }

    /* Grid Table Styles */
    .grid-table { min-width: 800px; }
    .grid-table th, .grid-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #e0e0e0; white-space: nowrap; }
    .grid-table th { font-weight: 600; color: #333; background: #f5f5f5; border-bottom: 2px solid #ddd; }
    .grid-table tr:hover { background: #f8f9fa; }
    .grid-table tr.clickable { cursor: pointer; }
    .grid-table td.status-ready { color: #2e7d32; }
    .grid-table td.status-needs_review { color: #f57c00; }
    .grid-table td.status-blocked { color: #c62828; }
    .grid-table td.status-finalized { color: #1565c0; }
    .grid-table td.status-flagged { color: #7b1fa2; }
    .grid-table td.truncated { max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
    .grid-table .row-index { color: #999; font-size: 0.8em; }
    /* v1.6.2: Row badges for signal counts */
    .row-badges { display: inline-flex; gap: 3px; margin-left: 6px; }
    .row-badge { 
      display: inline-flex; align-items: center; justify-content: center;
      min-width: 16px; height: 16px; padding: 0 4px;
      border-radius: 8px; font-size: 0.7em; font-weight: 600;
    }
    .badge-patch { background: #e3f2fd; color: #1565c0; }
    .badge-sflogic { background: #fff3e0; color: #e65100; }
    .badge-manual { background: #fffde7; color: #f57f17; }
    .badge-system { background: #f5f5f5; color: #616161; }
    .badge-blacklist { background: #ffebee; color: #c62828; }
    /* v1.6.6: Patch tooltip styles */
    .row-badge { position: relative; cursor: pointer; }
    .patch-tooltip { 
      display: none; position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
      background: #1a1a2e; color: white; padding: 10px 12px; border-radius: 6px;
      font-size: 0.8em; white-space: nowrap; z-index: 1000; min-width: 180px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); margin-top: 6px;
    }
    .patch-tooltip::before {
      content: ''; position: absolute; top: -6px; left: 50%; transform: translateX(-50%);
      border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 6px solid #1a1a2e;
    }
    .row-badge:hover .patch-tooltip { display: block; }
    .patch-tooltip-title { font-weight: 600; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #333; }
    .patch-tooltip-item { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
    .patch-tooltip-field { flex: 1; font-family: 'Courier New', monospace; font-size: 0.9em; }
    .patch-chip { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; font-weight: 500; }
    .patch-chip-correction { background: #1565c0; color: white; }
    .patch-chip-rfi { background: #e65100; color: white; }
    .patch-chip-blacklist { background: #c62828; color: white; }
    .patch-chip-system { background: #616161; color: white; }
    .patch-chip-legacy { background: #78909c; color: white; }
    /* v1.6.6: Field Inspector patch highlight */
    .srr-field-card.has-patch { border-left: 3px solid #1565c0; background: #f8fbff; }
    .srr-field-card.has-patch.patch-rfi { border-left-color: #e65100; background: #fff8f5; }
    .srr-field-card.has-patch.patch-blacklist { border-left-color: #c62828; background: #fff5f5; }
    .srr-field-card.has-patch.patch-system { border-left-color: #616161; background: #fafafa; }
    .field-patch-indicator { display: inline-flex; gap: 4px; margin-left: 8px; }
    .field-patch-chip { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; font-weight: 500; }
    .field-patch-chip.correction { background: #e3f2fd; color: #1565c0; }
    .field-patch-chip.rfi { background: #fff3e0; color: #e65100; }
    .field-patch-chip.blacklist { background: #ffebee; color: #c62828; }
    .field-patch-chip.system_change { background: #f5f5f5; color: #616161; }
    .field-patch-chip.legacy { background: #eceff1; color: #546e7a; font-style: italic; }
    .filter-select { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; min-width: 150px; }

    .drawer-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); display: none; z-index: 900; }
    .drawer-overlay.active { display: block; }
    .drawer { position: fixed; top: 0; right: -550px; width: 550px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 901; transition: right 0.3s ease; display: flex; flex-direction: column; }
    .drawer.active { right: 0; }
    .drawer-header { background: #1a1a2e; color: white; padding: 15px 20px; flex-shrink: 0; }
    .drawer-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .drawer-header h3 { margin: 0; font-size: 1em; }
    .drawer-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .drawer-identity { display: flex; align-items: center; gap: 10px; }
    .identity-pill { background: #0f3460; padding: 6px 12px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.75em; word-break: break-all; flex-grow: 1; }
    .identity-copy { background: #1565c0; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75em; white-space: nowrap; }
    .identity-copy:hover { background: #1976d2; }
    .drawer-tabs { display: flex; background: #263238; flex-shrink: 0; }
    .drawer-tab { flex: 1; padding: 12px 8px; text-align: center; color: #90a4ae; background: none; border: none; cursor: pointer; font-size: 0.85em; border-bottom: 3px solid transparent; transition: all 0.2s; }
    .drawer-tab:hover { color: white; background: #37474f; }
    .drawer-tab.active { color: white; border-bottom-color: #1565c0; background: #37474f; }
    .drawer-tab-count { display: inline-block; background: #455a64; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.75em; margin-left: 4px; }
    .drawer-body { padding: 15px; overflow-y: auto; flex-grow: 1; }
    .drawer-json { background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; word-break: break-all; max-height: 100%; overflow-y: auto; }
    .drawer-table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    .drawer-table th, .drawer-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    .drawer-table th { background: #f5f5f5; font-weight: 600; color: #333; }
    .drawer-table tr:hover { background: #f9f9f9; }
    .drawer-empty { color: #666; font-style: italic; padding: 20px; text-align: center; background: #f9f9f9; border-radius: 6px; }
    .drawer-actions { padding: 15px 20px; border-top: 1px solid #eee; flex-shrink: 0; }
    .drawer-btn { padding: 10px 14px; background: #1565c0; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; }
    .drawer-btn:hover { background: #1976d2; }
    .drawer-actions-grid { display: flex; flex-wrap: wrap; gap: 8px; }
    .drawer-btn-secondary { background: #455a64; }
    .drawer-btn-secondary:hover { background: #546e7a; }
    .drawer-warning { background: #fff3e0; color: #e65100; padding: 10px 15px; font-size: 0.85em; border-bottom: 1px solid #ffe0b2; }
    .identity-primary { color: #4caf50; font-weight: bold; }
    .identity-fallback { color: #90a4ae; }

    .selection-controls { display: flex; gap: 8px; margin-bottom: 10px; align-items: center; }
    .selection-btn { padding: 4px 10px; font-size: 0.75em; border: 1px solid #ddd; background: #f5f5f5; border-radius: 4px; cursor: pointer; }
    .selection-btn:hover { background: #e0e0e0; }
    .selection-count { font-size: 0.8em; color: #666; margin-left: auto; }
    .drawer-table input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
    .drawer-table th:first-child, .drawer-table td:first-child { width: 30px; text-align: center; }

    .patch-studio { position: fixed; top: 0; right: -450px; width: 450px; height: 100vh; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 902; transition: right 0.3s ease; display: flex; flex-direction: column; }
    .patch-studio.active { right: 0; }
    .patch-studio-header { background: #2e7d32; color: white; padding: 15px 20px; flex-shrink: 0; }
    .patch-studio-header h3 { margin: 0 0 5px 0; font-size: 1em; }
    .patch-studio-header-row { display: flex; justify-content: space-between; align-items: center; }
    .patch-studio-close { background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; line-height: 1; }
    .patch-studio-body { padding: 15px; overflow-y: auto; flex-grow: 1; }
    .patch-field { margin-bottom: 15px; }
    .patch-field label { display: block; font-size: 0.8em; color: #666; margin-bottom: 4px; font-weight: 600; text-transform: uppercase; }
    .patch-field input, .patch-field textarea { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; font-family: inherit; }
    .patch-field textarea { min-height: 60px; resize: vertical; }
    .patch-changes-header { display: flex; justify-content: space-between; align-items: center; margin: 15px 0 10px; }
    .patch-changes-header h4 { margin: 0; font-size: 0.9em; color: #333; }
    .patch-changes-list { background: #f9f9f9; border-radius: 6px; max-height: 250px; overflow-y: auto; }
    .patch-change-item { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid #eee; font-size: 0.85em; }
    .patch-change-item:last-child { border-bottom: none; }
    .patch-change-info { flex-grow: 1; }
    .patch-change-remove { background: none; border: none; color: #c62828; cursor: pointer; font-size: 1.1em; padding: 4px 8px; }
    .patch-change-remove:hover { background: #ffebee; border-radius: 4px; }
    .patch-studio-actions { padding: 15px 20px; border-top: 1px solid #eee; flex-shrink: 0; display: flex; flex-direction: column; gap: 8px; }
    .patch-studio-btn { padding: 10px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; }
    .patch-studio-btn-primary { background: #2e7d32; color: white; }
    .patch-studio-btn-primary:hover { background: #388e3c; }
    .patch-studio-btn-secondary { background: #455a64; color: white; }
    .patch-studio-btn-secondary:hover { background: #546e7a; }
    .patch-empty { color: #666; font-style: italic; padding: 20px; text-align: center; }
    .evidence-section { margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee; }
    .evidence-section h4 { margin: 0 0 10px 0; font-size: 0.85em; color: #666; text-transform: uppercase; }
    .evidence-btns { display: flex; flex-wrap: wrap; gap: 6px; }
    .evidence-btn { padding: 6px 10px; font-size: 0.75em; background: #e0e0e0; border: none; border-radius: 4px; cursor: pointer; }
    .evidence-btn:hover { background: #bdbdbd; }

    .patch-studio-tabs { display: flex; background: #1b5e20; flex-shrink: 0; }
    .patch-studio-tab { flex: 1; padding: 10px 8px; text-align: center; color: rgba(255,255,255,0.7); background: none; border: none; cursor: pointer; font-size: 0.85em; border-bottom: 3px solid transparent; transition: all 0.2s; }
    .patch-studio-tab:hover { color: white; background: rgba(255,255,255,0.1); }
    .patch-studio-tab.active { color: white; border-bottom-color: #81c784; background: rgba(255,255,255,0.1); }
    .patch-studio-panel { display: none; }
    .patch-studio-panel.active { display: block; }

    .preflight-checklist { margin-bottom: 15px; }
    .preflight-step { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; margin-bottom: 8px; }
    .preflight-step-num { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.75em; font-weight: bold; flex-shrink: 0; }
    .preflight-step-num.pending { background: #e0e0e0; color: #666; }
    .preflight-step-num.pass { background: #c8e6c9; color: #2e7d32; }
    .preflight-step-num.warn { background: #fff3e0; color: #e65100; }
    .preflight-step-num.fail { background: #ffcdd2; color: #c62828; }
    .preflight-step-info { flex-grow: 1; }
    .preflight-step-title { font-weight: 600; font-size: 0.9em; }
    .preflight-step-status { font-size: 0.75em; color: #666; }
    .preflight-step-chip { padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; text-transform: uppercase; }
    .preflight-step-chip.pending { background: #e0e0e0; color: #666; }
    .preflight-step-chip.pass { background: #c8e6c9; color: #2e7d32; }
    .preflight-step-chip.warn { background: #fff3e0; color: #e65100; }
    .preflight-step-chip.fail { background: #ffcdd2; color: #c62828; }

    .preflight-input-group { margin-bottom: 15px; }
    .preflight-input-group label { display: block; font-size: 0.8em; color: #666; margin-bottom: 4px; font-weight: 600; }
    .preflight-input-group textarea { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; font-family: 'Courier New', monospace; min-height: 80px; resize: vertical; }
    .preflight-input-group input { width: 100%; padding: 8px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; }
    .preflight-input-actions { display: flex; gap: 6px; margin-top: 6px; }
    .preflight-parse-btn { padding: 4px 10px; font-size: 0.75em; background: #1565c0; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .preflight-parse-btn:hover { background: #1976d2; }
    .preflight-clear-btn { padding: 4px 10px; font-size: 0.75em; background: #e0e0e0; border: none; border-radius: 4px; cursor: pointer; }
    .preflight-clear-btn:hover { background: #bdbdbd; }

    .preflight-result { background: #f5f5f5; border-radius: 6px; padding: 10px 12px; margin-top: 8px; font-size: 0.85em; }
    .preflight-result.pass { background: #e8f5e9; border-left: 3px solid #2e7d32; }
    .preflight-result.warn { background: #fff8e1; border-left: 3px solid #f57c00; }
    .preflight-result.fail { background: #ffebee; border-left: 3px solid #c62828; }
    .preflight-result-row { display: flex; justify-content: space-between; padding: 3px 0; }
    .preflight-result-key { color: #666; }
    .preflight-result-val { font-weight: 500; font-family: 'Courier New', monospace; }

    .preflight-conflicts-table { width: 100%; border-collapse: collapse; font-size: 0.8em; margin-top: 10px; }
    .preflight-conflicts-table th, .preflight-conflicts-table td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #eee; }
    .preflight-conflicts-table th { background: #f5f5f5; font-weight: 600; }

    .preflight-section-title { font-size: 0.85em; font-weight: 600; color: #333; margin: 15px 0 8px; padding-bottom: 4px; border-bottom: 1px solid #eee; }
    .preflight-reset-row { display: flex; gap: 8px; margin-top: 15px; }
    .preflight-reset-btn { padding: 8px 14px; font-size: 0.85em; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .preflight-reset-btn:hover { background: #d32f2f; }

    .session-loader { background: #e8eaf6; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .session-loader-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .session-loader-header h3 { margin: 0; font-size: 0.95em; color: #3f51b5; }
    .session-loader-toggle { padding: 6px 12px; font-size: 0.8em; background: #3f51b5; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .session-loader-toggle:hover { background: #5c6bc0; }
    .session-loader-body { display: none; }
    .session-loader-body.active { display: block; }
    .session-loader-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
    .session-loader-field { flex: 1; min-width: 200px; }
    .session-loader-field label { display: block; font-size: 0.75em; color: #666; margin-bottom: 4px; font-weight: 600; text-transform: uppercase; }
    .session-loader-field input { width: 100%; padding: 8px 10px; border: 1px solid #c5cae9; border-radius: 4px; font-size: 0.85em; font-family: 'Courier New', monospace; }
    .session-loader-actions { display: flex; gap: 8px; }
    .session-loader-btn { padding: 8px 14px; font-size: 0.85em; border: none; border-radius: 4px; cursor: pointer; }
    .session-loader-btn-primary { background: #3f51b5; color: white; }
    .session-loader-btn-primary:hover { background: #5c6bc0; }
    .session-loader-btn-secondary { background: #e0e0e0; color: #333; }
    .session-loader-btn-secondary:hover { background: #bdbdbd; }
    .session-loader-status { margin-top: 10px; font-size: 0.85em; padding: 8px 12px; border-radius: 4px; }
    .session-loader-status.success { background: #e8f5e9; color: #2e7d32; }
    .session-loader-status.error { background: #ffebee; color: #c62828; }
    .session-loader-status.info { background: #e3f2fd; color: #1565c0; }

    .delta-summary { display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
    .delta-card { background: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; min-width: 90px; border-left: 4px solid #9e9e9e; }
    .delta-card.positive { border-left-color: #4caf50; }
    .delta-card.negative { border-left-color: #f44336; }
    .delta-card.neutral { border-left-color: #9e9e9e; }
    .delta-card .delta-value { font-size: 1.5em; font-weight: bold; }
    .delta-card .delta-value.positive { color: #4caf50; }
    .delta-card .delta-value.negative { color: #f44336; }
    .delta-card .delta-value.neutral { color: #9e9e9e; }
    .delta-card .delta-label { font-size: 0.75em; color: #666; text-transform: uppercase; }
    .delta-card .delta-detail { font-size: 0.7em; color: #999; margin-top: 2px; }

    .row-added { background: #e8f5e9 !important; }
    .row-added td:first-child::before { content: '+'; color: #4caf50; font-weight: bold; margin-right: 4px; }
    .row-removed { background: #ffebee !important; text-decoration: line-through; opacity: 0.7; }
    .row-removed td:first-child::before { content: '-'; color: #f44336; font-weight: bold; margin-right: 4px; }
    .row-changed { background: #fff3e0 !important; }
    .row-changed td:first-child::before { content: '~'; color: #ff9800; font-weight: bold; margin-right: 4px; }

    .compare-legend { display: flex; gap: 15px; margin-bottom: 10px; font-size: 0.8em; }
    .compare-legend-item { display: flex; align-items: center; gap: 4px; }
    .compare-legend-dot { width: 12px; height: 12px; border-radius: 2px; }
    .compare-legend-dot.added { background: #4caf50; }
    .compare-legend-dot.changed { background: #ff9800; }
    .compare-legend-dot.removed { background: #f44336; }

    .compare-actions { display: flex; gap: 10px; margin-bottom: 15px; }
    .compare-btn { padding: 8px 14px; font-size: 0.85em; background: #7c4dff; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .compare-btn:hover { background: #651fff; }

    .config-inspector { background: #fce4ec; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .config-inspector-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .config-inspector-header h3 { margin: 0; font-size: 0.95em; color: #880e4f; }
    .config-inspector-toggle { padding: 6px 12px; font-size: 0.8em; background: #880e4f; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .config-inspector-toggle:hover { background: #ad1457; }
    .config-inspector-body { display: none; }
    .config-inspector-body.active { display: block; }
    .config-inspector-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
    .config-inspector-field { flex: 1; min-width: 200px; }
    .config-inspector-field label { display: block; font-size: 0.75em; color: #666; margin-bottom: 4px; font-weight: 600; text-transform: uppercase; }
    .config-inspector-field input { width: 100%; padding: 8px 10px; border: 1px solid #f8bbd9; border-radius: 4px; font-size: 0.85em; font-family: 'Courier New', monospace; }
    .config-inspector-actions { display: flex; gap: 8px; }
    .config-inspector-btn { padding: 8px 14px; font-size: 0.85em; border: none; border-radius: 4px; cursor: pointer; }
    .config-inspector-btn-primary { background: #880e4f; color: white; }
    .config-inspector-btn-primary:hover { background: #ad1457; }
    .config-inspector-btn-secondary { background: #e0e0e0; color: #333; }
    .config-inspector-btn-secondary:hover { background: #bdbdbd; }
    .config-inspector-status { margin-top: 10px; font-size: 0.85em; padding: 8px 12px; border-radius: 4px; }
    .config-inspector-status.success { background: #e8f5e9; color: #2e7d32; }
    .config-inspector-status.error { background: #ffebee; color: #c62828; }
    .config-inspector-status.info { background: #e3f2fd; color: #1565c0; }

    .patch-summary { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .patch-summary-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .patch-summary-header h4 { margin: 0; font-size: 0.95em; color: #333; }
    .patch-summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }
    .patch-summary-item { }
    .patch-summary-item label { display: block; font-size: 0.7em; color: #666; text-transform: uppercase; margin-bottom: 2px; }
    .patch-summary-item .value { font-family: 'Courier New', monospace; font-size: 0.9em; }
    .version-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
    .version-chip.match { background: #c8e6c9; color: #2e7d32; }
    .version-chip.mismatch { background: #ffcdd2; color: #c62828; }

    .ruleset-delta { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .ruleset-delta h4 { margin: 0 0 10px 0; font-size: 0.95em; color: #333; }
    .ruleset-delta-counts { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 10px; }
    .ruleset-count-card { background: #f5f5f5; padding: 8px 12px; border-radius: 6px; text-align: center; min-width: 80px; }
    .ruleset-count-card .count { font-size: 1.3em; font-weight: bold; }
    .ruleset-count-card .count.added { color: #4caf50; }
    .ruleset-count-card .count.deprecated { color: #f44336; }
    .ruleset-count-card .label { font-size: 0.7em; color: #666; text-transform: uppercase; }

    .changes-table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    .changes-table th, .changes-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    .changes-table th { background: #880e4f; color: white; font-weight: 600; }
    .changes-table tr:hover { background: #fce4ec; }
    .action-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
    .action-chip.add_rule { background: #c8e6c9; color: #2e7d32; }
    .action-chip.deprecate_rule { background: #ffcdd2; color: #c62828; }

    .config-inspector-copy-actions { display: flex; gap: 10px; margin-top: 15px; }
    .config-copy-btn { padding: 8px 14px; font-size: 0.85em; background: #880e4f; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .config-copy-btn:hover { background: #ad1457; }

    .stream-panel { background: #e0f2f1; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .stream-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .stream-panel-header h3 { margin: 0; font-size: 0.95em; color: #00695c; }
    .stream-panel-toggle { padding: 6px 12px; font-size: 0.8em; background: #00695c; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .stream-panel-toggle:hover { background: #00897b; }
    .stream-panel-body { display: none; }
    .stream-panel-body.active { display: block; }

    .stream-concept { background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .stream-concept h4 { margin: 0 0 10px 0; font-size: 0.95em; color: #00695c; }
    .stream-concept p { font-size: 0.85em; color: #555; line-height: 1.5; margin-bottom: 10px; }

    .session-timeline { display: flex; gap: 15px; overflow-x: auto; padding: 10px 0; }
    .session-card { background: white; border-radius: 8px; padding: 12px; min-width: 180px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-left: 4px solid #00695c; }
    .session-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .session-card-title { font-weight: 600; font-size: 0.9em; color: #333; }
    .session-card-idx { font-size: 0.75em; color: #666; background: #e0e0e0; padding: 2px 6px; border-radius: 10px; }
    .session-card-stats { font-size: 0.8em; color: #666; }
    .session-card-stats div { display: flex; justify-content: space-between; padding: 2px 0; }

    .state-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.7em; font-weight: 600; text-transform: uppercase; }
    .state-chip.consolidated { background: #c8e6c9; color: #2e7d32; }
    .state-chip.partial { background: #fff3e0; color: #e65100; }
    .state-chip.waiting { background: #e3f2fd; color: #1565c0; }
    .state-chip.blocked { background: #ffcdd2; color: #c62828; }
    
    /* Queue Tab Styles */
    .queue-tab { padding: 8px 14px; border: 1px solid #ddd; border-radius: 20px; background: #f5f5f5; cursor: pointer; font-size: 0.85em; transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px; }
    .queue-tab:hover { background: #e0e0e0; }
    .queue-tab.active { background: #1976d2; color: white; border-color: #1976d2; }
    .queue-tab .queue-count { background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 10px; font-size: 0.85em; min-width: 20px; text-align: center; }
    .queue-tab.active .queue-count { background: rgba(255,255,255,0.2); }
    
    /* Patch Console Table Styles */
    #patch-console-table tr:hover { background: #f5f5f5; }
    #patch-console-table td { padding: 8px; border-bottom: 1px solid #eee; }
    .patch-status-chip { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
    .patch-status-chip.draft { background: #e3f2fd; color: #1565c0; }
    .patch-status-chip.submitted { background: #fff3e0; color: #e65100; }
    .patch-status-chip.approved { background: #e8f5e9; color: #2e7d32; }
    .patch-status-chip.sent { background: #ede7f6; color: #5e35b1; }
    .patch-status-chip.returned { background: #fce4ec; color: #c2185b; }
    .patch-status-chip.applied { background: #c8e6c9; color: #1b5e20; }
    .patch-status-chip.rejected { background: #ffcdd2; color: #b71c1c; }
    
    /* Masterline / Artifact Registry Styles */
    .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 22px; transition: 0.3s; }
    .toggle-slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.3s; }
    .toggle-switch input:checked + .toggle-slider { background-color: #4caf50; }
    .toggle-switch input:checked + .toggle-slider:before { transform: translateX(18px); }
    
    .masterline-status { font-size: 0.75em; font-weight: 600; padding: 2px 8px; border-radius: 10px; }
    .masterline-status.on { background: #c8e6c9; color: #2e7d32; }
    .masterline-status.off { background: #e0e0e0; color: #666; }
    
    .artifact-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    .artifact-table th { text-align: left; padding: 10px 12px; background: #f5f5f5; border-bottom: 2px solid #ddd; font-weight: 600; color: #333; }
    .artifact-table td { padding: 10px 12px; border-bottom: 1px solid #eee; vertical-align: middle; }
    .artifact-table tr:hover { background: #fafafa; }
    
    .artifact-status { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 0.8em; font-weight: 600; }
    .artifact-status.status-loaded { background: #c8e6c9; color: #2e7d32; }
    .artifact-status.status-missing { background: #ffcdd2; color: #c62828; }
    .artifact-status.status-unknown { background: #e0e0e0; color: #666; }
    
    .rebound-badge { font-size: 0.7em; background: #e3f2fd; color: #1565c0; padding: 2px 6px; border-radius: 8px; margin-left: 6px; }
    
    .artifact-path { font-family: monospace; font-size: 0.85em; color: #666; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    
    .rebind-btn { padding: 4px 10px; font-size: 0.8em; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
    .rebind-btn:hover { background: #e3f2fd; border-color: #90caf9; }
    
    .info-icon { display: inline-block; width: 16px; height: 16px; line-height: 16px; text-align: center; font-size: 12px; color: #90a4ae; cursor: help; margin-left: 4px; vertical-align: middle; }
    .info-icon:hover { color: #1976d2; }
    
    .json-header { font-size: 0.75em; color: #78909c; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; font-weight: 600; }
    
    /* Workflow Map Styles */
    .workflow-map { display: flex; flex-direction: column; gap: 0; }
    .workflow-node { display: flex; align-items: flex-start; gap: 15px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; margin-bottom: 0; background: #fafafa; cursor: pointer; transition: all 0.2s ease; position: relative; }
    .workflow-node:hover { background: #e3f2fd; border-color: #90caf9; }
    .workflow-node:not(:last-child)::after { content: ''; position: absolute; left: 28px; bottom: -12px; width: 2px; height: 12px; background: #90caf9; z-index: 1; }
    .workflow-node-icon { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; background: #e3f2fd; border-radius: 50%; font-size: 1em; flex-shrink: 0; }
    .workflow-node-content { flex: 1; min-width: 0; }
    .workflow-node-title { font-weight: 600; color: #333; margin-bottom: 4px; font-size: 0.95em; }
    .workflow-node-desc { font-size: 0.8em; color: #666; margin-bottom: 8px; }
    .workflow-node-artifacts { display: flex; flex-wrap: wrap; gap: 6px; }
    .workflow-artifact { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 12px; font-size: 0.75em; background: #e8f5e9; color: #2e7d32; }
    .workflow-artifact.missing { background: #ffebee; color: #c62828; }
    .workflow-artifact.unknown { background: #f5f5f5; color: #666; }
    .workflow-connector { height: 12px; margin-left: 27px; border-left: 2px solid #90caf9; }

    .state-legend { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; }
    .state-legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.8em; }

    .flow-diagram { background: #fafafa; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
    .flow-diagram-title { font-weight: 600; font-size: 0.9em; color: #333; margin-bottom: 10px; }
    .flow-stages { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .flow-stage { background: white; padding: 10px 15px; border-radius: 6px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); min-width: 100px; }
    .flow-stage-name { font-size: 0.8em; font-weight: 600; color: #333; }
    .flow-stage-desc { font-size: 0.7em; color: #666; margin-top: 4px; }
    .flow-arrow { color: #00695c; font-size: 1.2em; }
    .flow-stage.source { border-left: 3px solid #1565c0; }
    .flow-stage.process { border-left: 3px solid #00695c; }
    .flow-stage.output { border-left: 3px solid #2e7d32; }
    .flow-stage.hold { border-left: 3px solid #ff9800; }

    .reconsolidation-table { width: 100%; border-collapse: collapse; font-size: 0.85em; margin-bottom: 15px; }
    .reconsolidation-table th, .reconsolidation-table td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    .reconsolidation-table th { background: #00695c; color: white; font-weight: 600; }
    .reconsolidation-table tr:hover { background: #e0f2f1; }

    .stream-actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .stream-btn { padding: 8px 14px; font-size: 0.85em; background: #00695c; color: white; border: none; border-radius: 4px; cursor: pointer; }
    .stream-btn:hover { background: #00897b; }

    .record-state-summary { display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px; }
    .record-state-card { background: white; padding: 10px 15px; border-radius: 6px; text-align: center; min-width: 100px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .record-state-card .count { font-size: 1.3em; font-weight: bold; }
    .record-state-card .label { font-size: 0.7em; color: #666; text-transform: uppercase; }
    .record-state-card.consolidated .count { color: #2e7d32; }
    .record-state-card.partial .count { color: #e65100; }
    .record-state-card.waiting .count { color: #1565c0; }
    .record-state-card.blocked .count { color: #c62828; }
  </style>
</head>
<body>
  <!-- Debug HUD (v1.2.8) -->
  <div id="debug-hud" class="admin-only-content" style="position: fixed; top: 5px; right: 5px; background: rgba(0,0,0,0.7); color: #0f0; font-family: monospace; font-size: 11px; padding: 4px 8px; border-radius: 4px; z-index: 99999;">Route: - | Data: - | Mode: -</div>
  
  <div class="app-layout">
    <nav class="nav-sidebar">
      <div class="nav-header" style="display: flex; align-items: center; gap: 12px; height: 56px; padding: 10px 16px;">
        <div style="width: 44px; height: 44px; flex-shrink: 0; filter: drop-shadow(0 0 8px rgba(100, 200, 255, 0.6)) drop-shadow(0 0 16px rgba(100, 200, 255, 0.3));">
          <img src="../../assets/brand/orchestrate-os-logo.svg" alt="Orchestrate OS" title="Orchestrate OS" style="width: 100%; height: 100%; display: block; object-fit: contain;">
        </div>
        <div>
          <h1 style="font-size: 0.95em; margin: 0;">Orchestrate OS</h1>
          <div class="version">Semantic Control Board</div>
        </div>
      </div>
      <div class="nav-menu">
        <!-- Progress Block (routes to Triage) -->
        <div class="nav-section" style="padding: 16px 16px 8px;">
          <a class="progress-block" href="#/triage" data-page="triage">
            <div class="progress-header">Progress</div>
            <div class="progress-stats">
              <div class="progress-stat">
                <span class="progress-stat-count" id="progress-todo">0</span>
                <span class="progress-stat-label">To Do</span>
              </div>
              <div class="progress-stat">
                <span class="progress-stat-count" id="progress-review">0</span>
                <span class="progress-stat-label">Review</span>
              </div>
              <div class="progress-stat">
                <span class="progress-stat-count" id="progress-done">0</span>
                <span class="progress-stat-label">Done</span>
              </div>
            </div>
            <div class="progress-bar-container">
              <div class="progress-bar-fill" id="progress-bar-fill" style="width: 0%;"></div>
            </div>
          </a>
        </div>

        <!-- Active Data Source Bar -->
        <div class="active-data-source-bar" id="active-data-source-bar">
          <div class="active-data-source-info">
            <div class="active-data-source-label">Active Data Source</div>
            <div class="active-data-source-name" id="active-data-source-name">No dataset loaded</div>
          </div>
          <button class="active-data-source-change" id="active-data-source-action" onclick="openDataSourcePanel()">Change</button>
        </div>

        <!-- Locked Role Display (for Analyst/Reviewer - appears above nav) -->
        <div id="locked-role-display-top" style="display: none; margin: 12px 16px; padding: 8px 12px; font-size: 0.8em; background: rgba(21, 101, 192, 0.15); color: #64b5f6; border-radius: 6px; text-align: center; border: 1px solid rgba(21, 101, 192, 0.3);"></div>

        <div class="nav-divider"></div>

        <!-- Navigation Section -->
        <div class="nav-section">
          <div class="nav-section-header">Navigation</div>
          
          <!-- Sheet Selector (stub) -->
          <div style="padding: 4px 16px 8px;">
            <select class="sheet-selector" id="sidebar-sheet-selector" onchange="handleSheetSelectorChange(this.value)">
              <option value="all">All Sheets</option>
            </select>
          </div>
          
          <!-- View Mode Buttons: Triage â†’ All Data Grid â†’ Record Inspection -->
          <a class="nav-item" data-page="triage" href="#/triage">
            <span class="nav-icon">ðŸ“‹</span>
            <span class="nav-label">Triage</span>
          </a>
          <a class="nav-item" data-page="grid" href="#/grid">
            <span class="nav-icon">ðŸ“Š</span>
            <span class="nav-label">All Data Grid</span>
          </a>
          <a class="nav-item" id="nav-record-inspection" href="#" onclick="openRecordInspectionFromNav(); return false;">
            <span class="nav-icon">ðŸ”Ž</span>
            <span class="nav-label">Record Inspection</span>
          </a>
          <a class="nav-item reviewer-only" data-page="verifier-review" href="#/verifier-review">
            <span class="nav-icon">âœ“</span>
            <span class="nav-label">Verifier Review</span>
          </a>
        </div>

        <div class="nav-divider"></div>

        <!-- Tools Section -->
        <div class="nav-section">
          <div class="nav-section-header">Tools</div>
          <a class="nav-item analyst-only" data-page="patch" href="#/patch">
            <span class="nav-icon">âœŽ</span>
            <span class="nav-label">Patch Studio</span>
          </a>
          <a class="nav-item reviewer-only" data-page="review" href="#/review">
            <span class="nav-icon">ðŸ”</span>
            <span class="nav-label">Config Inspector</span>
          </a>
          <a class="nav-item admin-only" data-page="admin-approval" href="#/admin-approval">
            <span class="nav-icon">âœ“âœ“</span>
            <span class="nav-label">Admin Approval</span>
          </a>
          <a class="nav-item admin-only" data-page="admin" href="#/admin">
            <span class="nav-icon">âš™</span>
            <span class="nav-label">Governance</span>
          </a>
          <a class="nav-item admin-only" id="nav-config-flows" href="#" onclick="openConfigFlows(); return false;">
            <span class="nav-icon">ðŸ”§</span>
            <span class="nav-label">Config Flows</span>
          </a>
        </div>

      </div>
      <!-- Sidebar Footer (anchored to bottom) -->
      <div class="nav-footer">
        <div class="nav-divider"></div>
        <!-- Cache Section (v1.4.13) -->
        <div class="nav-section">
          <div class="nav-section-header">PDF Cache</div>
          <div class="cache-info" style="padding: 4px 20px; font-size: 0.8em; color: #888;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Cached PDFs</span>
              <span id="cache-pdf-count">0</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span>Storage used</span>
              <span id="cache-storage-used">0 B</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9em; color: #aaa;">
              <span>Max capacity</span>
              <span>250 MB</span>
            </div>
            <button class="cache-clear-btn" onclick="clearCachedPDFs()">Clear All Cached PDFs</button>
          </div>
        </div>
        <!-- Export / Save -->
        <div class="nav-section" style="padding: 12px 16px;">
          <button class="nav-action-btn export-btn" onclick="handleExportSave()">
            <span class="nav-action-icon">ðŸ’¾</span>
            <span>Export / Save</span>
          </button>
        </div>
      </div>
      <div class="nav-mode-section">
        <div class="nav-mode-label">Role</div>
        <div class="mode-toggle" id="mode-toggle-container">
          <button class="mode-btn mode-analyst active" data-mode="analyst">Analyst</button>
          <button class="mode-btn mode-reviewer" data-mode="reviewer">Reviewer</button>
          <button class="mode-btn mode-admin" data-mode="admin">Admin</button>
        </div>
        <div id="locked-role-display" style="display: none; padding: 6px 12px; font-size: 0.75em; background: rgba(21, 101, 192, 0.15); color: #64b5f6; border-radius: 4px; text-align: center;"></div>
      </div>
      
      <!-- Sign Out link -->
      <div style="padding: 12px 20px; border-top: 1px solid #2d2d4a;">
        <a href="#" id="sign-out-link" onclick="handleSignOut(event)" style="display: flex; align-items: center; gap: 8px; color: #888; text-decoration: none; font-size: 0.8em; transition: color 0.2s;">
          <span style="font-size: 1.1em;">â†</span>
          <span>Sign Out</span>
        </a>
      </div>
      
    </nav>

    <main class="main-content">
      
      <!-- First-Run Banner (admin-only - refers to config) -->
      <div class="first-run-banner admin-only-content" id="first-run-banner" style="display: none;">
        <span class="banner-icon">&#9881;</span>
        <span class="banner-text">Using default setup. Click <strong>Configure</strong> to connect your local files and set your workflow defaults.</span>
        <button class="banner-dismiss" onclick="dismissFirstRunBanner()" title="Dismiss">&times;</button>
      </div>

      <!-- Empty Queue Message (visible when no data loaded) -->
      <div class="empty-queue-message" id="empty-queue-message">
        <div class="empty-queue-icon">ðŸ“‹</div>
        <h3>No records loaded yet</h3>
        <p>Import a dataset to start working.</p>
        <button class="empty-queue-cta" id="empty-queue-load" onclick="openDataSourcePanel()">Add Data Source</button>
      </div>
      
      <!-- Loader Page (DEPRECATED - v1.2.9 uses drawer instead) -->
      <div class="page-content" id="page-loader" style="display: none !important;">
        <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
          <div style="font-size: 0.75em; color: #999; text-align: right; margin-bottom: 10px;">PAGE: LOADER | BUILD v1.6.28</div>
          
          <!-- PRIMARY ACTION PANEL: Continue to Triage (shown when dataset active) -->
          <div id="loader-continue-panel" style="display: none; background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%); border-radius: 12px; padding: 30px; margin-bottom: 30px; color: white; text-align: center;">
            <div style="font-size: 2em; margin-bottom: 10px;">âœ…</div>
            <h2 style="margin: 0 0 8px 0; font-size: 1.4em; color: white;">Dataset Ready</h2>
            <div id="loader-active-dataset-info" style="font-size: 0.9em; opacity: 0.9; margin-bottom: 20px;"></div>
            <button id="btn-continue-triage" class="empty-queue-cta" style="background: white; color: #1976d2; font-size: 1.1em; padding: 14px 28px; border-radius: 8px;">Continue to Triage</button>
            <div style="margin-top: 15px;">
              <button id="btn-copy-bundle-primary" class="top-toolbar-btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);" onclick="copyBundleJSON()">Copy Bundle JSON</button>
            </div>
          </div>
          
          <!-- PRIMARY ACTION PANEL: Import CSV (shown when no dataset) -->
          <div id="loader-import-panel" style="display: none; background: linear-gradient(135deg, #455a64 0%, #37474f 100%); border-radius: 12px; padding: 30px; margin-bottom: 20px; color: white; text-align: center;">
            <div style="font-size: 2em; margin-bottom: 10px;">ðŸ“„</div>
            <h2 style="margin: 0 0 8px 0; font-size: 1.4em; color: white;">Load a File</h2>
            <p style="font-size: 0.95em; opacity: 0.9; margin: 0 0 20px 0;">Import a CSV file to start working with your data.</p>
            <input type="file" id="file-import-csv-primary" accept=".csv" style="display: none;">
            <button id="btn-import-csv-primary" class="empty-queue-cta" style="background: white; color: #37474f; font-size: 1.1em; padding: 14px 28px; border-radius: 8px;">Import CSV</button>
          </div>
          
          <!-- SECONDARY ACTION: Load Sample Dataset (hidden v1.4.23 - folder-based workflow) -->
          <div id="loader-sample-panel" style="display: none !important;"></div>
          
          <!-- COLLAPSIBLE: Other Actions -->
          <div id="loader-other-actions" style="background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden;">
            <button id="loader-toggle-actions" style="width: 100%; padding: 14px 20px; background: none; border: none; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.95em; color: #333;">
              <span style="font-weight: 600;">Other Actions</span>
              <span id="loader-toggle-icon" style="font-size: 0.8em;">&#9660;</span>
            </button>
            <div id="loader-actions-content" style="display: none; padding: 0 20px 20px 20px;">
              <div style="display: grid; gap: 12px;">
                <!-- Sample dataset hidden (v1.4.23 - folder-based workflow) -->
                
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 1px solid #e0e0e0; border-radius: 6px;">
                  <span>ðŸ“„</span>
                  <div style="flex: 1;">
                    <div style="font-weight: 600; font-size: 0.9em;">Import CSV</div>
                    <div style="font-size: 0.8em; color: #666;">Create dataset from CSV file</div>
                  </div>
                  <input type="file" id="file-import-csv" accept=".csv" style="display: none;">
                  <button id="btn-import-csv" class="top-toolbar-btn" style="padding: 8px 16px;">Choose...</button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 1px solid #e0e0e0; border-radius: 6px;">
                  <span>ðŸ“Ž</span>
                  <div style="flex: 1;">
                    <div style="font-weight: 600; font-size: 0.9em;">Attach PDF</div>
                    <div style="font-size: 0.8em; color: #666;">Add artifact reference</div>
                  </div>
                  <input type="file" id="file-attach-pdf" accept=".pdf" style="display: none;">
                  <button id="btn-attach-pdf" class="top-toolbar-btn" style="padding: 8px 16px;">Attach...</button>
                </div>
                <div id="pdf-attachments-list" style="font-size: 0.85em; color: #666; padding-left: 30px;"></div>
              </div>
              
              <div class="admin-only-content" style="border-top: 1px solid #e0e0e0; margin-top: 15px; padding-top: 15px;">
                <div style="font-weight: 600; font-size: 0.85em; color: #666; margin-bottom: 10px;">Test Utilities</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                  <button class="top-toolbar-btn" id="btn-reset-demo-state" style="font-size: 0.85em;">Reset Demo State</button>
                  <button class="top-toolbar-btn" id="btn-rebuild-field-index" style="font-size: 0.85em;">Rebuild Field Index</button>
                </div>
              </div>
            </div>
          </div>
          
        </div>
      </div>

      <!-- ACCESS RESTRICTED PAGE (v1.4.22) -->
      <div class="page" id="page-restricted" style="display: none;">
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 60vh; text-align: center;">
          <div style="font-size: 64px; margin-bottom: 20px;">ðŸ”’</div>
          <h2 style="margin: 0 0 10px; color: #333;">Access Restricted</h2>
          <p style="color: #666; margin-bottom: 24px; max-width: 400px;" id="restricted-message">You don't have permission to view this page with your current role.</p>
          <div style="display: flex; gap: 12px;">
            <button onclick="navigateToRoleDefault()" class="toolbar-btn" style="padding: 10px 24px;">Go to My Dashboard</button>
            <button onclick="window.location.href='/ui/landing/'" class="toolbar-btn" style="padding: 10px 24px; background: #f5f5f5; color: #333;">Switch Role</button>
          </div>
        </div>
      </div>

      <!-- TRIAGE PAGE (default after data loaded) -->
      <div class="page" id="page-triage">
        <div id="analyst-triage-content">
          <div class="page-header" style="position: relative;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
              <h2 id="triage-page-title">Triage</h2>
              <span style="font-size: 0.7em; color: #999;">PAGE: TRIAGE | BUILD v1.6.28</span>
            </div>
            <p class="page-desc">All items requiring analyst review and action.</p>
            <!-- Sticky Search Bar (top right) - frosted glass style with scroll-aware behavior -->
            <div id="triage-search-bar" style="position: fixed; top: 12px; right: 24px; z-index: 100; display: flex; align-items: center; gap: 6px; background: rgba(255, 255, 255, 0.72); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.5); box-shadow: 0 2px 12px rgba(0,0,0,0.08); transition: opacity 0.2s ease, transform 0.2s ease;">
              <input type="text" id="global-search-input" placeholder="Search recordsâ€¦" 
                     style="padding: 5px 8px; border: none; background: transparent; border-radius: 4px; font-size: 0.8em; width: 160px; color: #444; outline: none;" 
                     onkeydown="handleGlobalSearchKeydown(event)">
              <span style="font-size: 0.6em; color: #999; padding: 2px 5px; background: rgba(0,0,0,0.06); border-radius: 3px;">âŒ˜K</span>
            </div>
          </div>

          <!-- QUEUE 1: Manual Review -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">Manual Review <span id="manual-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="manual-queue-list" style="background: #fffef5;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No manual review items</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- QUEUE 2: Salesforce Logic Flags -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">Salesforce Logic Flags <span id="sflogic-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="sflogic-queue-list" style="background: #fffaf5;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No Salesforce logic flags</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- QUEUE 3: Patch Queue -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">Patch Queue <span id="patch-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
              <button style="margin-left: auto; padding: 4px 10px; font-size: 0.75em; background: transparent; border: 1px solid #ddd; border-radius: 4px; color: #999; cursor: not-allowed;" disabled title="Filter coming soon">Filter</button>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="patch-queue-list" style="background: #f8fbff;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No patch requests yet</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- QUEUE 4: System Changes -->
          <div class="triage-queue-section" style="margin-bottom: 24px;">
            <div class="queue-header" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
              <h3 style="margin: 0; font-size: 1.05em; color: #333;">System Changes <span id="system-queue-count" style="font-weight: 400; color: #666;">(0)</span></h3>
            </div>
            <div class="queue-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
                <thead style="background: #f5f5f5; border-bottom: 1px solid #e0e0e0;">
                  <tr>
                    <th style="padding: 8px 12px;">Type</th>
                    <th style="padding: 8px 12px;">Record</th>
                    <th style="padding: 8px 12px;">Field</th>
                    <th style="padding: 8px 12px;">Status</th>
                    <th style="padding: 8px 12px;">Last Updated</th>
                    <th style="padding: 8px 12px;">Actions</th>
                  </tr>
                </thead>
                <tbody id="system-queue-list" style="background: #fafafa;">
                  <tr><td colspan="6" style="padding: 20px; text-align: center; color: #999;">No system changes</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div id="verifier-triage-content" style="display: none;">
          <div class="page-header">
            <h2 id="verifier-triage-title">Triage - Reviewer</h2>
            <p class="page-desc">Review submitted RFIs, Corrections, and Blacklist requests.</p>
          </div>
          
          <!-- v1.5.2: Division + Status filter bar -->
          <div class="reviewer-filter-bar" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px; padding: 12px 16px; background: #f8f9fa; border-radius: 8px; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 0.85em; color: #666; font-weight: 600;">Division:</label>
              <select id="reviewer-filter-division" class="filter-select" style="min-width: 140px;" onchange="onReviewerFilterChange()">
                <option value="">All Divisions</option>
                <option value="__unassigned__">Unassigned</option>
              </select>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 0.85em; color: #666; font-weight: 600;">Status:</label>
              <select id="reviewer-filter-status" class="filter-select" style="min-width: 140px;" onchange="onReviewerFilterChange()">
                <option value="">All Statuses</option>
                <option value="pending">Pending Review</option>
                <option value="needs_clarification">Needs Clarification</option>
                <option value="sent_to_admin">Sent to Admin</option>
                <option value="resolved">Resolved</option>
              </select>
            </div>
            <span id="reviewer-filter-count" style="font-size: 0.85em; color: #666; margin-left: auto;"></span>
          </div>
          
          <!-- v1.5.3: Patch Type tabs (Corrections, Blacklist, RFI) -->
          <div class="patch-type-tabs" style="display: flex; gap: 8px; margin-bottom: 16px;">
            <div class="pt-tab active" data-ptype="" onclick="setReviewerPatchType('')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #e3f2fd; color: #1565c0; border: 1px solid #1565c0;">All Types <span id="pt-count-all">(0)</span></div>
            <div class="pt-tab" data-ptype="correction" onclick="setReviewerPatchType('correction')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #f5f5f5; color: #333; border: 1px solid #ddd;">Corrections <span id="pt-count-correction">(0)</span></div>
            <div class="pt-tab" data-ptype="blacklist" onclick="setReviewerPatchType('blacklist')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #f5f5f5; color: #333; border: 1px solid #ddd;">Blacklist <span id="pt-count-blacklist">(0)</span></div>
            <div class="pt-tab" data-ptype="rfi" onclick="setReviewerPatchType('rfi')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.85em; font-weight: 600; background: #f5f5f5; color: #333; border: 1px solid #ddd;">RFI <span id="pt-count-rfi">(0)</span></div>
          </div>
          
          <div class="verifier-tabs" style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 1px solid #ddd; padding-bottom: 10px;">
            <div class="v-tab active" data-vqueue="pending" onclick="setVerifierQueue('pending')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600; background: #f5f5f5;">Pending <span id="v-count-pending">(0)</span></div>
            <div class="v-tab" data-vqueue="needs_clarification" onclick="setVerifierQueue('needs_clarification')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600;">Clarification <span id="v-count-clarification">(0)</span></div>
            <div class="v-tab" data-vqueue="sent_to_admin" onclick="setVerifierQueue('sent_to_admin')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600;">To Admin <span id="v-count-admin">(0)</span></div>
            <div class="v-tab" data-vqueue="resolved" onclick="setVerifierQueue('resolved')" style="padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 0.9em; font-weight: 600;">Resolved <span id="v-count-resolved">(0)</span></div>
          </div>

          <div class="verifier-table-container" style="background: white; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85em; text-align: left;">
              <thead style="background: #f8f9fa; border-bottom: 1px solid #eee;">
                <tr>
                  <th style="padding: 12px;">Type</th>
                  <th style="padding: 12px;">Record</th>
                  <th style="padding: 12px;">Field</th>
                  <th style="padding: 12px;">Change / Value</th>
                  <th style="padding: 12px;">Comment</th>
                  <th style="padding: 12px;">Submitted</th>
                  <th style="padding: 12px;">Actions</th>
                </tr>
              </thead>
              <tbody id="verifier-queue-list">
                <tr><td colspan="7" style="padding: 40px; text-align: center; color: #999;">No payloads in this queue</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </div><!-- end page-triage -->

      <!-- ALL-DATA GRID PAGE -->
      <div class="page" id="page-grid">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>All-Data Grid</h2>
            <span style="font-size: 0.7em; color: #999;">PAGE: ALL-DATA-GRID | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Dense spreadsheet view of all records with filtering and search.</p>
        </div>
        
        <!-- v1.5.2: Reviewer-only filter bar (mirrors triage filters) -->
        <div id="reviewer-grid-filter-bar" class="reviewer-filter-bar" style="display: none; gap: 16px; align-items: center; margin-bottom: 16px; padding: 12px 16px; background: #fff3e0; border: 1px solid #ffcc80; border-radius: 8px; flex-wrap: wrap;">
          <span style="font-size: 0.85em; font-weight: 600; color: #e65100;">Read-Only Mode</span>
          <div style="display: flex; align-items: center; gap: 8px; margin-left: 16px;">
            <label style="font-size: 0.85em; color: #666; font-weight: 600;">Division:</label>
            <select id="reviewer-grid-filter-division" class="filter-select" style="min-width: 140px;" onchange="onReviewerGridFilterChange()">
              <option value="">All Divisions</option>
            </select>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <label style="font-size: 0.85em; color: #666; font-weight: 600;">Status:</label>
            <select id="reviewer-grid-filter-status" class="filter-select" style="min-width: 140px;" onchange="onReviewerGridFilterChange()">
              <option value="">All Statuses</option>
              <option value="pending">Pending Review</option>
              <option value="needs_clarification">Needs Clarification</option>
              <option value="sent_to_admin">Sent to Admin</option>
              <option value="resolved">Resolved</option>
            </select>
          </div>
          <span id="reviewer-grid-filter-count" style="font-size: 0.85em; color: #666; margin-left: auto;"></span>
        </div>

        <!-- Grid Controls -->
        <div id="analyst-grid-controls" class="grid-controls" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px; flex-wrap: wrap;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <label style="font-size: 0.85em; color: #666;">Sheet:</label>
            <select id="grid-sheet-selector" class="filter-select" style="min-width: 160px;">
              <option value="">All Sheets</option>
            </select>
          </div>
          <div style="flex: 1; min-width: 200px;">
            <input type="text" id="grid-search" class="filter-search" placeholder="Search all fields..." style="width: 100%;">
          </div>
          <div class="filter-chips" id="grid-status-chips" style="display: flex; gap: 6px; flex-wrap: wrap;">
            <span class="filter-chip active" data-filter="all" onclick="setGridFilter('all')">All</span>
            <span class="filter-chip status-ready" data-filter="ready" onclick="setGridFilter('ready')">Ready</span>
            <span class="filter-chip status-needs_review" data-filter="needs_review" onclick="setGridFilter('needs_review')">Needs Review</span>
            <span class="filter-chip status-blocked" data-filter="blocked" onclick="setGridFilter('blocked')">Blocked</span>
          </div>
          <button class="top-toolbar-btn" id="grid-column-toggle" onclick="toggleColumnMenu()" title="Toggle columns">Columns</button>
        </div>

        <!-- Column Toggle Menu (hidden by default) -->
        <div id="grid-column-menu" style="display: none; position: fixed; top: 120px; right: 40px; background: white; border: 1px solid #ddd; border-radius: 8px; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; max-height: 300px; overflow-y: auto;">
          <div style="font-weight: 600; margin-bottom: 8px; color: #333;">Visible Columns</div>
          <div id="grid-column-checkboxes"></div>
        </div>

        <!-- Per-Sheet Mini Stats -->
        <div id="grid-sheet-stats" style="display: flex; gap: 16px; align-items: center; margin-bottom: 12px; padding: 10px 16px; background: #f8f9fa; border-radius: 6px; font-size: 0.85em; color: #555;">
          <span id="grid-stat-rows"><strong>Rows:</strong> <span class="stat-value">0</span></span>
          <span class="stat-divider" style="color: #ccc;">|</span>
          <span id="grid-stat-ready"><strong>Ready:</strong> <span class="stat-value" style="color: #2e7d32;">0</span></span>
          <span id="grid-stat-review"><strong>Needs Review:</strong> <span class="stat-value" style="color: #f57c00;">0</span></span>
          <span id="grid-stat-blocked"><strong>Blocked:</strong> <span class="stat-value" style="color: #c62828;">0</span></span>
          <span class="stat-divider admin-only-content" style="color: #ccc; display: none;">|</span>
          <span id="grid-stat-unknown" class="admin-only-content" style="display: none; cursor: pointer;" onclick="openLoaderDrawer()" title="Click to load data"><strong>Unknown Cols:</strong> <span class="stat-value" style="color: #7b1fa2;">0</span></span>
        </div>
        
        <!-- v1.6.11: Change Map Legend (shown only for modified dataset) -->
        <div id="grid-change-legend" style="display: none; margin-bottom: 12px; padding: 8px 16px; background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.8em;">
          <span style="font-weight: 600; color: #333; margin-right: 12px;">Cell Colors:</span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #FFD6D6; border: 1px solid #e53935; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">Blacklist</span>
          </span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #FFE7B3; border: 1px solid #ff9800; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">RFI</span>
          </span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #CFE8FF; border: 1px solid #1976d2; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">Correction</span>
          </span>
          <span class="legend-item" style="margin-right: 16px;">
            <span style="display: inline-block; width: 14px; height: 14px; background: #EFEFEF; border: 1px solid #9e9e9e; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">System</span>
          </span>
          <span class="legend-item">
            <span style="display: inline-block; width: 14px; height: 14px; background: #DDF5DD; border: 1px solid #4caf50; border-radius: 2px; vertical-align: middle;"></span>
            <span style="margin-left: 4px; color: #555;">Verified</span>
          </span>
        </div>

        <!-- Dense Grid Table -->
        <div class="grid-table-container" style="overflow-x: auto; border: 1px solid #e0e0e0; border-radius: 8px;">
          <table class="grid-table" id="grid-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
            <thead id="grid-thead" style="position: sticky; top: 0; background: #f5f5f5; z-index: 10;">
              <tr id="grid-header-row"></tr>
            </thead>
            <tbody id="grid-tbody"></tbody>
          </table>
        </div>

        <!-- Grid Footer -->
        <div class="grid-footer" style="margin-top: 12px; display: flex; justify-content: space-between; align-items: center; color: #666; font-size: 0.85em;">
          <span id="grid-row-count">0 records</span>
          <span id="grid-filter-info"></span>
          <span style="font-size: 0.75em; color: #aaa;">PAGE: ALL-DATA-GRID | BUILD v1.6.28</span>
        </div>
      </div><!-- end page-grid -->

      <!-- SINGLE ROW REVIEW PAGE -->
      <div class="page" id="page-row">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2 id="srr-page-title">Record Inspection</h2>
            <span style="font-size: 0.7em; color: #999;">PAGE: SINGLE-ROW-REVIEW | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Per-record inspection with Evidence Pack authoring and Patch Request creation.</p>
        </div>

        <!-- Top Bar: Identity, State Badge, Back Button -->
        <div class="srr-top-bar">
          <button class="srr-back-btn" onclick="srrBackToGrid()">â† Back to Grid</button>
          <div style="flex: 1;">
            <span style="font-size: 0.75em; color: #aaa; margin-right: 8px;">Record:</span>
            <span class="srr-identity" id="srr-record-id">â€”</span>
          </div>
          <div>
            <span style="font-size: 0.75em; color: #aaa; margin-right: 8px;">Review State:</span>
            <span class="srr-state-badge" id="srr-state-badge">â€”</span>
          </div>
          <button class="srr-back-btn" onclick="showAuditLogForRecord()" title="View audit log for this record">Audit Log</button>
        </div>

        <!-- Three-Panel Layout -->
        <div class="srr-layout">
          <!-- Left Panel: Field Inspector with Search, Filters, Field Cards -->
          <div class="srr-panel srr-panel-left">
            <div class="srr-panel-header" style="flex-direction: column; align-items: flex-start; gap: 2px;">
              <span id="srr-inspector-title" style="font-size: 0.95em;">Field Inspector</span>
              <span id="srr-field-count" style="font-weight: normal; color: #666; font-size: 0.8em;">0 fields</span>
            </div>
            <!-- v1.4.18: Search input -->
            <div class="srr-search-bar">
              <input type="text" class="srr-search-input" id="srr-field-search" placeholder="Search fields..." oninput="srrFilterFields()">
            </div>
            <div class="srr-filter-bar" id="srr-filter-bar">
              <div class="srr-filter-chips" id="srr-filter-chips">
                <span class="srr-filter-chip active" data-filter="all" onclick="srrSetFilter('all')">All <span class="chip-count" id="srr-count-all"></span></span>
                <span class="srr-filter-chip" data-filter="todo" onclick="srrSetFilter('todo')">To Do <span class="chip-count" id="srr-count-todo"></span></span>
                <span class="srr-filter-chip" data-filter="verified" onclick="srrSetFilter('verified')">Verified <span class="chip-count" id="srr-count-verified"></span></span>
                <span class="srr-filter-chip" data-filter="rfi" onclick="srrSetFilter('rfi')">RFI <span class="chip-count" id="srr-count-rfi"></span></span>
                <span class="srr-filter-chip" data-filter="patched" onclick="srrSetFilter('patched')">Patched <span class="chip-count" id="srr-count-patched"></span></span>
              </div>
            </div>
            <!-- v1.6.15: Asterisk legend -->
            <div class="srr-field-legend">
              <span><span class="legend-required">*</span> Options</span>
              <span><span class="legend-invalid">**</span> Invalid</span>
            </div>
            <div class="srr-panel-body" id="srr-field-list" style="padding: 0;">
              <div class="srr-empty-state">No fields loaded</div>
            </div>
          </div>

          <!-- Center Panel: Document Viewer -->
          <div class="srr-panel srr-panel-center">
            <div class="srr-panel-header">
              <span>Document Viewer</span>
              <span id="srr-doc-page" style="font-weight: normal; color: #666; font-size: 0.85em;">Page 1 of 1</span>
            </div>
            <div class="srr-doc-viewer">
              <div class="srr-doc-controls">
                <button class="srr-doc-btn" id="srr-prev-btn" onclick="srrPrevPage()" title="Previous page">â† Prev</button>
                <span class="srr-page-indicator" id="srr-page-indicator">Page 1</span>
                <button class="srr-doc-btn" id="srr-next-btn" onclick="srrNextPage()" title="Next page">Next â†’</button>
                <span class="srr-doc-spacer"></span>
                <button class="srr-doc-btn" id="srr-zoom-out" onclick="srrZoomOut()" title="Zoom out">âˆ’</button>
                <span class="srr-zoom-indicator" id="srr-zoom-indicator">100%</span>
                <button class="srr-doc-btn" id="srr-zoom-in" onclick="srrZoomIn()" title="Zoom in">+</button>
              </div>
              <div class="srr-doc-source" id="srr-doc-source" style="font-size: 0.75em; color: #666; padding: 4px 8px; background: #f5f5f5; border-bottom: 1px solid #e0e0e0; display: none;">
                <span id="srr-doc-source-type" style="font-weight: 500;"></span>
                <span id="srr-doc-source-name" style="margin-left: 6px; color: #888;"></span>
              </div>
              <div class="srr-doc-frame" id="srr-doc-frame">
                <!-- v1.6.12: Non-blocking PDF highlight overlay -->
                <div id="srr-pdf-highlight-toast" class="srr-pdf-highlight-toast" style="display: none;">
                  <span id="srr-pdf-highlight-label">Field</span>
                  <span class="close-btn" onclick="srrClearHighlight()" title="Close (Esc)">Ã—</span>
                </div>
                <div id="srr-pdf-highlight-box" class="srr-pdf-highlight-box" style="display: none;"></div>
                
                <div class="srr-doc-empty-state" id="srr-doc-empty">
                  <div style="font-size: 3em; margin-bottom: 10px;">ðŸ“„</div>
                  <div style="font-weight: 500;">No document attached</div>
                  <div style="font-size: 0.85em; color: #999; margin-top: 8px;">Attach PDFs via Data Source panel to view here</div>
                </div>
                <!-- PDF Error Banner (v1.4.13) -->
                <div id="srr-pdf-error" style="display: none; padding: 16px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 8px; margin: 12px; color: #e65100;">
                  <div style="display: flex; align-items: flex-start; gap: 10px;">
                    <span style="font-size: 1.2em;">âš ï¸</span>
                    <div style="flex: 1;">
                      <div style="font-weight: 600; margin-bottom: 6px;" id="srr-pdf-error-title">PDF failed to render</div>
                      <div style="font-size: 0.9em; margin-bottom: 10px;" id="srr-pdf-error-msg">The document could not be displayed in the viewer.</div>
                      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <a id="srr-pdf-open-tab" href="#" target="_blank" style="color: #1565c0; text-decoration: underline; font-size: 0.9em;">Open in New Tab</a>
                        <button id="srr-pdf-use-local" onclick="srrSwitchToLocalAttachment()" style="display: none; padding: 4px 10px; font-size: 0.85em; background: #fff; border: 1px solid #ff9800; border-radius: 4px; cursor: pointer;">Use Local Attachment</button>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="srr-doc-container" id="srr-doc-container" style="display: none;">
                  <object id="srr-pdf-object" class="srr-pdf-object" type="application/pdf" data="about:blank">
                    <div class="srr-pdf-fallback" id="srr-pdf-fallback">
                      <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 2em; margin-bottom: 10px;">ðŸ“„</div>
                        <div style="margin-bottom: 12px;">PDF viewer blocked by browser</div>
                        <a id="srr-pdf-open-tab" href="#" target="_blank" class="btn-primary" style="display: inline-block; padding: 8px 16px; background: #1565c0; color: white; text-decoration: none; border-radius: 4px;">Open in New Tab</a>
                      </div>
                    </div>
                  </object>
                </div>
              </div>
              <div class="srr-anchor-list" id="srr-anchor-list">
                <div style="font-size: 0.8em; font-weight: 600; color: #666; margin-bottom: 8px;">Evidence Anchors</div>
                <div class="srr-empty-state" style="padding: 10px;">No anchors defined</div>
              </div>
            </div>
          </div>

          <!-- Right Panel: Patch Editor + Evidence Pack + Submit -->
          <div class="srr-panel srr-panel-right">
            <div class="srr-panel-header" style="display: flex; align-items: center; gap: 8px;">
              <span id="srr-right-panel-title">Patch Editor</span>
              <!-- v1.5.1: Reviewer-only Patch Tester tab -->
              <div id="srr-panel-tabs" class="srr-panel-tabs" style="display: none; margin-left: auto;">
                <button class="srr-panel-tab active" data-tab="editor" onclick="srrSwitchRightTab('editor')">Editor</button>
                <button class="srr-panel-tab" data-tab="tester" onclick="srrSwitchRightTab('tester')">Patch Tester</button>
              </div>
            </div>
            
            <!-- Patch Editor Content (default, for analysts) -->
            <div class="srr-panel-body" id="srr-tab-editor">
              <!-- Patch Type Chips (horizontal scroll) - v1.5.2: Acts on selected field -->
              <div class="srr-patch-type-selector" style="margin-bottom: 16px;">
                <div class="srr-patch-type-label" style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 6px;">Patch Type</div>
                <div class="srr-patch-type-chips no-selection" id="srr-patch-type-chips" style="display: flex; gap: 6px; overflow-x: auto; white-space: nowrap; padding-bottom: 4px;">
                  <div class="srr-patch-type-chip correction active" data-type="correction" onclick="srrOnPatchTypeChange('correction')">Correction</div>
                  <div class="srr-patch-type-chip blacklist" data-type="blacklist" onclick="srrOnPatchTypeChange('blacklist')">Blacklist</div>
                  <div class="srr-patch-type-chip rfi" data-type="rfi" onclick="srrOnPatchTypeChange('rfi')">RFI</div>
                </div>
                <div class="srr-patch-type-selected-field" id="srr-patch-type-selected-field">Select a field to apply action</div>
              </div>

              <!-- Action Box - title changes based on patch type -->
              <div class="srr-patch-editor" id="srr-patch-editor">
                <div class="srr-patch-editor-title">
                  <span id="srr-action-box-title">Changed Fields</span>
                  <span id="srr-override-badge" class="srr-override-badge srr-section-hidden">OVERRIDE</span>
                  <span id="srr-change-count" style="font-weight: normal; color: #666; font-size: 0.85em; margin-left: auto;">0 changes</span>
                </div>
                <div id="srr-patch-editor-fields">
                  <div class="srr-patch-editor-empty" id="srr-action-box-helper">Click a field value to edit. Changed fields appear here.</div>
                </div>
                
                <!-- v1.4.19: Override toggle (Correction only, when applicable) -->
                <div id="srr-override-section" class="srr-override-row srr-section-hidden">
                  <div class="srr-override-toggle" id="srr-override-toggle" onclick="srrToggleOverride()"></div>
                  <div class="srr-override-label">Enable Override (skip repro requirement)</div>
                </div>
                
                <!-- v1.4.19: Blacklist Subject (Blacklist Flag only) -->
                <div id="srr-blacklist-section" class="srr-blacklist-subject srr-section-hidden">
                  <div class="srr-blacklist-subject-label">Blacklist Subject</div>
                  <div id="srr-blacklist-subject-value">(Derived from selected field/value)</div>
                </div>
                
                <!-- RFI Assignment Stub (RFI only) -->
                <div id="srr-rfi-section" class="srr-rfi-target srr-section-hidden">
                  <div class="srr-rfi-stub" style="display: flex; align-items: center; gap: 8px; padding: 10px; background: #f5f5f5; border-radius: 6px; color: #888;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                    <span style="font-size: 0.85em;">Assign user (coming soon)</span>
                  </div>
                </div>
              </div>

              <!-- Evidence Pack: Conditional sections based on Patch Type -->
              <div style="font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">Evidence Pack</div>
              
              <!-- Observation (Correction only) -->
              <div class="srr-evidence-block" id="srr-observation-block">
                <div class="srr-evidence-label">Observation <span class="srr-evidence-alias">(WHEN)</span></div>
                <select class="srr-evidence-select" id="srr-observation-type" onchange="srrOnObservationChange()">
                  <option value="">-- Select observation type --</option>
                  <option value="incorrect_value">Incorrect Value</option>
                  <option value="missing_value">Missing Value</option>
                  <option value="formatting_issue">Formatting Issue</option>
                  <option value="duplicate_entry">Duplicate Entry</option>
                  <option value="inconsistent_data">Inconsistent Data</option>
                  <option value="override_needed">Override Needed</option>
                </select>
              </div>
              
              <!-- Expected (Correction only) -->
              <div class="srr-evidence-block" id="srr-expected-block">
                <div class="srr-evidence-label">Expected <span class="srr-evidence-alias">(THEN)</span></div>
                <select class="srr-evidence-select" id="srr-expected-type" onchange="srrOnExpectedChange()">
                  <option value="">-- Select expected behavior --</option>
                  <option value="correct_value">Use Correct Value</option>
                  <option value="populate_field">Populate Empty Field</option>
                  <option value="standardize_format">Standardize Format</option>
                  <option value="remove_duplicate">Remove Duplicate</option>
                  <option value="align_with_source">Align with Source Document</option>
                  <option value="allow_override">Allow Override</option>
                </select>
              </div>
              
              <!-- Justification / Comment (all patch types) -->
              <div class="srr-evidence-block" id="srr-justification-block">
                <div class="srr-evidence-label" id="srr-justification-label">Justification <span class="srr-evidence-alias">(BECAUSE)</span></div>
                <textarea class="srr-evidence-textarea" id="srr-justification" placeholder="Explain why this change/flag/question is necessary..." oninput="srrSaveEvidenceDraft()"></textarea>
              </div>
              
              <!-- Repro (Correction only, when required) -->
              <div class="srr-evidence-block" id="srr-repro-block">
                <div class="srr-evidence-label">
                  Repro Method
                  <span id="srr-repro-required-marker" class="srr-repro-required">(required)</span>
                </div>
                <select class="srr-evidence-select" id="srr-repro-type" onchange="srrSaveEvidenceDraft()">
                  <option value="">-- Select repro method --</option>
                  <option value="breaks_salesforce_rule">Breaks Salesforce Rule</option>
                  <option value="breaks_qa_gate">Breaks QA Gate</option>
                  <option value="resolver_mismatch">Resolver Mismatch</option>
                  <option value="doc_evidence_mismatch">Doc Evidence Mismatch (attach file)</option>
                </select>
                <div class="srr-evidence-file-input" id="srr-repro-file-section">
                  <input type="file" id="srr-repro-file" accept=".pdf,.png,.jpg,.jpeg" onchange="srrHandleReproFile(this)">
                  <span id="srr-repro-file-name" style="font-size: 0.8em; color: #666;"></span>
                </div>
              </div>

              <!-- Spacer to push buttons lower -->
              <div style="flex-grow: 1; min-height: 20px;"></div>
              
              <!-- Submit Section (positioned lower) -->
              <div class="srr-patch-section" style="margin-top: auto; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                <div class="srr-actions">
                  <button class="srr-btn srr-btn-secondary" onclick="srrSaveDraft()">Save Draft</button>
                  <button class="srr-btn srr-btn-primary" id="srr-submit-btn" onclick="srrSubmitPatchRequest()">Submit Patch Request</button>
                </div>
              </div>
            </div><!-- end srr-tab-editor -->
            
            <!-- v1.5.1: Patch Tester Content (reviewer only) -->
            <div class="srr-panel-body" id="srr-tab-tester" style="display: none;">
              <div style="margin-bottom: 16px;">
                <div style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px;">Patch Summary</div>
                <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e0e0e0;">
                  <div style="margin-bottom: 8px;">
                    <span style="font-size: 0.75em; color: #888;">Field:</span>
                    <span id="srr-tester-field" style="font-weight: 600; margin-left: 6px; font-family: monospace;">â€”</span>
                  </div>
                  <div style="margin-bottom: 8px;">
                    <span style="font-size: 0.75em; color: #888;">Old Value:</span>
                    <span id="srr-tester-old-value" style="margin-left: 6px; color: #888; text-decoration: line-through;">â€”</span>
                  </div>
                  <div>
                    <span style="font-size: 0.75em; color: #888;">Proposed:</span>
                    <span id="srr-tester-proposed-value" style="margin-left: 6px; color: #2e7d32; font-weight: 600;">â€”</span>
                  </div>
                </div>
              </div>
              
              <div style="margin-bottom: 16px;">
                <div style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px;">Adjust New Value</div>
                <input type="text" id="srr-tester-new-value" class="srr-evidence-select" style="width: 100%; padding: 10px; border: 1px solid #4caf50; border-radius: 6px; font-family: monospace;" placeholder="Edit proposed value...">
                <div style="font-size: 0.75em; color: #888; margin-top: 4px;">Modify the proposed value before sending back for analyst confirmation.</div>
              </div>
              
              <div style="margin-bottom: 16px;">
                <div style="font-size: 0.75em; font-weight: 600; color: #666; text-transform: uppercase; margin-bottom: 8px;">Reviewer Notes to Analyst</div>
                <textarea id="srr-tester-notes" class="srr-evidence-textarea" placeholder="Explain why you're adjusting this patch or what the analyst should verify..." style="min-height: 100px;"></textarea>
              </div>
              
              <div style="flex-grow: 1; min-height: 20px;"></div>
              
              <div style="margin-top: auto; padding-top: 16px; border-top: 1px solid #e0e0e0;">
                <button class="srr-btn srr-btn-primary" style="width: 100%; background: #ff9800;" onclick="srrSendBackToAnalyst()">
                  â†© Send Back to Analyst
                </button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; text-align: center;">Item will appear in Analyst's Needs Clarification queue.</div>
              </div>
            </div><!-- end srr-tab-tester -->
          </div>
        </div>
        
        <!-- v1.6.7: Footer with file name -->
        <div class="srr-footer" id="srr-footer">
          <span id="srr-file-name" class="srr-footer-filename"></span>
        </div>
      </div><!-- end page-row -->

      <!-- PATCH STUDIO PAGE -->
      <div class="page" id="page-patch">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>Patch Studio</h2>
            <span style="font-size: 0.7em; color: #999;">PAGE: PATCH-STUDIO | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Select records, build rule patches, validate with preflight gate, and export.</p>
        </div>

        <div class="preflight-gate" id="preflight-gate">
          <div class="preflight-header">
            <h3>Preflight Gate (PR Checklist)</h3>
            <button class="preflight-toggle" id="preflight-toggle">Show</button>
          </div>
          <div class="preflight-body" id="preflight-body">
            <div class="preflight-checklist">
              <div class="preflight-item" data-step="1">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 1: Validate Config</div>
                  <div class="preflight-evidence" id="evidence-1"></div>
                </div>
              </div>
              <div class="preflight-item" data-step="2">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 2: Preview Baseline</div>
                  <div class="preflight-evidence" id="evidence-2"></div>
                </div>
              </div>
              <div class="preflight-item" data-step="3">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 3: Smoke Baseline</div>
                  <div class="preflight-evidence" id="evidence-3"></div>
                </div>
              </div>
              <div class="preflight-item" data-step="4">
                <div class="preflight-checkbox"></div>
                <div class="preflight-content">
                  <div class="preflight-label">Step 4: Smoke Edge</div>
                  <div class="preflight-evidence" id="evidence-4"></div>
                </div>
              </div>
            </div>
            <div class="preflight-paste">
              <label>Paste Terminal Output (auto-parses evidence)</label>
              <textarea id="preflight-paste-area" placeholder="Paste terminal output here to auto-extract evidence..."></textarea>
              <button class="preflight-parse-btn" id="preflight-parse">Parse Evidence</button>
            </div>
            <div class="preflight-actions">
              <button class="preflight-btn preflight-btn-secondary" id="preflight-reset">Reset All</button>
              <button class="preflight-btn preflight-btn-primary" id="preflight-copy-evidence">Copy Evidence Summary</button>
            </div>
            <div class="preflight-summary" id="preflight-summary"></div>
          </div>
        </div>

        <div class="patch-studio-inline" id="patch-studio-inline">
          <h3>Patch Draft Builder</h3>
          <p class="page-desc">Open Record Workbench from Triage page to select records and add rules.</p>
          <div id="patch-draft-summary"></div>
          <div class="patch-studio-inline-actions">
            <button class="toolbar-btn" id="copy-patch-json">Copy Patch JSON</button>
            <button class="toolbar-btn" id="copy-pr-summary">Copy PR Summary</button>
          </div>
        </div>
      </div><!-- end page-patch -->

      <!-- REVIEW PAGE -->
      <div class="page" id="page-review">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>Review</h2>
            <span style="font-size: 0.7em; color: #999;">PAGE: CONFIG-INSPECTOR | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Inspect config deltas, compare artifact versions, and generate evidence summaries.</p>
        </div>

        <div class="config-inspector" id="config-inspector">
          <div class="config-inspector-header">
            <h3>Config + Patch Inspector (Ruleset Delta)</h3>
            <button class="config-inspector-toggle" id="config-inspector-toggle">Show</button>
          </div>
          <div class="config-inspector-body" id="config-inspector-body">
            <div class="config-inspector-row">
              <div class="config-inspector-field">
                <label>Base Config Path</label>
                <input type="text" id="base-config-path" value="config/config_pack.base.json" placeholder="config/config_pack.base.json">
              </div>
              <div class="config-inspector-field">
                <label>Patch Path</label>
                <input type="text" id="patch-path" value="config/config_pack.example.patch.json" placeholder="config/config_pack.example.patch.json">
              </div>
              <div class="config-inspector-actions">
                <button class="config-inspector-btn config-inspector-btn-primary" id="load-config">Load Config</button>
                <button class="config-inspector-btn config-inspector-btn-secondary" id="clear-config">Clear</button>
              </div>
            </div>
            <div class="config-inspector-status" id="config-status" style="display: none;"></div>
            <div id="config-results" style="display: none;">
              <div class="patch-summary" id="patch-summary"></div>
              <div class="ruleset-delta" id="ruleset-delta"></div>
              <div class="table-container">
                <table class="changes-table" id="changes-table"></table>
              </div>
              <div class="config-inspector-copy-actions">
                <button class="config-copy-btn" id="copy-ruleset-delta">Copy Ruleset Delta (Markdown)</button>
              </div>
            </div>
          </div>
        </div>

        <div class="session-loader" id="session-loader">
          <div class="session-loader-header">
            <h3>Session Loader (Comparison Mode)</h3>
            <button class="session-loader-toggle" id="session-loader-toggle">Show</button>
          </div>
          <div class="session-loader-body" id="session-loader-body">
            <div class="session-loader-row">
              <div class="session-loader-field">
                <label>Primary Artifact Path</label>
                <input type="text" id="primary-path" value="out/sf_packet.preview.json" placeholder="out/sf_packet.preview.json">
              </div>
              <div class="session-loader-field">
                <label>Comparison Artifact Path (optional)</label>
                <input type="text" id="compare-path" placeholder="out/sf_packet.preview.prev.json">
              </div>
              <div class="session-loader-actions">
                <button class="session-loader-btn session-loader-btn-primary" id="load-session">Load</button>
                <button class="session-loader-btn session-loader-btn-secondary" id="clear-compare">Clear Compare</button>
              </div>
            </div>
            <div class="session-loader-status" id="session-status" style="display: none;"></div>
          </div>
        </div>

        <div id="review-evidence-summary" class="evidence-summary-panel"></div>
      </div><!-- end page-review -->

      <!-- VERIFIER REVIEW PAGE -->
      <div class="page" id="page-verifier-review">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <button class="srr-back-btn" onclick="navigateBackFromVerifierReview()" style="padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.85em;">â† Back</button>
              <h2 style="margin: 0;">Verifier Review</h2>
              <span class="vr-state-badge" id="vr-state-badge">Submitted</span>
            </div>
            <span style="font-size: 0.7em; color: #999;">PAGE: VERIFIER-REVIEW | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Review submitted Patch Requests, request clarification, approve or reject.</p>
        </div>

        <div class="vr-container" id="vr-container">
          <!-- Left Column: Type-Specific Content -->
          <div>
            <!-- Payload Type Badge -->
            <div style="margin-bottom: 16px;">
              <span id="vr-type-badge" style="display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; font-weight: 600; background: #1565c0; color: white;">CORRECTION</span>
              <button id="vr-open-srr-btn" onclick="vrOpenSingleRowReview()" style="margin-left: 12px; padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Open Single Row Review</button>
            </div>

            <!-- RFI Content Block -->
            <div id="vr-rfi-content" style="display: none;">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">â“</span> RFI Details</div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Field</div>
                  <div class="vr-intent-value" id="vr-rfi-field">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Current Value</div>
                  <div class="vr-intent-value" id="vr-rfi-value">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Question</div>
                  <div class="vr-intent-value" id="vr-rfi-comment">â€”</div>
                </div>
              </div>

              <!-- Comment Thread Stub -->
              <div class="vr-section" style="margin-top: 16px;">
                <div class="vr-section-header"><span class="icon">ðŸ’¬</span> Comment Thread</div>
                <div id="vr-comment-thread" style="display: flex; flex-direction: column; gap: 12px;">
                  <div style="display: flex; gap: 10px; align-items: flex-start;">
                    <div style="width: 32px; height: 32px; border-radius: 50%; background: #e3f2fd; display: flex; align-items: center; justify-content: center; font-size: 0.8em; color: #1565c0; flex-shrink: 0;">A</div>
                    <div style="flex: 1;">
                      <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: 600; font-size: 0.85em;">Analyst</span>
                        <span style="font-size: 0.75em; color: #999;">(coming soon)</span>
                      </div>
                      <div style="background: #f5f5f5; padding: 10px 14px; border-radius: 12px; font-size: 0.9em; color: #666;">Thread messages will appear here...</div>
                    </div>
                  </div>
                  <div style="display: flex; gap: 10px; align-items: flex-start;">
                    <div style="width: 32px; height: 32px; border-radius: 50%; background: #fff3e0; display: flex; align-items: center; justify-content: center; font-size: 0.8em; color: #f57c00; flex-shrink: 0;">V</div>
                    <div style="flex: 1;">
                      <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
                        <span style="font-weight: 600; font-size: 0.85em;">Verifier</span>
                        <span style="font-size: 0.75em; color: #999;">(coming soon)</span>
                      </div>
                      <div style="background: #fff3e0; padding: 10px 14px; border-radius: 12px; font-size: 0.9em; color: #666;">Verifier responses will appear here...</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Correction Content Block -->
            <div id="vr-correction-content" style="display: none;">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">âœï¸</span> Correction Details</div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Field</div>
                  <div class="vr-intent-value" id="vr-corr-field">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Old Value</div>
                  <div class="vr-intent-value" id="vr-corr-old" style="color: #999; text-decoration: line-through;">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">New Value</div>
                  <div class="vr-intent-value" id="vr-corr-new" style="color: #2e7d32; font-weight: 600;">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Justification</div>
                  <div class="vr-intent-value" id="vr-corr-comment">â€”</div>
                </div>
              </div>
            </div>

            <!-- Blacklist Content Block -->
            <div id="vr-blacklist-content" style="display: none;">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">ðŸš«</span> Blacklist Details</div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Field</div>
                  <div class="vr-intent-value" id="vr-bl-field">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Value</div>
                  <div class="vr-intent-value" id="vr-bl-value">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Blacklist Subject</div>
                  <div class="vr-intent-value" id="vr-bl-subject" style="color: #d32f2f;">â€”</div>
                </div>
                <div class="vr-intent-block">
                  <div class="vr-intent-label">Justification</div>
                  <div class="vr-intent-value" id="vr-bl-comment">â€”</div>
                </div>
              </div>
            </div>

            <!-- Legacy Evidence Pack (for sample data fallback) -->
            <div id="vr-legacy-content">
              <div class="vr-section">
                <div class="vr-section-header"><span class="icon">ðŸ“‹</span> Structured Intent</div>
                <div id="vr-intent-blocks">
                  <div class="vr-intent-block">
                    <div class="vr-intent-label">Observation (WHEN)</div>
                    <div class="vr-intent-value" id="vr-intent-when">â€”</div>
                  </div>
                  <div class="vr-intent-block">
                    <div class="vr-intent-label">Expected (THEN)</div>
                    <div class="vr-intent-value" id="vr-intent-then">â€”</div>
                  </div>
                  <div class="vr-intent-block">
                    <div class="vr-intent-label">Justification (BECAUSE)</div>
                    <div class="vr-intent-value" id="vr-intent-because">â€”</div>
                  </div>
                </div>
              </div>

              <div class="vr-section" style="margin-top: 16px;">
                <div class="vr-section-header"><span class="icon">ðŸ“Ž</span> Evidence Pack</div>
                <div id="vr-evidence-blocks">
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Observation</div>
                    <div class="vr-evidence-text" id="vr-ev-observation">â€”</div>
                  </div>
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Expected</div>
                    <div class="vr-evidence-text" id="vr-ev-expected">â€”</div>
                  </div>
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Justification</div>
                    <div class="vr-evidence-text" id="vr-ev-justification">â€”</div>
                  </div>
                  <div class="vr-evidence-block">
                    <div class="vr-evidence-label">Repro</div>
                    <div class="vr-evidence-text" id="vr-ev-repro">â€”</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Column: Preflight + Author + Revisions + Notes + Actions -->
          <div>
            <!-- Preflight Report -->
            <div class="vr-section">
              <div class="vr-section-header"><span class="icon">âœ…</span> Preflight Report</div>
              <div id="vr-preflight-badges" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <span class="vr-preflight-badge pass">Schema âœ“</span>
                <span class="vr-preflight-badge pass">Conflicts âœ“</span>
                <span class="vr-preflight-badge pass">Evidence âœ“</span>
              </div>
            </div>

            <!-- Author Info -->
            <div class="vr-section" style="margin-top: 16px;">
              <div class="vr-section-header"><span class="icon">ðŸ‘¤</span> Author Info</div>
              <div class="vr-author-info">
                <div><span class="vr-author-label">Submitted by:</span> <span class="vr-author-value" id="vr-author-name">analyst@example.com</span></div>
                <div><span class="vr-author-label">Submitted at:</span> <span class="vr-author-value" id="vr-author-time">â€”</span></div>
                <div><span class="vr-author-label">Patch ID:</span> <span class="vr-author-value" id="vr-patch-id" style="font-family: monospace;">â€”</span></div>
              </div>
            </div>

            <!-- Revision History -->
            <div class="vr-section" style="margin-top: 16px;">
              <div class="vr-section-header"><span class="icon">ðŸ“œ</span> Revision History</div>
              <div id="vr-revisions">
                <div class="vr-empty-state">No previous revisions</div>
              </div>
            </div>

            <!-- Review Notes -->
            <div class="vr-section" style="margin-top: 16px;">
              <div class="vr-section-header"><span class="icon">ðŸ“</span> Review Notes</div>
              <textarea class="vr-notes-area" id="vr-notes" placeholder="Add notes for this review (visible to author if clarification requested)..."></textarea>
            </div>
          </div>

          <!-- Full-Width: Actions Panel -->
          <div class="vr-full-width">
            <div class="vr-actions-panel">
              <div class="vr-actions-header">Verifier Actions</div>
              <div class="vr-actions-grid">
                <button class="vr-action-btn begin" id="vr-btn-begin" onclick="vrBeginReview()">Begin Review</button>
                <button class="vr-action-btn clarify" id="vr-btn-clarify" onclick="vrRequestClarification()" disabled>Request Clarification</button>
                <button class="vr-action-btn approve" id="vr-btn-approve" onclick="vrApprove()" disabled>Approve (Verifier)</button>
                <button class="vr-action-btn reject" id="vr-btn-reject" onclick="vrReject()" disabled>Reject</button>
              </div>
              <div id="vr-decision-summary" style="margin-top: 12px;"></div>
            </div>
          </div>
        </div>
      </div><!-- end page-verifier-review -->

      <!-- Verifier Review Clarification Modal -->
      <div class="vr-clarify-modal" id="vr-clarify-modal">
        <div class="vr-clarify-modal-content">
          <h4>Request Clarification</h4>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 12px;">Describe what information or evidence is needed from the author.</p>
          <textarea id="vr-clarify-text" placeholder="What clarification is needed?"></textarea>
          <div class="vr-clarify-modal-actions">
            <button class="vr-action-btn" style="background: #e0e0e0; color: #333;" onclick="vrClarifyCancel()">Cancel</button>
            <button class="vr-action-btn clarify" onclick="vrClarifySubmit()">Send Request</button>
          </div>
        </div>
      </div>

      <!-- ADMIN APPROVAL PAGE -->
      <div class="page" id="page-admin-approval">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <button class="srr-back-btn" onclick="navigateTo('triage')" style="padding: 6px 12px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.85em;">â† Back</button>
              <h2 style="margin: 0;">Admin Approval</h2>
              <span class="aa-state-badge" id="aa-state-badge">Verifier Approved</span>
            </div>
            <span style="font-size: 0.7em; color: #999;">PAGE: ADMIN-APPROVAL | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Final approval surface before Promote Patch to Baseline.</p>
        </div>

        <div class="aa-container" id="aa-container">
          <!-- Left Column: Intent + Evidence -->
          <div>
            <!-- Structured Intent -->
            <div class="aa-section">
              <div class="aa-section-header"><span class="icon">ðŸ“‹</span> Structured Intent</div>
              <div id="aa-intent-blocks">
                <div class="aa-intent-block">
                  <div class="aa-intent-label">Observation (WHEN)</div>
                  <div class="aa-intent-value" id="aa-intent-when">â€”</div>
                </div>
                <div class="aa-intent-block">
                  <div class="aa-intent-label">Expected (THEN)</div>
                  <div class="aa-intent-value" id="aa-intent-then">â€”</div>
                </div>
                <div class="aa-intent-block">
                  <div class="aa-intent-label">Justification (BECAUSE)</div>
                  <div class="aa-intent-value" id="aa-intent-because">â€”</div>
                </div>
              </div>
            </div>

            <!-- Evidence Pack -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">ðŸ“Ž</span> Evidence Pack</div>
              <div id="aa-evidence-blocks">
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Observation</div>
                  <div class="aa-evidence-text" id="aa-ev-observation">â€”</div>
                </div>
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Expected</div>
                  <div class="aa-evidence-text" id="aa-ev-expected">â€”</div>
                </div>
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Justification</div>
                  <div class="aa-evidence-text" id="aa-ev-justification">â€”</div>
                </div>
                <div class="aa-evidence-block">
                  <div class="aa-evidence-label">Repro</div>
                  <div class="aa-evidence-text" id="aa-ev-repro">â€”</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right Column: Verifier Decision + Preflight + Smoke + Changelog + Revisions -->
          <div>
            <!-- Verifier Decision -->
            <div class="aa-section">
              <div class="aa-section-header"><span class="icon">âœ“</span> Verifier Decision</div>
              <div class="aa-verifier-decision" id="aa-verifier-decision">
                <div class="aa-verifier-decision-header">Approved by Verifier</div>
                <div style="font-size: 0.85em; color: #666;">
                  <div><strong>Verifier:</strong> <span id="aa-verifier-name">verifier@example.com</span></div>
                  <div><strong>Approved at:</strong> <span id="aa-verifier-time">â€”</span></div>
                  <div><strong>Notes:</strong> <span id="aa-verifier-notes">All checklist items confirmed.</span></div>
                </div>
              </div>
            </div>

            <!-- Preflight Report -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">âœ…</span> Preflight Report</div>
              <div id="aa-preflight-badges" style="display: flex; flex-wrap: wrap; gap: 8px;">
                <span class="aa-preflight-badge pass">Schema âœ“</span>
                <span class="aa-preflight-badge pass">Conflicts âœ“</span>
                <span class="aa-preflight-badge pass">Evidence âœ“</span>
              </div>
            </div>

            <!-- Smoke (Strict) Status -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">ðŸ”¥</span> Smoke (Strict) Status</div>
              <div class="aa-smoke-status pass" id="aa-smoke-status">
                <span class="aa-smoke-icon">âœ“</span>
                <div>
                  <div class="aa-smoke-label">Smoke (Strict) Passing</div>
                  <div style="font-size: 0.8em; color: #666;">Last run: <span id="aa-smoke-time">â€”</span></div>
                </div>
              </div>
            </div>

            <!-- Patch Replay Gate (v1.4.17) -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">ðŸ”„</span> Patch Replay</div>
              <div class="aa-replay-status not-run" id="aa-replay-status">
                <span class="aa-replay-badge not-run" id="aa-replay-badge">NOT RUN</span>
                <span id="aa-replay-status-text">Replay evaluation not yet performed</span>
              </div>
              <button class="aa-replay-btn" id="aa-replay-btn" onclick="aaRunReplay()">Run Replay</button>
              
              <!-- Replay Packet (checks list) -->
              <div class="aa-replay-packet" id="aa-replay-packet" style="display: none;">
                <div class="aa-replay-check pass" id="aa-replay-check-schema">
                  <span class="aa-replay-check-icon">âœ“</span>
                  <span class="aa-replay-check-label">Schema Validation</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-conflicts">
                  <span class="aa-replay-check-icon">âœ“</span>
                  <span class="aa-replay-check-label">Conflict Detection</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-baseline">
                  <span class="aa-replay-check-icon">âœ“</span>
                  <span class="aa-replay-check-label">Baseline Compatibility</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-rules">
                  <span class="aa-replay-check-icon">âœ“</span>
                  <span class="aa-replay-check-label">Rule Evaluation</span>
                </div>
                <div class="aa-replay-check pass" id="aa-replay-check-output">
                  <span class="aa-replay-check-icon">âœ“</span>
                  <span class="aa-replay-check-label">Output Determinism</span>
                </div>
              </div>
              
              <!-- Failure Reason (shown only on FAIL) -->
              <div class="aa-replay-failure-reason" id="aa-replay-failure-reason" style="display: none;">
                <div class="aa-replay-failure-reason-header">Failure Reason</div>
                <div id="aa-replay-failure-text">â€”</div>
                <div style="margin-top: 8px; font-size: 0.8em;">
                  <a href="#" onclick="aaShowReplayAuditLog(); return false;">View in Audit Log â†’</a>
                </div>
              </div>
            </div>

            <!-- Changelog Preview -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">ðŸ“</span> Changelog Preview</div>
              <div class="aa-changelog-preview" id="aa-changelog-preview">## [1.4.6] - 2026-02-03

### Changed
- SF_R1_LABEL_NOT_ARTIST: Updated label_vendor requirement for LICENSING contracts</div>
            </div>

            <!-- Revision History -->
            <div class="aa-section" style="margin-top: 16px;">
              <div class="aa-section-header"><span class="icon">ðŸ“œ</span> Revision History</div>
              <div id="aa-revisions">
                <div style="font-size: 0.85em; color: #666;">No previous revisions</div>
              </div>
            </div>
          </div>

          <!-- Full-Width: Admin Notes + Actions -->
          <div class="aa-full-width">
            <div class="aa-section">
              <div class="aa-section-header"><span class="icon">ðŸ“</span> Admin Notes</div>
              <textarea class="aa-notes-area" id="aa-notes" placeholder="Add admin notes (visible in audit log)..."></textarea>
            </div>

            <div class="aa-actions-panel">
              <div class="aa-actions-header">Admin Actions</div>
              <div class="aa-actions-grid">
                <button class="aa-action-btn approve" id="aa-btn-approve" onclick="aaAdminApprove()">Admin Approve</button>
                <button class="aa-action-btn hold" id="aa-btn-hold" onclick="aaAdminHold()">Admin Hold</button>
                <button class="aa-action-btn release" id="aa-btn-release" onclick="aaReleaseHold()" disabled>Release Hold</button>
                <button class="aa-action-btn promote" id="aa-btn-promote" onclick="aaPromoteToBaseline()" disabled>Promote Patch to Baseline</button>
              </div>
              <div id="aa-decision-summary" style="margin-top: 12px;"></div>
            </div>
          </div>
        </div>
      </div><!-- end page-admin-approval -->

      <!-- Admin Hold Modal -->
      <div class="aa-hold-modal" id="aa-hold-modal">
        <div class="aa-hold-modal-content">
          <h4>Admin Hold</h4>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 12px;">Describe why this patch is being placed on hold.</p>
          <textarea id="aa-hold-text" placeholder="Hold reason..."></textarea>
          <div class="aa-hold-modal-actions">
            <button class="aa-action-btn" style="background: #e0e0e0; color: #333;" onclick="aaHoldCancel()">Cancel</button>
            <button class="aa-action-btn hold" onclick="aaHoldSubmit()">Place on Hold</button>
          </div>
        </div>
      </div>

      <!-- ADMIN PAGE (Console) -->
      <div class="page" id="page-admin">
        <div class="page-header">
          <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h2>Admin Panel</h2>
            <span style="font-size: 0.7em; color: #999;">PAGE: ADMIN-PANEL | BUILD v1.6.28</span>
          </div>
          <p class="page-desc">Centralized admin tools for governance, config, standardization, and patch management.</p>
        </div>

        <!-- Admin Panel Tabs -->
        <div class="admin-console-tabs" style="display: flex; gap: 4px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; padding-bottom: 0;">
          <button class="admin-tab active" data-admin-tab="governance" onclick="switchAdminTab('governance')" style="padding: 10px 20px; background: #1976d2; color: white; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-weight: 600;">Governance</button>
          <button class="admin-tab" data-admin-tab="users" onclick="switchAdminTab('users')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Users</button>
          <button class="admin-tab" data-admin-tab="patch-queue" onclick="switchAdminTab('patch-queue')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Patch Queue <span id="patch-queue-count" style="display:none; background:#e91e63; color:white; padding:1px 6px; border-radius:10px; font-size:0.8em; margin-left:4px;">0</span></button>
          <button class="admin-tab" data-admin-tab="config" onclick="switchAdminTab('config')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Config</button>
          <button class="admin-tab" data-admin-tab="inspector" onclick="switchAdminTab('inspector')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Inspector</button>
          <button class="admin-tab" data-admin-tab="standardizer" onclick="switchAdminTab('standardizer')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Standardizer</button>
          <button class="admin-tab" data-admin-tab="patch-console" onclick="switchAdminTab('patch-console')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Patch Console</button>
          <button class="admin-tab" data-admin-tab="evidence" onclick="switchAdminTab('evidence')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Evidence</button>
          <button class="admin-tab" data-admin-tab="unknown-cols" onclick="switchAdminTab('unknown-cols')" style="padding: 10px 20px; background: #f5f5f5; color: #666; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">Unknown Cols</button>
        </div>

        <!-- GOVERNANCE TAB -->
        <div id="admin-tab-governance" class="admin-tab-panel" data-admin-section="true">
        <!-- Masterline / Artifact Registry Section -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 1.1em; color: #333;">Artifact Registry <span class="info-icon" title="Manage the master artifacts that drive the semantic control board. When Dev Masterline is enabled, artifacts are auto-loaded from repository paths.">&#9432;</span></h3>
            <div style="display: flex; align-items: center; gap: 10px;">
              <label class="toggle-label" style="font-size: 0.85em; color: #666;">Dev Masterline</label>
              <label class="toggle-switch">
                <input type="checkbox" id="dev-masterline-toggle" onchange="toggleDevMasterline()">
                <span class="toggle-slider"></span>
              </label>
              <span id="dev-masterline-status" class="masterline-status on">ON</span>
            </div>
          </div>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">When enabled, master artifacts are auto-loaded from repository on startup. Rebind paths if files are in different locations.</p>
          <div id="artifact-registry-table"></div>
          <div style="margin-top: 15px; display: flex; gap: 10px;">
            <button class="toolbar-btn" onclick="checkAllArtifacts()">Refresh Status</button>
            <button class="toolbar-btn" onclick="masterlineAutoload()">Reload All</button>
          </div>
        </div>

        <!-- Workflow Map Section -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Workflow Map <span class="info-icon" title="Visual overview of the semantic governance pipeline. Each step shows required artifacts and their status.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Understand the end-to-end governance pipeline at a glance. Click any step to navigate.</p>
          <div id="workflow-map" class="workflow-map"></div>
        </div>

        <!-- Demo Dataset Toggle (v1.6.4) -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; font-size: 1.1em; color: #333;">Demo Dataset <span class="info-icon" title="Toggle between the Original (blank baseline) and Modified (in-progress) demo datasets. The modified dataset contains sample audit log entries.">&#9432;</span></h3>
            <span id="demo-mode-badge" style="display: none; font-size: 0.7em; background: #ff9800; color: white; padding: 3px 8px; border-radius: 4px; font-weight: 600;">Demo: Modified (In-Progress)</span>
          </div>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Switch between Original (clean baseline) and Modified (in-progress with audit log data) demo datasets.</p>
          <div style="display: flex; gap: 10px; align-items: center;">
            <button id="demo-toggle-original" class="toolbar-btn" onclick="setDemoMode('original')" style="flex: 1;">Original (Baseline)</button>
            <button id="demo-toggle-modified" class="toolbar-btn" onclick="setDemoMode('modified')" style="flex: 1;">Modified (In-Progress)</button>
          </div>
          <div id="demo-partial-banner" style="display: none; margin-top: 12px; padding: 10px; background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; font-size: 0.85em; color: #e65100;">
            âš ï¸ Demo dataset is in-progress (partial completion). Audit log entries show sample data.
          </div>
        </div>

        <!-- Governance Notes -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Governance Notes</h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Admin-level notes and overrides are recorded here.</p>
          <div id="admin-governance-notes" style="background: #f9f9f9; padding: 15px; border-radius: 6px; min-height: 60px;">
            <em style="color: #888;">No governance notes recorded.</em>
          </div>
        </div>

        <!-- Quick Actions -->
        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Quick Actions</h3>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="toolbar-btn" onclick="document.getElementById('btn-run')?.click()">Run Commands</button>
            <button class="toolbar-btn" onclick="switchAdminTab('inspector')">Open Inspector</button>
          </div>
        </div>
        </div><!-- end admin-tab-governance -->

        <!-- USERS TAB (v1.4.21) -->
        <div id="admin-tab-users" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <!-- Environment Mode Toggle (v1.6.17) -->
          <div class="admin-section" style="background: white; padding: 16px 20px; border-radius: 8px; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h4 style="margin: 0 0 4px 0; font-size: 0.95em; color: #333;">Environment Mode</h4>
                <p style="margin: 0; font-size: 0.8em; color: #666;">Playground mode enables user management. Production mode is read-only.</p>
              </div>
              <div id="env-mode-toggle" style="display: flex; border: 1px solid #ddd; border-radius: 6px; overflow: hidden;">
                <button id="env-mode-prod" onclick="setEnvMode('production')" style="padding: 8px 16px; border: none; background: #f5f5f5; color: #666; cursor: pointer; font-size: 0.85em; font-weight: 500;">Production</button>
                <button id="env-mode-playground" onclick="setEnvMode('playground')" style="padding: 8px 16px; border: none; background: #f5f5f5; color: #666; cursor: pointer; font-size: 0.85em; font-weight: 500;">Playground</button>
              </div>
            </div>
          </div>
          
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
              <h3 style="margin: 0; font-size: 1.1em; color: #333;">User Access <span class="info-icon" title="Manage user roles. In Playground mode, changes are stored locally.">&#9432;</span></h3>
              <div id="add-user-btn-container" style="display: flex; gap: 10px; align-items: center;">
                <button id="add-user-btn" class="toolbar-btn" onclick="openAddUserModal()" style="background: #4caf50; color: white; padding: 8px 14px; font-size: 0.85em; display: flex; align-items: center; gap: 6px;">
                  <span style="font-size: 1.1em;">+</span> Add User
                </button>
              </div>
            </div>
            <p id="users-mode-desc" style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Assign roles to users. Changes persist in local storage only.</p>
            
            <div id="users-table-container" style="border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                <thead style="background: #f5f5f5;">
                  <tr>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 20%;">User</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 28%;">Email</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 18%;">Role</th>
                    <th style="padding: 12px 8px; text-align: center; border-bottom: 1px solid #e0e0e0; width: 14%;">Status</th>
                    <th style="padding: 12px 8px; text-align: center; border-bottom: 1px solid #e0e0e0; width: 20%;">Actions</th>
                  </tr>
                </thead>
                <tbody id="users-table-body">
                </tbody>
              </table>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center;">
              <button class="toolbar-btn" onclick="resetDemoUsers()">Reset to Defaults</button>
              <span style="font-size: 0.8em; color: #888;">Last updated: <span id="users-last-updated">â€”</span></span>
            </div>
          </div>
        </div><!-- end admin-tab-users -->

        <!-- ADD USER MODAL (v1.6.16) -->
        <div id="add-user-modal" class="modal-overlay">
          <div class="modal" style="max-width: 450px;">
            <div class="modal-header">
              <h3>Add New User</h3>
              <button class="modal-close" onclick="closeAddUserModal()">&times;</button>
            </div>
            <div class="modal-body">
              <div id="add-user-error" style="display: none; background: #ffebee; color: #c62828; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.9em;"></div>
              
              <div style="margin-bottom: 15px;">
                <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Full Name <span style="color: #c62828;">*</span></label>
                <input type="text" id="add-user-name" placeholder="e.g. Jane Smith" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em; box-sizing: border-box;">
              </div>
              
              <div style="margin-bottom: 15px;">
                <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Email <span style="color: #c62828;">*</span></label>
                <input type="email" id="add-user-email" placeholder="e.g. jane.smith@company.com" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em; box-sizing: border-box;">
              </div>
              
              <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                <div style="flex: 1;">
                  <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Role</label>
                  <select id="add-user-role" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em;">
                    <option value="analyst" selected>Analyst</option>
                    <option value="reviewer">Reviewer</option>
                    <option value="admin">Admin</option>
                  </select>
                </div>
                <div style="flex: 1;">
                  <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Status</label>
                  <select id="add-user-status" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em;">
                    <option value="active" selected>Active</option>
                    <option value="pending">Pending</option>
                    <option value="disabled">Disabled</option>
                  </select>
                </div>
              </div>
              
              <div style="margin-bottom: 20px;">
                <label style="display: block; font-size: 0.85em; font-weight: 600; color: #333; margin-bottom: 6px;">Division <span style="color: #888; font-weight: 400;">(optional)</span></label>
                <input type="text" id="add-user-division" placeholder="e.g. Operations" style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95em; box-sizing: border-box;">
              </div>
              
              <div style="background: #fff3e0; padding: 10px 12px; border-radius: 4px; font-size: 0.8em; color: #e65100; margin-bottom: 15px;">
                <strong>Pre-provisioned:</strong> This user will be ready when real authentication is enabled. The system will match by email.
              </div>
              
              <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="modal-btn modal-btn-secondary" onclick="closeAddUserModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="submitAddUser()" style="background: #4caf50;">Add User</button>
              </div>
            </div>
          </div>
        </div>

        <!-- PATCH QUEUE TAB (v1.5.1) -->
        <div id="admin-tab-patch-queue" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Patch Queue <span class="info-icon" title="Patch requests approved by Verifiers awaiting final Admin approval.">&#9432;</span></h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Review Correction and Blacklist patch requests approved by Verifiers.</p>
            
            <div id="patch-queue-table-container" style="max-height: 400px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                <thead style="background: #f5f5f5; position: sticky; top: 0;">
                  <tr>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Type</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Record ID</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Field</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Old â†’ New</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Comment</th>
                    <th style="padding: 12px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Submitted</th>
                    <th style="padding: 12px 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Actions</th>
                  </tr>
                </thead>
                <tbody id="patch-queue-tbody">
                  <tr><td colspan="7" style="padding: 20px; text-align: center; color: #888;">No items pending Admin review</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div><!-- end admin-tab-patch-queue -->

        <!-- PATCH CONSOLE TAB -->
        <div id="admin-tab-patch-console" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Patch Requests Console <span class="info-icon" title="Manage patch requests through their lifecycle. Track requests from creation through Kiwi processing to final application.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Track and manage patch requests. Batch export to Kiwi, import returns, and apply changes.</p>
          
          <!-- Queue Tabs -->
          <div id="patch-queue-tabs" style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px;">
            <button class="queue-tab active" data-queue="new" onclick="switchPatchQueueTab('new')">New <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="needs_review" onclick="switchPatchQueueTab('needs_review')">Needs Review <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="approved" onclick="switchPatchQueueTab('approved')">Approved <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="sent_to_kiwi" onclick="switchPatchQueueTab('sent_to_kiwi')">Sent to Kiwi <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="kiwi_returned" onclick="switchPatchQueueTab('kiwi_returned')">Kiwi Returned <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="applied" onclick="switchPatchQueueTab('applied')">Applied <span class="queue-count">0</span></button>
            <button class="queue-tab" data-queue="rejected" onclick="switchPatchQueueTab('rejected')">Rejected <span class="queue-count">0</span></button>
          </div>
          
          <!-- Batch Actions -->
          <div id="patch-batch-actions" style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
            <button class="toolbar-btn" onclick="selectAllCurrentQueue()">Select All</button>
            <button class="toolbar-btn" onclick="clearPatchRequestSelection(); renderPatchConsoleTable();">Clear Selection</button>
            <button class="toolbar-btn" onclick="batchMarkSentToKiwi()" style="background: #1565c0;">Export to Kiwi (Copy)</button>
            <button class="toolbar-btn" onclick="openKiwiReturnInbox()" style="background: #7b1fa2;">Paste Kiwi Return</button>
            <button class="toolbar-btn" onclick="batchMarkApplied()" style="background: #2e7d32;">Mark Applied</button>
            <button class="toolbar-btn" onclick="batchCopyCommitPack()" style="background: #f57c00;">Copy Batch Commit Pack</button>
          </div>
          
          <!-- Compact Table -->
          <div id="patch-console-table-container" style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px;">
            <table id="patch-console-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
              <thead style="background: #f5f5f5; position: sticky; top: 0;">
                <tr>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0; width: 40px;"><input type="checkbox" id="patch-select-all" onchange="toggleSelectAllPatches(this.checked)"></th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">ID</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Intent</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Target</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Status</th>
                  <th style="padding: 10px 8px; text-align: left; border-bottom: 1px solid #e0e0e0;">Updated</th>
                  <th style="padding: 10px 8px; text-align: center; border-bottom: 1px solid #e0e0e0;">Actions</th>
                </tr>
              </thead>
              <tbody id="patch-console-tbody">
                <tr><td colspan="7" style="padding: 20px; text-align: center; color: #888;">No patch requests in this queue</td></tr>
              </tbody>
            </table>
          </div>
          
          <!-- Summary Stats -->
          <div id="patch-console-summary" style="margin-top: 15px; display: flex; gap: 20px; flex-wrap: wrap; font-size: 0.85em; color: #666;">
            <span>Total: <strong id="patch-total-count">0</strong></span>
            <span>Selected: <strong id="patch-selected-count">0</strong></span>
            <span>Comments Open: <strong id="comments-open-count">0</strong></span>
          </div>
        </div>
        
        <!-- Kiwi Return Inbox Modal -->
        <div id="kiwi-return-inbox-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Paste Kiwi Return</h3>
              <button class="modal-close" onclick="closeKiwiReturnInbox()">&times;</button>
            </div>
            <div class="modal-body">
              <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">Paste the JSON returned from Kiwi. Each request will be matched by request_id and updated.</p>
              <textarea id="kiwi-return-textarea" placeholder="Paste Kiwi return JSON here..." style="width: 100%; height: 200px; font-family: monospace; font-size: 0.85em; padding: 10px; border: 1px solid #ddd; border-radius: 6px;"></textarea>
              <div id="kiwi-return-status" style="margin-top: 10px; display: none; padding: 10px; border-radius: 6px;"></div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
              <button class="toolbar-btn" onclick="closeKiwiReturnInbox()">Cancel</button>
              <button class="toolbar-btn" onclick="processKiwiReturn()" style="background: #7b1fa2;">Process Return</button>
            </div>
          </div>
        </div>
        
        <!-- Add Comment Modal -->
        <div id="add-comment-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Add Comment (RFI)</h3>
              <button class="modal-close" onclick="closeAddCommentModal()">&times;</button>
            </div>
            <div class="modal-body">
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">Target</label>
                <div id="comment-target-display" style="font-family: monospace; font-size: 0.9em; padding: 8px; background: #f5f5f5; border-radius: 4px;"></div>
              </div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">Comment</label>
                <textarea id="comment-content-input" placeholder="Describe your question or clarification request..." style="width: 100%; height: 100px; font-size: 0.9em; padding: 10px; border: 1px solid #ddd; border-radius: 6px;"></textarea>
              </div>
              <input type="hidden" id="comment-target-type">
              <input type="hidden" id="comment-target-id">
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
              <button class="toolbar-btn" onclick="closeAddCommentModal()">Cancel</button>
              <button class="toolbar-btn" onclick="submitNewComment()" style="background: #1976d2;">Add Comment</button>
            </div>
          </div>
        </div>
        
        <!-- Elevate to Patch Request Modal -->
        <div id="elevate-to-patch-modal" class="modal-overlay" style="display: none;">
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Elevate to Patch Request</h3>
              <button class="modal-close" onclick="closeElevateToPatchModal()">&times;</button>
            </div>
            <div class="modal-body">
              <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">Create a patch request from this resolved comment. Fill in the intent of the change.</p>
              <div id="elevate-comment-preview" style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 0.9em;"></div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">WHEN (Condition)</label>
                <input type="text" id="elevate-intent-when" placeholder="e.g., field 'label' contains 'Artist'" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">THEN (Action)</label>
                <input type="text" id="elevate-intent-then" placeholder="e.g., set 'label' to 'Record Label'" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <div style="margin-bottom: 15px;">
                <label style="font-size: 0.85em; color: #666; display: block; margin-bottom: 5px;">BECAUSE (Reason)</label>
                <input type="text" id="elevate-intent-because" placeholder="e.g., 'Artist' is reserved for performer names" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <input type="hidden" id="elevate-comment-id">
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
              <button class="toolbar-btn" onclick="closeElevateToPatchModal()">Cancel</button>
              <button class="toolbar-btn" onclick="submitElevateToPatch()" style="background: #7b1fa2;">Create Patch Request</button>
            </div>
          </div>
        </div>
        </div><!-- end admin-tab-patch-console -->

        <!-- EVIDENCE TAB -->
        <div id="admin-tab-evidence" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Version & Baseline</h3>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
            <div>
              <label style="font-size: 0.75em; color: #666; text-transform: uppercase;">Current Base Version</label>
              <div style="font-family: monospace; font-size: 1em; margin-top: 4px;" id="admin-base-version">--</div>
            </div>
            <div>
              <label style="font-size: 0.75em; color: #666; text-transform: uppercase;">Patch Target Version</label>
              <div style="font-family: monospace; font-size: 1em; margin-top: 4px;" id="admin-patch-version">--</div>
            </div>
            <div>
              <label style="font-size: 0.75em; color: #666; text-transform: uppercase;">Last Smoke Test</label>
              <div style="font-size: 0.9em; margin-top: 4px;" id="admin-last-smoke">Not Run</div>
            </div>
          </div>
        </div>

        <div class="admin-section" data-admin-section="true" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Evidence Gates</h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Status of preflight checks. Evidence is pasted in (UI does not run these).</p>
          <div id="admin-evidence-gates" style="display: flex; gap: 10px; flex-wrap: wrap;">
            <div class="state-chip pending">Validation: Pending</div>
            <div class="state-chip pending">Conflicts: Pending</div>
            <div class="state-chip pending">Smoke Baseline: Pending</div>
            <div class="state-chip pending">Smoke Edge: Pending</div>
          </div>
        </div>
        </div><!-- end admin-tab-evidence -->

        <!-- UNKNOWN COLUMNS TAB -->
        <div id="admin-tab-unknown-cols" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Unknown Columns (Schema Drift) <span class="info-icon" title="Columns found in imported data that don't match any canonical field. Decide how to handle each.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Columns detected during standardization that aren't in the canonical schema. Decide how to classify each one.</p>
          
          <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button class="toolbar-btn" onclick="refreshUnknownColumnsTable()">Refresh</button>
            <button class="toolbar-btn" onclick="exportUnknownColumnsRequest()">Export Update Request (Copy)</button>
            <button class="toolbar-btn" onclick="clearUnknownColumnsDecisions()">Clear Decisions</button>
          </div>
          
          <div id="unknown-cols-table-container" style="overflow-x: auto;">
            <table class="grid-table" id="unknown-cols-table" style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
              <thead style="background: #f5f5f5;">
                <tr>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Sheet</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Original Name</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Normalized</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Sample Values</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Non-Empty</th>
                  <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Action</th>
                </tr>
              </thead>
              <tbody id="unknown-cols-tbody">
                <tr><td colspan="6" style="text-align: center; padding: 40px; color: #888;">No unknown columns detected</td></tr>
              </tbody>
            </table>
          </div>
        </div>
        
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Pending Decisions</h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Columns marked for action. Export to generate a standard update request artifact.</p>
          <div id="unknown-cols-decisions" style="background: #f9f9f9; padding: 15px; border-radius: 6px; min-height: 60px; font-family: monospace; font-size: 0.85em;">
            <em style="color: #888;">No decisions made yet.</em>
          </div>
        </div>
        </div><!-- end admin-tab-unknown-cols -->

        <!-- STANDARDIZER TAB -->
        <div id="admin-tab-standardizer" class="admin-tab-panel" data-admin-section="true" style="display: none;">
        <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Standardizer <span class="info-icon" title="Convert CSV data into the canonical merged_dataset.json format. Headers are normalized and issues are tracked.">&#9432;</span></h3>
          <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Upload or paste CSV data to normalize into the standard merged dataset format.</p>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 15px;">
            <div>
              <label style="font-size: 0.8em; color: #666; display: block; margin-bottom: 6px;">Paste CSV</label>
              <textarea id="standardizer-csv-input" placeholder="Paste CSV data here..." style="width: 100%; height: 120px; font-family: monospace; font-size: 0.85em; padding: 10px; border: 1px solid #ddd; border-radius: 6px; resize: vertical;"></textarea>
            </div>
            <div>
              <label style="font-size: 0.8em; color: #666; display: block; margin-bottom: 6px;">Upload CSV File</label>
              <div id="standardizer-drop-zone" class="drop-zone" style="height: 120px; display: flex; align-items: center; justify-content: center; border: 2px dashed #ccc; border-radius: 6px; cursor: pointer; background: #fafafa;">
                <span id="standardizer-drop-text" style="color: #888; font-size: 0.85em;">Drop CSV here or click to browse</span>
              </div>
              <input type="file" id="standardizer-file-input" accept=".csv,.txt" style="display: none;">
            </div>
          </div>
          
          <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button class="toolbar-btn" onclick="runStandardizer()">Run Standardizer</button>
            <button class="toolbar-btn" onclick="generateSampleCSV()">Generate Sample CSV</button>
            <button class="toolbar-btn" onclick="clearStandardizer()">Clear</button>
          </div>
          
          <div id="standardizer-status" style="display: none; padding: 10px; border-radius: 6px; margin-bottom: 15px;"></div>
          
          <div id="standardizer-output" style="display: none;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
              <button class="tab-btn active" data-std-tab="summary" onclick="showStandardizerTab('summary')">Summary</button>
              <button class="tab-btn" data-std-tab="dataset" onclick="showStandardizerTab('dataset')">Merged Dataset</button>
              <button class="tab-btn" data-std-tab="issues" onclick="showStandardizerTab('issues')">Issues</button>
              <button class="tab-btn" data-std-tab="changelog" onclick="showStandardizerTab('changelog')">Change Log</button>
            </div>
            <div id="standardizer-tab-content" style="background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 300px; overflow-y: auto;"></div>
            <div style="margin-top: 10px; display: flex; gap: 10px;">
              <button class="toolbar-btn" onclick="copyStandardizerOutput('dataset')">Copy Merged Dataset</button>
              <button class="toolbar-btn" onclick="copyStandardizerOutput('issues')">Copy Issues</button>
            </div>
          </div>
        </div>
        </div><!-- end admin-tab-standardizer -->

        <!-- CONFIG TAB -->
        <div id="admin-tab-config" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">Config + Patch Inspector</h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">Load and compare config packs. View ruleset deltas between base and patch.</p>
            <div class="config-inspector-row" style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">
              <div style="flex: 1; min-width: 200px;">
                <label style="font-size: 0.8em; color: #666; display: block; margin-bottom: 4px;">Base Config Path</label>
                <input type="text" id="admin-base-config-path" value="config/config_pack.base.json" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
              </div>
              <div style="flex: 1; min-width: 200px;">
                <label style="font-size: 0.8em; color: #666; display: block; margin-bottom: 4px;">Patch Path</label>
                <input type="text" id="admin-patch-path" value="config/config_pack.example.patch.json" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
              </div>
            </div>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
              <button class="toolbar-btn" onclick="loadAdminConfig()">Load Config</button>
              <button class="toolbar-btn" onclick="clearAdminConfig()">Clear</button>
            </div>
            <div id="admin-config-status" style="display: none; padding: 10px; border-radius: 6px; margin-bottom: 15px;"></div>
            <div id="admin-config-results" style="display: none;">
              <div id="admin-patch-summary" style="background: #e3f2fd; padding: 15px; border-radius: 6px; margin-bottom: 15px;"></div>
              <div id="admin-ruleset-delta" style="background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 300px; overflow-y: auto;"></div>
            </div>
          </div>
        </div><!-- end admin-tab-config -->

        <!-- INSPECTOR TAB -->
        <div id="admin-tab-inspector" class="admin-tab-panel" data-admin-section="true" style="display: none;">
          <div class="admin-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 15px; font-size: 1.1em; color: #333;">JSON Inspector</h3>
            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">View raw JSON data for current session artifacts.</p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
              <button class="toolbar-btn" onclick="inspectJSON('sf_packet')">SF Packet</button>
              <button class="toolbar-btn" onclick="inspectJSON('base_config')">Base Config</button>
              <button class="toolbar-btn" onclick="inspectJSON('patch_config')">Patch Config</button>
              <button class="toolbar-btn" onclick="inspectJSON('dataset')">Dataset</button>
            </div>
            <div id="admin-json-inspector" style="background: #263238; color: #eceff1; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 0.75em; max-height: 400px; overflow-y: auto; white-space: pre-wrap;">
              <em style="color: #888;">Select an artifact to inspect...</em>
            </div>
            <div style="margin-top: 10px;">
              <button class="toolbar-btn" onclick="copyInspectorJSON()">Copy JSON</button>
            </div>
          </div>
        </div><!-- end admin-tab-inspector -->

      </div><!-- end page-admin -->

    </main><!-- end main-content -->
  </div><!-- end app-layout -->

  <!-- Staged Loader Overlay -->
  <div id="staged-loader-overlay" class="staged-loader-overlay" style="display: none;">
    <div class="staged-loader-content">
      <div class="staged-loader-spinner"></div>
      <div class="staged-loader-title">Loading Dataset</div>
      <div class="staged-loader-stages">
        <div class="staged-loader-stage" data-stage="loading">
          <span class="stage-icon">â—‹</span>
          <span class="stage-label">Loading dataset</span>
        </div>
        <div class="staged-loader-stage" data-stage="standardizing">
          <span class="stage-icon">â—‹</span>
          <span class="stage-label">Standardizing fields</span>
        </div>
        <div class="staged-loader-stage" data-stage="validating">
          <span class="stage-icon">â—‹</span>
          <span class="stage-label">Validating rules</span>
        </div>
        <div class="staged-loader-stage" data-stage="changemap">
          <span class="stage-icon">â—‹</span>
          <span class="stage-label">Building change map</span>
        </div>
        <div class="staged-loader-stage" data-stage="rendering">
          <span class="stage-icon">â—‹</span>
          <span class="stage-label">Rendering grid</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Global Modals and Drawers (outside pages) -->
  <!-- Data Source Drawer (right-side slide-over) -->
  <div class="drawer-overlay" id="data-source-drawer">
    <div class="drawer">
      <div class="drawer-header">
        <h3>Data Source</h3>
        <button class="drawer-close" onclick="closeDataSourceDrawer()">&times;</button>
      </div>
      <div class="drawer-body">
        <!-- Connected Folder Section (v1.4.24 - auto-mapped from email, read-only) -->
        <div id="data-source-folder-section" style="display: none; margin-bottom: 20px;">
          <div class="folder-connected-card" style="text-align: center;">
            <div class="folder-connected-icon">ðŸ“</div>
            <div class="folder-connected-label">Connected Folder</div>
            <div class="folder-connected-name" id="connected-folder-name" style="text-align: center;">â€”</div>
            <div class="folder-sync-time" id="folder-sync-time">Last sync: â€”</div>
          </div>
        </div>
        
        <!-- Empty State Section (v1.4.24 - should not appear, folder auto-mapped) -->
        <div id="data-source-empty-section" style="display: none;">
          <div style="text-align: center; padding: 24px 20px; color: #888; background: #f5f5f5; border-radius: 8px; border: 2px dashed #ddd; margin-bottom: 20px;">
            <div style="font-size: 2em; margin-bottom: 10px;">ðŸ“</div>
            <div style="font-weight: 600; color: #333; margin-bottom: 8px;">Folder Not Assigned</div>
            <p style="margin: 0; font-size: 0.9em;">Please sign out and sign in again to assign your folder.</p>
          </div>
        </div>
        
        <!-- Active Dataset Section (shown when data loaded) -->
        <div id="data-source-active-section" style="display: none; margin-bottom: 20px; padding: 16px; background: #e8f5e9; border: 1px solid #81c784; border-radius: 8px; position: relative;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
            <span style="font-size: 1.5em;">ðŸ“Š</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 0.95em; color: #2e7d32;">Active Dataset</div>
              <div id="active-dataset-name" style="font-size: 0.85em; color: #555; font-family: monospace;">â€”</div>
            </div>
            <div class="active-badge-container" style="position: relative;">
              <span id="active-badge" class="active-badge-hover" style="background: #4caf50; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: 600; cursor: pointer;" onclick="toggleDisconnectMenu(event)">ACTIVE â–¾</span>
              <div id="disconnect-menu" style="display: none; position: absolute; top: 100%; right: 0; margin-top: 4px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; min-width: 140px;">
                <button onclick="disconnectActiveDataset()" style="display: block; width: 100%; padding: 10px 14px; background: none; border: none; text-align: left; cursor: pointer; font-size: 0.85em; color: #c62828;" onmouseover="this.style.background='#ffebee'" onmouseout="this.style.background='none'">
                  â Disconnect
                </button>
              </div>
            </div>
          </div>
          <div id="active-dataset-meta" style="font-size: 0.8em; color: #666;">
            <!-- Row count, loaded timestamp -->
          </div>
        </div>
        
        <!-- Upload Section removed (v1.4.23 - folder-based workflow) -->
        <div id="data-source-upload-section" style="display: none;"></div>
        
        <!-- Search Stub (V2) - Disabled -->
        <div id="data-source-search-section" style="display: none; margin-bottom: 16px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
            <span style="font-weight: 600; font-size: 0.85em; color: #999;">Search</span>
            <span style="font-size: 0.7em; background: #e0e0e0; padding: 1px 5px; border-radius: 3px; font-weight: 600; color: #666;">Coming Soon</span>
          </div>
          <input type="text" id="data-source-search-input" placeholder="Search coming with Drive integration..." disabled style="width: 100%; padding: 10px 12px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 0.9em; box-sizing: border-box; background: #f5f5f5; color: #999; cursor: not-allowed;">
        </div>
        
        <!-- Saved Datasets Section (v1.6.8) -->
        <div id="data-source-demo-section" style="margin-bottom: 16px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
            <span style="font-weight: 600; font-size: 0.85em; color: #666; text-transform: uppercase;">Saved Datasets</span>
          </div>
          
          <!-- v1.6.8: In-Progress Banner (shown when modified dataset is active) -->
          <div id="demo-modified-banner" style="display: none; margin-bottom: 10px; padding: 8px 12px; background: #fff3e0; border: 1px solid #ffb74d; border-radius: 6px; font-size: 0.8em; color: #e65100;">
            <span style="margin-right: 6px;">âš ï¸</span> Demo dataset is in-progress (partial completion).
          </div>
          
          <!-- Original Dataset Card -->
          <div id="demo-dataset-card-original" class="demo-dataset-card" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #f0f7ff; border: 2px solid #90caf9; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 8px;" onclick="loadSampleDataset({ variant: 'original', autoRedirect: true })" onmouseover="this.style.background='#e3f2fd'" onmouseout="this.style.background=this.classList.contains('active') ? '#e3f2fd' : '#f0f7ff'">
            <span style="font-size: 1.3em;">ðŸ“‹</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 0.9em; color: #1565c0;">Ostereo (Original)</div>
              <div style="font-size: 0.75em; color: #666;">Baseline dataset (clean)</div>
            </div>
            <span class="demo-card-load-arrow" style="color: #1976d2; font-size: 0.8em; font-weight: 600;">Load â†’</span>
          </div>
          
          <!-- Modified Dataset Card -->
          <div id="demo-dataset-card-modified" class="demo-dataset-card" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 8px; cursor: pointer; transition: all 0.2s;" onclick="loadSampleDataset({ variant: 'modified', autoRedirect: true })" onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background=this.classList.contains('active') ? '#fff3e0' : '#fafafa'">
            <span style="font-size: 1.3em;">ðŸ“</span>
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-weight: 600; font-size: 0.9em; color: #e65100;">Ostereo (Modified / In-Progress)</span>
                <span style="font-size: 0.65em; background: #ff9800; color: white; padding: 2px 6px; border-radius: 3px; font-weight: 600;">In-Progress</span>
              </div>
              <div style="font-size: 0.75em; color: #666;">Partial completion with sample edits</div>
            </div>
            <span class="demo-card-load-arrow" style="color: #e65100; font-size: 0.8em; font-weight: 600;">Load â†’</span>
          </div>
        </div>
        
        <!-- Drive Files Section (v1.4.24 - read-only stub) -->
        <div id="data-source-library-header" style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <span style="font-weight: 600; font-size: 0.85em; color: #666; text-transform: uppercase;">Drive Files</span>
            <span style="font-size: 0.65em; background: #e0e0e0; padding: 2px 6px; border-radius: 3px; font-weight: 600; color: #666;">Coming Soon</span>
          </div>
          <p style="color: #888; font-size: 0.8em; margin: 0;">Files from your assigned folder (read-only).</p>
        </div>
        
        <!-- Drive Files List (mocked) -->
        <div id="upload-library-list" style="display: flex; flex-direction: column; gap: 10px;">
          <!-- Populated by renderDriveFilesList() -->
        </div>
        
        <div class="modal-status" id="data-source-status" style="display: none; margin-top: 15px;"></div>
      </div>
      <div class="drawer-footer">
        <button class="modal-btn modal-btn-secondary" onclick="closeDataSourceDrawer()" style="width: 100%;">Close</button>
      </div>
    </div>
  </div>

  <!-- Loader Modal (centered overlay for data loading) -->
  <div class="loader-modal-overlay" id="loader-modal-overlay" onclick="closeLoaderModal(event)">
    <div class="loader-modal" id="loader-modal" onclick="event.stopPropagation()">
      <div class="loader-modal-header">
        <h3>Data Source</h3>
        <button class="loader-modal-close" id="loader-modal-close-btn" onclick="closeLoaderModal()" aria-label="Close">&times;</button>
      </div>
      <div class="loader-modal-body">
        <!-- Inline Error Display (v1.4.4) -->
        <div id="loader-error-display" style="display: none; margin-bottom: 16px; padding: 12px 16px; background: #ffebee; border: 1px solid #ef5350; border-radius: 8px; color: #c62828;">
          <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 1.1em;">âš ï¸</span>
            <div id="loader-error-message" style="flex: 1; font-size: 0.9em;"></div>
          </div>
        </div>
        <!-- Column Mapping Warning Banner (v1.4.12) -->
        <div id="column-mapping-banner" style="display: none; margin-bottom: 16px; padding: 12px 16px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 8px; color: #e65100;">
          <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 1.1em;">âš ï¸</span>
            <div id="column-mapping-message" style="flex: 1; font-size: 0.9em;"></div>
          </div>
        </div>
        
        <!-- Import CSV Section -->
        <div style="margin-bottom: 20px;">
          <div style="font-weight: 600; margin-bottom: 10px; color: #333;">Upload / Add Data Source</div>
          <div class="drop-zone" id="loader-drawer-dropzone" onclick="document.getElementById('loader-drawer-file').click();">
            <div class="drop-zone-icon">ðŸ“„</div>
            <div class="drop-zone-text">Drop CSV or XLSX file here or click to browse</div>
            <div class="drop-zone-file" id="loader-drawer-file-name" style="display: none;"></div>
          </div>
          <input type="file" id="loader-drawer-file" accept=".csv,.xlsx" style="display: none;">
          <div style="font-size: 0.75em; color: #888; margin-top: 6px;">Supported: CSV, XLSX files</div>
        </div>
        
        <!-- Folder Connection Info (v1.4.24 - auto-mapped, read-only) -->
        <div id="loader-folder-info" style="margin-bottom: 20px; padding: 15px; background: #e8f5e9; border-radius: 8px; border: 1px solid #81c784; display: none;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 1.2em;">ðŸ“</span>
            <div style="flex: 1; text-align: center;">
              <div style="font-weight: 600; font-size: 0.9em; color: #2e7d32;">Connected Folder</div>
              <div id="loader-folder-name" style="font-size: 0.85em; color: #558b2f;">â€”</div>
            </div>
          </div>
        </div>
        
        <!-- Empty Folder State (v1.4.24 - should not appear) -->
        <div id="loader-no-folder" style="margin-bottom: 20px; padding: 15px; background: #fff3e0; border-radius: 8px; border: 1px solid #ff9800; display: none;">
          <div style="text-align: center;">
            <div style="font-size: 1.5em; margin-bottom: 8px;">ðŸ“‚</div>
            <div style="font-weight: 600; font-size: 0.9em; color: #e65100;">Please sign in again to assign your folder.</div>
          </div>
        </div>
        
        <!-- Admin Utilities (admin-only) -->
        <div class="admin-only-content" style="border-top: 1px solid #e0e0e0; padding-top: 15px; margin-top: 15px;">
          <div style="font-weight: 600; margin-bottom: 10px; color: #888; font-size: 0.85em;">ADMIN UTILITIES</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="top-toolbar-btn" onclick="resetDemoState();">Reset Demo State</button>
            <button class="top-toolbar-btn" onclick="rebuildFieldIndex();">Rebuild Index</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Folder Selection Modal removed (v1.4.24 - folder auto-mapped from email) -->

  <!-- Config Flows Drawer (right-side slide-over for admin config editing) -->
  <div class="drawer-overlay" id="config-flows-drawer">
    <div class="drawer" style="width: 700px;">
      <div class="drawer-header" style="background: linear-gradient(135deg, #1a1a2e 0%, #2d2d44 100%);">
        <h3>Config Flows</h3>
        <button class="drawer-close" onclick="closeConfigFlows()">&times;</button>
      </div>
      <div class="drawer-body" style="display: flex; gap: 0; padding: 0;">
        <!-- Workflow Rail (Left Column) -->
        <div class="config-flows-rail" style="width: 200px; background: #f8f9fa; border-right: 1px solid #e0e0e0; padding: 15px 0; flex-shrink: 0;">
          <div class="rail-header" style="padding: 0 15px 10px; font-size: 0.75em; color: #666; text-transform: uppercase; font-weight: 600;">Workflow Stages</div>
          <div class="rail-items" id="config-flows-rail">
            <a class="rail-item active" data-stage="data_sources" onclick="selectConfigFlowStage('data_sources')">
              <span class="rail-number">1</span>
              <span class="rail-label">Data Sources</span>
            </a>
            <a class="rail-item" data-stage="dataset_mapping" onclick="selectConfigFlowStage('dataset_mapping')">
              <span class="rail-number">2</span>
              <span class="rail-label">Dataset Mapping</span>
            </a>
            <a class="rail-item" data-stage="standardization" onclick="selectConfigFlowStage('standardization')">
              <span class="rail-number">3</span>
              <span class="rail-label">Standardization</span>
            </a>
            <a class="rail-item" data-stage="ruleset" onclick="selectConfigFlowStage('ruleset')">
              <span class="rail-number">4</span>
              <span class="rail-label">Ruleset</span>
            </a>
            <a class="rail-item" data-stage="validation_gates" onclick="selectConfigFlowStage('validation_gates')">
              <span class="rail-number">5</span>
              <span class="rail-label">Validation Gates</span>
            </a>
            <a class="rail-item" data-stage="patch_generation" onclick="selectConfigFlowStage('patch_generation')">
              <span class="rail-number">6</span>
              <span class="rail-label">Patch Generation</span>
            </a>
            <a class="rail-item" data-stage="smoke_baselines" onclick="selectConfigFlowStage('smoke_baselines')">
              <span class="rail-number">7</span>
              <span class="rail-label">Smoke Baselines</span>
            </a>
            <a class="rail-item" data-stage="export" onclick="selectConfigFlowStage('export')">
              <span class="rail-number">8</span>
              <span class="rail-label">Export / PR</span>
            </a>
          </div>
        </div>
        
        <!-- Flow Stage Detail (Main Column) -->
        <div class="config-flows-detail" style="flex: 1; padding: 20px; overflow-y: auto;">
          <div class="stage-header" style="margin-bottom: 15px;">
            <h4 id="config-flow-stage-title" style="margin: 0 0 5px; font-size: 1.1em;">Data Sources</h4>
            <p id="config-flow-stage-desc" style="margin: 0; color: #666; font-size: 0.9em;">Configure where data is loaded from.</p>
          </div>
          
          <div class="stage-tabs" style="display: flex; gap: 0; border-bottom: 1px solid #e0e0e0; margin-bottom: 15px;">
            <button class="stage-tab active" data-tab="plain-english" onclick="selectConfigFlowTab('plain-english')">Plain-English</button>
            <button class="stage-tab" data-tab="payload" onclick="selectConfigFlowTab('payload')">Payload</button>
            <button class="stage-tab" data-tab="master" onclick="selectConfigFlowTab('master')">Master</button>
            <button class="stage-tab" data-tab="diff" onclick="selectConfigFlowTab('diff')">Diff</button>
            <button class="stage-tab" data-tab="history" onclick="selectConfigFlowTab('history')">History</button>
          </div>
          
          <div id="config-flow-tab-content">
            <!-- Tab content rendered dynamically -->
            <div style="padding: 20px; background: #f5f5f5; border-radius: 6px; color: #666;">
              <p>This stage configures how Preview and Reference packets are loaded into the session.</p>
              <p style="margin-top: 10px;">Available methods:</p>
              <ul style="margin: 10px 0 0 20px;">
                <li>Repo Masters (auto-load from repository)</li>
                <li>Paste JSON (manual paste)</li>
                <li>Drag & Drop (file upload)</li>
                <li>Local Path Hint (reference local files)</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Record Detail Drawer (right-side slide-over for contract details) -->
  <div class="drawer-overlay" id="record-drawer">
    <div class="drawer" style="width: 500px;">
      <div class="drawer-header">
        <h3 id="record-drawer-title">Record Details</h3>
        <button class="drawer-close" onclick="closeRecordDrawer()">&times;</button>
      </div>
      <div class="drawer-body" id="record-drawer-content">
        <p style="color: #666;">Select a contract to view details.</p>
      </div>
      <div class="drawer-footer">
        <div style="display: flex; gap: 10px; justify-content: space-between;">
          <button class="modal-btn modal-btn-secondary" id="record-drawer-prev" onclick="navigateRecord(-1)" disabled>Previous</button>
          <span id="record-drawer-position" style="line-height: 36px; color: #666;">-/-</span>
          <button class="modal-btn modal-btn-secondary" id="record-drawer-next" onclick="navigateRecord(1)" disabled>Next</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Patch Request Detail Drawer -->
  <div class="drawer-overlay" id="patch-detail-drawer">
    <div class="drawer" style="width: 550px;">
      <div class="drawer-header" style="background: #7b1fa2; color: white;">
        <h3 id="patch-detail-title">Patch Request Details</h3>
        <button class="drawer-close" onclick="closePatchDetailDrawer()" style="color: white;">&times;</button>
      </div>
      <div class="drawer-body" id="patch-detail-content" style="padding: 20px;">
        <p style="color: #666;">Select a patch request to view details.</p>
      </div>
      <div class="drawer-footer" id="patch-detail-footer" style="border-top: 1px solid #eee; padding: 15px;">
      </div>
    </div>
  </div>

  <!-- Ruleset Modal -->
  <div class="modal-overlay" id="ruleset-modal">
    <div class="modal wizard-modal">
      <div class="modal-header">
        <h3>Ruleset Configuration</h3>
        <button class="modal-close" onclick="closeRulesetModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="wizard-section">
          <h4>Base (Truth)</h4>
          <div class="wizard-field">
            <label>Base Config Path</label>
            <input type="text" id="wizard-base-config" value="config/config_pack.base.json" placeholder="config/config_pack.base.json">
            <div class="hint">The authoritative semantic ruleset</div>
          </div>
        </div>
        <div class="wizard-section">
          <h4>Patch (Proposed)</h4>
          <div class="wizard-field">
            <label>Patch Path</label>
            <input type="text" id="wizard-patch-config" value="config/config_pack.example.patch.json" placeholder="config/config_pack.example.patch.json">
            <div class="hint">Optional patch file with proposed changes</div>
          </div>
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-primary" id="wizard-load-ruleset">Load Ruleset</button>
          <button class="modal-btn modal-btn-secondary" onclick="closeRulesetModal()">Cancel</button>
        </div>
        <div class="modal-status" id="ruleset-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Compare Modal -->
  <div class="modal-overlay" id="compare-modal">
    <div class="modal wizard-modal">
      <div class="modal-header">
        <h3>Comparison Mode</h3>
        <button class="modal-close" onclick="closeCompareModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="wizard-section">
          <h4>Compare Artifact (Optional)</h4>
          <div class="wizard-field">
            <label>Comparison Artifact Path</label>
            <input type="text" id="wizard-compare-path" placeholder="out/sf_packet.preview.prev.json">
            <div class="hint">Load a previous artifact to compare changes and view deltas</div>
          </div>
          <div class="wizard-preset">
            <button class="wizard-preset-btn" data-compare="out/sf_packet.preview.prev.json">Previous Preview</button>
            <button class="wizard-preset-btn" data-compare="">Clear Compare</button>
          </div>
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-primary" id="wizard-load-compare">Load Comparison</button>
          <button class="modal-btn modal-btn-secondary" onclick="closeCompareModal()">Cancel</button>
        </div>
        <div class="modal-status" id="compare-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Run Commands Modal -->
  <div class="modal-overlay" id="run-modal">
    <div class="modal wizard-modal">
      <div class="modal-header">
        <h3>Run Commands</h3>
        <button class="modal-close" onclick="closeRunModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 15px; color: #666;">Copy validation and preview commands to run in your terminal. This viewer does not execute commands directly.</p>
        <div class="wizard-section">
          <h4>Validation &amp; Preview Commands</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
            <button class="toolbar-btn" data-cmd="validate">Validate</button>
            <button class="toolbar-btn" data-cmd="preview_baseline">Preview Baseline</button>
            <button class="toolbar-btn" data-cmd="preview_edge">Preview Edge</button>
            <button class="toolbar-btn" data-cmd="smoke_baseline">Smoke Baseline</button>
            <button class="toolbar-btn" data-cmd="smoke_edge">Smoke Edge</button>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="run-modal-confirm">
            <label for="run-modal-confirm" style="color: #f57c00; font-size: 0.9em;">I CONFIRM RUN</label>
          </div>
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-secondary" onclick="closeRunModal()">Close</button>
        </div>
        <div class="modal-status" id="run-modal-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <!-- Configure Wizard Modal -->
  <div class="modal-overlay" id="configure-wizard-modal">
    <div class="modal wizard-modal" style="max-width: 550px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #7c4dff 0%, #536dfe 100%);">
        <h3 id="wizard-step-title">Configure Kiwi</h3>
        <button class="modal-close" onclick="closeConfigureWizard()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="wizard-progress" style="display: flex; gap: 8px; margin-bottom: 20px;">
          <span class="wizard-step-dot active" data-step="0"></span>
          <span class="wizard-step-dot" data-step="1"></span>
          <span class="wizard-step-dot" data-step="2"></span>
          <span class="wizard-step-dot" data-step="3"></span>
        </div>
        <div id="wizard-step-content">
          <!-- Step content rendered dynamically -->
        </div>
        <div class="modal-actions" style="margin-top: 20px; justify-content: space-between;">
          <button class="modal-btn modal-btn-secondary" id="wizard-back" onclick="wizardBack()" style="display: none;">Back</button>
          <button class="modal-btn modal-btn-primary" id="wizard-next" onclick="wizardNext()" style="margin-left: auto;">Next</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Command Modal (legacy) -->
  <div class="modal-overlay" id="command-modal">
    <div class="modal">
      <div class="modal-header">
        <h3 id="modal-title">Command</h3>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <p id="modal-description" style="margin-bottom: 15px; color: #666;"></p>
        <div class="modal-command" id="modal-command"></div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-primary" id="modal-copy">Copy to Clipboard</button>
          <button class="modal-btn modal-btn-danger" id="modal-run" disabled>Run (Confirm Required)</button>
          <button class="modal-btn modal-btn-secondary" id="modal-cancel">Cancel</button>
        </div>
        <div class="modal-status" id="modal-status" style="display: none;"></div>
      </div>
    </div>
  </div>

  <div class="drawer-overlay" id="drawer-overlay"></div>
  <div class="drawer" id="drawer">
    <div class="drawer-header">
      <div class="drawer-header-row">
        <h3>Record Workbench</h3>
        <button class="drawer-close" id="drawer-close">&times;</button>
      </div>
      <div class="drawer-identity">
        <div class="identity-pill" id="identity-pill"></div>
        <button class="identity-copy" id="identity-copy">Copy ID</button>
      </div>
    </div>
    <div class="drawer-tabs" id="drawer-tabs">
      <button class="drawer-tab active" data-tab="contract">Contract</button>
      <button class="drawer-tab" data-tab="issues">Issues <span class="drawer-tab-count" id="issues-count">0</span></button>
      <button class="drawer-tab" data-tab="actions">Actions <span class="drawer-tab-count" id="actions-count">0</span></button>
      <button class="drawer-tab" data-tab="changelog">Change Log <span class="drawer-tab-count" id="changelog-count">0</span></button>
      <button class="drawer-tab" data-tab="patch-studio" style="background: #2e7d32; color: white;">Patch Studio</button>
    </div>
    <div class="drawer-warning" id="drawer-warning" style="display: none;"></div>
    <div class="drawer-body" id="drawer-body"></div>
    <div class="drawer-panel" id="patch-studio-panel" style="display: none; flex: 1; overflow-y: auto; padding: 0;">
      <div class="patch-studio-sub-tabs" style="display: flex; background: #263238; flex-shrink: 0;">
        <button class="patch-studio-sub-tab active" data-subtab="draft" style="flex: 1; padding: 10px; border: none; background: #1a1a2e; color: white; cursor: pointer; font-size: 0.85em;">Draft</button>
        <button class="patch-studio-sub-tab" data-subtab="preflight" style="flex: 1; padding: 10px; border: none; background: #263238; color: #aaa; cursor: pointer; font-size: 0.85em;">Preflight</button>
        <button class="patch-studio-sub-tab" data-subtab="evidence" style="flex: 1; padding: 10px; border: none; background: #263238; color: #aaa; cursor: pointer; font-size: 0.85em;">Evidence Pack</button>
      </div>
      <div class="patch-studio-sub-panel" id="subtab-draft" style="padding: 15px;">
        <fieldset style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
          <legend style="font-weight: 600; font-size: 0.85em; color: #1565c0; padding: 0 8px;">WHEN (condition)</legend>
          <div style="margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Target Field</label>
            <select id="ps-target-field" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
              <option value="">-- Select field --</option>
            </select>
            <span style="font-size: 0.75em; color: #888;">e.g., contracts.label_name</span>
          </div>
          <div style="margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Condition Type</label>
            <select id="ps-condition-type" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
              <option value="">-- Select condition --</option>
              <option value="SHOULD_BE_BLANK_BUT_POPULATED">Should be blank but has data</option>
              <option value="SHOULD_BE_PRESENT_BUT_MISSING">Should have data but is empty</option>
              <option value="INVALID_FORMAT">Invalid format/pattern</option>
              <option value="OUT_OF_RANGE">Value out of allowed range</option>
              <option value="MISMATCH_WITH_OTHER_FIELD">Mismatches another field</option>
              <option value="DUPLICATE">Duplicate value detected</option>
              <option value="OTHER">Other (specify below)</option>
            </select>
          </div>
          <div id="ps-condition-other-wrap" style="display: none; margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Describe condition (required for Other)</label>
            <input type="text" id="ps-condition-other" placeholder="e.g., contains 'Various Artists'" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
          </div>
        </fieldset>
        
        <fieldset style="border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
          <legend style="font-weight: 600; font-size: 0.85em; color: #2e7d32; padding: 0 8px;">THEN (action)</legend>
          <div style="margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Action Type</label>
            <select id="ps-action-type" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
              <option value="">-- Select action --</option>
              <option value="REQUIRE_PRESENT">Require field to have a value</option>
              <option value="REQUIRE_BLANK">Require field to be blank</option>
              <option value="WARN_ONLY">Warn only (non-blocking)</option>
              <option value="NORMALIZE_VALUE">Normalize/standardize value</option>
              <option value="MAP_FIELD">Map to another field</option>
              <option value="BLOCK_SUBMISSION">Block submission</option>
              <option value="OTHER">Other (specify below)</option>
            </select>
          </div>
          <div id="ps-action-other-wrap" style="display: none; margin-bottom: 10px;">
            <label style="display: block; font-size: 0.8em; color: #666; margin-bottom: 4px;">Describe action (required for Other)</label>
            <input type="text" id="ps-action-other" placeholder="e.g., require artist_name to be present" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
          </div>
        </fieldset>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Comment (plain English) <span style="color: #c62828;">*</span></label>
          <textarea id="ps-intent-because" placeholder="Explain why this rule exists in human terms. This is what reviewers/admins will read." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 60px;"></textarea>
          <span style="font-size: 0.75em; color: #888;">Required. Max 500 characters.</span>
        </div>
        
        <div style="background: #f5f5f5; border-radius: 6px; padding: 12px; margin-bottom: 15px; border-left: 3px solid #1565c0;">
          <div style="font-weight: 600; font-size: 0.8em; color: #1565c0; margin-bottom: 8px;">Intent Preview</div>
          <div id="ps-intent-preview" style="font-size: 0.85em; color: #333;">
            <div><strong>WHEN:</strong> <span id="preview-when" style="color: #666;">(select field and condition)</span></div>
            <div><strong>THEN:</strong> <span id="preview-then" style="color: #666;">(select action)</span></div>
            <div><strong>BECAUSE:</strong> <span id="preview-because" style="color: #666;">(enter comment)</span></div>
          </div>
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Target Artifact</label>
          <select id="ps-target" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
            <option value="proposed_changes">Proposed Changes</option>
            <option value="salesforce">Salesforce Rules</option>
            <option value="qa_rules">QA Rules</option>
            <option value="resolver_rules">Resolver Rules</option>
            <option value="truth_config">Truth Config</option>
          </select>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Risk Level</label>
          <select id="ps-risk" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em;">
            <option value="low">Low - minor adjustment</option>
            <option value="medium">Medium - affects multiple records</option>
            <option value="high">High - significant system change</option>
          </select>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.85em;">Rationale (optional)</label>
          <textarea id="ps-rationale" placeholder="Additional context or notes..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 40px;"></textarea>
        </div>
      </div>
      <div class="patch-studio-sub-panel" id="subtab-preflight" style="display: none; padding: 15px;">
        <h4 style="margin: 0 0 15px 0; font-size: 0.95em;">Preflight Checks</h4>
        <div id="ps-preflight-checks" style="display: flex; flex-direction: column; gap: 10px;">
          <div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
            <span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: #e8f5e9; color: #2e7d32;">PASS</span>
            <span style="font-size: 0.9em;">Intent fields populated</span>
          </div>
          <div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
            <span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: #fff3e0; color: #e65100;">WARN</span>
            <span style="font-size: 0.9em;">Evidence pack incomplete</span>
          </div>
          <div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
            <span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: #e3f2fd; color: #1565c0;">INFO</span>
            <span style="font-size: 0.9em;">Target: Proposed Changes</span>
          </div>
        </div>
        <div style="margin-top: 20px;">
          <button class="toolbar-btn" id="ps-run-preflight" style="width: 100%;">Run Preflight Checks</button>
        </div>
        <div style="margin-top: 15px;">
          <button class="toolbar-btn" id="ps-copy-preflight" style="width: 100%; background: #455a64;">Copy Preflight Report</button>
        </div>
      </div>
      <div class="patch-studio-sub-panel" id="subtab-evidence" style="display: none; padding: 15px;">
        <h4 style="margin: 0 0 10px 0; font-size: 0.95em;">Evidence Pack (Copy-only)</h4>
        <p style="font-size: 0.8em; color: #666; margin-bottom: 15px;">Structured evidence blocks to support your patch request.</p>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Observation</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('observation')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-observation" placeholder="What did you observe that prompted this change?" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Expected</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('expected')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-expected" placeholder="What behavior is expected?" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Justification</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('justification')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-justification" placeholder="Why this change is correct..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <label style="font-weight: 600; font-size: 0.85em;">Repro</label>
            <button class="toolbar-btn" onclick="copyEvidenceBlock('repro')" style="padding: 2px 8px; font-size: 0.75em;">Copy</button>
          </div>
          <textarea id="ps-evidence-repro" placeholder="Steps to reproduce the issue..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 50px;"></textarea>
        </div>
      </div>
    </div>
    <div class="drawer-actions" id="drawer-actions-default">
      <div class="drawer-actions-grid">
        <button class="drawer-btn" id="drawer-copy">Copy JSON</button>
        <button class="drawer-btn drawer-btn-secondary" id="copy-pr-summary">Copy PR Summary</button>
        <button class="drawer-btn drawer-btn-secondary" id="copy-rule-draft">Copy Rule Draft</button>
        <button class="drawer-btn" id="switch-to-patch-studio-tab" style="background: #2e7d32;">Build Patch</button>
      </div>
    </div>
    <div class="drawer-actions" id="drawer-actions-patch-studio" style="display: none;">
      <div style="padding: 10px; background: #f0f0f0; border-top: 1px solid #ddd;">
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
          <span style="font-size: 0.75em; background: #e3f2fd; color: #1565c0; padding: 3px 8px; border-radius: 4px; display: flex; align-items: center; gap: 4px;" title="These buttons copy data to clipboard without creating queue artifacts">
            <span style="font-size: 1em;">&#128203;</span> Copy-only
          </span>
          <span style="font-size: 0.75em; background: #e8f5e9; color: #2e7d32; padding: 3px 8px; border-radius: 4px; display: flex; align-items: center; gap: 4px;" title="Submit creates a tracked Patch Request artifact">
            <span style="font-size: 1em;">&#10003;</span> Submit creates Patch Request
          </span>
        </div>
      </div>
      <div class="drawer-actions-grid" style="padding: 10px;">
        <button class="drawer-btn drawer-btn-secondary" id="ps-copy-draft" title="Copy the current draft to clipboard">Copy Draft</button>
        <button class="drawer-btn drawer-btn-secondary" id="ps-save-local" title="Save draft to browser storage">Save Draft</button>
        <button class="drawer-btn" id="ps-submit-to-queue" style="background: #2e7d32; grid-column: span 2;" title="Submit this Patch Request for review">Submit Patch Request</button>
      </div>
    </div>
  </div>

  <!-- Legacy Patch Studio overlay removed in v1.2.4 - all functionality now in Workbench tab -->

  <!-- Unsaved Changes Guard Modal -->
  <!-- v1.4.20: Guard modal for unresolved PATCHED/RFI fields -->
  <div class="srr-guard-modal" id="srr-guard-modal">
    <div class="srr-guard-dialog">
      <div class="srr-guard-title">Unresolved Fields</div>
      <div class="srr-guard-message">You have <strong id="srr-guard-count">0</strong> unresolved fields (Patched or RFI). What would you like to do?</div>
      <div class="srr-guard-actions">
        <button class="srr-guard-btn cancel" onclick="srrGuardCancel()">Stay Here</button>
        <button class="srr-guard-btn discard" onclick="srrGuardDiscardAll()">Discard Changes</button>
        <button class="srr-guard-btn save" onclick="srrGuardSaveDraft()">Save Draft</button>
      </div>
    </div>
  </div>

  <script>
    const PRIMARY_PATH = 'out/sf_packet.preview.json';
    const FALLBACK_PATH = 'examples/datasets/ostereo_demo_original.json';
    const RELATIVE_PRIMARY = '../../out/sf_packet.preview.json';
    const RELATIVE_FALLBACK = '../../examples/datasets/ostereo_demo_original.json';
    const DEFAULT_DATASET_URL = '/examples/datasets/ostereo_demo_original.json';
    const MODIFIED_DATASET_URL = '/examples/datasets/ostereo_demo_v1.json';
    const COMMANDS_PATH = 'run_commands.json';
    const STORAGE_KEY = 'viewer_selection_v10';
    const PREFLIGHT_STORAGE_KEY = 'viewer_preflight_v10';
    const SETTINGS_STORAGE_KEY = 'viewer_settings_v12';
    const FIRST_RUN_DISMISSED_KEY = 'viewer_first_run_dismissed_v12';
    const DEMO_TOGGLE_KEY = 'viewer_demo_toggle_v1';
    
    // v1.6.4: Demo toggle state (Original = baseline, Modified = in-progress)
    var demoToggleState = {
      mode: localStorage.getItem(DEMO_TOGGLE_KEY) || 'original', // 'original' or 'modified'
      isModified: function() { return this.mode === 'modified'; }
    };
    
    // ========== STAGED LOADER CONTROLLER ==========
    // Shows staged progress overlay for dataset loading pipeline
    // Only displays if load takes >300ms to avoid flicker on fast loads
    var stagedLoader = {
      stages: ['loading', 'standardizing', 'validating', 'changemap', 'rendering'],
      currentStage: null,
      startTime: null,
      showTimeout: null,
      visible: false,
      DELAY_MS: 300, // Don't show loader for fast loads
      
      // Start the loading process (call before loading begins)
      start: function() {
        this.startTime = Date.now();
        this.currentStage = null;
        this.visible = false;
        this.resetStages();
        
        // Schedule showing the loader after delay
        var self = this;
        this.showTimeout = setTimeout(function() {
          self.show();
        }, this.DELAY_MS);
      },
      
      // Set current stage (call as each stage begins)
      setStage: function(stageName) {
        this.currentStage = stageName;
        
        // Mark previous stages as completed
        var stageIdx = this.stages.indexOf(stageName);
        for (var i = 0; i < this.stages.length; i++) {
          var stageEl = document.querySelector('.staged-loader-stage[data-stage="' + this.stages[i] + '"]');
          if (!stageEl) continue;
          
          stageEl.classList.remove('active', 'completed');
          var iconEl = stageEl.querySelector('.stage-icon');
          
          if (i < stageIdx) {
            stageEl.classList.add('completed');
            if (iconEl) iconEl.textContent = 'âœ“';
          } else if (i === stageIdx) {
            stageEl.classList.add('active');
            if (iconEl) iconEl.textContent = 'â—';
          } else {
            if (iconEl) iconEl.textContent = 'â—‹';
          }
        }
      },
      
      // Complete and hide the loader
      finish: function() {
        // Cancel scheduled show if still pending
        if (this.showTimeout) {
          clearTimeout(this.showTimeout);
          this.showTimeout = null;
        }
        
        // Mark all stages complete briefly before hiding
        if (this.visible) {
          for (var i = 0; i < this.stages.length; i++) {
            var stageEl = document.querySelector('.staged-loader-stage[data-stage="' + this.stages[i] + '"]');
            if (stageEl) {
              stageEl.classList.remove('active');
              stageEl.classList.add('completed');
              var iconEl = stageEl.querySelector('.stage-icon');
              if (iconEl) iconEl.textContent = 'âœ“';
            }
          }
          
          // Hide after a brief moment to show completion
          var self = this;
          setTimeout(function() {
            self.hide();
          }, 150);
        }
        
        this.currentStage = null;
        this.startTime = null;
      },
      
      // Show the overlay
      show: function() {
        var overlay = document.getElementById('staged-loader-overlay');
        if (overlay) {
          overlay.style.display = 'flex';
          this.visible = true;
          // Set current stage if one was already set
          if (this.currentStage) {
            this.setStage(this.currentStage);
          }
        }
      },
      
      // Hide the overlay
      hide: function() {
        var overlay = document.getElementById('staged-loader-overlay');
        if (overlay) {
          overlay.style.display = 'none';
          this.visible = false;
        }
      },
      
      // Reset all stages to initial state
      resetStages: function() {
        for (var i = 0; i < this.stages.length; i++) {
          var stageEl = document.querySelector('.staged-loader-stage[data-stage="' + this.stages[i] + '"]');
          if (stageEl) {
            stageEl.classList.remove('active', 'completed');
            var iconEl = stageEl.querySelector('.stage-icon');
            if (iconEl) iconEl.textContent = 'â—‹';
          }
        }
      }
    };
    
    // Meta sheet patterns - these are audit log sheets, not data sheets
    const META_SHEET_PATTERNS = ['_change_log', 'RFIs & Analyst Notes', '_meta', '_audit'];
    
    // v1.6.20: Reference/glossary sheets - supporting data, not actionable records
    // These should be excluded from triage queues (sf_issues, sf_field_actions)
    const REFERENCE_SHEET_PATTERNS = [
      'glossary', 'field_dictionary', 'field dictionary', 
      'opportunity_field_catalog', 'opportunity field catalog',
      'qa_flags', 'hinge', 'mapping', 'dictionary', 'catalog_meta',
      'field_catalog', 'field catalog', 'reference', 'lookup'
    ];
    
    // Default settings (used when no user config exists)
    const DEFAULT_SETTINGS = {
      use_repo_masters: true,
      preferred_load_method: 'Repo Masters',
      local_data_root: '',
      default_queues: ['To Do', 'Needs Review', 'Flagged'],
      compare_mode_default: true,
      configured: false
    };
    
    let userSettings = { ...DEFAULT_SETTINGS };
    const PATCH_STORAGE_KEY = 'viewer_patch_v10';
    const COMPARISON_PATH = '../../out/sf_packet.preview.prev.json';

    let loadedBaseConfig = null;
    let loadedPatch = null;
    let configVersionMatch = null;

    let commands = {};
    let allData = { contractResults: [], issues: [], fieldActions: [], changeLog: [] };
    let compareData = null;
    let rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
    let deltaStats = null;
    let activeFilters = { search: '', severities: ['blocking', 'warning', 'info'], statuses: ['ready', 'needs_review', 'blocked'], subtype: '' };
    let currentSelection = { joinIdentity: null, contractIdx: null, activeTab: 'contract' };
    let selectedRecords = { issues: new Set(), actions: new Set(), changelog: new Set() };
    let patchDraft = { baseVersion: '0.1.0', author: '', rationale: '', changes: [] };
    let preflightEvidence = {
      baseVersion: { raw: '', parsed: null, status: 'pending' },
      validation: { raw: '', parsed: null, status: 'pending' },
      conflict: { raw: '', parsed: null, status: 'pending' },
      smokeBaseline: { raw: '', parsed: null, status: 'pending' },
      smokeEdge: { raw: '', parsed: null, status: 'pending' },
      sha256: ''
    };

    let currentMode = 'analyst';
    let currentQueue = 'todo';
    let dataLoaded = false;
    let currentArtifactPath = '';
    
    // v1.6.18: Performance logging toggle (add ?perf=1 to URL)
    const PERF_ENABLED = new URLSearchParams(window.location.search).get('perf') === '1';
    function perfLog(label, startTime) {
      if (!PERF_ENABLED) return;
      console.log('[Perf] ' + label + ': ' + (performance.now() - startTime).toFixed(2) + 'ms');
    }
    function perfStart() {
      return PERF_ENABLED ? performance.now() : 0;
    }
    
    // v1.6.18: Dataset revision for cache invalidation
    let datasetRevision = 0;
    let flattenCache = { revision: -1, result: null };
    
    // Session state tracking
    const sessionState = {
      status: 'not-loaded', // 'not-loaded', 'loaded', 'fallback'
      sourceType: null, // 'paste', 'drop', 'example', null
      loadedAt: null,
      previewData: null,
      expectedData: null,
      fileName: null
    };
    
    // ========== ARTIFACT STORE (v1.5.1 localStorage Mock Filesystem) ==========
    // Environment + workspace scoped storage adapter
    const ARTIFACT_STORE = {
      prefix: 'fs:',
      workspace_id: 'ws_default',
      environment: 'playground', // 'playground' | 'prod'
      
      // Generate scoped key
      _key: function(path) {
        return this.prefix + this.environment + '/' + this.workspace_id + '/' + path;
      },
      
      // Filesystem helpers
      fsRead: function(path) {
        var key = this._key(path);
        var data = localStorage.getItem(key);
        return data ? data : null;
      },
      
      fsWrite: function(path, contents) {
        var key = this._key(path);
        localStorage.setItem(key, typeof contents === 'string' ? contents : JSON.stringify(contents));
        return true;
      },
      
      fsAppend: function(path, line) {
        var key = this._key(path);
        var existing = localStorage.getItem(key) || '';
        var newLine = typeof line === 'string' ? line : JSON.stringify(line);
        localStorage.setItem(key, existing + (existing ? '\n' : '') + newLine);
        return true;
      },
      
      fsList: function(pathPrefix) {
        var fullPrefix = this._key(pathPrefix || '');
        var results = [];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (key && key.startsWith(fullPrefix)) {
            results.push(key.substring(this._key('').length));
          }
        }
        return results;
      },
      
      fsDelete: function(path) {
        var key = this._key(path);
        localStorage.removeItem(key);
        return true;
      },
      
      // Clear only playground environment keys
      resetPlayground: function() {
        var playgroundPrefix = this.prefix + 'playground/';
        var keysToDelete = [];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (key && key.startsWith(playgroundPrefix)) {
            keysToDelete.push(key);
          }
        }
        keysToDelete.forEach(function(k) { localStorage.removeItem(k); });
        console.log('[ArtifactStore] Reset playground, cleared', keysToDelete.length, 'keys');
        return keysToDelete.length;
      }
    };
    
    // ========== RECORD IDENTITY MODEL (v1.5.2) ==========
    // Context for multi-tenant record identity
    const IDENTITY_CONTEXT = {
      tenant_id: 'tenant_default',
      division_id: 'div_default',
      dataset_id: null
    };
    
    // UUID regex for alias detection (RFC4122 v1-5)
    const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    
    // PatchRequest Store (shared between analyst/reviewer/admin)
    const PATCH_REQUEST_STORE = {
      _key: function(patch_request_id) {
        return 'pr:' + ARTIFACT_STORE.environment + ':' + patch_request_id;
      },
      
      get: function(patch_request_id) {
        if (!patch_request_id) return null;
        var data = localStorage.getItem(this._key(patch_request_id));
        if (data) {
          try {
            return JSON.parse(data);
          } catch (e) {
            console.error('[PatchRequestStore] Parse error:', patch_request_id, e);
            return null;
          }
        }
        return null;
      },
      
      save: function(patchRequest) {
        if (!patchRequest || !patchRequest.request_id) {
          console.error('[PatchRequestStore] Invalid patch request');
          return false;
        }
        localStorage.setItem(this._key(patchRequest.request_id), JSON.stringify(patchRequest));
        console.log('[PatchRequestStore] Saved:', patchRequest.request_id);
        return true;
      },
      
      update: function(patch_request_id, updates) {
        var existing = this.get(patch_request_id);
        if (!existing) {
          console.error('[PatchRequestStore] Cannot update, not found:', patch_request_id);
          return false;
        }
        var merged = Object.assign({}, existing, updates);
        merged.updated_at_utc = new Date().toISOString();
        return this.save(merged);
      },
      
      list: function() {
        var prefix = 'pr:' + ARTIFACT_STORE.environment + ':';
        var results = [];
        for (var i = 0; i < localStorage.length; i++) {
          var key = localStorage.key(i);
          if (key && key.startsWith(prefix)) {
            var data = localStorage.getItem(key);
            if (data) {
              try {
                results.push(JSON.parse(data));
              } catch (e) {}
            }
          }
        }
        return results;
      }
    };
    
    // Simple non-crypto hash for deterministic IDs
    function simpleHash(str) {
      var hash = 0;
      for (var i = 0; i < str.length; i++) {
        var char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash).toString(36);
    }
    
    // Canonicalize row for fingerprinting (stable stringification)
    function canonicalizeRowForFingerprint(row) {
      if (!row || typeof row !== 'object') return '';
      var keys = Object.keys(row).filter(function(k) {
        return !k.startsWith('_'); // Skip internal fields
      }).sort();
      var parts = keys.map(function(k) {
        var val = row[k];
        if (val === null || val === undefined) return k + ':';
        return k + ':' + String(val).trim();
      });
      return parts.join('|');
    }
    
    // Generate stable record_id from tenant + dataset + row fingerprint
    function generateStableRecordId(tenant_id, dataset_id, row) {
      var seed = tenant_id + '|' + dataset_id + '|' + canonicalizeRowForFingerprint(row);
      return 'rec_' + simpleHash(seed);
    }
    
    // Detect UUIDs in row values and return as aliases
    function extractUuidAliases(row) {
      var aliases = [];
      if (!row || typeof row !== 'object') return aliases;
      
      Object.keys(row).forEach(function(key) {
        var val = row[key];
        if (typeof val === 'string' && UUID_REGEX.test(val.trim())) {
          aliases.push({ type: 'uuid', field: key, value: val.trim() });
        }
      });
      return aliases;
    }
    
    // Enhance row with record identity model
    function enhanceRowWithIdentity(row, sheetName, rawRowIndex, sourceFileName, datasetId) {
      var tid = IDENTITY_CONTEXT.tenant_id;
      var did = datasetId || IDENTITY_CONTEXT.dataset_id || 'ds_' + Date.now().toString(36);
      
      // v1.6.9: Use stable sheet:row IDs for meta sheets (change logs, RFIs)
      // This prevents random rec_* IDs and enables stable row mapping
      var isMetaSheet = sheetName && (
        sheetName.includes('_change_log') || 
        sheetName === 'RFIs & Analyst Notes'
      );
      
      // Generate stable record_id if not present
      var record_id = row.record_id;
      if (!record_id) {
        if (isMetaSheet) {
          // Meta sheets use sheet:row format for stable mapping
          record_id = sheetName + ':' + rawRowIndex;
        } else {
          record_id = generateStableRecordId(tid, did, row);
        }
      }
      
      // Extract UUID aliases
      var aliases = extractUuidAliases(row);
      
      // Attach identity fields
      row._identity = {
        tenant_id: tid,
        division_id: IDENTITY_CONTEXT.division_id,
        dataset_id: did,
        record_id: record_id,
        source_pointers: {
          sheet_name: sheetName,
          source_file_name: sourceFileName || '',
          raw_row_index: rawRowIndex
        },
        aliases: aliases
      };
      
      // Also set top-level record_id for backwards compatibility
      row.record_id = record_id;
      
      return row;
    }
    
    // ========== CANONICAL RECORD STORE (v1.5.3) ==========
    // Path: kiwi/v1/{tenant_id}/records/{dataset_id}/{record_id}.json
    
    function getRecordStorageKey(tenantId, datasetId, recordId) {
      return 'kiwi/v1/' + tenantId + '/records/' + datasetId + '/' + recordId + '.json';
    }
    
    function persistRecordToStore(row, sheetName, rowIndex) {
      if (!row) return null;
      
      // v1.5.3 Fix: Generate identity if missing
      var identity = row._identity;
      if (!identity) {
        // Generate stable record_id from row data
        var tenantId = IDENTITY_CONTEXT.tenant_id || 'tenant_default';
        var datasetId = IDENTITY_CONTEXT.dataset_id || sheetName || 'default';
        var recordId = row.record_id || (sheetName + ':' + rowIndex);
        
        identity = {
          tenant_id: tenantId,
          division_id: IDENTITY_CONTEXT.division_id || 'div_default',
          dataset_id: datasetId,
          record_id: recordId,
          source_pointers: { sheet_name: sheetName, row_index: rowIndex },
          aliases: [sheetName + ':' + rowIndex]
        };
        
        // Attach identity to row for future reference
        row._identity = identity;
        // Also set record_id directly on row for grid lookups
        row.record_id = recordId;
      }
      
      var storageKey = getRecordStorageKey(
        identity.tenant_id,
        identity.dataset_id,
        identity.record_id
      );
      
      // Build canonical record with full identity
      var storedRecord = {
        tenant_id: identity.tenant_id,
        division_id: identity.division_id,
        dataset_id: identity.dataset_id,
        record_id: identity.record_id,
        source_pointers: {
          sheet_name: sheetName,
          row_index: rowIndex,
          file_name: (identity.source_pointers && identity.source_pointers.source_file_name) || '',
          file_url: row.file_url || ''
        },
        aliases: identity.aliases || [sheetName + ':' + rowIndex],
        data: row,
        _stored_at: new Date().toISOString()
      };
      
      try {
        localStorage.setItem(storageKey, JSON.stringify(storedRecord));
      } catch (e) {
        if (e.name === 'QuotaExceededError' || e.code === 22) {
          // v1.6.5: Handle quota exceeded gracefully - clear old records and retry once
          console.warn('[RecordStore] Quota exceeded, clearing old records...');
          clearOldRecordsFromStore();
          try {
            localStorage.setItem(storageKey, JSON.stringify(storedRecord));
          } catch (e2) {
            console.warn('[RecordStore] Still quota exceeded after cleanup, skipping persist');
            return null;
          }
        } else {
          console.warn('[RecordStore] Failed to persist record:', e);
          return null;
        }
      }
      return storageKey;
    }
    
    // v1.6.5: Clear old records from localStorage to free up quota
    function clearOldRecordsFromStore() {
      var keysToRemove = [];
      for (var i = 0; i < localStorage.length; i++) {
        var key = localStorage.key(i);
        if (key && key.startsWith('kiwi/v1/') && key.endsWith('.json')) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(function(key) {
        localStorage.removeItem(key);
      });
      console.log('[RecordStore] Cleared', keysToRemove.length, 'old records from store');
      return keysToRemove.length;
    }
    
    function loadRecordFromStore(tenantId, datasetId, recordId) {
      var storageKey = getRecordStorageKey(tenantId, datasetId, recordId);
      var stored = localStorage.getItem(storageKey);
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch (e) {
          console.warn('[RecordStore] Failed to parse record:', storageKey, e);
          return null;
        }
      }
      return null;
    }
    
    function persistAllRecordsToStore() {
      // v1.5.3 Fix: Persist all workbook records to canonical store
      // Now works with or without pre-existing _identity - generates if missing
      var count = 0;
      if (!workbook || !workbook.sheets) {
        console.warn('[RecordStore] No workbook or sheets to persist');
        return count;
      }
      
      Object.keys(workbook.sheets).forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        var rows = sheet ? sheet.rows : [];
        if (!rows || rows.length === 0) return;
        
        rows.forEach(function(row, idx) {
          if (row) {
            // persistRecordToStore now generates identity if missing
            persistRecordToStore(row, sheetName, idx);
            count++;
          }
        });
      });
      
      console.log('[RecordStore] Persisted', count, 'records to canonical store');
      return count;
    }
    
    // Generate deterministic artifact ID
    function generateArtifactId(dataset_id, record_id, field_key, timestamp) {
      var seed = [dataset_id, record_id, field_key, timestamp].join('|');
      return 'art_' + simpleHash(seed) + '_' + Date.now().toString(36).slice(-4);
    }
    
    // Generate thread ID for RFI conversations
    function generateThreadId(artifact_id) {
      return 'thread_' + artifact_id.replace('art_', '');
    }
    
    // ========== ARTIFACT ENVELOPE & CRUD ==========
    // Artifact envelope contract fields
    function createArtifact(params) {
      var now = new Date().toISOString();
      var artifact_id = params.artifact_id || generateArtifactId(
        params.dataset_id,
        params.record_id,
        params.field_key,
        now
      );
      var thread_id = params.thread_id || generateThreadId(artifact_id);
      
      var artifact = {
        artifact_id: artifact_id,
        workspace_id: ARTIFACT_STORE.workspace_id,
        environment: ARTIFACT_STORE.environment,
        dataset_id: params.dataset_id || '',
        record_id: params.record_id || '',
        field_key: params.field_key || '',
        artifact_type: params.artifact_type || 'rfi', // 'rfi' | 'patch_request'
        status: params.status || 'open',
        created_by_actor_id: params.created_by_actor_id || getCurrentActorId(),
        created_by_role: params.created_by_role || currentMode,
        assigned_to: params.assigned_to || null,
        created_at: now,
        updated_at: now,
        thread_id: thread_id,
        source_pointers: params.source_pointers || {
          sheet_name: params.sheet_name || '',
          file_url: params.file_url || '',
          file_name: params.file_name || ''
        },
        body: params.body || {}
      };
      
      // Persist artifact
      ARTIFACT_STORE.fsWrite(artifact_id + '.json', artifact);
      
      // Log event
      logArtifactEvent(params.artifact_type === 'rfi' ? 'RFI_CREATED' : 'PATCH_DRAFT_CREATED', artifact);
      
      console.log('[ArtifactStore] Created artifact:', artifact_id, artifact.artifact_type);
      return artifact;
    }
    
    function getArtifact(artifact_id) {
      var data = ARTIFACT_STORE.fsRead(artifact_id + '.json');
      if (data) {
        try {
          return JSON.parse(data);
        } catch (e) {
          console.error('[ArtifactStore] Failed to parse artifact:', artifact_id, e);
          return null;
        }
      }
      return null;
    }
    
    function updateArtifact(artifact_id, updates) {
      var artifact = getArtifact(artifact_id);
      if (!artifact) {
        console.error('[ArtifactStore] Artifact not found:', artifact_id);
        return null;
      }
      
      Object.assign(artifact, updates, { updated_at: new Date().toISOString() });
      ARTIFACT_STORE.fsWrite(artifact_id + '.json', artifact);
      
      console.log('[ArtifactStore] Updated artifact:', artifact_id, updates);
      return artifact;
    }
    
    function listArtifacts(filter) {
      var files = ARTIFACT_STORE.fsList('');
      var artifacts = [];
      
      files.forEach(function(path) {
        if (path.endsWith('.json') && path.startsWith('art_')) {
          var data = ARTIFACT_STORE.fsRead(path);
          if (data) {
            try {
              var artifact = JSON.parse(data);
              if (!filter || matchesFilter(artifact, filter)) {
                artifacts.push(artifact);
              }
            } catch (e) { /* skip invalid */ }
          }
        }
      });
      
      // Sort by created_at descending
      artifacts.sort(function(a, b) {
        return new Date(b.created_at) - new Date(a.created_at);
      });
      
      return artifacts;
    }
    
    function matchesFilter(artifact, filter) {
      if (filter.artifact_type && artifact.artifact_type !== filter.artifact_type) return false;
      if (filter.status && artifact.status !== filter.status) return false;
      if (filter.created_by_role && artifact.created_by_role !== filter.created_by_role) return false;
      if (filter.assigned_to && artifact.assigned_to !== filter.assigned_to) return false;
      if (filter.dataset_id && artifact.dataset_id !== filter.dataset_id) return false;
      if (filter.record_id && artifact.record_id !== filter.record_id) return false;
      return true;
    }
    
    // ========== EVENT LOG ==========
    function logArtifactEvent(event_type, artifact, extra) {
      var event = {
        event_type: event_type,
        artifact_id: artifact.artifact_id,
        artifact_type: artifact.artifact_type,
        record_id: artifact.record_id,
        field_key: artifact.field_key,
        actor_id: getCurrentActorId(),
        role: currentMode,
        timestamp: new Date().toISOString()
      };
      if (extra) Object.assign(event, extra);
      
      ARTIFACT_STORE.fsAppend('events.jsonl', event);
      console.log('[ArtifactStore] Event logged:', event_type, artifact.artifact_id);
    }
    
    function getEventLog() {
      var data = ARTIFACT_STORE.fsRead('events.jsonl');
      if (!data) return [];
      
      return data.split('\n').filter(Boolean).map(function(line) {
        try { return JSON.parse(line); } catch (e) { return null; }
      }).filter(Boolean);
    }
    
    // ========== THREAD SYSTEM (RFI Replies) ==========
    function getThread(thread_id) {
      var data = ARTIFACT_STORE.fsRead(thread_id + '.json');
      if (data) {
        try { return JSON.parse(data); } catch (e) { return null; }
      }
      return { thread_id: thread_id, messages: [] };
    }
    
    function addThreadMessage(thread_id, message) {
      var thread = getThread(thread_id);
      var msg = {
        message_id: 'msg_' + Date.now().toString(36),
        author_id: getCurrentActorId(),
        author_role: currentMode,
        content: message.content || '',
        created_at: new Date().toISOString()
      };
      thread.messages.push(msg);
      ARTIFACT_STORE.fsWrite(thread_id + '.json', thread);
      
      // Log event
      var artifact = getArtifactByThreadId(thread_id);
      if (artifact) {
        logArtifactEvent('RFI_REPLIED', artifact, { message_id: msg.message_id });
      }
      
      return msg;
    }
    
    function getArtifactByThreadId(thread_id) {
      var artifacts = listArtifacts({});
      return artifacts.find(function(a) { return a.thread_id === thread_id; }) || null;
    }
    
    // ========== ACTOR & ROLE HELPERS ==========
    var playgroundActors = {
      analyst: 'analyst@example.com',
      reviewer: 'reviewer@example.com',
      admin: 'admin@example.com'
    };
    
    function getCurrentActorId() {
      return playgroundActors[currentMode] || 'unknown@example.com';
    }
    
    // Environment switching (v1.5.1)
    function setEnvironment(env) {
      if (env === 'prod') {
        showToast('Production environment is locked', 'warning');
        return;
      }
      ARTIFACT_STORE.environment = env;
      document.querySelectorAll('.env-btn').forEach(function(btn) {
        var isActive = btn.dataset.env === env;
        btn.classList.toggle('active', isActive);
        btn.style.background = isActive ? '#e3f2fd' : '#f5f5f5';
        btn.style.color = isActive ? '#1565c0' : '#666';
      });
      console.log('[ArtifactStore] Environment set to:', env);
      showToast('Environment: ' + env, 'info');
    }
    
    // Reset playground data (v1.5.1)
    function resetPlayground() {
      if (!confirm('Reset playground? This will clear all RFIs, patches, and event logs.')) {
        return;
      }
      var cleared = ARTIFACT_STORE.resetPlayground();
      // Also clear legacy verifier queue
      verifierQueueState.payloads = [];
      saveVerifierQueue();
      // Clear legacy patch storage
      localStorage.removeItem(PATCH_STORAGE_KEY);
      
      showToast('Playground reset: ' + cleared + ' artifacts cleared', 'success');
      
      // Re-render any active views
      if (typeof renderVerifierTriage === 'function') {
        renderVerifierTriage();
      }
    }
    
    // ========== QUEUE GENERATION FROM ARTIFACTS ==========
    function getAnalystQueue() {
      var actorId = playgroundActors['analyst'];
      return listArtifacts({}).filter(function(a) {
        return a.created_by_actor_id === actorId || a.assigned_to === actorId;
      });
    }
    
    function getVerifierQueue() {
      return listArtifacts({ artifact_type: 'rfi', status: 'open' }).concat(
        listArtifacts({ artifact_type: 'rfi', status: 'submitted' })
      ).concat(
        listArtifacts({ artifact_type: 'patch_request', status: 'submitted' })
      );
    }
    
    function getPatchQueue() {
      // v1.5.1: Return artifacts approved by verifier (Correction/Blacklist only, not RFI)
      return listArtifacts({ status: 'sent_to_admin' }).filter(function(a) {
        return a.artifact_type === 'patch_request' || a.artifact_type === 'blacklist';
      });
    }
    
    // ========== RECORD LOOKUP BY record_id ==========
    function findRecordById(record_id, datasetId, tenantId) {
      if (!record_id) return null;
      
      var result = null;
      
      // First: Try workbook.sheets (in-memory dataset)
      if (workbook && workbook.sheets) {
        Object.keys(workbook.sheets).some(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          var rows = sheet ? sheet.rows : [];
          if (!rows) return false;
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            // v1.5.2: Check record_id (including _identity.record_id), then fallbacks
            var rowRecordId = row.record_id || (row._identity && row._identity.record_id);
            if (rowRecordId === record_id || 
                row.contract_key === record_id ||
                (sheetName + ':' + i) === record_id) {
              result = { sheetName: sheetName, rowIndex: i, row: row };
              return true;
            }
          }
          return false;
        });
      }
      
      // v1.5.3: Fallback to canonical record store if not found in workbook
      if (!result) {
        var tid = tenantId || IDENTITY_CONTEXT.tenant_id;
        var did = datasetId || IDENTITY_CONTEXT.dataset_id;
        if (tid && did) {
          var storedRecord = loadRecordFromStore(tid, did, record_id);
          if (storedRecord && storedRecord.data) {
            var sp = storedRecord.source_pointers || {};
            result = {
              sheetName: sp.sheet_name || 'default',
              rowIndex: sp.row_index || 0,
              row: storedRecord.data,
              fromStore: true // Mark as loaded from persistent store
            };
            console.log('[RecordStore] Loaded record from store:', record_id);
          }
        }
      }
      
      return result;
    }
    
    function navigateToArtifact(artifact) {
      if (!artifact) return;
      
      var recordInfo = findRecordById(artifact.record_id);
      if (recordInfo) {
        srrState.currentSheetName = recordInfo.sheetName;
        srrState.focusFieldKey = artifact.field_key || null;
        navigateTo('row/' + recordInfo.rowIndex);
        console.log('[ArtifactStore] Navigated to record:', artifact.record_id, 'field:', artifact.field_key);
      } else {
        showToast('Record not found: ' + artifact.record_id, 'warning');
      }
    }
    
    // ========== WORKBOOK DATA STRUCTURE (v1.4.3 INGEST-01) ==========
    // Canonical multi-sheet dataset contract
    var workbook = {
      sheets: {},       // { sheetName: { headers: [], rows: [], meta: {} } }
      order: [],        // Deterministic sheet ordering
      activeSheet: null // Currently selected sheet
    };
    
    function resetWorkbook() {
      workbook.sheets = {};
      workbook.order = [];
      workbook.activeSheet = null;
    }
    
    function setActiveSheet(sheetName) {
      if (workbook.sheets[sheetName]) {
        workbook.activeSheet = sheetName;
        console.log('[Workbook] Active sheet set to:', sheetName);
        return true;
      }
      return false;
    }
    
    function getActiveSheetData() {
      if (!workbook.activeSheet || !workbook.sheets[workbook.activeSheet]) {
        return { headers: [], rows: [], meta: {} };
      }
      return workbook.sheets[workbook.activeSheet];
    }
    
    function addSheet(sheetName, headers, rows, meta) {
      // v1.5.2: Set dataset context if not set
      var datasetId = IDENTITY_CONTEXT.dataset_id || 'ds_' + Date.now().toString(36);
      if (!IDENTITY_CONTEXT.dataset_id) {
        IDENTITY_CONTEXT.dataset_id = datasetId;
      }
      
      var sourceFileName = (meta && meta.source_file_name) || '';
      
      // v1.5.2: Enhance each row with identity model
      var enhancedRows = (rows || []).map(function(row, idx) {
        return enhanceRowWithIdentity(row, sheetName, idx, sourceFileName, datasetId);
      });
      
      workbook.sheets[sheetName] = {
        headers: headers || [],
        rows: enhancedRows,
        meta: meta || {}
      };
      if (!workbook.order.includes(sheetName)) {
        workbook.order.push(sheetName);
        workbook.order.sort(); // Lexical ordering
      }
      // Set active sheet if none set
      if (!workbook.activeSheet) {
        workbook.activeSheet = sheetName;
      }
      console.log('[Workbook] Added sheet:', sheetName, 'headers:', headers.length, 'rows:', enhancedRows.length, 'dataset:', datasetId);
    }
    
    const STORAGE_KEY_SESSION = 'controlboard_session_v11';
    const ARTIFACT_REGISTRY_KEY = 'orchestrateos.artifacts.v1';
    const STORAGE_KEY_DATASET = 'orchestrate.dataset.v1';
    const STORAGE_KEY_PDF_ATTACHMENTS = 'orchestrate.pdf_attachments.v1';
    const STORAGE_KEY_LIBRARY = 'orchestrate.upload_library.v1';
    const STORAGE_KEY_ACTIVE_DATASET = 'orchestrate.active_dataset_id.v1';
    
    // ========== WORKBOOK PARSING + COLUMN MAPPING (V1.4.12) ==========
    var COLUMN_MAPPING_STATE = {
      mappingResolved: false,
      fileNameColumn: null,
      fileUrlColumn: null,
      missingColumns: []
    };
    
    function resolveColumnMapping(headers) {
      COLUMN_MAPPING_STATE.mappingResolved = false;
      COLUMN_MAPPING_STATE.fileNameColumn = null;
      COLUMN_MAPPING_STATE.fileUrlColumn = null;
      COLUMN_MAPPING_STATE.missingColumns = [];
      
      if (!headers || headers.length === 0) {
        COLUMN_MAPPING_STATE.missingColumns = ['file_name', 'file_url'];
        return COLUMN_MAPPING_STATE;
      }
      
      var lowerHeaders = headers.map(function(h) { return (h || '').toLowerCase().trim(); });
      
      // v1.4.14: Extended aliases for file_name
      var fileNameAliases = ['file_name', 'filename', 'file name', 'contract file', 'contract file name', 'document', 'doc_name'];
      var fileNameIdx = lowerHeaders.findIndex(function(h) { 
        return fileNameAliases.indexOf(h) >= 0;
      });
      
      // v1.4.14: Extended aliases for file_url
      var fileUrlAliases = ['file_url', 'fileurl', 'file url', 'url', 'contract source', 'contract url', 'pdf url', 'source', 'document_url', 'doc_url', 'link'];
      var fileUrlIdx = lowerHeaders.findIndex(function(h) { 
        return fileUrlAliases.indexOf(h) >= 0;
      });
      
      if (fileNameIdx >= 0) COLUMN_MAPPING_STATE.fileNameColumn = headers[fileNameIdx];
      if (fileUrlIdx >= 0) COLUMN_MAPPING_STATE.fileUrlColumn = headers[fileUrlIdx];
      
      if (!COLUMN_MAPPING_STATE.fileNameColumn && headers.length >= 1) {
        COLUMN_MAPPING_STATE.fileNameColumn = headers[0];
        console.log('[ColumnMapping] Fallback: column A as file_name:', headers[0]);
      }
      if (!COLUMN_MAPPING_STATE.fileUrlColumn && headers.length >= 2) {
        COLUMN_MAPPING_STATE.fileUrlColumn = headers[1];
        console.log('[ColumnMapping] Fallback: column B as file_url:', headers[1]);
      }
      
      if (!COLUMN_MAPPING_STATE.fileNameColumn) COLUMN_MAPPING_STATE.missingColumns.push('file_name');
      if (!COLUMN_MAPPING_STATE.fileUrlColumn) COLUMN_MAPPING_STATE.missingColumns.push('file_url');
      
      COLUMN_MAPPING_STATE.mappingResolved = COLUMN_MAPPING_STATE.missingColumns.length === 0;
      console.log('[ColumnMapping] Resolved:', COLUMN_MAPPING_STATE);
      return COLUMN_MAPPING_STATE;
    }
    
    function applyColumnMapping(rows, headers, mapping) {
      if (!mapping || !mapping.mappingResolved) return rows;
      
      return rows.map(function(row, idx) {
        var newRow = Object.assign({}, row);
        newRow._row_index = idx;
        
        if (mapping.fileNameColumn && mapping.fileNameColumn !== 'file_name') {
          newRow.file_name = row[mapping.fileNameColumn] || null;
        }
        if (mapping.fileUrlColumn && mapping.fileUrlColumn !== 'file_url') {
          newRow.file_url = row[mapping.fileUrlColumn] || null;
        }
        if (!newRow.contract_key) newRow.contract_key = 'ROW_' + (idx + 1);
        if (!newRow.status) newRow.status = 'needs_review';
        return newRow;
      });
    }
    
    function parseWorkbook(data, filename) {
      var result = { sheets: {}, order: [], errors: [], mapping: null };
      var ext = (filename.split('.').pop() || '').toLowerCase();
      
      try {
        if (ext === 'csv' || ext === 'tsv' || ext === 'txt') {
          var text = typeof data === 'string' ? data : new TextDecoder().decode(data);
          var parsed = parseCSV(text);
          var sheetName = filename.replace(/\.[^.]+$/, '') || 'Sheet1';
          
          var mapping = resolveColumnMapping(parsed.headers);
          result.mapping = mapping;
          var normalizedRows = applyColumnMapping(parsed.rows, parsed.headers, mapping);
          
          result.sheets[sheetName] = { headers: parsed.headers, rows: normalizedRows, meta: { delimiter: parsed.delimiter } };
          result.order.push(sheetName);
          
        } else if (ext === 'xlsx' || ext === 'xls') {
          if (typeof XLSX === 'undefined') {
            result.errors.push('XLSX library not loaded. Please refresh the page.');
            return result;
          }
          
          var arrayBuffer = data instanceof ArrayBuffer ? data : data.buffer;
          var workbookXLSX = XLSX.read(arrayBuffer, { type: 'array' });
          
          var firstSheetMapping = null;
          workbookXLSX.SheetNames.forEach(function(sheetName, idx) {
            var sheet = workbookXLSX.Sheets[sheetName];
            var jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
            
            if (jsonData.length === 0) return;
            
            var headers = jsonData[0].map(function(h) { return String(h || '').trim(); });
            var rows = [];
            for (var i = 1; i < jsonData.length; i++) {
              var rowArr = jsonData[i];
              var rowObj = {};
              headers.forEach(function(h, colIdx) {
                rowObj[h] = rowArr[colIdx] !== undefined ? String(rowArr[colIdx]) : null;
              });
              rows.push(rowObj);
            }
            
            if (idx === 0) {
              firstSheetMapping = resolveColumnMapping(headers);
              result.mapping = firstSheetMapping;
            }
            
            var normalizedRows = applyColumnMapping(rows, headers, firstSheetMapping || { mappingResolved: false });
            result.sheets[sheetName] = { headers: headers, rows: normalizedRows, meta: { sheetIndex: idx } };
            result.order.push(sheetName);
          });
          
          result.order.sort();
        } else {
          result.errors.push('Unsupported file type: .' + ext);
        }
      } catch (err) {
        result.errors.push('Parse error: ' + err.message);
        console.error('[parseWorkbook] Error:', err);
      }
      
      console.log('[parseWorkbook] Result:', result.order.length, 'sheets, errors:', result.errors.length);
      return result;
    }
    
    function showColumnMappingBanner(missingColumns) {
      var banner = document.getElementById('column-mapping-banner');
      var msgEl = document.getElementById('column-mapping-message');
      if (banner && msgEl) {
        if (missingColumns && missingColumns.length > 0) {
          msgEl.textContent = 'Missing required columns: ' + missingColumns.join(', ') + '. Record Inspection will show empty PDF state.';
          banner.style.display = 'block';
        } else {
          banner.style.display = 'none';
        }
      }
    }
    
    function hideColumnMappingBanner() {
      var banner = document.getElementById('column-mapping-banner');
      if (banner) banner.style.display = 'none';
    }
    
    // ========== DEFAULT DATASET (V1.6.3) ==========
    // Ostereo Demo is now the sole default dataset - loaded from JSON file
    // v1.6.4: Moved to loadSampleDataset section - cachedOriginalDataset and cachedModifiedDataset
    
    // ========== NOMENCLATURE PACK (D4) ==========
    // Maps internal tokens to human-readable labels
    const NOMENCLATURE = {
      labels: {
        'sf_packet': 'Preview Packet',
        'sf_summary': 'Summary',
        'sf_contract_results': 'Contract Results',
        'sf_issues': 'Issues',
        'sf_field_actions': 'Field Actions',
        'config_pack_base': 'Truth Config',
        'config_pack_patch': 'Proposed Changes',
        'standardized_dataset': 'Standardized Dataset',
        'expected_output': 'Reference Expected',
        'merged_dataset': 'Merged Dataset',
        'contract_key': 'Contract Key',
        'file_url': 'File URL',
        'file_name': 'File Name',
        'detected_subtype': 'Detected Subtype',
        'sf_contract_status': 'Status'
      },
      tooltips: {
        'Preview Packet': 'The output from running the semantic rules against your data. Contains issues, field actions, and contract statuses.',
        'Truth Config': 'The versioned baseline configuration containing all semantic rules. This is the source of truth.',
        'Proposed Changes': 'A patch file containing rule additions or modifications pending review.',
        'Standardized Dataset': 'Input data that has been normalized to a consistent format for processing.',
        'Reference Expected': 'Golden file outputs used to verify deterministic behavior.',
        'Merged Dataset': 'Combined and normalized data from multiple input sources.',
        'Contract Key': 'Primary identifier linking records across the system.',
        'File URL': 'Secondary identifier based on source file location.',
        'File Name': 'Tertiary identifier based on source file name.',
        'Identity Keys': 'The three-part join identity: Contract Key, File URL, and File Name. Used to match records deterministically.'
      }
    };
    
    // ========== MASTERLINE ARTIFACT REGISTRY (D1) ==========
    const DEFAULT_ARTIFACT_PATHS = {
      truth_config: '../../config/config_pack.base.json',
      proposed_changes: '../../config/config_pack.example.patch.json',
      reference_expected: '../../examples/expected_outputs/sf_packet.example.json',
      standardized_dataset: '../../examples/standardized_dataset.example.json',
      preview_packet: '../../out/sf_packet.preview.json'
    };
    
    const ARTIFACT_LABELS = {
      truth_config: 'Truth Config',
      proposed_changes: 'Proposed Changes',
      reference_expected: 'Reference Expected',
      standardized_dataset: 'Standardized Dataset',
      preview_packet: 'Preview Packet'
    };
    
    let artifactRegistry = {
      devMasterlineEnabled: true,
      bindings: {}
    };
    
    // Helper: Get human label for internal token
    function humanLabel(token) {
      return NOMENCLATURE.labels[token] || token;
    }
    
    // Helper: Get tooltip for a label
    function getTooltip(label) {
      return NOMENCLATURE.tooltips[label] || '';
    }
    
    // Helper: Create info icon with tooltip
    function infoIcon(label) {
      var tip = getTooltip(label);
      if (!tip) return '';
      return '<span class="info-icon" title="' + escapeHtml(tip) + '">&#9432;</span>';
    }
    
    // Load artifact registry from localStorage
    function loadArtifactRegistry() {
      try {
        var saved = localStorage.getItem(ARTIFACT_REGISTRY_KEY);
        if (saved) {
          var parsed = JSON.parse(saved);
          artifactRegistry = Object.assign({}, artifactRegistry, parsed);
        }
      } catch (e) {
        console.warn('Could not load artifact registry:', e);
      }
      // Ensure default bindings exist
      Object.keys(DEFAULT_ARTIFACT_PATHS).forEach(function(key) {
        if (!artifactRegistry.bindings[key]) {
          artifactRegistry.bindings[key] = {
            path: DEFAULT_ARTIFACT_PATHS[key],
            status: 'unknown',
            lastChecked: null,
            rebound: false
          };
        }
      });
    }
    
    // Save artifact registry to localStorage
    function saveArtifactRegistry() {
      try {
        localStorage.setItem(ARTIFACT_REGISTRY_KEY, JSON.stringify(artifactRegistry));
      } catch (e) {
        console.warn('Could not save artifact registry:', e);
      }
    }
    
    // Check if an artifact exists at its path
    async function checkArtifactStatus(key) {
      var binding = artifactRegistry.bindings[key];
      if (!binding) return 'missing';
      try {
        var response = await fetch(binding.path, { method: 'HEAD' });
        binding.status = response.ok ? 'loaded' : 'missing';
      } catch (e) {
        binding.status = 'missing';
      }
      binding.lastChecked = new Date().toISOString();
      return binding.status;
    }
    
    // Check all artifacts and update registry
    async function checkAllArtifacts() {
      var keys = Object.keys(artifactRegistry.bindings);
      await Promise.all(keys.map(function(key) {
        return checkArtifactStatus(key);
      }));
      saveArtifactRegistry();
      renderArtifactRegistryTable();
      renderWorkflowMap();
    }
    
    // Masterline autoload on boot
    async function masterlineAutoload() {
      if (!artifactRegistry.devMasterlineEnabled) return;
      
      // First try to restore from localStorage session
      if (restoreSessionFromStorage()) {
        console.log('[Masterline] Restored from localStorage session');
        // Also check artifacts for registry display
        await checkAllArtifacts();
        return;
      }
      
      // v1.6.8: On cold start, load original demo dataset
      console.log('[Masterline] Cold start - loading demo dataset: ostereo_demo_original.json');
      await loadSampleDataset({ variant: 'original', autoRedirect: false });
      
      // Check artifacts for registry display (after loading demo data)
      await checkAllArtifacts();
      
      // Load Truth Config if exists
      var truthBinding = artifactRegistry.bindings.truth_config;
      if (truthBinding && truthBinding.status === 'loaded') {
        try {
          var response = await fetch(truthBinding.path);
          if (response.ok) {
            loadedBaseConfig = await response.json();
          }
        } catch (e) {
          console.warn('Masterline: Could not load Truth Config:', e);
        }
      }
      
      // Load Proposed Changes if exists
      var patchBinding = artifactRegistry.bindings.proposed_changes;
      if (patchBinding && patchBinding.status === 'loaded') {
        try {
          var response = await fetch(patchBinding.path);
          if (response.ok) {
            loadedPatch = await response.json();
          }
        } catch (e) {
          console.warn('Masterline: Could not load Proposed Changes:', e);
        }
      }
    }
    
    // Render artifact registry table in Admin panel
    function renderArtifactRegistryTable() {
      var container = document.getElementById('artifact-registry-table');
      if (!container) return;
      
      var rows = Object.keys(ARTIFACT_LABELS).map(function(key) {
        var binding = artifactRegistry.bindings[key] || {};
        var label = ARTIFACT_LABELS[key];
        var status = binding.status || 'unknown';
        var statusClass = status === 'loaded' ? 'status-loaded' : status === 'missing' ? 'status-missing' : 'status-unknown';
        var statusText = status === 'loaded' ? 'Loaded' : status === 'missing' ? 'Missing' : 'Unknown';
        var reboundBadge = binding.rebound ? ' <span class="rebound-badge">Rebound</span>' : '';
        var path = binding.path || DEFAULT_ARTIFACT_PATHS[key];
        
        return '<tr>' +
          '<td>' + label + ' ' + infoIcon(label) + '</td>' +
          '<td><span class="artifact-status ' + statusClass + '">' + statusText + '</span>' + reboundBadge + '</td>' +
          '<td class="artifact-path" title="' + escapeHtml(path) + '">' + escapeHtml(path.split('/').pop()) + '</td>' +
          '<td><button class="rebind-btn" onclick="rebindArtifact(\'' + key + '\')">Rebind</button></td>' +
          '</tr>';
      }).join('');
      
      container.innerHTML = '<table class="artifact-table">' +
        '<thead><tr><th>Artifact</th><th>Status</th><th>File</th><th>Action</th></tr></thead>' +
        '<tbody>' + rows + '</tbody></table>';
    }
    
    // Rebind artifact path
    function rebindArtifact(key) {
      var binding = artifactRegistry.bindings[key];
      var currentPath = binding ? binding.path : DEFAULT_ARTIFACT_PATHS[key];
      var newPath = prompt('Enter new path for ' + ARTIFACT_LABELS[key] + ':', currentPath);
      if (newPath && newPath !== currentPath) {
        artifactRegistry.bindings[key] = {
          path: newPath,
          status: 'unknown',
          lastChecked: null,
          rebound: true
        };
        saveArtifactRegistry();
        checkArtifactStatus(key).then(function() {
          saveArtifactRegistry();
          renderArtifactRegistryTable();
        });
      }
    }
    
    // Toggle Dev Masterline mode
    function toggleDevMasterline() {
      artifactRegistry.devMasterlineEnabled = !artifactRegistry.devMasterlineEnabled;
      saveArtifactRegistry();
      updateDevMasterlineUI();
      if (artifactRegistry.devMasterlineEnabled) {
        masterlineAutoload();
      }
    }
    
    // Update Dev Masterline toggle UI
    function updateDevMasterlineUI() {
      var toggle = document.getElementById('dev-masterline-toggle');
      var status = document.getElementById('dev-masterline-status');
      if (toggle) {
        toggle.checked = artifactRegistry.devMasterlineEnabled;
      }
      if (status) {
        status.textContent = artifactRegistry.devMasterlineEnabled ? 'ON' : 'OFF';
        status.className = 'masterline-status ' + (artifactRegistry.devMasterlineEnabled ? 'on' : 'off');
      }
    }
    
    // ========== WORKFLOW MAP (D2) ==========
    const WORKFLOW_STAGES = [
      {
        id: 'load',
        title: 'Data Source',
        desc: 'Add or switch data source. Load Preview Packet and reference data.',
        icon: 'ðŸ“',
        artifacts: ['preview_packet', 'reference_expected'],
        action: function() { openDataSourcePanel(); }
      },
      {
        id: 'config',
        title: 'Configuration',
        desc: 'Truth Config and Proposed Changes define semantic rules.',
        icon: 'âš™',
        artifacts: ['truth_config', 'proposed_changes'],
        action: function() { openConfigFlows(); }
      },
      {
        id: 'standardize',
        title: 'Standardize',
        desc: 'Normalize input data format (CSV/XLSX to merged dataset).',
        icon: 'ðŸ“‹',
        artifacts: ['standardized_dataset'],
        action: function() { if (currentMode === 'admin') openConfigFlows(); }
      },
      {
        id: 'preview',
        title: 'Preview',
        desc: 'Generated Preview Packet with issues and field actions.',
        icon: 'ðŸ‘',
        artifacts: ['preview_packet'],
        action: function() { navigateTo('triage'); }
      },
      {
        id: 'triage',
        title: 'Triage',
        desc: 'Review contracts by queue, filter by severity/status.',
        icon: 'ðŸ“Š',
        artifacts: [],
        action: function() { navigateTo('triage'); }
      },
      {
        id: 'patch',
        title: 'Patch Draft',
        desc: 'Build rule patches from selected issues and actions.',
        icon: 'âœ',
        artifacts: [],
        action: function() { navigateTo('patch'); }
      },
      {
        id: 'evidence',
        title: 'Evidence',
        desc: 'Paste validation and smoke test results as evidence.',
        icon: 'âœ“',
        artifacts: [],
        action: function() { showEvidenceStatus(); }
      },
      {
        id: 'export',
        title: 'PR Ready',
        desc: 'Export patch bundle and PR summary for review.',
        icon: 'ðŸ“¤',
        artifacts: [],
        action: function() { navigateTo('patch'); }
      }
    ];
    
    // ========== COMMENT (RFI) SYSTEM ==========
    var COMMENTS_STORAGE_KEY = 'orchestrate.comments.v1';
    
    var COMMENT_STATUSES = ['Open', 'ReviewerResponded', 'Resolved', 'ElevatedToPatchRequest', 'Closed'];
    var COMMENT_SCOPES = ['field', 'sheet', 'contract'];
    var COMMENT_ROLES = ['Analyst', 'Reviewer', 'Admin'];
    
    var commentsStore = {
      comments: [],
      loaded: false
    };
    
    function generateCommentId() {
      return 'CMT_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 6);
    }
    
    function loadComments() {
      try {
        var stored = localStorage.getItem(COMMENTS_STORAGE_KEY);
        if (stored) {
          var parsed = JSON.parse(stored);
          commentsStore.comments = Array.isArray(parsed.comments) ? parsed.comments : [];
        } else {
          commentsStore.comments = [];
        }
        commentsStore.loaded = true;
      } catch (e) {
        console.error('Failed to load comments:', e);
        commentsStore.comments = [];
        commentsStore.loaded = true;
      }
      return commentsStore.comments;
    }
    
    function saveComments() {
      try {
        var data = {
          version: '1.0.0',
          saved_at: new Date().toISOString(),
          comments: commentsStore.comments
        };
        localStorage.setItem(COMMENTS_STORAGE_KEY, JSON.stringify(data));
        return true;
      } catch (e) {
        console.error('Failed to save comments:', e);
        return false;
      }
    }
    
    function createComment(options) {
      var now = new Date().toISOString();
      var comment = {
        comment_id: generateCommentId(),
        created_at_utc: now,
        author: options.author || 'Unknown',
        author_role: options.author_role || currentMode || 'Analyst',
        record_identity: {
          contract_key: options.contract_key || null,
          file_url: options.file_url || null,
          file_name: options.file_name || null
        },
        scope: {
          level: options.scope_level || 'contract',
          sheet: options.sheet || null,
          field: options.field || null
        },
        message: options.message || '',
        status: 'Open',
        linked_patch_request_id: null,
        history: [
          {
            at_utc: now,
            actor: options.author || 'Unknown',
            role: options.author_role || currentMode || 'Analyst',
            action: 'Created',
            notes: null
          }
        ]
      };
      commentsStore.comments.push(comment);
      saveComments();
      return comment;
    }
    
    function getComment(commentId) {
      return commentsStore.comments.find(function(c) { return c.comment_id === commentId; }) || null;
    }
    
    function updateComment(commentId, updates, actor, actorRole) {
      var comment = getComment(commentId);
      if (!comment) return null;
      
      var now = new Date().toISOString();
      var changes = [];
      
      if (updates.message !== undefined && updates.message !== comment.message) {
        comment.message = updates.message;
        changes.push('message');
      }
      if (updates.status !== undefined && updates.status !== comment.status) {
        var oldStatus = comment.status;
        comment.status = updates.status;
        changes.push('status: ' + oldStatus + ' â†’ ' + updates.status);
      }
      if (updates.linked_patch_request_id !== undefined) {
        comment.linked_patch_request_id = updates.linked_patch_request_id;
        changes.push('linked to patch request');
      }
      
      if (changes.length > 0) {
        comment.history.push({
          at_utc: now,
          actor: actor || 'Unknown',
          role: actorRole || currentMode || 'Analyst',
          action: 'Updated',
          notes: changes.join('; ')
        });
        saveComments();
      }
      return comment;
    }
    
    function addCommentResponse(commentId, responseMessage, actor, actorRole) {
      var comment = getComment(commentId);
      if (!comment) return null;
      
      var now = new Date().toISOString();
      comment.history.push({
        at_utc: now,
        actor: actor || 'Unknown',
        role: actorRole || currentMode || 'Analyst',
        action: 'Responded',
        notes: responseMessage
      });
      
      if (actorRole === 'Reviewer' || actorRole === 'Admin') {
        comment.status = 'ReviewerResponded';
      }
      
      saveComments();
      return comment;
    }
    
    function resolveComment(commentId, actor, actorRole) {
      return updateComment(commentId, { status: 'Resolved' }, actor, actorRole);
    }
    
    function closeComment(commentId, actor, actorRole) {
      return updateComment(commentId, { status: 'Closed' }, actor, actorRole);
    }
    
    function elevateCommentToPatchRequest(commentId, patchRequestId, actor, actorRole) {
      var comment = getComment(commentId);
      if (!comment) return null;
      
      comment.status = 'ElevatedToPatchRequest';
      comment.linked_patch_request_id = patchRequestId;
      comment.history.push({
        at_utc: new Date().toISOString(),
        actor: actor || 'Unknown',
        role: actorRole || 'Reviewer',
        action: 'Elevated to Patch Request',
        notes: 'Linked to ' + patchRequestId
      });
      
      saveComments();
      return comment;
    }
    
    function deleteComment(commentId) {
      var idx = commentsStore.comments.findIndex(function(c) { return c.comment_id === commentId; });
      if (idx === -1) return false;
      commentsStore.comments.splice(idx, 1);
      saveComments();
      return true;
    }
    
    function getCommentsForRecord(contractKey, fileUrl, fileName) {
      return commentsStore.comments.filter(function(c) {
        var ri = c.record_identity;
        return (ri.contract_key === contractKey || (!ri.contract_key && !contractKey)) &&
               (ri.file_url === fileUrl || (!ri.file_url && !fileUrl)) &&
               (ri.file_name === fileName || (!ri.file_name && !fileName));
      });
    }
    
    function getCommentsByStatus(status) {
      return commentsStore.comments.filter(function(c) { return c.status === status; });
    }
    
    function getCommentsByTarget(targetType, targetId) {
      return commentsStore.comments.filter(function(c) {
        return c.target_type === targetType && c.target_id === targetId;
      });
    }
    
    function getOpenComments() {
      return commentsStore.comments.filter(function(c) {
        return c.status === 'Open' || c.status === 'ReviewerResponded';
      });
    }
    
    function getCommentCounts() {
      var counts = {
        total: commentsStore.comments.length,
        open: 0,
        reviewer_responded: 0,
        resolved: 0,
        elevated: 0,
        closed: 0
      };
      commentsStore.comments.forEach(function(c) {
        if (c.status === 'Open') counts.open++;
        else if (c.status === 'ReviewerResponded') counts.reviewer_responded++;
        else if (c.status === 'Resolved') counts.resolved++;
        else if (c.status === 'ElevatedToPatchRequest') counts.elevated++;
        else if (c.status === 'Closed') counts.closed++;
      });
      return counts;
    }
    
    function exportCommentsJSON() {
      return JSON.stringify({
        exported_at: new Date().toISOString(),
        count: commentsStore.comments.length,
        comments: commentsStore.comments.map(function(c) {
          return Object.assign({}, c);
        }).sort(function(a, b) {
          return a.created_at_utc.localeCompare(b.created_at_utc);
        })
      }, null, 2);
    }
    
    // Initialize comments on load
    loadComments();
    
    // ========== PATCH REQUEST SYSTEM ==========
    var PATCH_REQUESTS_STORAGE_KEY = 'orchestrate.patch_requests.v1';
    
    var PATCH_REQUEST_STATUSES = [
      'Draft',
      'Submitted',
      'Needs_Clarification',
      'Reviewer_Responded',
      'Reviewer_Approved',
      'Admin_Approved',
      'Sent_to_Kiwi',
      'Kiwi_Returned',
      'Applied',
      'Rejected',
      'Cancelled',
      'Admin_Hold'
    ];
    
    var PATCH_REQUEST_QUEUE_TABS = [
      { id: 'new', label: 'New', statuses: ['Submitted'] },
      { id: 'needs_review', label: 'Needs Review', statuses: ['Needs_Clarification', 'Reviewer_Responded'] },
      { id: 'approved', label: 'Approved', statuses: ['Reviewer_Approved', 'Admin_Approved'] },
      { id: 'sent_to_kiwi', label: 'Sent to Kiwi', statuses: ['Sent_to_Kiwi'] },
      { id: 'kiwi_returned', label: 'Kiwi Returned', statuses: ['Kiwi_Returned'] },
      { id: 'applied', label: 'Applied', statuses: ['Applied'] },
      { id: 'rejected', label: 'Rejected', statuses: ['Rejected', 'Cancelled'] }
    ];
    
    var PATCH_REQUEST_TARGETS = ['salesforce', 'qa_rules', 'resolver_rules', 'truth_config', 'proposed_changes'];
    
    var ROLE_PERMISSIONS = {
      'Analyst': {
        can: ['create_draft', 'edit_own_draft', 'submit_to_patch_queue', 'respond_to_clarification', 'cancel_own_draft_or_submitted'],
        cannot: ['reviewer_approve', 'admin_approve', 'send_to_kiwi', 'paste_kiwi_return', 'mark_applied', 'admin_hold']
      },
      'Verifier': {
        can: ['comment_rfi', 'request_clarification', 'edit_review_fields', 'reviewer_approve', 'reject', 'send_back_to_submitted_after_edits'],
        cannot: ['send_to_kiwi', 'paste_kiwi_return', 'mark_applied', 'admin_approve', 'edit_patch_payload_directly'],
        edit_allowlist: ['intent.when', 'intent.then', 'intent.because', 'target_scope', 'risk', 'review_notes', 'evidence.checklist_status', 'clarification_questions']
      },
      'Admin': {
        can: ['everything_verifier_can', 'admin_approve', 'send_to_kiwi', 'paste_kiwi_return', 'mark_applied', 'admin_hold', 'cancel_any', 'export_commit_pack']
      }
    };
    
    var STATUS_TRANSITIONS = [
      { from: 'Draft', to: 'Submitted', roles: ['Analyst'], action: 'submit_to_patch_queue', audit: 'PATCH_REQUEST_SUBMITTED' },
      { from: 'Submitted', to: 'Needs_Clarification', roles: ['Verifier', 'Admin'], action: 'request_clarification', audit: 'CLARIFICATION_REQUESTED' },
      { from: 'Needs_Clarification', to: 'Reviewer_Responded', roles: ['Analyst'], action: 'respond_to_clarification', audit: 'CLARIFICATION_RESPONDED' },
      { from: 'Reviewer_Responded', to: 'Reviewer_Approved', roles: ['Verifier'], action: 'reviewer_approve', audit: 'REVIEWER_APPROVED' },
      { from: 'Submitted', to: 'Reviewer_Approved', roles: ['Verifier'], action: 'reviewer_approve', audit: 'REVIEWER_APPROVED' },
      { from: 'Reviewer_Approved', to: 'Admin_Approved', roles: ['Admin'], action: 'admin_approve', audit: 'ADMIN_APPROVED' },
      { from: 'Admin_Approved', to: 'Sent_to_Kiwi', roles: ['Admin'], action: 'send_to_kiwi', audit: 'SENT_TO_KIWI' },
      { from: 'Sent_to_Kiwi', to: 'Kiwi_Returned', roles: ['Admin'], action: 'paste_kiwi_return', audit: 'KIWI_RETURN_INGESTED' },
      { from: 'Kiwi_Returned', to: 'Applied', roles: ['Admin'], action: 'mark_applied', audit: 'PATCH_APPLIED' },
      { from: 'Submitted', to: 'Rejected', roles: ['Verifier', 'Admin'], action: 'reject', audit: 'PATCH_REJECTED' },
      { from: 'Reviewer_Responded', to: 'Rejected', roles: ['Verifier', 'Admin'], action: 'reject', audit: 'PATCH_REJECTED' },
      { from: 'Draft', to: 'Cancelled', roles: ['Analyst', 'Admin'], action: 'cancel', audit: 'PATCH_CANCELLED' },
      { from: 'Submitted', to: 'Cancelled', roles: ['Analyst', 'Admin'], action: 'cancel', audit: 'PATCH_CANCELLED' },
      { from: 'Reviewer_Approved', to: 'Admin_Hold', roles: ['Admin'], action: 'admin_hold', audit: 'ADMIN_HOLD_SET' },
      { from: 'Admin_Hold', to: 'Admin_Approved', roles: ['Admin'], action: 'release_hold', audit: 'ADMIN_HOLD_RELEASED' }
    ];
    
    function canTransition(fromStatus, toStatus, role) {
      var transition = STATUS_TRANSITIONS.find(function(t) {
        return t.from === fromStatus && t.to === toStatus;
      });
      if (!transition) return false;
      if (role === 'Admin' && transition.roles.includes('Verifier')) return true;
      return transition.roles.includes(role);
    }
    
    function getAuditEventForTransition(fromStatus, toStatus) {
      var transition = STATUS_TRANSITIONS.find(function(t) {
        return t.from === fromStatus && t.to === toStatus;
      });
      return transition ? transition.audit : 'STATUS_CHANGED';
    }
    
    function getAvailableTransitions(currentStatus, role) {
      return STATUS_TRANSITIONS.filter(function(t) {
        if (t.from !== currentStatus) return false;
        if (role === 'Admin') return true;
        if (role === 'Verifier' && (t.roles.includes('Verifier') || t.roles.includes('Admin'))) return false;
        return t.roles.includes(role);
      }).map(function(t) { return t.to; });
    }
    
    function canEditField(role, fieldPath) {
      if (role === 'Admin') return true;
      if (role === 'Verifier') {
        return ROLE_PERMISSIONS.Verifier.edit_allowlist.includes(fieldPath);
      }
      return false;
    }
    
    var patchRequestsStore = {
      requests: [],
      loaded: false,
      selectedIds: []
    };
    
    function generatePatchRequestId() {
      return 'PR_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 6);
    }
    
    function loadPatchRequests() {
      try {
        var stored = localStorage.getItem(PATCH_REQUESTS_STORAGE_KEY);
        if (stored) {
          var parsed = JSON.parse(stored);
          patchRequestsStore.requests = Array.isArray(parsed.requests) ? parsed.requests : [];
        } else {
          patchRequestsStore.requests = [];
        }
        patchRequestsStore.loaded = true;
      } catch (e) {
        console.error('Failed to load patch requests:', e);
        patchRequestsStore.requests = [];
        patchRequestsStore.loaded = true;
      }
      return patchRequestsStore.requests;
    }
    
    function savePatchRequests() {
      try {
        var data = {
          version: '1.0.0',
          saved_at: new Date().toISOString(),
          requests: patchRequestsStore.requests
        };
        localStorage.setItem(PATCH_REQUESTS_STORAGE_KEY, JSON.stringify(data));
        return true;
      } catch (e) {
        console.error('Failed to save patch requests:', e);
        return false;
      }
    }
    
    var CONDITION_TYPES = [
      { value: 'SHOULD_BE_BLANK_BUT_POPULATED', label: 'Should be blank but has data' },
      { value: 'SHOULD_BE_PRESENT_BUT_MISSING', label: 'Should have data but is empty' },
      { value: 'INVALID_FORMAT', label: 'Invalid format/pattern' },
      { value: 'OUT_OF_RANGE', label: 'Value out of allowed range' },
      { value: 'MISMATCH_WITH_OTHER_FIELD', label: 'Mismatches another field' },
      { value: 'DUPLICATE', label: 'Duplicate value detected' },
      { value: 'OTHER', label: 'Other (specify)' }
    ];
    
    var ACTION_TYPES = [
      { value: 'REQUIRE_PRESENT', label: 'Require field to have a value' },
      { value: 'REQUIRE_BLANK', label: 'Require field to be blank' },
      { value: 'WARN_ONLY', label: 'Warn only (non-blocking)' },
      { value: 'NORMALIZE_VALUE', label: 'Normalize/standardize value' },
      { value: 'MAP_FIELD', label: 'Map to another field' },
      { value: 'BLOCK_SUBMISSION', label: 'Block submission' },
      { value: 'OTHER', label: 'Other (specify)' }
    ];
    
    function renderIntentPreview(intentStructured) {
      var whenText = '';
      var thenText = '';
      
      if (intentStructured.target_field) {
        whenText = 'Field "' + intentStructured.target_field + '"';
        var condition = CONDITION_TYPES.find(function(c) { return c.value === intentStructured.condition_type; });
        if (condition) {
          whenText += ' ' + condition.label.toLowerCase();
        }
        if (intentStructured.condition_type === 'OTHER' && intentStructured.condition_params && intentStructured.condition_params.custom) {
          whenText += ': ' + intentStructured.condition_params.custom;
        }
      }
      
      var action = ACTION_TYPES.find(function(a) { return a.value === intentStructured.action_type; });
      if (action) {
        thenText = action.label;
      }
      if (intentStructured.action_type === 'OTHER' && intentStructured.action_params && intentStructured.action_params.custom) {
        thenText += ': ' + intentStructured.action_params.custom;
      }
      
      return {
        when: whenText || 'WHEN: (not specified)',
        then: thenText || 'THEN: (not specified)',
        because: intentStructured.because || ''
      };
    }
    
    function createPatchRequest(options) {
      var now = new Date().toISOString();
      
      var intentStructured = {
        target_field: options.target_field || (options.sheet && options.field ? options.sheet + '.' + options.field : null),
        condition_type: options.condition_type || 'OTHER',
        condition_params: options.condition_params || (options.when ? { custom: options.when } : null),
        action_type: options.action_type || 'OTHER',
        action_params: options.action_params || (options.then ? { custom: options.then } : null),
        severity: options.severity || 'warning',
        risk: options.risk || 'low',
        target_artifact: options.target || 'proposed_changes',
        because: options.because || ''
      };
      
      var intentRendered = renderIntentPreview(intentStructured);
      if (options.because) {
        intentRendered.because = options.because;
      }
      
      var request = {
        request_id: generatePatchRequestId(),
        created_at_utc: now,
        updated_at_utc: now,
        submitted_at_utc: null,
        author: options.author || 'Unknown',
        author_role: options.author_role || currentMode || 'Analyst',
        assigned_to: null,
        status: options.status || 'Draft',
        // v1.5.2: Enhanced record identity with record_id
        tenant_id: options.tenant_id || IDENTITY_CONTEXT.tenant_id,
        division_id: options.division_id || IDENTITY_CONTEXT.division_id,
        dataset_id: options.dataset_id || IDENTITY_CONTEXT.dataset_id || 'default',
        record_id: options.record_id || null,
        patch_kind: options.patch_kind || options.patch_type || 'correction',
        record_identity: {
          contract_key: options.contract_key || null,
          file_url: options.file_url || null,
          file_name: options.file_name || null
        },
        target_scope: {
          target: options.target || 'proposed_changes',
          sheet: options.sheet || null,
          field: options.field || null
        },
        risk: options.risk || 'low',
        intent_structured: intentStructured,
        intent_rendered: intentRendered,
        proposed_changes: options.proposed_changes || [{
          field: options.field || null,
          old_value: options.old_value || null,
          new_value: options.new_value || null
        }],
        proposed_change: {
          intent: intentRendered,
          rationale: options.rationale || ''
        },
        evidence_pack: {
          observation: options.evidence_observation || '',
          expected_behavior: options.evidence_expected || '',
          rule_justification: options.evidence_justification || '',
          repro_steps: options.evidence_repro || ''
        },
        evidence: {
          observation: options.evidence_observation || '',
          expected_behavior: options.evidence_expected || '',
          rule_justification: options.evidence_justification || '',
          repro_steps: options.evidence_repro || '',
          preflight_results: null,
          checklist_status: {}
        },
        thread: options.thread || [],
        review_notes: '',
        clarification_questions: [],
        revisions: [],
        linked_comment_id: options.linked_comment_id || null,
        kiwi_return: null,
        audit_log: [
          {
            at_utc: now,
            actor: options.author || 'Unknown',
            role: options.author_role || currentMode || 'Analyst',
            event: 'PATCH_REQUEST_CREATED',
            details: null
          }
        ],
        history: [
          {
            at_utc: now,
            actor: options.author || 'Unknown',
            role: options.author_role || currentMode || 'Analyst',
            action: 'Created',
            from_status: null,
            to_status: 'Draft',
            notes: null
          }
        ]
      };
      patchRequestsStore.requests.push(request);
      savePatchRequests();
      
      // v1.5.2: Also save to PATCH_REQUEST_STORE for shared access
      PATCH_REQUEST_STORE.save(request);
      
      return request;
    }
    
    function getPatchRequest(requestId) {
      return patchRequestsStore.requests.find(function(r) { return r.request_id === requestId; }) || null;
    }
    
    function updatePatchRequestStatus(requestId, newStatus, actor, actorRole, notes) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (!PATCH_REQUEST_STATUSES.includes(newStatus)) return null;
      
      var role = actorRole || currentMode || 'Analyst';
      if (!canTransition(request.status, newStatus, role)) {
        console.warn('Transition not allowed:', request.status, '->', newStatus, 'for role', role);
        return null;
      }
      
      var now = new Date().toISOString();
      var oldStatus = request.status;
      var auditEvent = getAuditEventForTransition(oldStatus, newStatus);
      
      request.status = newStatus;
      request.updated_at_utc = now;
      
      if (newStatus === 'Submitted' && !request.submitted_at_utc) {
        request.submitted_at_utc = now;
      }
      
      request.history.push({
        at_utc: now,
        actor: actor || 'Unknown',
        role: role,
        action: 'Status Changed',
        from_status: oldStatus,
        to_status: newStatus,
        notes: notes || null
      });
      
      if (!request.audit_log) request.audit_log = [];
      request.audit_log.push({
        at_utc: now,
        actor: actor || 'Unknown',
        role: role,
        event: auditEvent,
        details: notes || null
      });
      
      savePatchRequests();
      return request;
    }
    
    function updatePatchRequest(requestId, updates, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      
      var now = new Date().toISOString();
      var role = actorRole || currentMode || 'Analyst';
      var changes = [];
      var oldSnapshot = null;
      
      if (request.status !== 'Draft') {
        oldSnapshot = JSON.parse(JSON.stringify({
          proposed_change: request.proposed_change,
          target_scope: request.target_scope,
          evidence: request.evidence,
          review_notes: request.review_notes
        }));
      }
      
      if (updates.proposed_change) {
        if (updates.proposed_change.intent) {
          if (role === 'Verifier') {
            ['when', 'then', 'because'].forEach(function(field) {
              if (updates.proposed_change.intent[field] !== undefined && canEditField(role, 'intent.' + field)) {
                request.proposed_change.intent[field] = updates.proposed_change.intent[field];
                changes.push('intent.' + field + ' updated');
              }
            });
          } else {
            Object.assign(request.proposed_change.intent, updates.proposed_change.intent);
            changes.push('intent updated');
          }
        }
        if (updates.proposed_change.rationale !== undefined) {
          request.proposed_change.rationale = updates.proposed_change.rationale;
          changes.push('rationale updated');
        }
      }
      if (updates.target_scope && canEditField(role, 'target_scope')) {
        Object.assign(request.target_scope, updates.target_scope);
        changes.push('target updated');
      }
      if (updates.risk !== undefined && canEditField(role, 'risk')) {
        request.risk = updates.risk;
        changes.push('risk updated');
      }
      if (updates.review_notes !== undefined && canEditField(role, 'review_notes')) {
        request.review_notes = updates.review_notes;
        changes.push('review notes updated');
      }
      if (updates.evidence) {
        if (!request.evidence) request.evidence = {};
        Object.assign(request.evidence, updates.evidence);
        changes.push('evidence updated');
      }
      if (updates.clarification_questions) {
        request.clarification_questions = updates.clarification_questions;
        changes.push('clarification questions updated');
      }
      
      if (changes.length > 0) {
        request.updated_at_utc = now;
        
        if (oldSnapshot && request.status !== 'Draft') {
          if (!request.revisions) request.revisions = [];
          request.revisions.push({
            revision_id: 'REV_' + Date.now().toString(36),
            at_utc: now,
            actor: actor || 'Unknown',
            role: role,
            diff_summary: changes.join('; '),
            previous_snapshot: oldSnapshot
          });
        }
        
        request.history.push({
          at_utc: now,
          actor: actor || 'Unknown',
          role: role,
          action: 'Updated',
          from_status: request.status,
          to_status: request.status,
          notes: changes.join('; ')
        });
        
        if (!request.audit_log) request.audit_log = [];
        request.audit_log.push({
          at_utc: now,
          actor: actor || 'Unknown',
          role: role,
          event: 'PATCH_REQUEST_UPDATED',
          details: changes.join('; ')
        });
        
        savePatchRequests();
      }
      return request;
    }
    
    function submitPatchRequest(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Draft') return null;
      return updatePatchRequestStatus(requestId, 'Submitted', actor, actorRole, 'Submitted to patch queue');
    }
    
    function requestClarification(requestId, questions, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Submitted') return null;
      
      request.clarification_questions = questions || [];
      var result = updatePatchRequestStatus(requestId, 'Needs_Clarification', actor, actorRole, 'Clarification requested');
      return result;
    }
    
    function respondToClarification(requestId, response, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Needs_Clarification') return null;
      
      if (!request.clarification_questions) request.clarification_questions = [];
      request.clarification_questions.push({
        type: 'response',
        from: actor || 'Analyst',
        at_utc: new Date().toISOString(),
        text: response
      });
      
      return updatePatchRequestStatus(requestId, 'Reviewer_Responded', actor, actorRole, 'Clarification provided');
    }
    
    function reviewerApprove(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (!['Submitted', 'Reviewer_Responded'].includes(request.status)) return null;
      return updatePatchRequestStatus(requestId, 'Reviewer_Approved', actor, actorRole, 'Approved by reviewer');
    }
    
    function adminApprove(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Reviewer_Approved') return null;
      return updatePatchRequestStatus(requestId, 'Admin_Approved', actor, actorRole, 'Approved by admin');
    }
    
    function setAdminHold(requestId, reason, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Reviewer_Approved') return null;
      return updatePatchRequestStatus(requestId, 'Admin_Hold', actor, actorRole, reason || 'Placed on admin hold');
    }
    
    function releaseAdminHold(requestId, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Admin_Hold') return null;
      return updatePatchRequestStatus(requestId, 'Admin_Approved', actor, actorRole, 'Released from admin hold');
    }
    
    function deletePatchRequest(requestId) {
      var idx = patchRequestsStore.requests.findIndex(function(r) { return r.request_id === requestId; });
      if (idx === -1) return false;
      patchRequestsStore.requests.splice(idx, 1);
      savePatchRequests();
      return true;
    }
    
    // Batch selection
    function selectPatchRequest(requestId) {
      if (!patchRequestsStore.selectedIds.includes(requestId)) {
        patchRequestsStore.selectedIds.push(requestId);
      }
    }
    
    function deselectPatchRequest(requestId) {
      var idx = patchRequestsStore.selectedIds.indexOf(requestId);
      if (idx !== -1) {
        patchRequestsStore.selectedIds.splice(idx, 1);
      }
    }
    
    function togglePatchRequestSelection(requestId) {
      if (patchRequestsStore.selectedIds.includes(requestId)) {
        deselectPatchRequest(requestId);
      } else {
        selectPatchRequest(requestId);
      }
    }
    
    function clearPatchRequestSelection() {
      patchRequestsStore.selectedIds = [];
    }
    
    function getSelectedPatchRequests() {
      return patchRequestsStore.selectedIds.map(function(id) {
        return getPatchRequest(id);
      }).filter(function(r) { return r !== null; });
    }
    
    function selectAllInQueue(queueId) {
      var queue = PATCH_REQUEST_QUEUE_TABS.find(function(q) { return q.id === queueId; });
      if (!queue) return;
      patchRequestsStore.requests.forEach(function(r) {
        if (queue.statuses.includes(r.status)) {
          selectPatchRequest(r.request_id);
        }
      });
    }
    
    // Queue queries
    function getPatchRequestsByQueue(queueId) {
      var queue = PATCH_REQUEST_QUEUE_TABS.find(function(q) { return q.id === queueId; });
      if (!queue) return [];
      return patchRequestsStore.requests.filter(function(r) {
        return queue.statuses.includes(r.status);
      }).sort(function(a, b) {
        return b.updated_at_utc.localeCompare(a.updated_at_utc);
      });
    }
    
    function getPatchRequestsByStatus(status) {
      return patchRequestsStore.requests.filter(function(r) { return r.status === status; });
    }
    
    function getPatchRequestCounts() {
      var counts = { total: patchRequestsStore.requests.length };
      PATCH_REQUEST_QUEUE_TABS.forEach(function(queue) {
        counts[queue.id] = 0;
      });
      patchRequestsStore.requests.forEach(function(r) {
        PATCH_REQUEST_QUEUE_TABS.forEach(function(queue) {
          if (queue.statuses.includes(r.status)) {
            counts[queue.id]++;
          }
        });
      });
      return counts;
    }
    
    // Kiwi handshake functions
    function markSentToKiwi(requestIds, actor, actorRole) {
      var updated = [];
      requestIds.forEach(function(id) {
        var result = updatePatchRequestStatus(id, 'Sent_to_Kiwi', actor, actorRole, 'Exported for Kiwi processing');
        if (result) updated.push(result);
      });
      return updated;
    }
    
    function applyKiwiReturn(requestId, kiwiPayload, actor, actorRole) {
      var request = getPatchRequest(requestId);
      if (!request) return null;
      if (request.status !== 'Sent_to_Kiwi') return null;
      
      var now = new Date().toISOString();
      request.kiwi_return = {
        returned_at_utc: now,
        patch_payload_json: kiwiPayload.patch_payload_json || kiwiPayload,
        notes: kiwiPayload.notes || null,
        derived_target: kiwiPayload.derived_target || request.target_scope.target,
        proposed_version: kiwiPayload.proposed_version || null
      };
      request.status = 'Kiwi_Returned';
      request.updated_at_utc = now;
      request.history.push({
        at_utc: now,
        actor: actor || 'Admin',
        role: actorRole || 'Admin',
        action: 'Kiwi Return Applied',
        from_status: 'Sent_to_Kiwi',
        to_status: 'Kiwi_Returned',
        notes: 'Kiwi payload received'
      });
      
      if (!request.audit_log) request.audit_log = [];
      request.audit_log.push({
        at_utc: now,
        actor: actor || 'Admin',
        role: actorRole || 'Admin',
        event: 'KIWI_RETURN_INGESTED',
        details: 'Kiwi payload received'
      });
      
      savePatchRequests();
      return request;
    }
    
    function markApplied(requestIds, actor, actorRole) {
      var updated = [];
      requestIds.forEach(function(id) {
        var result = updatePatchRequestStatus(id, 'Applied', actor, actorRole, 'Patch applied to target artifact');
        if (result) updated.push(result);
      });
      return updated;
    }
    
    function markRejected(requestId, reason, actor, actorRole) {
      return updatePatchRequestStatus(requestId, 'Rejected', actor, actorRole, reason);
    }
    
    // Export functions
    function exportPatchRequestsForKiwi(requestIds) {
      var requests = requestIds.map(function(id) { return getPatchRequest(id); }).filter(function(r) { return r !== null; });
      return JSON.stringify({
        batch_id: 'BATCH_' + Date.now().toString(36),
        exported_at_utc: new Date().toISOString(),
        count: requests.length,
        requests: requests.map(function(r) {
          return {
            request_id: r.request_id,
            record_identity: r.record_identity,
            target_scope: r.target_scope,
            proposed_change: r.proposed_change,
            author: r.author,
            created_at_utc: r.created_at_utc
          };
        })
      }, null, 2);
    }
    
    function exportBatchCommitPack(requestIds) {
      var requests = requestIds.map(function(id) { return getPatchRequest(id); }).filter(function(r) { return r !== null && r.kiwi_return; });
      return JSON.stringify({
        batch_id: 'COMMIT_' + Date.now().toString(36),
        created_at_utc: new Date().toISOString(),
        count: requests.length,
        items: requests.map(function(r) {
          return {
            request_id: r.request_id,
            target: r.target_scope.target,
            patch_payload_json: r.kiwi_return.patch_payload_json,
            suggested_files: getSuggestedFilesForTarget(r.target_scope.target),
            changelog_entry: generateChangelogEntry(r),
            pr_summary_markdown: generatePRSummary(r)
          };
        })
      }, null, 2);
    }
    
    function getSuggestedFilesForTarget(target) {
      var fileMap = {
        'salesforce': ['config/sf_rules.json'],
        'qa_rules': ['config/qa_rules.json'],
        'resolver_rules': ['config/resolver_rules.json'],
        'truth_config': ['config/config_pack.base.json'],
        'proposed_changes': ['config/config_pack.patch.json']
      };
      return fileMap[target] || ['config/config_pack.patch.json'];
    }
    
    function generateChangelogEntry(request) {
      var intent = request.proposed_change.intent;
      return '- ' + (intent.then || 'Update') + ' when ' + (intent.when || 'condition met') + ' (' + request.request_id + ')';
    }
    
    function generatePRSummary(request) {
      var intent = request.proposed_change.intent;
      return '## Patch Request: ' + request.request_id + '\n\n' +
        '**When:** ' + (intent.when || 'N/A') + '\n' +
        '**Then:** ' + (intent.then || 'N/A') + '\n' +
        '**Because:** ' + (intent.because || 'N/A') + '\n\n' +
        '**Rationale:** ' + (request.proposed_change.rationale || 'N/A') + '\n';
    }
    
    // Initialize patch requests on load
    loadPatchRequests();
    
    // ========== PATCH CONSOLE UI ==========
    var currentPatchQueue = 'new';
    
    function switchPatchQueueTab(queueId) {
      currentPatchQueue = queueId;
      document.querySelectorAll('.queue-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.queue === queueId);
      });
      renderPatchConsoleTable();
    }
    
    function updatePatchQueueCounts() {
      var counts = getPatchRequestCounts();
      document.querySelectorAll('.queue-tab').forEach(function(tab) {
        var queueId = tab.dataset.queue;
        var countSpan = tab.querySelector('.queue-count');
        if (countSpan && counts[queueId] !== undefined) {
          countSpan.textContent = counts[queueId];
        }
      });
      var totalEl = document.getElementById('patch-total-count');
      if (totalEl) totalEl.textContent = counts.total;
      
      var selectedEl = document.getElementById('patch-selected-count');
      if (selectedEl) selectedEl.textContent = patchRequestsStore.selectedIds.length;
      
      var commentsEl = document.getElementById('comments-open-count');
      if (commentsEl) {
        var commentCounts = getCommentCounts();
        commentsEl.textContent = commentCounts.open + commentCounts.reviewer_responded;
      }
    }
    
    function renderPatchConsoleTable() {
      var tbody = document.getElementById('patch-console-tbody');
      if (!tbody) return;
      
      var requests = getPatchRequestsByQueue(currentPatchQueue);
      updatePatchQueueCounts();
      
      if (requests.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="padding: 20px; text-align: center; color: #888;">No patch requests in this queue</td></tr>';
        return;
      }
      
      tbody.innerHTML = requests.map(function(r) {
        var isSelected = patchRequestsStore.selectedIds.includes(r.request_id);
        var intent = r.proposed_change.intent;
        var intentSummary = (intent.then || 'No intent').substring(0, 40) + ((intent.then || '').length > 40 ? '...' : '');
        var statusClass = getStatusClass(r.status);
        var updatedDate = new Date(r.updated_at_utc).toLocaleDateString();
        
        return '<tr>' +
          '<td><input type="checkbox" ' + (isSelected ? 'checked' : '') + ' onchange="togglePatchRequestSelection(\'' + r.request_id + '\'); renderPatchConsoleTable();"></td>' +
          '<td style="font-family: monospace; font-size: 0.85em;">' + escapeHtml(r.request_id.substring(0, 12)) + '</td>' +
          '<td>' + escapeHtml(intentSummary) + '</td>' +
          '<td>' + escapeHtml(humanLabel(r.target_scope.target) || 'N/A') + '</td>' +
          '<td><span class="patch-status-chip ' + statusClass + '">' + escapeHtml(r.status) + '</span></td>' +
          '<td style="font-size: 0.85em;">' + updatedDate + '</td>' +
          '<td style="text-align: center;"><button class="toolbar-btn" style="padding: 4px 8px; font-size: 0.8em;" onclick="viewPatchRequestDetail(\'' + r.request_id + '\')">View</button></td>' +
          '</tr>';
      }).join('');
    }
    
    function getStatusClass(status) {
      var classMap = {
        'Draft': 'draft',
        'Submitted': 'submitted',
        'Needs_Clarification': 'submitted',
        'Reviewer_Responded': 'submitted',
        'Reviewer_Approved': 'approved',
        'Admin_Hold': 'submitted',
        'Admin_Approved': 'approved',
        'Sent_to_Kiwi': 'sent',
        'Kiwi_Returned': 'returned',
        'Applied': 'applied',
        'Rejected': 'rejected',
        'Cancelled': 'rejected'
      };
      return classMap[status] || 'draft';
    }
    
    function toggleSelectAllPatches(checked) {
      var requests = getPatchRequestsByQueue(currentPatchQueue);
      if (checked) {
        requests.forEach(function(r) { selectPatchRequest(r.request_id); });
      } else {
        requests.forEach(function(r) { deselectPatchRequest(r.request_id); });
      }
      renderPatchConsoleTable();
    }
    
    function selectAllCurrentQueue() {
      selectAllInQueue(currentPatchQueue);
      renderPatchConsoleTable();
    }
    
    function batchMarkSentToKiwi() {
      var selected = getSelectedPatchRequests();
      if (selected.length === 0) {
        showToast('No requests selected', 'warning');
        return;
      }
      
      var approvedOnly = selected.filter(function(r) {
        return r.status === 'Reviewer_Approved' || r.status === 'Admin_Approved';
      });
      
      if (approvedOnly.length === 0) {
        showToast('Selected requests must be Approved to send to Kiwi', 'warning');
        return;
      }
      
      var exportJson = exportPatchRequestsForKiwi(approvedOnly.map(function(r) { return r.request_id; }));
      navigator.clipboard.writeText(exportJson).then(function() {
        markSentToKiwi(approvedOnly.map(function(r) { return r.request_id; }), 'Admin', 'Admin');
        clearPatchRequestSelection();
        renderPatchConsoleTable();
        showToast('Exported ' + approvedOnly.length + ' requests to clipboard and marked as Sent to Kiwi', 'success');
      });
    }
    
    function openKiwiReturnInbox() {
      document.getElementById('kiwi-return-inbox-modal').style.display = 'flex';
      document.getElementById('kiwi-return-textarea').value = '';
      document.getElementById('kiwi-return-status').style.display = 'none';
    }
    
    function closeKiwiReturnInbox() {
      document.getElementById('kiwi-return-inbox-modal').style.display = 'none';
    }
    
    function processKiwiReturn() {
      var textarea = document.getElementById('kiwi-return-textarea');
      var statusEl = document.getElementById('kiwi-return-status');
      var text = textarea.value.trim();
      
      if (!text) {
        statusEl.textContent = 'Please paste Kiwi return JSON';
        statusEl.style.display = 'block';
        statusEl.style.background = '#ffebee';
        statusEl.style.color = '#c62828';
        return;
      }
      
      try {
        var data = JSON.parse(text);
        var items = data.items || data.requests || (Array.isArray(data) ? data : [data]);
        var matched = 0;
        var notFound = 0;
        
        items.forEach(function(item) {
          var requestId = item.request_id;
          if (requestId) {
            var result = applyKiwiReturn(requestId, item, 'Admin', 'Admin');
            if (result) matched++;
            else notFound++;
          }
        });
        
        statusEl.textContent = 'Processed: ' + matched + ' matched, ' + notFound + ' not found';
        statusEl.style.display = 'block';
        statusEl.style.background = matched > 0 ? '#e8f5e9' : '#fff3e0';
        statusEl.style.color = matched > 0 ? '#2e7d32' : '#e65100';
        
        if (matched > 0) {
          renderPatchConsoleTable();
          setTimeout(function() { closeKiwiReturnInbox(); }, 1500);
        }
      } catch (e) {
        statusEl.textContent = 'Invalid JSON: ' + e.message;
        statusEl.style.display = 'block';
        statusEl.style.background = '#ffebee';
        statusEl.style.color = '#c62828';
      }
    }
    
    function batchMarkApplied() {
      var selected = getSelectedPatchRequests();
      if (selected.length === 0) {
        showToast('No requests selected', 'warning');
        return;
      }
      
      var returnedOnly = selected.filter(function(r) { return r.status === 'Kiwi_Returned'; });
      if (returnedOnly.length === 0) {
        showToast('Selected requests must be in Kiwi Returned status', 'warning');
        return;
      }
      
      markApplied(returnedOnly.map(function(r) { return r.request_id; }), 'Admin', 'Admin');
      clearPatchRequestSelection();
      renderPatchConsoleTable();
      showToast('Marked ' + returnedOnly.length + ' requests as Applied', 'success');
    }
    
    function batchCopyCommitPack() {
      var selected = getSelectedPatchRequests();
      if (selected.length === 0) {
        showToast('No requests selected', 'warning');
        return;
      }
      
      var returnedOnly = selected.filter(function(r) { return r.status === 'Kiwi_Returned' && r.kiwi_return; });
      if (returnedOnly.length === 0) {
        showToast('Selected requests must have Kiwi returns', 'warning');
        return;
      }
      
      var commitPack = exportBatchCommitPack(returnedOnly.map(function(r) { return r.request_id; }));
      navigator.clipboard.writeText(commitPack).then(function() {
        showToast('Copied commit pack for ' + returnedOnly.length + ' requests', 'success');
      });
    }
    
    var currentPatchDetailId = null;
    
    function viewPatchRequestDetail(requestId) {
      var request = getPatchRequest(requestId);
      if (!request) return;
      
      currentPatchDetailId = requestId;
      var intent = request.proposed_change.intent;
      var statusClass = getStatusClass(request.status);
      
      var html = '';
      
      // Status and ID header
      html += '<div style="margin-bottom: 20px;">' +
        '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">' +
        '<span class="patch-status-chip ' + statusClass + '" style="font-size: 0.85em;">' + escapeHtml(request.status) + '</span>' +
        '<span style="font-family: monospace; font-size: 0.8em; color: #666;">' + escapeHtml(request.request_id) + '</span>' +
        '</div>' +
        '<div style="font-size: 0.85em; color: #666;">Created: ' + new Date(request.created_at_utc).toLocaleString() + '</div>' +
        '</div>';
      
      // Plain-English Intent section
      html += '<div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
        '<h4 style="margin: 0 0 12px 0; font-size: 0.9em; text-transform: uppercase; color: #333;">Plain-English Intent</h4>' +
        '<div style="margin-bottom: 10px;">' +
        '<span style="color: #1976d2; font-weight: 600;">WHEN:</span> ' + escapeHtml(intent.when || 'N/A') +
        '</div>' +
        '<div style="margin-bottom: 10px;">' +
        '<span style="color: #388e3c; font-weight: 600;">THEN:</span> ' + escapeHtml(intent.then || 'N/A') +
        '</div>' +
        '<div>' +
        '<span style="color: #e65100; font-weight: 600;">BECAUSE:</span> ' + escapeHtml(intent.because || 'N/A') +
        '</div>' +
        '</div>';
      
      // Target Artifact section
      html += '<div style="margin-bottom: 20px;">' +
        '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #333;">Target Artifact</h4>' +
        '<table style="width: 100%; font-size: 0.9em;">' +
        '<tr><td style="padding: 4px 0; color: #666; width: 100px;">Type</td><td>' + escapeHtml(humanLabel(request.target_scope.target) || 'N/A') + '</td></tr>' +
        '<tr><td style="padding: 4px 0; color: #666;">Target ID</td><td style="font-family: monospace;">' + escapeHtml(request.target_scope.target_id || 'N/A') + '</td></tr>' +
        '</table>' +
        '</div>';
      
      // Rationale
      if (request.proposed_change.rationale) {
        html += '<div style="margin-bottom: 20px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #333;">Rationale</h4>' +
          '<p style="margin: 0; font-size: 0.9em; color: #555;">' + escapeHtml(request.proposed_change.rationale) + '</p>' +
          '</div>';
      }
      
      // Kiwi Payload section (if sent or returned)
      if (request.status === 'Sent_to_Kiwi' || request.status === 'Kiwi_Returned' || request.status === 'Applied') {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #7b1fa2;">Kiwi Integration</h4>';
        
        if (request.kiwi_sent_at_utc) {
          html += '<div style="font-size: 0.85em; margin-bottom: 8px;"><strong>Sent to Kiwi:</strong> ' + new Date(request.kiwi_sent_at_utc).toLocaleString() + '</div>';
        }
        
        if (request.kiwi_return) {
          html += '<div style="font-size: 0.85em; margin-bottom: 8px;"><strong>Returned:</strong> ' + new Date(request.kiwi_returned_at_utc).toLocaleString() + '</div>' +
            '<div style="margin-top: 10px;">' +
            '<details style="background: #f9f9f9; padding: 10px; border-radius: 6px;">' +
            '<summary style="cursor: pointer; font-weight: 500; font-size: 0.9em;">View Kiwi Return Payload</summary>' +
            '<pre style="margin: 10px 0 0 0; font-size: 0.8em; overflow-x: auto; white-space: pre-wrap;">' + escapeHtml(JSON.stringify(request.kiwi_return, null, 2)) + '</pre>' +
            '</details>' +
            '</div>';
        }
        
        html += '</div>';
      }
      
      // Apply Checklist (for Kiwi_Returned status)
      if (request.status === 'Kiwi_Returned') {
        html += '<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
          '<h4 style="margin: 0 0 12px 0; font-size: 0.9em; text-transform: uppercase; color: #2e7d32;">Apply Checklist</h4>' +
          '<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; margin-bottom: 8px;">' +
          '<input type="checkbox" id="apply-check-1"> Kiwi return payload validated' +
          '</label>' +
          '<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; margin-bottom: 8px;">' +
          '<input type="checkbox" id="apply-check-2"> Changes copied to config pack' +
          '</label>' +
          '<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em;">' +
          '<input type="checkbox" id="apply-check-3"> Smoke test passed' +
          '</label>' +
          '</div>';
      }
      
      // Clarification questions section (if any)
      if (request.clarification_questions && request.clarification_questions.length > 0) {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #e65100;">Clarification Thread</h4>';
        request.clarification_questions.forEach(function(q) {
          if (typeof q === 'string') {
            html += '<div style="background: #fff3e0; padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 0.9em;">' + escapeHtml(q) + '</div>';
          } else if (q.type === 'response') {
            html += '<div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 0.9em;">' +
              '<strong>' + escapeHtml(q.from || 'Analyst') + ':</strong> ' + escapeHtml(q.text) + '</div>';
          } else {
            html += '<div style="background: #fff3e0; padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 0.9em;">' + escapeHtml(q.text || q) + '</div>';
          }
        });
        html += '</div>';
      }
      
      // Review notes section (editable for Verifier/Admin)
      if ((currentMode === 'Verifier' || currentMode === 'Admin') && 
          ['Submitted', 'Needs_Clarification', 'Reviewer_Responded'].includes(request.status)) {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<h4 style="margin: 0 0 10px 0; font-size: 0.9em; text-transform: uppercase; color: #1565c0;">Review Notes (Verifier)</h4>' +
          '<textarea id="pr-review-notes" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; resize: vertical; min-height: 60px;" placeholder="Add review notes...">' + escapeHtml(request.review_notes || '') + '</textarea>' +
          '</div>';
      }
      
      // Revisions section
      if (request.revisions && request.revisions.length > 0) {
        html += '<div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">' +
          '<details>' +
          '<summary style="cursor: pointer; font-weight: 600; font-size: 0.9em; color: #333;">Revisions (' + request.revisions.length + ')</summary>' +
          '<div style="margin-top: 10px; font-size: 0.85em;">';
        request.revisions.forEach(function(rev) {
          html += '<div style="background: #f9f9f9; padding: 8px; border-radius: 4px; margin-bottom: 6px;">' +
            '<div style="color: #666;">' + new Date(rev.at_utc).toLocaleString() + ' by ' + escapeHtml(rev.actor) + ' (' + escapeHtml(rev.role) + ')</div>' +
            '<div style="color: #333;">' + escapeHtml(rev.diff_summary) + '</div>' +
            '</div>';
        });
        html += '</div></details></div>';
      }
      
      document.getElementById('patch-detail-title').textContent = 'Patch Request';
      document.getElementById('patch-detail-content').innerHTML = html;
      
      // Footer actions based on status and role
      var role = currentMode || 'Analyst';
      var footerHtml = '<div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end;">';
      
      // Analyst actions
      if (role === 'Analyst') {
        if (request.status === 'Draft') {
          footerHtml += '<button class="toolbar-btn" onclick="submitPatchForReview(\'' + requestId + '\')" style="background: #1976d2;" title="Submit this patch request for review">Submit for Review</button>';
        } else if (request.status === 'Needs_Clarification') {
          footerHtml += '<button class="toolbar-btn" onclick="openClarificationResponseModal(\'' + requestId + '\')" style="background: #e65100;" title="Respond to clarification request">Respond to Clarification</button>';
        }
        if (['Draft', 'Submitted'].includes(request.status)) {
          footerHtml += '<button class="toolbar-btn" onclick="cancelPatchRequest(\'' + requestId + '\')" style="background: #c62828;" title="Cancel this patch request">Cancel</button>';
        }
      }
      
      // Verifier actions
      if (role === 'Verifier' || role === 'Admin') {
        if (request.status === 'Submitted') {
          footerHtml += '<button class="toolbar-btn" onclick="openClarificationModal(\'' + requestId + '\')" style="background: #e65100;" title="Request more information from the analyst">Request Clarification</button>';
          footerHtml += '<button class="toolbar-btn" onclick="approveAsReviewer(\'' + requestId + '\')" style="background: #388e3c;" title="Approve this patch request">Approve</button>';
          footerHtml += '<button class="toolbar-btn" onclick="rejectPatchRequest(\'' + requestId + '\')" style="background: #c62828;" title="Reject this patch request">Reject</button>';
        } else if (request.status === 'Reviewer_Responded') {
          footerHtml += '<button class="toolbar-btn" onclick="approveAsReviewer(\'' + requestId + '\')" style="background: #388e3c;" title="Approve this patch request">Approve</button>';
          footerHtml += '<button class="toolbar-btn" onclick="rejectPatchRequest(\'' + requestId + '\')" style="background: #c62828;" title="Reject this patch request">Reject</button>';
        }
      }
      
      // Admin-only actions
      if (role === 'Admin') {
        if (request.status === 'Reviewer_Approved') {
          footerHtml += '<button class="toolbar-btn" onclick="adminApprovePatch(\'' + requestId + '\')" style="background: #1565c0;" title="Give admin approval">Admin Approve</button>';
          footerHtml += '<button class="toolbar-btn" onclick="setAdminHoldPatch(\'' + requestId + '\')" style="background: #f57c00;" title="Put on hold for review">Admin Hold</button>';
        } else if (request.status === 'Admin_Hold') {
          footerHtml += '<button class="toolbar-btn" onclick="releaseAdminHoldPatch(\'' + requestId + '\')" style="background: #1565c0;" title="Release from admin hold">Release Hold</button>';
        } else if (request.status === 'Admin_Approved') {
          footerHtml += '<button class="toolbar-btn" onclick="exportToKiwi(\'' + requestId + '\')" style="background: #7b1fa2;" title="Export to Kiwi and mark as sent">Export to Kiwi</button>';
        } else if (request.status === 'Sent_to_Kiwi') {
          footerHtml += '<button class="toolbar-btn" onclick="openPasteKiwiReturnModal(\'' + requestId + '\')" style="background: #7b1fa2;" title="Paste Kiwi return payload">Paste Kiwi Return</button>';
        } else if (request.status === 'Kiwi_Returned') {
          footerHtml += '<button class="toolbar-btn" onclick="copyCommitPack(\'' + requestId + '\')" title="Copy commit pack to clipboard">Copy Commit Pack</button>';
          footerHtml += '<button class="toolbar-btn" onclick="markSingleApplied(\'' + requestId + '\')" style="background: #388e3c;" title="Mark as applied">Mark Applied</button>';
        }
      }
      
      footerHtml += '<button class="toolbar-btn" onclick="closePatchDetailDrawer()">Close</button>';
      footerHtml += '</div>';
      document.getElementById('patch-detail-footer').innerHTML = footerHtml;
      
      document.getElementById('patch-detail-drawer').classList.add('active');
    }
    
    function closePatchDetailDrawer() {
      document.getElementById('patch-detail-drawer').classList.remove('active');
      currentPatchDetailId = null;
    }
    
    function submitPatchForReview(requestId) {
      var author = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      submitForReview(requestId, author, author);
      closePatchDetailDrawer();
      renderPatchConsoleTable();
      showToast('Patch request submitted for review', 'success');
    }
    
    function copyPatchForKiwi(requestId) {
      var exportJson = exportPatchRequestsForKiwi([requestId]);
      navigator.clipboard.writeText(exportJson).then(function() {
        showToast('Copied patch request to clipboard for Kiwi', 'success');
      });
    }
    
    function copyCommitPack(requestId) {
      var commitPack = exportBatchCommitPack([requestId]);
      navigator.clipboard.writeText(commitPack).then(function() {
        showToast('Commit pack copied to clipboard', 'success');
      });
    }
    
    function markSingleApplied(requestId) {
      var author = currentMode || 'Admin';
      markApplied([requestId], author, author);
      closePatchDetailDrawer();
      renderPatchConsoleTable();
      showToast('Marked as Applied', 'success');
    }
    
    function cancelPatchRequest(requestId) {
      var author = currentMode || 'Analyst';
      var result = updatePatchRequestStatus(requestId, 'Cancelled', author, author, 'Cancelled by ' + author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Patch request cancelled', 'success');
      } else {
        showToast('Failed to cancel patch request', 'error');
      }
    }
    
    function approveAsReviewer(requestId) {
      var author = currentMode || 'Verifier';
      var reviewNotes = document.getElementById('pr-review-notes')?.value || '';
      
      var request = getPatchRequest(requestId);
      if (reviewNotes && request) {
        updatePatchRequest(requestId, { review_notes: reviewNotes }, author, author);
      }
      
      var result = reviewerApprove(requestId, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Patch request approved by reviewer', 'success');
      } else {
        showToast('Failed to approve patch request', 'error');
      }
    }
    
    function rejectPatchRequest(requestId) {
      var reason = prompt('Enter rejection reason:');
      if (!reason) return;
      
      var author = currentMode || 'Verifier';
      var result = markRejected(requestId, reason, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Patch request rejected', 'success');
      } else {
        showToast('Failed to reject patch request', 'error');
      }
    }
    
    function openClarificationModal(requestId) {
      var questions = prompt('Enter clarification questions:');
      if (!questions) return;
      
      var author = currentMode || 'Verifier';
      var result = requestClarification(requestId, [questions], author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Clarification requested', 'success');
      } else {
        showToast('Failed to request clarification', 'error');
      }
    }
    
    function openClarificationResponseModal(requestId) {
      var response = prompt('Enter your response to the clarification request:');
      if (!response) return;
      
      var author = currentMode || 'Analyst';
      var result = respondToClarification(requestId, response, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Clarification response submitted', 'success');
      } else {
        showToast('Failed to submit response', 'error');
      }
    }
    
    function adminApprovePatch(requestId) {
      var author = currentMode || 'Admin';
      var result = adminApprove(requestId, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Admin approval granted', 'success');
      } else {
        showToast('Failed to grant admin approval', 'error');
      }
    }
    
    function setAdminHoldPatch(requestId) {
      var reason = prompt('Enter reason for admin hold:') || 'Placed on hold for further review';
      var author = currentMode || 'Admin';
      var result = setAdminHold(requestId, reason, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Placed on admin hold', 'success');
      } else {
        showToast('Failed to set admin hold', 'error');
      }
    }
    
    function releaseAdminHoldPatch(requestId) {
      var author = currentMode || 'Admin';
      var result = releaseAdminHold(requestId, author, author);
      if (result) {
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Released from admin hold', 'success');
      } else {
        showToast('Failed to release admin hold', 'error');
      }
    }
    
    function exportToKiwi(requestId) {
      var author = currentMode || 'Admin';
      var exportJson = exportPatchRequestsForKiwi([requestId]);
      navigator.clipboard.writeText(exportJson).then(function() {
        markSentToKiwi([requestId], author, author);
        closePatchDetailDrawer();
        renderPatchConsoleTable();
        showToast('Exported to Kiwi and copied to clipboard', 'success');
      });
    }
    
    function openPasteKiwiReturnModal(requestId) {
      var payloadStr = prompt('Paste Kiwi return JSON payload:');
      if (!payloadStr) return;
      
      try {
        var payload = JSON.parse(payloadStr);
        var author = currentMode || 'Admin';
        var result = applyKiwiReturn(requestId, payload, author, author);
        if (result) {
          closePatchDetailDrawer();
          renderPatchConsoleTable();
          showToast('Kiwi return applied', 'success');
        } else {
          showToast('Failed to apply Kiwi return', 'error');
        }
      } catch (e) {
        showToast('Invalid JSON payload', 'error');
      }
    }
    
    // Initialize patch console when admin view loads
    function initPatchConsole() {
      renderPatchConsoleTable();
      updatePatchQueueCounts();
    }
    
    // ========== COMMENT UI FUNCTIONS ==========
    function openAddCommentModal(targetType, targetId) {
      document.getElementById('comment-target-type').value = targetType;
      document.getElementById('comment-target-id').value = targetId;
      document.getElementById('comment-target-display').textContent = targetType + ': ' + targetId;
      document.getElementById('comment-content-input').value = '';
      document.getElementById('add-comment-modal').style.display = 'flex';
    }
    
    function closeAddCommentModal() {
      document.getElementById('add-comment-modal').style.display = 'none';
    }
    
    function submitNewComment() {
      var targetType = document.getElementById('comment-target-type').value;
      var targetId = document.getElementById('comment-target-id').value;
      var content = document.getElementById('comment-content-input').value.trim();
      
      if (!content) {
        showToast('Please enter a comment', 'warning');
        return;
      }
      
      var author = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      createComment(targetType, targetId, content, author, author);
      closeAddCommentModal();
      showToast('Comment added', 'success');
      
      // Refresh the drawer if it's a record comment
      if (targetType === 'record') {
        renderRecordDrawer();
      }
      updatePatchQueueCounts();
    }
    
    function resolveCommentById(commentId) {
      var author = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      resolveComment(commentId, author, author);
      renderRecordDrawer();
      updatePatchQueueCounts();
      showToast('Comment resolved', 'success');
    }
    
    function elevateCommentToPatchRequest(commentId) {
      var comment = getComment(commentId);
      if (!comment) return;
      
      document.getElementById('elevate-comment-id').value = commentId;
      document.getElementById('elevate-comment-preview').innerHTML = 
        '<strong>Original Comment:</strong> ' + escapeHtml(comment.content) + 
        '<br><span style="font-size: 0.85em; color: #666;">Target: ' + comment.target_type + ' / ' + escapeHtml(comment.target_id) + '</span>';
      document.getElementById('elevate-intent-when').value = '';
      document.getElementById('elevate-intent-then').value = '';
      document.getElementById('elevate-intent-because').value = '';
      document.getElementById('elevate-to-patch-modal').style.display = 'flex';
    }
    
    function closeElevateToPatchModal() {
      document.getElementById('elevate-to-patch-modal').style.display = 'none';
    }
    
    function submitElevateToPatch() {
      var commentId = document.getElementById('elevate-comment-id').value;
      var comment = getComment(commentId);
      if (!comment) return;
      
      var intentWhen = document.getElementById('elevate-intent-when').value.trim();
      var intentThen = document.getElementById('elevate-intent-then').value.trim();
      var intentBecause = document.getElementById('elevate-intent-because').value.trim();
      
      if (!intentThen) {
        showToast('Please fill in the THEN (action) field', 'warning');
        return;
      }
      
      var author = getCurrentUserName();
      
      var patchRequest = createPatchRequest({
        target: comment.target_type,
        contract_key: comment.record_identity.contract_key,
        file_url: comment.record_identity.file_url,
        file_name: comment.record_identity.file_name,
        when: intentWhen || 'N/A',
        then: intentThen,
        because: intentBecause || comment.content,
        rationale: 'Elevated from comment: ' + comment.content,
        author: author,
        author_role: author,
        linked_comment_id: commentId
      });
      elevateToRequest(commentId, patchRequest.request_id, author, author);
      
      closeElevateToPatchModal();
      renderRecordDrawer();
      renderPatchConsoleTable();
      showToast('Created Patch Request from comment', 'success');
    }
    
    // ========== STANDARDIZER (D3) ==========
    let standardizerResult = {
      mergedDataset: null,
      issues: [],
      changeLog: [],
      currentTab: 'summary'
    };
    
    // Infer CSV delimiter
    function inferDelimiter(csvText) {
      var firstLine = csvText.split('\n')[0] || '';
      var counts = { ',': 0, '\t': 0, ';': 0, '|': 0 };
      for (var i = 0; i < firstLine.length; i++) {
        if (counts.hasOwnProperty(firstLine[i])) counts[firstLine[i]]++;
      }
      var best = ',';
      var max = 0;
      Object.keys(counts).forEach(function(d) {
        if (counts[d] > max) { max = counts[d]; best = d; }
      });
      return best;
    }
    
    // Parse CSV to array of objects
    function parseCSV(csvText, delimiter) {
      delimiter = delimiter || inferDelimiter(csvText);
      var lines = csvText.trim().split('\n');
      if (lines.length < 2) return { headers: [], rows: [], delimiter: delimiter };
      
      var headers = lines[0].split(delimiter).map(function(h) { return h.trim().replace(/^"|"$/g, ''); });
      var rows = [];
      for (var i = 1; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) continue;
        var values = line.split(delimiter).map(function(v) { return v.trim().replace(/^"|"$/g, ''); });
        var row = {};
        headers.forEach(function(h, idx) {
          row[h] = values[idx] !== undefined ? values[idx] : null;
        });
        rows.push(row);
      }
      return { headers: headers, rows: rows, delimiter: delimiter };
    }
    
    // Normalize header name
    function normalizeHeader(header) {
      return header
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
    }
    
    // Standard canonical headers
    var CANONICAL_HEADERS = ['contract_key', 'file_url', 'file_name', 'sheet', 'field', 'value', 'status', 'subtype'];
    
    // Run the standardizer
    function runStandardizer() {
      var csvInput = document.getElementById('standardizer-csv-input');
      var csvText = csvInput.value.trim();
      
      if (!csvText) {
        showStandardizerStatus('Please enter or upload CSV data.', 'error');
        return;
      }
      
      var parsed = parseCSV(csvText);
      if (parsed.rows.length === 0) {
        showStandardizerStatus('No data rows found in CSV.', 'error');
        return;
      }
      
      var issues = [];
      var changeLog = [];
      var headerMap = {};
      var normalizedHeaders = [];
      var missingAnchors = [];
      
      // Normalize headers
      parsed.headers.forEach(function(original) {
        var normalized = normalizeHeader(original);
        if (normalized !== original.toLowerCase()) {
          changeLog.push({ type: 'header_renamed', original: original, normalized: normalized });
        }
        headerMap[original] = normalized;
        normalizedHeaders.push(normalized);
      });
      
      // Check for canonical headers
      CANONICAL_HEADERS.forEach(function(anchor) {
        var found = normalizedHeaders.some(function(h) { return h === anchor || h.includes(anchor); });
        if (!found && (anchor === 'contract_key' || anchor === 'file_url' || anchor === 'file_name')) {
          issues.push({
            type: 'missing_required_anchor',
            severity: 'blocking',
            anchor: anchor,
            message: 'Required anchor header "' + anchor + '" not found in input.'
          });
          missingAnchors.push(anchor);
        }
      });
      
      // Check for ambiguous columns
      var normalizedCounts = {};
      normalizedHeaders.forEach(function(h) {
        normalizedCounts[h] = (normalizedCounts[h] || 0) + 1;
      });
      Object.keys(normalizedCounts).forEach(function(h) {
        if (normalizedCounts[h] > 1) {
          issues.push({
            type: 'ambiguous_columns',
            severity: 'warning',
            header: h,
            count: normalizedCounts[h],
            message: 'Header "' + h + '" appears ' + normalizedCounts[h] + ' times after normalization.'
          });
        }
      });
      
      // Build normalized rows
      var normalizedRows = parsed.rows.map(function(row, idx) {
        var newRow = { _row_index: idx };
        parsed.headers.forEach(function(original) {
          var normalized = headerMap[original];
          newRow[normalized] = row[original] !== '' ? row[original] : null;
        });
        return newRow;
      });
      
      // Sort rows deterministically by canonical keys
      normalizedRows.sort(function(a, b) {
        var keys = ['contract_key', 'file_url', 'file_name', 'sheet', 'field'];
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var av = (a[k] || '').toString();
          var bv = (b[k] || '').toString();
          if (av < bv) return -1;
          if (av > bv) return 1;
        }
        return 0;
      });
      
      // Build merged dataset
      var mergedDataset = {
        version: '1.0.0',
        generated_at: new Date().toISOString(),
        source: 'standardizer',
        delimiter_detected: parsed.delimiter,
        schema: {
          original_headers: parsed.headers,
          normalized_headers: normalizedHeaders,
          header_mapping: headerMap
        },
        data: {
          rows: normalizedRows,
          row_count: normalizedRows.length
        }
      };
      
      standardizerResult.mergedDataset = mergedDataset;
      standardizerResult.issues = issues;
      standardizerResult.changeLog = changeLog;
      
      var hasBlocking = issues.some(function(i) { return i.severity === 'blocking'; });
      var status = hasBlocking ? 'Completed with blocking issues' : 'Completed successfully';
      var statusType = hasBlocking ? 'warning' : 'success';
      showStandardizerStatus(status + ': ' + normalizedRows.length + ' rows, ' + issues.length + ' issues.', statusType);
      
      document.getElementById('standardizer-output').style.display = 'block';
      showStandardizerTab('summary');
    }
    
    function showStandardizerStatus(message, type) {
      var el = document.getElementById('standardizer-status');
      el.textContent = message;
      el.style.display = 'block';
      el.style.background = type === 'error' ? '#ffebee' : type === 'warning' ? '#fff3e0' : '#e8f5e9';
      el.style.color = type === 'error' ? '#c62828' : type === 'warning' ? '#e65100' : '#2e7d32';
    }
    
    function showStandardizerTab(tab) {
      standardizerResult.currentTab = tab;
      document.querySelectorAll('[data-std-tab]').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.stdTab === tab);
      });
      
      var content = document.getElementById('standardizer-tab-content');
      var ds = standardizerResult.mergedDataset;
      var issues = standardizerResult.issues;
      var log = standardizerResult.changeLog;
      
      if (tab === 'summary') {
        content.innerHTML = '<div class="json-header">Summary</div>' +
          '<div>Rows: ' + (ds ? ds.data.row_count : 0) + '</div>' +
          '<div>Original Headers: ' + (ds ? ds.schema.original_headers.length : 0) + '</div>' +
          '<div>Issues: ' + issues.length + ' (' + issues.filter(function(i){return i.severity==='blocking';}).length + ' blocking)</div>' +
          '<div>Changes: ' + log.length + '</div>';
      } else if (tab === 'dataset') {
        content.innerHTML = '<div class="json-header">Internal JSON (advanced)</div><pre>' + 
          (ds ? escapeHtml(JSON.stringify(ds, null, 2)) : 'No data') + '</pre>';
      } else if (tab === 'issues') {
        content.innerHTML = '<div class="json-header">Standardization Issues</div><pre>' + 
          escapeHtml(JSON.stringify(issues, null, 2)) + '</pre>';
      } else if (tab === 'changelog') {
        content.innerHTML = '<div class="json-header">Change Log</div><pre>' + 
          escapeHtml(JSON.stringify(log, null, 2)) + '</pre>';
      }
    }
    
    function generateSampleCSV() {
      var sample = 'Contract Key,File Name,File URL,Sheet,Field,Value,Status\n' +
        'CK001,a.pdf,https://example.org/a.pdf,Sheet1,title,Sample Title,ready\n' +
        'CK002,b.pdf,https://example.org/b.pdf,Sheet1,title,Another Title,needs_review\n' +
        'CK003,c.xlsx,https://example.org/c.xlsx,Data,amount,1500.00,ready\n';
      document.getElementById('standardizer-csv-input').value = sample;
      showStandardizerStatus('Sample CSV generated. Click "Run Standardizer" to process.', 'success');
    }
    
    function clearStandardizer() {
      document.getElementById('standardizer-csv-input').value = '';
      document.getElementById('standardizer-status').style.display = 'none';
      document.getElementById('standardizer-output').style.display = 'none';
      document.getElementById('standardizer-drop-text').textContent = 'Drop CSV here or click to browse';
      standardizerResult = { mergedDataset: null, issues: [], changeLog: [], currentTab: 'summary' };
    }
    
    function copyStandardizerOutput(type) {
      var text = '';
      if (type === 'dataset' && standardizerResult.mergedDataset) {
        text = JSON.stringify(standardizerResult.mergedDataset, null, 2);
      } else if (type === 'issues') {
        text = JSON.stringify(standardizerResult.issues, null, 2);
      }
      navigator.clipboard.writeText(text).then(function() {
        showToast('Copied to clipboard!', 'success');
      });
    }
    
    // Setup standardizer drop zone
    function setupStandardizerDropZone() {
      var dropZone = document.getElementById('standardizer-drop-zone');
      var fileInput = document.getElementById('standardizer-file-input');
      if (!dropZone || !fileInput) return;
      
      dropZone.addEventListener('click', function() { fileInput.click(); });
      dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        dropZone.style.borderColor = '#1976d2';
        dropZone.style.background = '#e3f2fd';
      });
      dropZone.addEventListener('dragleave', function() {
        dropZone.style.borderColor = '#ccc';
        dropZone.style.background = '#fafafa';
      });
      dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        dropZone.style.borderColor = '#ccc';
        dropZone.style.background = '#fafafa';
        var file = e.dataTransfer.files[0];
        if (file) handleStandardizerFile(file);
      });
      fileInput.addEventListener('change', function(e) {
        var file = e.target.files[0];
        if (file) handleStandardizerFile(file);
      });
    }
    
    function handleStandardizerFile(file) {
      var reader = new FileReader();
      reader.onload = function(e) {
        document.getElementById('standardizer-csv-input').value = e.target.result;
        document.getElementById('standardizer-drop-text').textContent = file.name;
        showStandardizerStatus('File loaded: ' + file.name + '. Click "Run Standardizer" to process.', 'success');
      };
      reader.readAsText(file);
    }

    function renderWorkflowMap() {
      var container = document.getElementById('workflow-map');
      if (!container) return;
      
      var html = WORKFLOW_STAGES.map(function(stage, idx) {
        var artifactChips = stage.artifacts.map(function(artifactKey) {
          var binding = artifactRegistry.bindings[artifactKey];
          var status = binding ? binding.status : 'unknown';
          var statusClass = status === 'loaded' ? '' : status === 'missing' ? 'missing' : 'unknown';
          var label = ARTIFACT_LABELS[artifactKey] || artifactKey;
          var statusIcon = status === 'loaded' ? 'âœ“' : status === 'missing' ? 'âœ—' : '?';
          return '<span class="workflow-artifact ' + statusClass + '">' + statusIcon + ' ' + label + '</span>';
        }).join('');
        
        var connector = idx < WORKFLOW_STAGES.length - 1 ? '<div class="workflow-connector"></div>' : '';
        
        return '<div class="workflow-node" onclick="WORKFLOW_STAGES[' + idx + '].action()">' +
          '<div class="workflow-node-icon">' + stage.icon + '</div>' +
          '<div class="workflow-node-content">' +
            '<div class="workflow-node-title">' + stage.title + '</div>' +
            '<div class="workflow-node-desc">' + stage.desc + '</div>' +
            (artifactChips ? '<div class="workflow-node-artifacts">' + artifactChips + '</div>' : '') +
          '</div>' +
        '</div>' + connector;
      }).join('');
      
      container.innerHTML = html;
    }
    
    function updateSessionChip() {
      const chip = document.getElementById('session-chip');
      const chipText = document.getElementById('session-chip-text');
      const meta = document.getElementById('session-meta');
      const previewStatus = document.getElementById('preview-status');
      const triageInfo = document.getElementById('triage-session-info');
      
      // v1.5.5: chip may not exist after header cleanup
      if (!chip) return;
      chip.className = 'session-chip ' + sessionState.status;
      
      if (sessionState.status === 'loaded') {
        chipText.textContent = 'Loaded';
        const sourceLabel = sessionState.sourceType === 'paste' ? 'paste' : 
                           sessionState.sourceType === 'drop' ? sessionState.fileName || 'file' : 
                           sessionState.sourceType;
        meta.textContent = `via ${sourceLabel} at ${new Date(sessionState.loadedAt).toLocaleTimeString()}`;
        if (previewStatus) {
          previewStatus.textContent = 'Loaded';
          previewStatus.className = 'loader-section-status loaded';
        }
        if (triageInfo) {
          triageInfo.innerHTML = `<strong>Source:</strong> ${sourceLabel} (memory) | <strong>Loaded:</strong> ${new Date(sessionState.loadedAt).toLocaleString()}`;
        }
      } else if (sessionState.status === 'fallback') {
        chipText.textContent = 'Fallback';
        meta.textContent = 'using example data';
        if (previewStatus) {
          previewStatus.textContent = 'Example';
          previewStatus.className = 'loader-section-status loaded';
        }
        if (triageInfo) {
          triageInfo.innerHTML = `<strong>Source:</strong> example (fallback) | Using bundled sample data`;
        }
      } else {
        chipText.textContent = 'Not Loaded';
        meta.textContent = '';
        if (previewStatus) {
          previewStatus.textContent = 'Not Loaded';
          previewStatus.className = 'loader-section-status empty';
        }
        if (triageInfo) {
          triageInfo.innerHTML = `<strong>Source:</strong> none | Click <em>Data Source</em> to begin`;
        }
      }
    }

    // ========== SIDEBAR FUNCTIONS (v1.4.6) ==========
    var cacheState = { pdfCount: 0, storageKB: 0, totalBytes: 0 };
    
    // ========== PDF CACHE (v1.4.13) ==========
    // IndexedDB-based offline-first PDF cache with LRU eviction
    // v1.4.18: PDF Proxy configuration - unified server on same origin (port 5000)
    // Priority: Supabase proxy (if env set) > FastAPI proxy (same origin) > show warning
    var PDF_PROXY_CONFIG = (function() {
      var host = window.location.hostname;
      var protocol = window.location.protocol;
      var origin = window.location.origin;
      
      // Check for Supabase configuration (set via embedded config or env)
      var supabaseUrl = window.VITE_SUPABASE_URL || localStorage.getItem('SUPABASE_URL') || '';
      var supabaseKey = window.VITE_SUPABASE_ANON_KEY || localStorage.getItem('SUPABASE_ANON_KEY') || '';
      
      var proxyType = 'none';
      var baseUrl = '';
      var authHeader = null;
      
      // Priority 1: Supabase Edge Function (DataDash method)
      if (supabaseUrl && supabaseKey) {
        baseUrl = supabaseUrl.replace(/\/$/, '') + '/functions/v1/contract-proxy';
        authHeader = 'Bearer ' + supabaseKey;
        proxyType = 'supabase';
      } else {
        // Priority 2: FastAPI proxy on SAME origin (unified server on port 5000)
        // No port switching needed - proxy endpoint is at /proxy/pdf on same server
        baseUrl = origin + '/proxy/pdf';
        proxyType = 'fastapi';
      }
      
      // v1.4.18: Debug logging (guarded by localStorage pdfDebug flag)
      if (localStorage.getItem('pdfDebug') === '1') {
        console.log('[PDF_PROXY_DEBUG]', JSON.stringify({
          proxyType: proxyType,
          viewerOrigin: origin,
          viewerHost: host,
          proxyBaseUrl: baseUrl,
          hasSupabaseEnv: !!(supabaseUrl && supabaseKey),
          authHeaderSet: !!authHeader
        }));
      } else {
        console.log('[PDF_PROXY] Type:', proxyType, '| URL:', baseUrl.substring(0, 60) + (baseUrl.length > 60 ? '...' : ''));
      }
      
      return {
        BASE_URL: baseUrl,
        ENABLED: proxyType !== 'none',
        PROXY_TYPE: proxyType,
        AUTH_HEADER: authHeader,
        TIMEOUT_MS: 30000
      };
    })();
    
    var PDF_CACHE_CONFIG = {
      DB_NAME: 'orchestrate_pdf_cache',
      DB_VERSION: 1,
      STORE_NAME: 'pdfs',
      INDEX_STORE: 'index',
      MAX_FILE_BYTES: 25 * 1024 * 1024,  // 25MB per file
      MAX_TOTAL_BYTES: 250 * 1024 * 1024  // 250MB total
    };
    
    var pdfCacheDB = null;
    var pdfCacheIndex = []; // In-memory index: [{key, source_url, size_bytes, created_at, last_accessed_at}]
    
    function initPdfCache() {
      return new Promise(function(resolve, reject) {
        if (!window.indexedDB) {
          console.warn('[PDF_CACHE] IndexedDB not supported, using memory-only mode');
          resolve(null);
          return;
        }
        
        var request = indexedDB.open(PDF_CACHE_CONFIG.DB_NAME, PDF_CACHE_CONFIG.DB_VERSION);
        
        request.onerror = function(e) {
          console.error('[PDF_CACHE] Failed to open IndexedDB:', e);
          resolve(null);
        };
        
        request.onsuccess = function(e) {
          pdfCacheDB = e.target.result;
          console.log('[PDF_CACHE] IndexedDB opened successfully');
          loadCacheIndex().then(resolve).catch(function() { resolve(null); });
        };
        
        request.onupgradeneeded = function(e) {
          var db = e.target.result;
          if (!db.objectStoreNames.contains(PDF_CACHE_CONFIG.STORE_NAME)) {
            db.createObjectStore(PDF_CACHE_CONFIG.STORE_NAME, { keyPath: 'key' });
          }
          if (!db.objectStoreNames.contains(PDF_CACHE_CONFIG.INDEX_STORE)) {
            db.createObjectStore(PDF_CACHE_CONFIG.INDEX_STORE, { keyPath: 'id' });
          }
        };
      });
    }
    
    function loadCacheIndex() {
      return new Promise(function(resolve, reject) {
        if (!pdfCacheDB) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.INDEX_STORE], 'readonly');
          var store = tx.objectStore(PDF_CACHE_CONFIG.INDEX_STORE);
          var req = store.get('cache_index');
          
          req.onsuccess = function() {
            if (req.result && Array.isArray(req.result.entries)) {
              pdfCacheIndex = req.result.entries;
            } else {
              pdfCacheIndex = [];
            }
            updateCacheStatsFromIndex();
            console.log('[PDF_CACHE] Loaded index:', pdfCacheIndex.length, 'entries');
            resolve();
          };
          
          req.onerror = function() {
            pdfCacheIndex = [];
            updateCacheStatsFromIndex();
            resolve();
          };
        } catch (e) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
        }
      });
    }
    
    function saveCacheIndex() {
      if (!pdfCacheDB) return Promise.resolve();
      
      return new Promise(function(resolve) {
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.INDEX_STORE], 'readwrite');
          var store = tx.objectStore(PDF_CACHE_CONFIG.INDEX_STORE);
          store.put({ id: 'cache_index', entries: pdfCacheIndex });
          tx.oncomplete = resolve;
          tx.onerror = resolve;
        } catch (e) {
          resolve();
        }
      });
    }
    
    function updateCacheStatsFromIndex() {
      var totalBytes = 0;
      pdfCacheIndex.forEach(function(entry) {
        totalBytes += entry.size_bytes || 0;
      });
      cacheState.pdfCount = pdfCacheIndex.length;
      cacheState.totalBytes = totalBytes;
      cacheState.storageKB = Math.round(totalBytes / 1024);
      updateCacheDisplay();
    }
    
    function computePdfCacheKey(recordIdentity, sourceUrl) {
      var identity = recordIdentity || 'unknown';
      var url = sourceUrl || '';
      return 'pdf:' + identity + ':' + url.split('?')[0];
    }
    
    function getCachedPdf(cacheKey) {
      return new Promise(function(resolve) {
        if (!pdfCacheDB) {
          resolve(null);
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME], 'readonly');
          var store = tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME);
          var req = store.get(cacheKey);
          
          req.onsuccess = function() {
            if (req.result && req.result.blob) {
              // Update last_accessed_at
              updateCacheEntryAccess(cacheKey);
              resolve(req.result.blob);
            } else {
              resolve(null);
            }
          };
          
          req.onerror = function() { resolve(null); };
        } catch (e) {
          resolve(null);
        }
      });
    }
    
    function updateCacheEntryAccess(cacheKey) {
      var entry = pdfCacheIndex.find(function(e) { return e.key === cacheKey; });
      if (entry) {
        entry.last_accessed_at = Date.now();
        saveCacheIndex();
      }
    }
    
    function cachePdf(cacheKey, sourceUrl, blob) {
      return new Promise(function(resolve) {
        if (!pdfCacheDB || !blob) {
          resolve(false);
          return;
        }
        
        var sizeBytes = blob.size;
        
        // Check per-file cap
        if (sizeBytes > PDF_CACHE_CONFIG.MAX_FILE_BYTES) {
          console.log('[PDF_CACHE] File too large to cache:', (sizeBytes / 1024 / 1024).toFixed(2), 'MB (max 25MB)');
          resolve(false);
          return;
        }
        
        // LRU eviction if needed
        evictLRUIfNeeded(sizeBytes).then(function() {
          try {
            var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME], 'readwrite');
            var store = tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME);
            
            var entry = {
              key: cacheKey,
              source_url: sourceUrl,
              size_bytes: sizeBytes,
              created_at: Date.now(),
              last_accessed_at: Date.now(),
              blob: blob
            };
            
            store.put(entry);
            
            tx.oncomplete = function() {
              // Update index
              var existingIdx = pdfCacheIndex.findIndex(function(e) { return e.key === cacheKey; });
              var indexEntry = {
                key: cacheKey,
                source_url: sourceUrl,
                size_bytes: sizeBytes,
                created_at: entry.created_at,
                last_accessed_at: entry.last_accessed_at
              };
              
              if (existingIdx >= 0) {
                pdfCacheIndex[existingIdx] = indexEntry;
              } else {
                pdfCacheIndex.push(indexEntry);
              }
              
              updateCacheStatsFromIndex();
              saveCacheIndex();
              console.log('[PDF_CACHE] Cached:', cacheKey, (sizeBytes / 1024).toFixed(1), 'KB');
              resolve(true);
            };
            
            tx.onerror = function() { resolve(false); };
          } catch (e) {
            resolve(false);
          }
        });
      });
    }
    
    function evictLRUIfNeeded(newFileBytes) {
      return new Promise(function(resolve) {
        var currentTotal = cacheState.totalBytes;
        var wouldBe = currentTotal + newFileBytes;
        
        if (wouldBe <= PDF_CACHE_CONFIG.MAX_TOTAL_BYTES) {
          resolve();
          return;
        }
        
        // Sort by last_accessed_at (oldest first)
        var sorted = pdfCacheIndex.slice().sort(function(a, b) {
          return (a.last_accessed_at || 0) - (b.last_accessed_at || 0);
        });
        
        var toEvict = [];
        var freedBytes = 0;
        var needed = wouldBe - PDF_CACHE_CONFIG.MAX_TOTAL_BYTES;
        
        for (var i = 0; i < sorted.length && freedBytes < needed; i++) {
          toEvict.push(sorted[i].key);
          freedBytes += sorted[i].size_bytes || 0;
        }
        
        if (toEvict.length === 0) {
          resolve();
          return;
        }
        
        console.log('[PDF_CACHE] Evicting', toEvict.length, 'LRU entries to free', (freedBytes / 1024).toFixed(1), 'KB');
        
        // Delete from IndexedDB
        var pending = toEvict.length;
        toEvict.forEach(function(key) {
          deleteCachedPdf(key).then(function() {
            pending--;
            if (pending === 0) resolve();
          });
        });
      });
    }
    
    function deleteCachedPdf(cacheKey) {
      return new Promise(function(resolve) {
        if (!pdfCacheDB) {
          pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
          updateCacheStatsFromIndex();
          resolve();
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME], 'readwrite');
          var store = tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME);
          store.delete(cacheKey);
          
          tx.oncomplete = function() {
            pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
            updateCacheStatsFromIndex();
            resolve();
          };
          
          tx.onerror = function() {
            pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
            updateCacheStatsFromIndex();
            resolve();
          };
        } catch (e) {
          pdfCacheIndex = pdfCacheIndex.filter(function(e) { return e.key !== cacheKey; });
          updateCacheStatsFromIndex();
          resolve();
        }
      });
    }
    
    function clearAllCachedPdfs() {
      return new Promise(function(resolve) {
        if (!pdfCacheDB) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
          return;
        }
        
        try {
          var tx = pdfCacheDB.transaction([PDF_CACHE_CONFIG.STORE_NAME, PDF_CACHE_CONFIG.INDEX_STORE], 'readwrite');
          tx.objectStore(PDF_CACHE_CONFIG.STORE_NAME).clear();
          tx.objectStore(PDF_CACHE_CONFIG.INDEX_STORE).clear();
          
          tx.oncomplete = function() {
            pdfCacheIndex = [];
            updateCacheStatsFromIndex();
            console.log('[PDF_CACHE] All cached PDFs cleared');
            resolve();
          };
          
          tx.onerror = function() {
            pdfCacheIndex = [];
            updateCacheStatsFromIndex();
            resolve();
          };
        } catch (e) {
          pdfCacheIndex = [];
          updateCacheStatsFromIndex();
          resolve();
        }
      });
    }
    
    function formatCacheSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / 1024 / 1024).toFixed(1) + ' MB';
    }

    // v1.6.31: Update progress block from actual data (signals + patch requests)
    function updateProgressBlock() {
      var todoEl = document.getElementById('progress-todo');
      var reviewEl = document.getElementById('progress-review');
      var doneEl = document.getElementById('progress-done');
      var barFill = document.getElementById('progress-bar-fill');
      
      if (!todoEl || !reviewEl || !doneEl) return;
      
      // v1.6.31: Count from actual data sources
      var todo = 0;      // Records with signals/issues needing analyst attention
      var review = 0;    // Patch requests submitted for reviewer/admin review
      var done = 0;      // Approved/promoted/verified records
      
      // TO DO: Count records with active signals (from signalStore)
      if (typeof signalStore !== 'undefined' && signalStore.stats) {
        todo = signalStore.stats.total || 0;
      }
      
      // REVIEW + DONE: Count from patch requests by status
      var patchRequests = PATCH_REQUEST_STORE.list();
      patchRequests.forEach(function(pr) {
        var status = pr.status || '';
        // In review: Submitted, Pending_Review, Sent_to_Admin, Verifier_Approved, Admin_Hold
        if (['Submitted', 'Pending_Review', 'Sent_to_Admin', 'Verifier_Approved', 'Admin_Hold', 'Needs_Clarification'].includes(status)) {
          review++;
        }
        // Done: Admin_Approved, Promoted, Applied
        else if (['Admin_Approved', 'Promoted', 'Applied', 'Resolved'].includes(status)) {
          done++;
        }
      });
      
      // Also count from triage queue if available
      var manualCount = parseInt(document.getElementById('manual-queue-count')?.textContent?.match(/\d+/)?.[0] || '0', 10);
      var sflogicCount = parseInt(document.getElementById('sflogic-queue-count')?.textContent?.match(/\d+/)?.[0] || '0', 10);
      var patchCount = parseInt(document.getElementById('patch-queue-count')?.textContent?.match(/\d+/)?.[0] || '0', 10);
      var systemCount = parseInt(document.getElementById('system-queue-count')?.textContent?.match(/\d+/)?.[0] || '0', 10);
      
      // Use triage counts if available and higher than signal count
      var triageTotal = manualCount + sflogicCount + patchCount + systemCount;
      if (triageTotal > 0 && triageTotal !== todo) {
        todo = Math.max(todo, triageTotal);
      }
      
      var total = todo + review + done;
      var progressPct = total > 0 ? Math.round((done / total) * 100) : 0;
      
      todoEl.textContent = todo;
      reviewEl.textContent = review;
      doneEl.textContent = done;
      if (barFill) barFill.style.width = progressPct + '%';
      
      console.log('[Progress] Updated: To Do=' + todo + ', Review=' + review + ', Done=' + done + ' (' + progressPct + '%)');
    }

    function updateActiveDataSourceBar(filename) {
      var nameEl = document.getElementById('active-data-source-name');
      var actionBtn = document.getElementById('active-data-source-action');
      if (nameEl) {
        nameEl.textContent = filename || 'No dataset loaded';
      }
      if (actionBtn) {
        actionBtn.textContent = filename ? 'Change' : 'Connect';
      }
    }

    // v1.6.4: Check if a sheet is a meta sheet (audit log, change log, etc.)
    function isMetaSheet(sheetName) {
      if (!sheetName) return false;
      return META_SHEET_PATTERNS.some(function(pattern) {
        return sheetName.includes(pattern);
      });
    }
    
    // v1.6.20: Check if sheet is a reference/glossary sheet (supporting data, not actionable)
    function isReferenceSheet(sheetName) {
      if (!sheetName) return false;
      var lowerName = sheetName.toLowerCase();
      return REFERENCE_SHEET_PATTERNS.some(function(pattern) {
        return lowerName.includes(pattern.toLowerCase());
      });
    }
    
    // v1.6.20: Filter out reference/glossary rows from issues/field_actions arrays
    function filterOutReferenceData(items) {
      if (!items || !Array.isArray(items)) return [];
      return items.filter(function(item) {
        var sheet = item.sheet || item.sheet_name || '';
        return !isReferenceSheet(sheet) && !isMetaSheet(sheet);
      });
    }
    
    // v1.6.4: Get all meta sheets from workbook
    function getMetaSheets() {
      if (!workbook || !workbook.order) return [];
      return workbook.order.filter(isMetaSheet);
    }
    
    // v1.6.4: Get data sheets (non-meta) from workbook
    function getDataSheets() {
      if (!workbook || !workbook.order) return [];
      return workbook.order.filter(function(s) { return !isMetaSheet(s); });
    }
    
    // v1.6.4: Set demo mode (original or modified)
    function setDemoMode(mode) {
      if (mode !== 'original' && mode !== 'modified') return;
      demoToggleState.mode = mode;
      localStorage.setItem(DEMO_TOGGLE_KEY, mode);
      updateDemoToggleUI();
      
      // Reload the appropriate dataset
      console.log('[DemoToggle] Switching to:', mode);
      loadSampleDataset({ autoRedirect: false });
      showToast('Switched to ' + (mode === 'modified' ? 'Modified (In-Progress)' : 'Original (Baseline)') + ' demo dataset', 'success');
    }
    
    // v1.6.4: Update demo toggle UI state
    function updateDemoToggleUI() {
      var isModified = demoToggleState.isModified();
      var originalBtn = document.getElementById('demo-toggle-original');
      var modifiedBtn = document.getElementById('demo-toggle-modified');
      var badge = document.getElementById('demo-mode-badge');
      var banner = document.getElementById('demo-partial-banner');
      var nameEl = document.getElementById('demo-dataset-name');
      var descEl = document.getElementById('demo-dataset-desc');
      
      if (originalBtn) {
        originalBtn.style.background = isModified ? '#f5f5f5' : '#1976d2';
        originalBtn.style.color = isModified ? '#333' : 'white';
      }
      if (modifiedBtn) {
        modifiedBtn.style.background = isModified ? '#ff9800' : '#f5f5f5';
        modifiedBtn.style.color = isModified ? 'white' : '#333';
      }
      if (badge) badge.style.display = isModified ? 'inline-block' : 'none';
      if (banner) banner.style.display = isModified ? 'block' : 'none';
      if (nameEl) nameEl.textContent = isModified ? 'ostereo_demo_v1.json' : 'ostereo_demo_original.json';
      if (descEl) descEl.textContent = isModified ? 'Modified dataset (in-progress)' : 'Baseline dataset (clean)';
    }

    function updateSidebarSheetSelector() {
      var selector = document.getElementById('sidebar-sheet-selector');
      if (!selector || !workbook || !workbook.order) return;
      
      selector.innerHTML = '<option value="all">All Sheets</option>';
      // v1.6.4: Only show data sheets, hide meta sheets
      getDataSheets().forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        if (!sheet) return;
        var opt = document.createElement('option');
        opt.value = sheetName;
        opt.textContent = sheetName + ' (' + (sheet.rows ? sheet.rows.length : 0) + ')';
        selector.appendChild(opt);
      });
    }

    function handleSheetSelectorChange(value) {
      console.log('[Sidebar] Sheet selector changed:', value);
      if (value === 'all') {
        gridState.sheet = null;
      } else {
        gridState.sheet = value;
      }
      renderGrid();
    }

    function openRecordInspectionFromNav() {
      var firstRow = gridState.filteredData && gridState.filteredData[0];
      if (firstRow && firstRow._row_id) {
        openRowReviewDrawer(firstRow._row_id);
      } else if (dataLoaded) {
        showToast('Select a row from the grid to inspect', 'info');
        navigateTo('grid');
      } else {
        showToast('Load a dataset first', 'warning');
      }
    }

    // v1.4.13: Wire clear cache to IndexedDB
    function clearCachedPDFs() {
      clearAllCachedPdfs().then(function() {
        try {
          localStorage.removeItem('orchestrate.pdf_attachments.v1');
        } catch (e) {}
        showToast('Cached PDFs cleared', 'success');
      });
    }

    // ========== EXPORT / SAVE FUNCTIONALITY (v1.6.31) ==========
    function handleExportSave() {
      if (typeof XLSX === 'undefined') {
        showToast('Excel library not loaded. Please refresh and try again.', 'error');
        return;
      }
      
      if (!workbook || !workbook.order || workbook.order.length === 0) {
        showToast('No data to export. Please load a dataset first.', 'warning');
        return;
      }
      
      showToast('Preparing export...', 'info');
      
      try {
        var wb = XLSX.utils.book_new();
        
        // v1.6.31: Export all data sheets with styling metadata
        var dataSheets = getDataSheets();
        dataSheets.forEach(function(sheetName) {
          var sheetData = workbook.sheets[sheetName];
          if (!sheetData || !sheetData.rows) return;
          
          // Build sheet array with headers
          var sheetArray = [sheetData.headers.slice()];
          
          // Add rows
          sheetData.rows.forEach(function(row) {
            var rowArray = sheetData.headers.map(function(h) {
              var val = row[h];
              if (val === null || val === undefined) return '';
              if (typeof val === 'object') return JSON.stringify(val);
              return val;
            });
            sheetArray.push(rowArray);
          });
          
          var ws = XLSX.utils.aoa_to_sheet(sheetArray);
          
          // v1.6.31: Apply column widths
          var colWidths = sheetData.headers.map(function(h) {
            return { wch: Math.min(30, Math.max(10, h.length + 2)) };
          });
          ws['!cols'] = colWidths;
          
          XLSX.utils.book_append_sheet(wb, ws, sheetName.substring(0, 31));
        });
        
        // v1.6.31: Add _change_log sheet with all changes
        var changeLogWs = buildChangeLogSheet();
        if (changeLogWs) {
          XLSX.utils.book_append_sheet(wb, changeLogWs, '_change_log');
        }
        
        // v1.6.31: Add RFIs & Analyst Notes sheet
        var rfiWs = buildRFISheet();
        if (rfiWs) {
          XLSX.utils.book_append_sheet(wb, rfiWs, 'RFIs & Analyst Notes');
        }
        
        // v1.6.31: Add Signals Summary sheet
        var signalsWs = buildSignalsSummarySheet();
        if (signalsWs) {
          XLSX.utils.book_append_sheet(wb, signalsWs, '_signals_summary');
        }
        
        // v1.6.31: Add Orchestrate OS Metadata sheet
        var metaWs = buildMetadataSheet();
        XLSX.utils.book_append_sheet(wb, metaWs, '_orchestrate_meta');
        
        // Generate filename with timestamp
        var datasetName = IDENTITY_CONTEXT.dataset_id || 'dataset';
        var timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
        var filename = 'orchestrate_' + datasetName + '_' + timestamp + '.xlsx';
        
        // Download file
        XLSX.writeFile(wb, filename);
        
        showToast('Exported: ' + filename, 'success');
        console.log('[Export] Generated:', filename, 'sheets:', wb.SheetNames.length);
        
      } catch (err) {
        console.error('[Export] Error:', err);
        showToast('Export failed: ' + err.message, 'error');
      }
    }
    
    // v1.6.31: Build _change_log sheet from patch requests and changeMap
    function buildChangeLogSheet() {
      var headers = [
        'record_id', 'sheet', 'field', 'change_type', 'old_value', 'new_value',
        'reason', 'analyst', 'timestamp', 'status', 'request_id'
      ];
      var rows = [headers];
      
      // Get all patch requests
      var patchRequests = PATCH_REQUEST_STORE.list();
      patchRequests.forEach(function(pr) {
        var row = [
          pr.record_id || '',
          pr.sheet || '',
          pr.field || '',
          pr.type || 'correction',
          pr.old_value || '',
          pr.new_value || '',
          pr.justification || pr.comment || '',
          pr.analyst || getCurrentUserName(),
          pr.created_at_utc || '',
          pr.status || 'Draft',
          pr.request_id || ''
        ];
        rows.push(row);
      });
      
      // Also include changeMap entries if available
      if (typeof changeMap !== 'undefined' && changeMap.changes) {
        Object.keys(changeMap.changes).forEach(function(recordId) {
          var recordChanges = changeMap.changes[recordId];
          Object.keys(recordChanges).forEach(function(field) {
            var change = recordChanges[field];
            var row = [
              recordId,
              change.sheet || '',
              field,
              change.type || 'correction',
              change.old_value || '',
              change.new_value || '',
              change.notes || '',
              change.analyst || '',
              change.timestamp || '',
              'Applied',
              ''
            ];
            rows.push(row);
          });
        });
      }
      
      if (rows.length <= 1) return null;
      
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(25, Math.max(12, h.length + 2)) };
      });
      return ws;
    }
    
    // v1.6.31: Build RFIs & Analyst Notes sheet (includes all escalations)
    function buildRFISheet() {
      var headers = [
        'record_id', 'sheet', 'field', 'type', 'comment_or_question', 'current_value',
        'submitted_by', 'submitted_at', 'escalated_to', 'escalation_status',
        'response', 'resolved_by', 'resolved_at'
      ];
      var rows = [headers];
      
      // v1.6.31: Include ALL patch requests that have been promoted/escalated
      // This tracks the full escalation trail through the role hierarchy
      var patchRequests = PATCH_REQUEST_STORE.list();
      
      patchRequests.forEach(function(pr) {
        // Determine escalation status based on patch request status
        var escalationStatus = 'Draft';
        var escalatedTo = '';
        
        // Map status to escalation level
        if (pr.status === 'Submitted' || pr.status === 'Pending_Review') {
          escalationStatus = 'Analyst -> Reviewer';
          escalatedTo = 'Reviewer';
        } else if (pr.status === 'Needs_Clarification') {
          escalationStatus = 'Reviewer -> Analyst (Returned)';
          escalatedTo = 'Analyst';
        } else if (pr.status === 'Verifier_Approved' || pr.status === 'Sent_to_Admin') {
          escalationStatus = 'Reviewer -> Admin';
          escalatedTo = 'Admin';
        } else if (pr.status === 'Admin_Approved' || pr.status === 'Promoted') {
          escalationStatus = 'Approved & Promoted';
          escalatedTo = 'Baseline';
        } else if (pr.status === 'Admin_Rejected' || pr.status === 'Rejected') {
          escalationStatus = 'Rejected';
          escalatedTo = 'Closed';
        } else if (pr.status === 'Admin_Hold') {
          escalationStatus = 'On Hold (Admin)';
          escalatedTo = 'Admin';
        } else if (pr.status === 'Draft') {
          escalationStatus = 'Draft (Not Submitted)';
          escalatedTo = '';
        }
        
        var row = [
          pr.record_id || '',
          pr.sheet || '',
          pr.field || '',
          pr.type || 'correction',
          pr.comment || pr.justification || pr.question || '',
          pr.current_value || pr.old_value || '',
          pr.analyst || pr.submitted_by || getCurrentUserName(),
          pr.created_at_utc || '',
          escalatedTo,
          escalationStatus,
          pr.response || pr.verifier_notes || '',
          pr.resolved_by || pr.approved_by || '',
          pr.resolved_at || pr.updated_at_utc || ''
        ];
        rows.push(row);
      });
      
      if (rows.length <= 1) return null;
      
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(30, Math.max(12, h.length + 2)) };
      });
      return ws;
    }
    
    // v1.6.31: Build Signals Summary sheet
    function buildSignalsSummarySheet() {
      var headers = [
        'record_id', 'sheet', 'field', 'signal_type', 'severity', 'message', 'value'
      ];
      var rows = [headers];
      
      if (typeof signalStore !== 'undefined' && signalStore.signals_by_cell) {
        Object.keys(signalStore.signals_by_cell).forEach(function(recordId) {
          var recordSignals = signalStore.signals_by_cell[recordId];
          Object.keys(recordSignals).forEach(function(field) {
            var signals = recordSignals[field];
            signals.forEach(function(sig) {
              var row = [
                recordId,
                sig.sheet || '',
                field,
                sig.signal_type || '',
                sig.severity || 'info',
                sig.message || '',
                sig.value || ''
              ];
              rows.push(row);
            });
          });
        });
      }
      
      if (rows.length <= 1) return null;
      
      var ws = XLSX.utils.aoa_to_sheet(rows);
      ws['!cols'] = headers.map(function(h) {
        return { wch: Math.min(25, Math.max(12, h.length + 2)) };
      });
      return ws;
    }
    
    // v1.6.31: Build Orchestrate OS Metadata sheet
    function buildMetadataSheet() {
      var metadata = [
        ['Orchestrate OS Export Metadata'],
        [''],
        ['Property', 'Value'],
        ['Export Date', new Date().toISOString()],
        ['Export Version', 'v1.6.31'],
        ['Dataset ID', IDENTITY_CONTEXT.dataset_id || ''],
        ['Tenant ID', IDENTITY_CONTEXT.tenant_id || ''],
        ['Division ID', IDENTITY_CONTEXT.division_id || ''],
        ['Total Sheets', workbook.order.length],
        ['Data Sheets', getDataSheets().length],
        ['Meta Sheets', getMetaSheets().length],
        ['Total Records', getTotalRecordCount()],
        ['Signal Count', signalStore && signalStore.stats ? signalStore.stats.total : 0],
        ['Patch Requests', PATCH_REQUEST_STORE.list().length],
        [''],
        ['Sheet Order'],
        ...workbook.order.map(function(s, i) { return [(i + 1), s]; }),
        [''],
        ['Signal Types'],
        ...Object.entries(signalStore && signalStore.stats && signalStore.stats.by_type ? signalStore.stats.by_type : {}).map(function(e) { return [e[0], e[1]]; }),
        [''],
        ['Nomenclature'],
        ['System Name', 'Orchestrate OS'],
        ['Purpose', 'Semantic Control Board'],
        ['Mode', 'Governance-only control plane'],
        ['Join Strategy', 'contract_key -> file_url -> file_name']
      ];
      
      var ws = XLSX.utils.aoa_to_sheet(metadata);
      ws['!cols'] = [{ wch: 25 }, { wch: 50 }];
      return ws;
    }
    
    // v1.6.31: Get total record count across all sheets
    function getTotalRecordCount() {
      var count = 0;
      if (workbook && workbook.sheets) {
        Object.keys(workbook.sheets).forEach(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          if (sheet && sheet.rows) {
            count += sheet.rows.length;
          }
        });
      }
      return count;
    }

    // v1.4.13: Update cache display with formatted size
    function updateCacheDisplay() {
      var countEl = document.getElementById('cache-pdf-count');
      var sizeEl = document.getElementById('cache-storage-used');
      if (countEl) countEl.textContent = cacheState.pdfCount;
      if (sizeEl) sizeEl.textContent = formatCacheSize(cacheState.totalBytes);
    }
    
    function loadFromData(data, sourceType, fileName) {
      // Start staged loader for this path
      stagedLoader.start();
      stagedLoader.setStage('loading');
      
      if (!data || (!data.sf_summary && !data.sf_contract_results && !data.sf_issues && !data.sf_field_actions)) {
        stagedLoader.finish();
        throw new Error('Invalid data format - expected Preview Packet structure');
      }
      
      stagedLoader.setStage('standardizing');
      
      sessionState.status = 'loaded';
      sessionState.sourceType = sourceType;
      sessionState.loadedAt = Date.now();
      sessionState.previewData = data;
      sessionState.fileName = fileName || null;
      
      allData.contractResults = sortByJoinTriplet(data.sf_contract_results || []);
      // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
      allData.issues = filterOutReferenceData(sortBySeverityFirst(data.sf_issues || [], ['sheet', 'field', 'issue_type']));
      allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(data.sf_field_actions || [], ['sheet', 'field', 'action']));
      allData.changeLog = sortBySeverityFirst(data.sf_change_log || [], ['sheet', 'field', 'notes']);
      allData.summary = data.sf_summary || {};
      
      renderSummary(data.sf_summary || {});
      populateSubtypeDropdown();
      
      // Rendering stage
      stagedLoader.setStage('rendering');
      renderAllTables();
      
      dataLoaded = true;
      currentArtifactPath = fileName || sourceType;
      updateUIForDataState();
      updateSessionChip();
      
      // v1.5.3: Persist all records to canonical store
      persistAllRecordsToStore();
      
      // v1.6.0: Generate signals for dataset
      generateSignalsForDataset();
      
      // v1.6.31: Seed patch requests from RFI meta sheet (if present in modified dataset)
      seedPatchRequestsFromMetaSheet();
      
      // Finish staged loader
      stagedLoader.finish();
      
      // Detect unknown columns for Admin (uses current dataset with sheet awareness)
      if (typeof detectUnknownColumns === 'function') {
        var sheetName = sessionState.fileName || sourceType || 'imported_data';
        detectUnknownColumns(allData.contractResults, sheetName);
      }
      
      // Persist to localStorage if enabled
      const rememberChecked = document.getElementById('remember-session')?.checked;
      if (rememberChecked) {
        try {
          localStorage.setItem(STORAGE_KEY_SESSION, JSON.stringify({
            status: sessionState.status,
            sourceType: sessionState.sourceType,
            loadedAt: sessionState.loadedAt,
            fileName: sessionState.fileName,
            previewData: data,
            rememberEnabled: true
          }));
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
      } else {
        // Clear any existing session if user unchecked remember
        try {
          localStorage.removeItem(STORAGE_KEY_SESSION);
        } catch (e) {}
      }
      
      closeDataSourceDrawer();
      showWizardStatus('data-source-status', 'Data loaded successfully!', 'success');
    }
    
    function resetSession() {
      sessionState.status = 'not-loaded';
      sessionState.sourceType = null;
      sessionState.loadedAt = null;
      sessionState.previewData = null;
      sessionState.expectedData = null;
      sessionState.fileName = null;
      
      dataLoaded = false;
      currentArtifactPath = '';
      currentDataset = null;
      
      // Reset workbook (v1.4.3)
      resetWorkbook();
      
      allData.contractResults = [];
      allData.issues = [];
      allData.fieldActions = [];
      allData.changeLog = [];
      allData.summary = {};
      
      // Clear only app-namespaced localStorage keys (keep patch draft)
      try {
        localStorage.removeItem(STORAGE_KEY_SESSION);
        localStorage.removeItem('orchestrate.dataset.v1');
        localStorage.removeItem('orchestrate.pdf_attachments.v1');
      } catch (e) {}
      
      updateUIForDataState();
      updateSessionChip();
      updateProgressBlock();
      renderAllTables();
      
      // Reset modal fields (if they exist)
      const previewPaste = document.getElementById('preview-paste-area');
      const expectedPaste = document.getElementById('expected-paste-area');
      const previewDropFile = document.getElementById('preview-drop-file');
      const expectedDropFile = document.getElementById('expected-drop-file');
      const previewDropLoad = document.getElementById('preview-drop-load');
      const expectedDropLoad = document.getElementById('expected-drop-load');
      const previewStatus = document.getElementById('preview-status');
      const expectedStatus = document.getElementById('expected-status');
      
      if (previewPaste) previewPaste.value = '';
      if (expectedPaste) expectedPaste.value = '';
      if (previewDropFile) previewDropFile.textContent = '';
      if (expectedDropFile) expectedDropFile.textContent = '';
      if (previewDropLoad) previewDropLoad.disabled = true;
      if (expectedDropLoad) expectedDropLoad.disabled = true;
      if (previewStatus) {
        previewStatus.textContent = 'Not Loaded';
        previewStatus.className = 'loader-section-status empty';
      }
      if (expectedStatus) {
        expectedStatus.textContent = 'Not Loaded';
        expectedStatus.className = 'loader-section-status empty';
      }
      
      // Navigate to loader after reset
      navigateTo('loader');
      showWizardStatus('data-source-status', 'Session reset. Patch draft preserved.', 'info');
    }
    
    function restoreSessionFromStorage() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY_SESSION);
        if (stored) {
          const session = JSON.parse(stored);
          // Only restore if rememberEnabled was true when saved (opt-in check)
          if (session.previewData && session.rememberEnabled) {
            // Set checkbox to match saved preference
            const rememberCheckbox = document.getElementById('remember-session');
            if (rememberCheckbox) rememberCheckbox.checked = true;
            
            // Load data without re-saving to localStorage
            sessionState.status = 'loaded';
            sessionState.sourceType = session.sourceType;
            sessionState.loadedAt = session.loadedAt;
            sessionState.previewData = session.previewData;
            sessionState.fileName = session.fileName;
            
            const data = session.previewData;
            allData.contractResults = sortByJoinTriplet(data.sf_contract_results || []);
            // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
            allData.issues = filterOutReferenceData(sortBySeverityFirst(data.sf_issues || [], ['sheet', 'field', 'issue_type']));
            allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(data.sf_field_actions || [], ['sheet', 'field', 'action']));
            allData.changeLog = sortBySeverityFirst(data.sf_change_log || [], ['sheet', 'field', 'notes']);
            allData.summary = data.sf_summary || {};
            
            renderSummary(data.sf_summary || {});
            populateSubtypeDropdown();
            renderAllTables();
            
            dataLoaded = true;
            currentArtifactPath = session.fileName || session.sourceType;
            updateUIForDataState();
            updateSessionChip();
            
            // v1.5.3: Persist all records to canonical store
            persistAllRecordsToStore();
            
            // v1.6.0: Generate signals for dataset
            generateSignalsForDataset();
            
            // v1.6.31: Seed patch requests from RFI meta sheet
            seedPatchRequestsFromMetaSheet();
            
            return true;
          }
        }
      } catch (e) {
        console.warn('Could not restore session:', e);
      }
      return false;
    }
    
    function setupLoaderHandlers() {
      // Tab switching within loader sections
      document.querySelectorAll('.loader-tabs').forEach(tabContainer => {
        tabContainer.addEventListener('click', e => {
          const tab = e.target.closest('.loader-tab');
          if (!tab) return;
          const panelId = tab.dataset.panel;
          
          tabContainer.querySelectorAll('.loader-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          const section = tabContainer.closest('.loader-section');
          if (section) {
            section.querySelectorAll('.loader-panel').forEach(p => p.classList.remove('active'));
          }
          document.getElementById(panelId)?.classList.add('active');
        });
      });
      
      // Preview paste load (guard with null check - may not exist)
      var previewPasteBtn = document.getElementById('preview-paste-load');
      if (previewPasteBtn) {
        previewPasteBtn.addEventListener('click', function() {
          var text = document.getElementById('preview-paste-area').value.trim();
          if (!text) {
            showWizardStatus('data-source-status', 'Please paste JSON first', 'error');
            return;
          }
          try {
            var data = JSON.parse(text);
            loadFromData(data, 'paste', null);
          } catch (e) {
            showWizardStatus('data-source-status', 'Invalid JSON: ' + e.message, 'error');
          }
        });
      }
      
      // Preview drop zone (guard with null check - may not exist)
      var previewDropZone = document.getElementById('preview-drop-zone');
      var previewFileInput = document.getElementById('preview-file-input');
      var previewFileData = null;
      
      if (previewDropZone && previewFileInput) {
        var previewFileData = null;
        
        previewDropZone.addEventListener('click', function() { previewFileInput.click(); });
        previewDropZone.addEventListener('dragover', function(e) {
          e.preventDefault();
          previewDropZone.classList.add('drag-over');
        });
        previewDropZone.addEventListener('dragleave', function() {
          previewDropZone.classList.remove('drag-over');
        });
        previewDropZone.addEventListener('drop', function(e) {
          e.preventDefault();
          previewDropZone.classList.remove('drag-over');
          var file = e.dataTransfer.files[0];
          if (file) handlePreviewFile(file);
        });
        previewFileInput.addEventListener('change', function(e) {
          var file = e.target.files[0];
          if (file) handlePreviewFile(file);
        });
        
        function handlePreviewFile(file) {
          var reader = new FileReader();
          reader.onload = function(e) {
            try {
              previewFileData = JSON.parse(e.target.result);
              var fileEl = document.getElementById('preview-drop-file');
              if (fileEl) fileEl.textContent = file.name;
              previewDropZone.classList.add('has-file');
              var loadBtn = document.getElementById('preview-drop-load');
              if (loadBtn) loadBtn.disabled = false;
              sessionState.fileName = file.name;
            } catch (err) {
              showWizardStatus('data-source-status', 'Invalid JSON file: ' + err.message, 'error');
            }
          };
          reader.readAsText(file);
        }
        
        var previewLoadBtn = document.getElementById('preview-drop-load');
        if (previewLoadBtn) {
          previewLoadBtn.addEventListener('click', function() {
            if (previewFileData) {
              loadFromData(previewFileData, 'drop', sessionState.fileName);
            }
          });
        }
      }
      
      // Expected paste load (guard all with null checks)
      var expectedPasteBtn = document.getElementById('expected-paste-load');
      if (expectedPasteBtn) {
        expectedPasteBtn.addEventListener('click', function() {
          var textarea = document.getElementById('expected-paste-area');
          var text = textarea ? textarea.value.trim() : '';
          if (!text) {
            showWizardStatus('data-source-status', 'Please paste expected JSON first', 'error');
            return;
          }
          try {
            var data = JSON.parse(text);
            sessionState.expectedData = data;
            var statusEl = document.getElementById('expected-status');
            if (statusEl) {
              statusEl.textContent = 'Loaded';
              statusEl.className = 'loader-section-status loaded';
            }
            showWizardStatus('data-source-status', 'Expected data loaded for comparison', 'success');
          } catch (e) {
            showWizardStatus('data-source-status', 'Invalid JSON: ' + e.message, 'error');
          }
        });
      }
      
      // Expected drop zone (guard all with null checks)
      var expectedDropZone = document.getElementById('expected-drop-zone');
      var expectedFileInput = document.getElementById('expected-file-input');
      
      if (expectedDropZone && expectedFileInput) {
        var expectedFileData = null;
        
        expectedDropZone.addEventListener('click', function() { expectedFileInput.click(); });
        expectedDropZone.addEventListener('dragover', function(e) {
          e.preventDefault();
          expectedDropZone.classList.add('drag-over');
        });
        expectedDropZone.addEventListener('dragleave', function() {
          expectedDropZone.classList.remove('drag-over');
        });
        expectedDropZone.addEventListener('drop', function(e) {
          e.preventDefault();
          expectedDropZone.classList.remove('drag-over');
          var file = e.dataTransfer.files[0];
          if (file) handleExpectedFile(file);
        });
        expectedFileInput.addEventListener('change', function(e) {
          var file = e.target.files[0];
          if (file) handleExpectedFile(file);
        });
        
        function handleExpectedFile(file) {
          var reader = new FileReader();
          reader.onload = function(e) {
            try {
              expectedFileData = JSON.parse(e.target.result);
              var fileEl = document.getElementById('expected-drop-file');
              if (fileEl) fileEl.textContent = file.name;
              expectedDropZone.classList.add('has-file');
              var loadBtn = document.getElementById('expected-drop-load');
              if (loadBtn) loadBtn.disabled = false;
            } catch (err) {
              showWizardStatus('data-source-status', 'Invalid JSON file: ' + err.message, 'error');
            }
          };
          reader.readAsText(file);
        }
        
        var expectedLoadBtn = document.getElementById('expected-drop-load');
        if (expectedLoadBtn) {
          expectedLoadBtn.addEventListener('click', function() {
            if (expectedFileData) {
              sessionState.expectedData = expectedFileData;
              var statusEl = document.getElementById('expected-status');
              if (statusEl) {
                statusEl.textContent = 'Loaded';
                statusEl.className = 'loader-section-status loaded';
              }
              showWizardStatus('data-source-status', 'Expected data loaded for comparison', 'success');
            }
          });
        }
      }
      
      // Path hint preset buttons
      document.querySelectorAll('#preview-path .wizard-preset-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var input = document.getElementById('preview-path-input');
          if (input) input.value = btn.dataset.path;
        });
      });
      
      // Reset session button (guard with null check)
      var resetBtn = document.getElementById('reset-session-btn');
      if (resetBtn) {
        resetBtn.addEventListener('click', function() {
          if (confirm('Reset session? This clears loaded artifacts but keeps your patch draft.')) {
            resetSession();
          }
        });
      }
    }

    // ========== APP SESSION STATE MACHINE (V1.2.8) ==========
    var currentPage = 'loader';
    
    function getAppSessionState() {
      // Returns current session state for route guard checks
      // Use dataLoaded as primary check - simpler and more reliable than bundle check
      return {
        active_dataset_id: localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET) || null,
        data_loaded: dataLoaded,
        current_page: currentPage,
        current_mode: currentMode
      };
    }
    
    function checkRouteRequirements(page) {
      // Check if route requirements are met
      // Use dataLoaded instead of bundle presence (more reliable)
      var requirements = {
        'triage': { needsData: true },
        'patch': { needsData: true },
        'review': { needsData: true },
        'admin': { needsData: false },
        'loader': { needsData: false }
      };
      
      var pageReqs = requirements[page] || { needsData: false };
      
      if (pageReqs.needsData && !dataLoaded) {
        return { valid: false, missing: 'data_loaded' };
      }
      return { valid: true };
    }
    
    function updateDebugHUD() {
      var hud = document.getElementById('debug-hud');
      if (!hud) return;
      var state = getAppSessionState();
      hud.innerHTML = 'Route: ' + currentPage + ' | Data: ' + (dataLoaded ? 'Yes' : 'No') + ' | Mode: ' + currentMode;
    }
    
    function pageRequiresDataset(page) {
      return ['triage', 'patch', 'review'].includes(page);
    }

    function navigateTo(page, options) {
      options = options || {};
      // Loader is now a drawer, not a page - redirect loader requests to triage
      if (page === 'loader') page = 'triage';
      var pages = ['triage', 'grid', 'patch', 'review', 'verifier-review', 'admin-review', 'admin-approval', 'admin', 'row', 'restricted'];
      
      // v1.5.3: Reset reviewer SRR mode when navigating away from row page
      if (!page.startsWith('row') && srrState.reviewerMode) {
        resetReviewerSRRMode();
      }
      
      // Handle row/:id routes
      // v1.4.16: Validate rowId - reject undefined/NaN/empty
      if (page.startsWith('row/')) {
        var rowId = page.split('/')[1];
        if (!rowId || rowId === 'undefined' || rowId === 'null' || rowId === 'NaN') {
          console.warn('[Navigate] Invalid row route ignored:', page);
          navigateTo(dataLoaded ? 'grid' : 'triage');
          return;
        }
        // v1.4.16: If SRR already open with same row, skip re-open (prevents hashchange loop failures)
        if (srrState.currentRowId !== null && String(srrState.currentRowId) === String(rowId) && srrState.currentSheetName) {
          console.log('[Navigate] SRR already open for row:', rowId, 'sheet:', srrState.currentSheetName);
          return;
        }
        // v1.4.16: If srrState has sheetName from prior open, use it for resolution
        if (srrState.currentSheetName && typeof rowId === 'string') {
          var idx = parseInt(rowId, 10);
          if (!isNaN(idx)) {
            openRowReviewDrawer(srrState.currentSheetName, idx);
            return;
          }
        }
        openRowReviewDrawer(rowId);
        return;
      }
      if (!pages.includes(page)) page = dataLoaded ? 'grid' : 'triage';
      
      console.log('[Navigate] Attempting navigation to: ' + page + ', dataLoaded: ' + dataLoaded);
      
      // For pages needing data, we still show the page but with empty state
      // No hard redirect - triage handles its own empty state with "Load Data" CTA
      
      // Parse admin tab from route (e.g., admin/standardizer -> tab=standardizer)
      var adminTab = null;
      if (page.startsWith('admin/')) {
        var parts = page.split('/');
        page = 'admin';
        adminTab = parts[1] || 'governance';
      }
      
      // v1.4.22: RBAC route guards - show Access Restricted page with specific message
      var restrictedReason = null;
      if (page === 'admin' && currentMode !== 'admin') {
        console.log('[Navigate] Admin page requires admin mode');
        restrictedReason = 'The Admin Panel is only available to users with the Admin role.';
        adminTab = null;
      }
      if (page === 'review' && currentMode !== 'reviewer' && currentMode !== 'admin') {
        console.log('[Navigate] Review page requires reviewer/admin mode');
        restrictedReason = 'Config Inspector is only available to Reviewers and Admins.';
      }
      if (page === 'verifier-review' && currentMode !== 'reviewer' && currentMode !== 'admin') {
        console.log('[Navigate] Verifier Review page requires reviewer/admin mode');
        restrictedReason = 'Verifier Review is only available to Reviewers and Admins.';
      }
      if (page === 'admin-approval' && currentMode !== 'admin') {
        console.log('[Navigate] Admin Approval page requires admin mode');
        restrictedReason = 'Admin Approval is only available to users with the Admin role.';
      }
      if (page === 'patch' && currentMode !== 'analyst') {
        console.log('[Navigate] Patch Studio requires analyst mode');
        restrictedReason = 'Patch Studio is only available to Analysts. Reviewers and Admins review patches submitted by Analysts.';
      }
      
      // If restricted, show access restricted page
      if (restrictedReason) {
        page = 'restricted';
        var msgEl = document.getElementById('restricted-message');
        if (msgEl) msgEl.textContent = restrictedReason;
      }
      // v1.5.1: Admin Review route (reuses verifier-review page with admin label)
      if (page.startsWith('admin-review/') || page === 'admin-review') {
        if (currentMode !== 'admin') {
          console.log('[Navigate] Admin Review page requires admin mode');
          page = 'restricted';
          var msgEl2 = document.getElementById('restricted-message');
          if (msgEl2) msgEl2.textContent = 'Admin Review is only available to users with the Admin role.';
        } else {
          // Extract artifact ID and load for admin review
          var artifactId = page.split('/')[1];
          if (artifactId) {
            loadAdminReviewData(artifactId);
          }
          // Use verifier-review page but with admin context
          page = 'verifier-review';
        }
      }
      
      // Update current page tracking
      currentPage = page;
      
      // Clear all pages first - MUST reset both class AND inline style
      document.querySelectorAll('.page').forEach(function(p) { 
        p.classList.remove('active'); 
        p.style.display = 'none';  // Reset inline style to ensure CSS takes over
      });
      document.querySelectorAll('.page-content').forEach(function(p) { p.style.display = 'none'; });
      document.querySelectorAll('.nav-item').forEach(function(n) { n.classList.remove('active'); });
      
      var pageEl = document.getElementById('page-' + page);
      var navEl = document.querySelector('.nav-item[data-page="' + page + '"]');
      
      console.log('[Navigate] Showing page element: page-' + page + ', found: ' + (pageEl ? 'yes' : 'no'));
      
      if (pageEl) {
        pageEl.classList.add('active');
        pageEl.style.display = 'block';
      }
      if (navEl) navEl.classList.add('active');
      
      // Show empty queue message on triage if no data loaded
      var emptyMsg = document.getElementById('empty-queue-message');
      if (emptyMsg) {
        if (page === 'triage' && !dataLoaded) {
          emptyMsg.classList.remove('hidden');
        } else {
          emptyMsg.classList.add('hidden');
        }
      }
      
      // Update debug HUD
      updateDebugHUD();
      
      // DEV-ONLY: Assert no admin sections render inside triage
      if (page === 'triage') {
        var triageEl = document.getElementById('page-triage');
        if (triageEl) {
          var adminSectionsInTriage = triageEl.querySelectorAll('[data-admin-section="true"]');
          if (adminSectionsInTriage.length > 0) {
            console.error('[DEV ASSERTION FAILED] Found ' + adminSectionsInTriage.length + ' admin sections inside triage page!');
          }
        }
      }
      
      // If navigating to admin with a specific tab, switch to it
      if (page === 'admin') {
        // Update admin queue count
        updatePatchQueueCount();
        if (adminTab) {
          switchAdminTab(adminTab);
        }
      }
      
      // v1.5.1: Show/hide Patch Tester tab based on role when entering SSR
      if (page === 'row') {
        srrShowPatchTesterTabs();
      }
      
      // If navigating to grid, initialize grid
      if (page === 'grid') {
        setTimeout(function() { 
          initGrid(); 
          // v1.5.2: Initialize reviewer grid mode
          if (currentMode === 'reviewer') {
            initReviewerGridFilters();
            renderReviewerGrid();
          }
        }, 0);
      }
      
      // If navigating to verifier-review, load data (only if we have a payload or haven't loaded yet)
      if (page === 'verifier-review') {
        // v1.5.1: Reset header/buttons if not in admin review mode
        if (!vrState.isAdminReview) {
          var headerEl = document.querySelector('#page-verifier-review h2');
          if (headerEl) headerEl.textContent = 'Verifier Review';
          var descEl = document.querySelector('#page-verifier-review .page-desc');
          if (descEl) descEl.textContent = 'Review submitted Patch Requests, request clarification, approve or reject.';
          resetVerifierReviewButtons();
        }
        
        setTimeout(function() {
          // Skip re-loading if we already have a loaded payload and no new selection
          if (!vrState.selectedPayloadId && vrState.currentPayload) {
            console.log('[VR_LOAD] Skipping reload - already have payload:', vrState.currentPayload.id || vrState.currentPatchId);
            return;
          }
          loadVerifierReviewData(vrState.selectedPayloadId);
          vrState.selectedPayloadId = null;  // Clear after use
        }, 0);
      }
      
      // If navigating to admin-approval, load sample data
      if (page === 'admin-approval') {
        setTimeout(function() { loadAdminApprovalData(); }, 0);
      }
      
      // Update hash (include tab for admin deep-links, preserve grid query params)
      if (page === 'admin' && adminTab && adminTab !== 'governance') {
        window.location.hash = '#/admin/' + adminTab;
      } else if (page === 'grid' && options.queryParams) {
        window.location.hash = '#/grid?' + options.queryParams;
      } else {
        window.location.hash = '#/' + page;
      }
    }
    
    // Navigate to grid with filter (for Triage alert lens)
    function navigateToGridFiltered(filter, sheet) {
      var params = [];
      if (filter && filter !== 'all') params.push('f=' + encodeURIComponent(filter));
      if (sheet) params.push('sheet=' + encodeURIComponent(sheet));
      navigateTo('grid', { queryParams: params.join('&') });
    }
    
    function recoverNavigation() {
      var currentHash = window.location.hash.replace('#/', '') || (dataLoaded ? 'grid' : 'triage');
      // Loader is now a drawer, redirect appropriately
      if (currentHash === 'loader') currentHash = dataLoaded ? 'grid' : 'triage';
      // Handle grid query params
      if (currentHash.startsWith('grid?')) {
        var queryPart = currentHash.split('?')[1];
        gridState.filter = 'all';
        gridState.sheet = '';
        gridState.search = '';
        if (queryPart) {
          var params = new URLSearchParams(queryPart);
          gridState.filter = params.get('f') || 'all';
          gridState.sheet = params.get('sheet') || '';
          gridState.search = params.get('q') || '';
        }
        currentHash = 'grid';
      }
      console.log('[RecoverNav] Recovering to: ' + currentHash);
      navigateTo(currentHash);
      return true;
    }

    // v1.6.22: Get the logged-in user's actual role (from landing page login)
    // Priority: demoUser.role (from login) > currentRole (from session) > fallback
    function getLoggedInUserRole() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        if (demoUser.role) {
          return demoUser.role.toLowerCase();
        }
      } catch (e) {}
      
      // Fallback to currentRole if demoUser is missing
      var currentRole = localStorage.getItem('currentRole');
      if (currentRole) {
        return currentRole.toLowerCase();
      }
      
      return '';
    }
    
    // v1.6.22: Apply role-based restrictions to mode switcher
    // Analyst/Reviewer: locked to their role, cannot switch
    // Admin: full "God mode" - can switch between all roles (when Playground enabled)
    var roleRestrictionsApplied = false;
    
    // v1.6.25: Check if user is in demo session (came from /ui/demo/)
    function isDemoSession() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        return demoUser.isDemo === true;
      } catch (e) {
        return false;
      }
    }
    
    // v1.6.25: Handle sign out - redirect to appropriate landing page
    function handleSignOut(event) {
      event.preventDefault();
      var isDemo = isDemoSession();
      // Clear session
      localStorage.removeItem('currentRole');
      localStorage.removeItem('demoUser');
      // Redirect to appropriate page
      window.location.href = isDemo ? '/ui/demo/' : '/ui/landing/';
    }
    
    // v1.6.24: Check if playground mode is enabled for admin
    function isPlaygroundEnabled() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        // In demo mode, playground is always enabled
        if (demoUser.isDemo === true) return true;
        return demoUser.playgroundEnabled === true;
      } catch (e) {
        return false;
      }
    }
    
    // v1.6.24: Set playground mode for admin
    function setPlaygroundEnabledFlag(enabled) {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        demoUser.playgroundEnabled = enabled;
        localStorage.setItem('demoUser', JSON.stringify(demoUser));
      } catch (e) {
        console.error('[Playground] Failed to save state:', e);
      }
    }
    
    // v1.6.31: Get current user's display name for audit/export attribution
    function getCurrentUserName() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        // Priority: name > email prefix > role-based default
        if (demoUser.name && demoUser.name.trim()) {
          return demoUser.name.trim();
        }
        if (demoUser.email) {
          // Extract name from email (e.g., "john.doe@company.com" -> "John Doe")
          var emailPrefix = demoUser.email.split('@')[0];
          return emailPrefix.replace(/[._]/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
        }
        // Fallback to role-based name
        var role = getCurrentRole();
        return role.charAt(0).toUpperCase() + role.slice(1);
      } catch (e) {
        return 'Analyst';
      }
    }
    
    function applyRoleBasedModeRestrictions() {
      var loggedInRole = getLoggedInUserRole();
      var modeToggle = document.getElementById('mode-toggle-container');
      var lockedDisplayBottom = document.getElementById('locked-role-display');
      var lockedDisplayTop = document.getElementById('locked-role-display-top');
      var modeSectionBottom = document.querySelector('.nav-mode-section');
      var signOutLink = document.getElementById('sign-out-link');
      
      // Style the sign out link hover (only once)
      if (signOutLink && !roleRestrictionsApplied) {
        signOutLink.addEventListener('mouseenter', function() {
          this.style.color = '#fff';
        });
        signOutLink.addEventListener('mouseleave', function() {
          this.style.color = '#888';
        });
      }
      roleRestrictionsApplied = true;
      
      // v1.6.24: Admin with Playground enabled has full role switching access
      if (loggedInRole === 'admin' && isPlaygroundEnabled()) {
        if (modeToggle) modeToggle.style.display = 'flex';
        if (lockedDisplayBottom) lockedDisplayBottom.style.display = 'none';
        if (lockedDisplayTop) lockedDisplayTop.style.display = 'none';
        if (modeSectionBottom) modeSectionBottom.style.display = 'block';
        return;
      }
      
      // v1.6.24: Admin without Playground is locked to admin mode
      if (loggedInRole === 'admin') {
        if (modeSectionBottom) modeSectionBottom.style.display = 'none';
        if (lockedDisplayTop) {
          lockedDisplayTop.innerHTML = '<span style="opacity: 0.7;">Mode:</span> Admin';
          lockedDisplayTop.style.display = 'block';
        }
        if (currentMode !== 'admin') {
          setMode('admin');
        }
        return;
      }
      
      // Analyst and Reviewer are locked to their respective modes
      if (loggedInRole === 'analyst' || loggedInRole === 'reviewer') {
        // Hide the entire mode section at bottom (toggle buttons + bottom indicator)
        if (modeSectionBottom) modeSectionBottom.style.display = 'none';
        
        // Show locked role indicator at TOP (above navigation)
        if (lockedDisplayTop) {
          var roleLabel = loggedInRole.charAt(0).toUpperCase() + loggedInRole.slice(1);
          lockedDisplayTop.innerHTML = '<span style="opacity: 0.7;">Mode:</span> ' + roleLabel;
          lockedDisplayTop.style.display = 'block';
        }
        
        // Only force setMode if current mode doesn't match (avoid redundant reload)
        if (currentMode !== loggedInRole) {
          setMode(loggedInRole);
        }
        return;
      }
      
      // No logged-in user or unrecognized role - locked to analyst mode
      if (modeSectionBottom) modeSectionBottom.style.display = 'none';
      if (lockedDisplayTop) {
        lockedDisplayTop.innerHTML = '<span style="opacity: 0.7;">Mode:</span> Analyst';
        lockedDisplayTop.style.display = 'block';
      }
    }
    
    function setMode(mode) {
      const modes = ['analyst', 'reviewer', 'admin'];
      if (!modes.includes(mode)) mode = 'analyst';
      currentMode = mode;
      
      // Update triage page titles with role
      var roleLabel = mode === 'analyst' ? 'Analyst' : mode === 'reviewer' ? 'Reviewer' : 'Admin';
      var triageTitle = document.getElementById('triage-page-title');
      var verifierTitle = document.getElementById('verifier-triage-title');
      if (triageTitle) triageTitle.textContent = 'Triage - ' + roleLabel;
      if (verifierTitle) verifierTitle.textContent = 'Triage - ' + roleLabel;
      
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      const modeBtn = document.querySelector(`.mode-btn[data-mode="${mode}"]`);
      if (modeBtn) modeBtn.classList.add('active');
      
      // Toggle nav visibility based on mode using CSS classes
      const appLayout = document.querySelector('.app-layout');
      if (appLayout) {
        appLayout.classList.remove('mode-analyst', 'mode-reviewer', 'mode-admin');
        appLayout.classList.add(`mode-${mode}`);
      }

      // v1.5.3 Fix: Toggle Triage view visibility + ALWAYS reload queues from canonical store
      const analystContent = document.getElementById('analyst-triage-content');
      const verifierContent = document.getElementById('verifier-triage-content');
      if (analystContent && verifierContent) {
        if (mode === 'reviewer' || mode === 'admin') {
          analystContent.style.display = 'none';
          verifierContent.style.display = 'block';
          
          // v1.5.3 Fix: Always reload reviewer queue from canonical stores (not dependent on analyst SRR state)
          reloadReviewerQueuesFromStore();
          initReviewerFilters();
          renderVerifierTriage();
        } else {
          analystContent.style.display = 'block';
          verifierContent.style.display = 'none';
          
          // v1.5.4: Render analyst triage from PatchRequest store
          renderAnalystTriage();
        }
      }
      
      // v1.5.2: Toggle Grid reviewer mode
      var reviewerGridBar = document.getElementById('reviewer-grid-filter-bar');
      var analystGridBar = document.getElementById('analyst-grid-controls');
      if (reviewerGridBar) {
        reviewerGridBar.style.display = mode === 'reviewer' ? 'flex' : 'none';
      }
      if (analystGridBar) {
        // Keep analyst controls visible but disable inline editing for reviewers
      }
      
      // If downgrading from admin mode, teardown admin state
      if (mode !== 'admin') {
        teardownAdminState();
      }
      
      // v1.5.3 Fix: Reset SRR state when switching roles to prevent stale isReadOnly
      if (mode === 'analyst') {
        // Analyst: ensure editing is enabled
        srrState.isReadOnly = false;
        srrState.reviewerMode = false;
        // Reset reviewer SRR mode to restore analyst UI (tabs, chips, etc.)
        if (srrState.currentRecord) {
          resetReviewerSRRMode();
          renderSrrFields(srrState.currentRecord);
        }
      } else if (mode === 'reviewer' || mode === 'admin') {
        // Reviewer/Admin: set read-only mode
        srrState.isReadOnly = true;
        // Initialize reviewer SRR mode if SRR is open (tabs, panel state)
        if (srrState.currentRecord) {
          srrState.reviewerMode = true;
          initReviewerSRRMode();
          renderSrrFields(srrState.currentRecord);
        }
      }
      
      // v1.4.22: Navigate to role-specific default landing on role change
      var currentHash = window.location.hash.replace('#/', '') || '';
      var needsRedirect = false;
      
      // Check if current page is restricted for new role
      if (currentHash.includes('admin') && mode !== 'admin') {
        needsRedirect = true;
      } else if ((currentHash.includes('review') || currentHash === 'verifier-review') && mode === 'analyst') {
        needsRedirect = true;
      } else if (currentHash === 'patch' && mode !== 'analyst') {
        needsRedirect = true;
      }
      
      if (needsRedirect) {
        showToast('Role changed - redirecting to your dashboard', 'info');
        navigateToRoleDefault();
      }
      
      applyModeVisibility(mode);
      localStorage.setItem('viewer_mode_v10', mode);
    }

    // v1.4.22: Navigate to role-specific default landing page
    function navigateToRoleDefault() {
      if (currentMode === 'admin') {
        navigateTo('admin');
      } else {
        // Analyst and Reviewer both default to Triage
        navigateTo('triage');
      }
    }
    
    function applyModeVisibility(mode) {
      const revElements = document.querySelectorAll('[data-mode-reviewer]');
      const anlElements = document.querySelectorAll('[data-mode-analyst]');
      const admElements = document.querySelectorAll('[data-mode-admin]');
      
      revElements.forEach(el => {
        el.classList.toggle('mode-hidden', mode !== 'reviewer' && mode !== 'admin');
      });
      anlElements.forEach(el => {
        el.classList.toggle('mode-hidden', mode !== 'analyst');
      });
      admElements.forEach(el => {
        el.classList.toggle('mode-hidden', mode !== 'admin');
      });
    }

    // =========================================================================
    // ADMIN USER PANEL (v1.4.21) - Demo role assignment
    // =========================================================================
    
    var DEMO_USERS_KEY = 'orchestrate_demo_users';
    // v1.6.27: Reduced to 6 users, blank defaults for editing
    var DEFAULT_DEMO_USERS = [
      { id: 'user_001', name: '', email: '', role: 'analyst', status: 'active' },
      { id: 'user_002', name: '', email: '', role: 'analyst', status: 'active' },
      { id: 'user_003', name: '', email: '', role: 'reviewer', status: 'active' },
      { id: 'user_004', name: '', email: '', role: 'reviewer', status: 'active' },
      { id: 'user_005', name: '', email: '', role: 'admin', status: 'active' },
      { id: 'user_006', name: '', email: '', role: 'admin', status: 'active' }
    ];
    
    function getDemoUsers() {
      try {
        var stored = localStorage.getItem(DEMO_USERS_KEY);
        if (stored) {
          return JSON.parse(stored);
        }
      } catch (e) {
        console.log('[Users] Error loading demo users:', e);
      }
      return JSON.parse(JSON.stringify(DEFAULT_DEMO_USERS));
    }
    
    function saveDemoUsers(users) {
      try {
        localStorage.setItem(DEMO_USERS_KEY, JSON.stringify(users));
        localStorage.setItem(DEMO_USERS_KEY + '_updated', new Date().toISOString());
        return true;
      } catch (e) {
        console.log('[Users] Error saving demo users:', e);
        return false;
      }
    }
    
    function renderUsersTable() {
      var tbody = document.getElementById('users-table-body');
      if (!tbody) return;
      
      var users = getDemoUsers();
      var isPlayground = isDemoMode();
      var currentUserEmail = null;
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        currentUserEmail = demoUser.email;
      } catch (e) {}
      
      // v1.6.27: All fields are editable inputs
      var html = '';
      users.forEach(function(user, idx) {
        var isCurrentUser = currentUserEmail && user.email && currentUserEmail.toLowerCase() === user.email.toLowerCase();
        var inputStyle = 'padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; width: 100%; box-sizing: border-box;';
        html += '<tr style="' + (isCurrentUser ? 'background: #fffde7;' : '') + '">';
        
        // Name column - editable input
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0;">';
        html += '<div style="display: flex; align-items: center; gap: 8px;">';
        var displayName = user.name || 'User ' + (idx + 1);
        html += '<div style="width: 32px; height: 32px; border-radius: 50%; background: ' + getUserColor(displayName) + '; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.85em;">' + getInitials(displayName) + '</div>';
        html += '<input type="text" id="user-name-' + idx + '" value="' + (user.name || '') + '" placeholder="Enter name" style="' + inputStyle + ' width: 140px;">';
        html += '</div></td>';
        
        // Email column - editable input
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0;">';
        html += '<input type="email" id="user-email-' + idx + '" value="' + (user.email || '') + '" placeholder="user@domain.com" style="' + inputStyle + '">';
        html += '</td>';
        
        // Role column - dropdown
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0;">';
        html += '<select id="user-role-' + idx + '" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; cursor: pointer;">';
        html += '<option value="analyst"' + (user.role === 'analyst' ? ' selected' : '') + '>Analyst</option>';
        html += '<option value="reviewer"' + (user.role === 'reviewer' ? ' selected' : '') + '>Reviewer</option>';
        html += '<option value="admin"' + (user.role === 'admin' ? ' selected' : '') + '>Admin</option>';
        html += '</select>';
        html += '</td>';
        
        // Status column - dropdown
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0; text-align: center;">';
        html += '<select id="user-status-' + idx + '" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; cursor: pointer;">';
        html += '<option value="active"' + (user.status === 'active' ? ' selected' : '') + '>Active</option>';
        html += '<option value="pending"' + (user.status === 'pending' ? ' selected' : '') + '>Pending</option>';
        html += '<option value="disabled"' + (user.status === 'disabled' ? ' selected' : '') + '>Disabled</option>';
        html += '</select>';
        html += '</td>';
        
        // Actions column - Save button
        html += '<td style="padding: 12px 8px; border-bottom: 1px solid #e0e0e0; text-align: center;">';
        html += '<button onclick="saveUserRow(' + idx + ')" class="toolbar-btn" style="padding: 6px 14px; font-size: 0.85em;">Save</button>';
        html += '</td>';
        html += '</tr>';
      });
      
      tbody.innerHTML = html;
      
      var lastUpdated = localStorage.getItem(DEMO_USERS_KEY + '_updated');
      var updatedEl = document.getElementById('users-last-updated');
      if (updatedEl) {
        updatedEl.textContent = lastUpdated ? new Date(lastUpdated).toLocaleString() : 'Never';
      }
    }
    
    function getUserColor(name) {
      var colors = ['#1976d2', '#388e3c', '#7b1fa2', '#d32f2f', '#f57c00', '#0288d1', '#689f38', '#512da8'];
      var hash = 0;
      for (var i = 0; i < name.length; i++) {
        hash = name.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    }
    
    function getInitials(name) {
      // v1.6.27: Handle empty names gracefully
      if (!name || name.trim() === '') return '??';
      return name.split(' ').filter(function(n) { return n.length > 0; }).map(function(n) { return n[0]; }).join('').substring(0, 2).toUpperCase() || '??';
    }
    
    // v1.6.27: Save all user fields (name, email, role, status)
    function saveUserRow(idx) {
      var users = getDemoUsers();
      if (!users[idx]) return;
      
      // Get all field values
      var nameInput = document.getElementById('user-name-' + idx);
      var emailInput = document.getElementById('user-email-' + idx);
      var roleSelect = document.getElementById('user-role-' + idx);
      var statusSelect = document.getElementById('user-status-' + idx);
      
      var newName = nameInput ? nameInput.value.trim() : users[idx].name;
      var newEmail = emailInput ? emailInput.value.trim().toLowerCase() : users[idx].email;
      var newRole = roleSelect ? roleSelect.value : users[idx].role;
      var newStatus = statusSelect ? statusSelect.value : users[idx].status;
      
      // Check for changes
      var hasChanges = newName !== users[idx].name ||
                       newEmail !== users[idx].email ||
                       newRole !== users[idx].role ||
                       newStatus !== users[idx].status;
      
      if (!hasChanges) {
        showToast('No changes to save', 'info');
        return;
      }
      
      // Update user data
      var oldEmail = users[idx].email;
      users[idx].name = newName;
      users[idx].email = newEmail;
      users[idx].role = newRole;
      users[idx].status = newStatus;
      
      saveDemoUsers(users);
      
      // Re-render to update avatar initials
      renderUsersTable();
      
      // Check if this affects the currently logged-in user
      var currentUserEmail = null;
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        currentUserEmail = demoUser.email;
      } catch (e) {}
      
      if (currentUserEmail && (currentUserEmail.toLowerCase() === oldEmail.toLowerCase() || currentUserEmail.toLowerCase() === newEmail.toLowerCase())) {
        localStorage.setItem('currentRole', newRole);
        showToast('Your user updated. Reload to apply changes.', 'warning');
      } else {
        var displayName = newName || 'User ' + (idx + 1);
        showToast(displayName + ' saved successfully', 'success');
      }
      
      select.dataset.originalRole = newRole;
      renderUsersTable();
    }
    
    function resetDemoUsers() {
      if (!confirm('Reset all demo users to default roles?')) return;
      localStorage.removeItem(DEMO_USERS_KEY);
      localStorage.removeItem(DEMO_USERS_KEY + '_updated');
      renderUsersTable();
      showToast('Demo users reset to defaults', 'info');
    }
    
    // v1.6.16: Add User Modal Functions
    function isUserEditingAllowed() {
      // Only allow user creation/editing in Demo/Playground mode
      return isDemoMode();
    }
    
    function openAddUserModal() {
      if (!isUserEditingAllowed()) {
        showToast('User management is only available in Demo mode', 'error');
        return;
      }
      var modal = document.getElementById('add-user-modal');
      if (modal) {
        modal.classList.add('active');
        document.getElementById('add-user-name').value = '';
        document.getElementById('add-user-email').value = '';
        document.getElementById('add-user-role').value = 'analyst';
        document.getElementById('add-user-status').value = 'active';
        document.getElementById('add-user-division').value = '';
        document.getElementById('add-user-error').style.display = 'none';
        document.getElementById('add-user-name').focus();
      }
    }
    
    function closeAddUserModal() {
      var modal = document.getElementById('add-user-modal');
      if (modal) modal.classList.remove('active');
    }
    
    function validateEmail(email) {
      var re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return re.test(String(email).toLowerCase());
    }
    
    function submitAddUser() {
      var name = (document.getElementById('add-user-name').value || '').trim();
      var email = (document.getElementById('add-user-email').value || '').trim();
      var role = document.getElementById('add-user-role').value || 'analyst';
      var status = document.getElementById('add-user-status').value || 'active';
      var division = (document.getElementById('add-user-division').value || '').trim();
      var errorEl = document.getElementById('add-user-error');
      
      // Validation
      if (!name) {
        errorEl.textContent = 'Please enter a full name.';
        errorEl.style.display = 'block';
        return;
      }
      
      if (!email) {
        errorEl.textContent = 'Please enter an email address.';
        errorEl.style.display = 'block';
        return;
      }
      
      if (!validateEmail(email)) {
        errorEl.textContent = 'Please enter a valid email address.';
        errorEl.style.display = 'block';
        return;
      }
      
      // Duplicate check
      var users = getDemoUsers();
      var emailLower = email.toLowerCase();
      var duplicate = users.some(function(u) {
        return u.email.toLowerCase() === emailLower;
      });
      
      if (duplicate) {
        errorEl.textContent = 'User with this email already exists.';
        errorEl.style.display = 'block';
        return;
      }
      
      // Create new user with pre-provisioned flag
      var newUser = {
        id: 'user_' + Date.now(),
        name: name,
        email: email,
        role: role,
        status: status,
        division: division || null,
        preProvisioned: true,
        createdAt: new Date().toISOString()
      };
      
      users.push(newUser);
      saveDemoUsers(users);
      
      closeAddUserModal();
      renderUsersTable();
      showToast('User "' + name + '" added successfully', 'success');
      console.log('[Users] Added pre-provisioned user:', newUser.email, 'role:', newUser.role);
    }
    
    function deleteUser(idx) {
      if (!isUserEditingAllowed()) {
        showToast('User management is only available in Demo mode', 'error');
        return;
      }
      var users = getDemoUsers();
      if (!users[idx]) return;
      
      var user = users[idx];
      if (!user.preProvisioned) {
        showToast('Cannot delete default demo users', 'error');
        return;
      }
      
      if (!confirm('Delete user "' + user.name + '"?')) return;
      
      users.splice(idx, 1);
      saveDemoUsers(users);
      renderUsersTable();
      showToast('User deleted', 'info');
      console.log('[Users] Deleted user:', user.email);
    }
    
    // Admin Console Tab Switching
    var currentAdminTab = 'governance';
    function switchAdminTab(tabName) {
      const tabs = ['governance', 'users', 'patch-queue', 'config', 'inspector', 'standardizer', 'patch-console', 'evidence', 'unknown-cols'];
      if (!tabs.includes(tabName)) tabName = 'governance';
      
      // Render users table and update env mode UI when switching to users tab
      if (tabName === 'users') {
        renderUsersTable();
        updateEnvModeUI();
      }
      currentAdminTab = tabName;
      
      // Hide all tab panels
      document.querySelectorAll('.admin-tab-panel').forEach(panel => {
        panel.style.display = 'none';
      });
      
      // Show selected tab panel
      const targetPanel = document.getElementById('admin-tab-' + tabName);
      if (targetPanel) {
        targetPanel.style.display = 'block';
      }
      
      // Update tab button styles
      document.querySelectorAll('.admin-tab').forEach(btn => {
        if (btn.dataset.adminTab === tabName) {
          btn.style.background = '#1976d2';
          btn.style.color = 'white';
          btn.style.fontWeight = '600';
        } else {
          btn.style.background = '#f5f5f5';
          btn.style.color = '#666';
          btn.style.fontWeight = 'normal';
        }
      });
      
      // Render admin queue when tab is shown
      if (tabName === 'patch-queue') {
        renderAdminQueue();
      }
      
      console.log('[Admin] Switched to tab:', tabName);
    }
    
    // ========== ADMIN QUEUE RENDERING (v1.5.1) ==========
    function renderAdminQueue() {
      var items = getPatchQueue();
      var tbody = document.getElementById('patch-queue-tbody');
      if (!tbody) return;
      
      // Update count badge
      var countEl = document.getElementById('patch-queue-count');
      if (countEl) {
        countEl.textContent = items.length;
        countEl.style.display = items.length > 0 ? 'inline' : 'none';
      }
      
      if (items.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="padding: 20px; text-align: center; color: #888;">No patch requests pending Admin approval. Items appear here after Verifier approval.</td></tr>';
        return;
      }
      
      // Also check legacy verifierQueueState for additional data
      var legacyPayloads = {};
      if (typeof verifierQueueState !== 'undefined' && verifierQueueState.payloads) {
        verifierQueueState.payloads.forEach(function(p) {
          legacyPayloads[p.id] = p;
        });
      }
      
      tbody.innerHTML = items.map(function(item) {
        var legacy = legacyPayloads[item.id] || {};
        var typeLabel = item.artifact_type === 'blacklist' ? 'Blacklist' : 'Correction';
        var typeColor = item.artifact_type === 'blacklist' ? '#9c27b0' : '#2e7d32';
        var oldVal = item.old_value || legacy.old_value || 'â€”';
        var newVal = item.new_value || legacy.new_value || 'â€”';
        var comment = item.comment || legacy.comment || '';
        var time = item.created_at ? new Date(item.created_at).toLocaleString() : 'â€”';
        
        return '<tr style="border-bottom: 1px solid #eee; cursor: pointer;" onclick="openAdminReviewDetail(\'' + item.id + '\')" onmouseover="this.style.background=\'#f5f8ff\'" onmouseout="this.style.background=\'transparent\'">' +
          '<td style="padding:12px;"><span style="background:' + typeColor + '; color:white; padding:2px 6px; border-radius:10px; font-size:0.8em;">' + typeLabel + '</span></td>' +
          '<td style="padding:12px; font-weight:600;">' + (item.record_id || 'â€”') + '</td>' +
          '<td style="padding:12px; font-family:monospace;">' + (item.field_key || legacy.field || 'â€”') + '</td>' +
          '<td style="padding:12px;"><span style="color:#888; text-decoration:line-through;">' + oldVal + '</span> â†’ <span style="color:#2e7d32; font-weight:600;">' + newVal + '</span></td>' +
          '<td style="padding:12px; color:#666; max-width:200px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="' + comment + '">' + comment + '</td>' +
          '<td style="padding:12px; color:#888;">' + time + '</td>' +
          '<td style="padding:12px; display:flex; gap:6px;">' +
            '<button onclick="event.stopPropagation(); adminApproveItem(\'' + item.id + '\')" style="background:#2e7d32; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Finalize</button>' +
            '<button onclick="event.stopPropagation(); adminRejectItem(\'' + item.id + '\')" style="background:#d32f2f; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Reject</button>' +
          '</td>' +
        '</tr>';
      }).join('');
    }
    
    function openAdminReviewDetail(artifactId) {
      // Load the artifact and open Admin Review page (reuses verifier review layout)
      var artifact = getArtifact(artifactId);
      if (!artifact) {
        // Try legacy payload
        var payload = verifierQueueState.payloads.find(function(p) { return p.id === artifactId; });
        if (!payload) {
          showToast('Item not found', 'warning');
          return;
        }
        // Convert legacy to artifact-like object
        artifact = {
          id: payload.id,
          artifact_type: payload.type === 'blacklist' ? 'blacklist' : 'patch_request',
          record_id: payload.record_id,
          field_key: payload.field,
          old_value: payload.old_value,
          new_value: payload.new_value,
          comment: payload.comment,
          status: payload.status
        };
      }
      
      // Set state for admin review (reuse verifier review state)
      vrState.currentPatchId = artifactId;
      vrState.reviewState = 'Verifier_Approved';
      vrState.loadedPayload = artifact;
      
      navigateTo('admin-review/' + artifactId);
    }
    
    function adminApproveItem(artifactId) {
      updatePayloadStatus(artifactId, 'resolved');
      renderAdminQueue();
      showToast('Item finalized and resolved', 'success');
    }
    
    function adminRejectItem(artifactId) {
      updatePayloadStatus(artifactId, 'rejected');
      renderAdminQueue();
      showToast('Item rejected', 'warning');
    }
    
    function updatePatchQueueCount() {
      // v1.5.1: Badge count = only patch_request with status=sent_to_admin
      var patchRequests = listArtifacts({ artifact_type: 'patch_request', status: 'sent_to_admin' });
      var countEl = document.getElementById('patch-queue-count');
      if (countEl) {
        countEl.textContent = patchRequests.length;
        countEl.style.display = patchRequests.length > 0 ? 'inline' : 'none';
      }
    }

    // Teardown admin state when leaving admin mode
    function teardownAdminState() {
      // Reset admin tab to default
      currentAdminTab = 'governance';
      // Clear any admin-specific temp state
      console.log('[Admin] Tearing down admin state');
    }

    function updateUIForDataState() {
      const emptyQueueMsg = document.getElementById('empty-queue-message');
      const topToolbar = document.getElementById('top-toolbar');
      
      if (dataLoaded) {
        if (emptyQueueMsg) emptyQueueMsg.classList.add('hidden');
        if (topToolbar) topToolbar.style.display = 'flex';
      } else {
        if (emptyQueueMsg) emptyQueueMsg.classList.remove('hidden');
        if (topToolbar) topToolbar.style.display = 'none';
      }
      
      // Update session chip (handles status display)
      updateSessionChip();
      // Update queue counts
      updateQueueCounts();
      
      // Update data status chip in sidebar (v1.4.5)
      var dataStatusChip = document.getElementById('data-status-chip');
      if (dataStatusChip) {
        if (dataLoaded && allData.contractResults && allData.contractResults.length > 0) {
          dataStatusChip.textContent = allData.contractResults.length;
          dataStatusChip.classList.add('has-items');
        } else {
          dataStatusChip.textContent = '--';
          dataStatusChip.classList.remove('has-items');
        }
      }
    }

    function updateQueueCounts() {
      const results = allData.contractResults || [];
      const counts = {
        todo: 0,
        needs_review: 0,
        flagged: 0,
        blocked: 0,
        finalized: 0
      };
      
      results.forEach(r => {
        const status = (r.sf_contract_status || '').toLowerCase();
        if (status === 'needs_review') counts.needs_review++;
        else if (status === 'blocked') counts.blocked++;
        else if (status === 'ready') counts.finalized++;
        else counts.todo++;
      });
      
      // Total unfinished = todo + needs_review (the main work queue)
      counts.todo = results.length - counts.finalized;
      
      // Update count badges
      Object.entries(counts).forEach(([queue, count]) => {
        const el = document.getElementById(`queue-count-${queue}`);
        if (el) {
          el.textContent = count;
          el.classList.toggle('has-items', count > 0);
          el.classList.toggle('blocking', queue === 'blocked' && count > 0);
        }
      });
      
      // Update progress block in sidebar
      if (typeof updateProgressBlock === 'function') updateProgressBlock();
    }

    // Feature Flags (V1 defaults)
    var FEATURE_FLAGS = {
      connectors_enabled: false  // V1: offline-first, no connectors
    };
    
    // Data Source Panel - unified entry point (v1.5.0)
    // Always opens right-side panel (never modal) - per spec
    function openDataSourcePanel() {
      openDataSourceDrawer();
    }
    
    // Data Sources Drawer functions (now Upload Library)
    function openDataSourceDrawer() {
      document.getElementById('data-source-drawer').classList.add('active');
      renderUploadLibrary();
      updateDataSourceDrawerState();
    }
    
    function closeDataSourceDrawer() {
      document.getElementById('data-source-drawer').classList.remove('active');
    }
    
    // Stub for updateSessionUI (v1.5.7 - noop for now, could update session indicators)
    function updateSessionUI() {
      // Placeholder for session UI updates (e.g., user avatar, session indicators)
    }
    
    // Update Data Source drawer to show current state (v1.4.23 folder-based)
    function updateDataSourceDrawerState() {
      var drawer = document.getElementById('data-source-drawer');
      if (!drawer) return;
      
      var headerEl = drawer.querySelector('.drawer-header h3');
      var folderSection = document.getElementById('data-source-folder-section');
      var emptySection = document.getElementById('data-source-empty-section');
      var activeSection = document.getElementById('data-source-active-section');
      var uploadSection = document.getElementById('data-source-upload-section');
      var searchSection = document.getElementById('data-source-search-section');
      var libraryHeader = document.getElementById('data-source-library-header');
      var uploadLibrary = getUploadLibrary();
      // v1.4.23: Filter out sample dataset from library count
      var realLibrary = uploadLibrary.filter(function(e) { return e.dataset_id !== 'ds-sample' && e.source !== 'sample'; });
      var count = realLibrary.length;
      var hasData = dataLoaded && sessionState.status === 'loaded';
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      
      // Update header
      if (headerEl) {
        headerEl.textContent = 'Data Source';
      }
      
      // v1.4.23: Show folder section if folder is mapped
      if (folderSection) {
        if (mappedFolder) {
          folderSection.style.display = 'block';
          var folderNameEl = document.getElementById('connected-folder-name');
          var syncTimeEl = document.getElementById('folder-sync-time');
          if (folderNameEl) folderNameEl.textContent = mappedFolder;
          if (syncTimeEl) {
            var syncTime = localStorage.getItem('ingestion_folder_sync_time');
            syncTimeEl.textContent = 'Last sync: ' + (syncTime ? new Date(syncTime).toLocaleString() : 'Not synced yet');
          }
        } else {
          folderSection.style.display = 'none';
        }
      }
      
      // Show empty section when no folder mapped
      if (emptySection) {
        emptySection.style.display = mappedFolder ? 'none' : 'block';
      }
      
      // Show active dataset section when data loaded
      if (activeSection) {
        if (hasData) {
          activeSection.style.display = 'block';
          var nameEl = document.getElementById('active-dataset-name');
          var metaEl = document.getElementById('active-dataset-meta');
          if (nameEl) {
            nameEl.textContent = sessionState.fileName || sessionState.sourceType || 'Loaded Dataset';
          }
          if (metaEl) {
            var rowCount = allData.contractResults ? allData.contractResults.length : 0;
            var loadedAt = sessionState.loadedAt ? new Date(sessionState.loadedAt).toLocaleString() : 'â€”';
            metaEl.innerHTML = '<strong>' + rowCount + '</strong> records | Loaded: ' + loadedAt;
          }
        } else {
          activeSection.style.display = 'none';
        }
      }
      
      // Hide upload section (v1.4.23 - folder-based workflow)
      if (uploadSection) {
        uploadSection.style.display = 'none';
      }
      
      // Show search section when folder mapped (disabled)
      if (searchSection) {
        searchSection.style.display = mappedFolder ? 'block' : 'none';
      }
      
      // v1.4.24: Always show Drive Files header (static stub content in HTML)
      if (libraryHeader) {
        libraryHeader.style.display = mappedFolder ? 'block' : 'none';
      }
      
      // Close disconnect menu
      var disconnectMenu = document.getElementById('disconnect-menu');
      if (disconnectMenu) disconnectMenu.style.display = 'none';
    }
    
    // ========== FOLDER SELECTION (v1.4.24 - auto-mapped, no modal) ==========
    // Legacy no-op functions (folder is now auto-mapped from email)
    function openFolderSelectionModal() { /* Removed in v1.4.24 */ }
    function closeFolderSelectionModal() { /* Removed in v1.4.24 */ }
    function confirmFolderSelection() { /* Removed in v1.4.24 */ }
    
    function updateActiveDataSourceBar() {
      var nameEl = document.getElementById('active-data-source-name');
      var actionBtn = document.getElementById('active-data-source-action');
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      
      if (nameEl) {
        if (mappedFolder) {
          nameEl.textContent = 'Connected: ' + mappedFolder;
        } else if (dataLoaded && sessionState.fileName) {
          nameEl.textContent = sessionState.fileName;
        } else {
          nameEl.textContent = 'No folder connected';
        }
      }
      if (actionBtn) {
        actionBtn.textContent = mappedFolder ? 'Change' : 'Connect';
        actionBtn.onclick = mappedFolder ? openDataSourcePanel : openFolderSelectionModal;
      }
    }
    
    function updateLoaderFolderState() {
      var folderInfo = document.getElementById('loader-folder-info');
      var noFolder = document.getElementById('loader-no-folder');
      var folderName = document.getElementById('loader-folder-name');
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      
      if (mappedFolder) {
        if (folderInfo) folderInfo.style.display = 'block';
        if (noFolder) noFolder.style.display = 'none';
        if (folderName) folderName.textContent = mappedFolder;
      } else {
        if (folderInfo) folderInfo.style.display = 'none';
        if (noFolder) noFolder.style.display = 'block';
      }
    }
    
    // Toggle disconnect menu on ACTIVE badge click
    function toggleDisconnectMenu(event) {
      event.stopPropagation();
      var menu = document.getElementById('disconnect-menu');
      if (menu) {
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      }
    }
    
    // Data Source panel search stub - show "coming soon" toast
    var dataSourceSearchDebounce = null;
    function showDataSourceSearchToast() {
      if (dataSourceSearchDebounce) return;
      dataSourceSearchDebounce = setTimeout(function() {
        dataSourceSearchDebounce = null;
      }, 1500);
      showToast('Search coming soon (V2)', 'info');
    }
    
    // Disconnect active dataset (move to Saved)
    function disconnectActiveDataset() {
      var menu = document.getElementById('disconnect-menu');
      if (menu) menu.style.display = 'none';
      
      // Save current dataset to library before clearing
      if (dataLoaded && sessionState.status === 'loaded') {
        saveCurrentDatasetToLibrary();
      }
      
      // Clear active dataset
      dataLoaded = false;
      sessionState.status = 'not_loaded';
      sessionState.fileName = null;
      sessionState.loadedAt = null;
      sessionState.sourceType = null;
      allData = { contractResults: [], fieldActions: [], issues: [], summary: {} };
      workbook = { sheets: {}, order: [] };
      localStorage.removeItem('activeDatasetId');
      
      // Update UI
      updateDataSourceDrawerState();
      renderUploadLibrary();
      updateSessionUI();
      updateQueueCounts();
      showToast('Dataset disconnected', 'info');
    }
    
    // Save current dataset to upload library
    function saveCurrentDatasetToLibrary() {
      var library = getUploadLibrary();
      var entry = {
        id: 'ds_' + Date.now(),
        name: sessionState.fileName || 'Dataset',
        type: sessionState.sourceType || 'unknown',
        recordCount: allData.contractResults ? allData.contractResults.length : 0,
        savedAt: new Date().toISOString(),
        data: JSON.stringify(allData)
      };
      library.push(entry);
      localStorage.setItem('upload_library_v1', JSON.stringify(library));
    }
    
    // Handle file upload from drawer
    function handleDrawerFileUpload(input) {
      var file = input.files[0];
      if (!file) return;
      
      var ext = file.name.split('.').pop().toLowerCase();
      if (ext !== 'csv' && ext !== 'xlsx') {
        showToast('Unsupported file type. Use CSV or XLSX.', 'error');
        return;
      }
      
      // If active dataset exists, rotate it to Saved
      if (dataLoaded && sessionState.status === 'loaded') {
        saveCurrentDatasetToLibrary();
        showToast('Previous dataset moved to Saved', 'info');
      }
      
      // Process the file
      if (ext === 'csv') {
        processCSVFile(file);
      } else if (ext === 'xlsx') {
        processXLSXFile(file);
      }
      
      input.value = ''; // Reset input
    }
    
    // Process CSV file from drawer upload
    function processCSVFile(file) {
      var reader = new FileReader();
      reader.onload = function(e) {
        var text = e.target.result;
        var parsed = parseCSV(text);
        
        // parseCSV returns { headers: [], rows: [], delimiter: '' }
        if (!parsed || !parsed.rows || parsed.rows.length === 0) {
          showToast('Failed to parse CSV file or no data rows found', 'error');
          return;
        }
        
        var headers = parsed.headers;
        var records = parsed.rows; // Already in object format
        
        // Create a workbook-compatible structure
        var sheetName = file.name.replace(/\.(csv|xlsx)$/i, '');
        
        // v1.5.3 Fix: Set IDENTITY_CONTEXT.dataset_id before persisting
        if (!IDENTITY_CONTEXT.dataset_id) {
          IDENTITY_CONTEXT.dataset_id = sheetName;
        }
        
        // Clear any cached version of this sheet to treat re-import as fresh
        clearCachedDataset(sheetName);
        
        // Load into workbook (the correct global variable that getGridDataset reads from)
        workbook.sheets[sheetName] = {
          name: sheetName,
          headers: headers,
          rows: records
        };
        if (workbook.order.indexOf(sheetName) < 0) {
          workbook.order.push(sheetName);
        }
        workbook.activeSheet = sheetName;
        
        console.log('[Loader] CSV file loaded: ' + sheetName + ', ' + records.length + ' rows');
        
        // Update state
        dataLoaded = true;
        datasetRevision++; // v1.6.18: Bump revision for cache invalidation
        sessionState.status = 'loaded';
        sessionState.loadedAt = new Date().toISOString();
        sessionState.source = 'file:' + file.name;
        
        updateUIForDataState();
        closeDataSourceDrawer();
        
        // v1.5.3: Persist all records to canonical store
        persistAllRecordsToStore();
        
        // v1.6.0: Generate signals for dataset
        generateSignalsForDataset();
        
        showToast('CSV loaded: ' + records.length + ' records', 'success');
        navigateTo('grid');
      };
      reader.onerror = function() {
        showToast('Failed to read file', 'error');
      };
      reader.readAsText(file);
    }
    
    // Clear cached dataset by name to ensure fresh import
    function clearCachedDataset(sheetName) {
      // Remove from workbook if exists
      if (workbook && workbook.sheets && workbook.sheets[sheetName]) {
        delete workbook.sheets[sheetName];
        var idx = workbook.order.indexOf(sheetName);
        if (idx >= 0) workbook.order.splice(idx, 1);
        console.log('[Loader] Cleared cached dataset: ' + sheetName);
      }
      
      // Remove from upload library localStorage
      try {
        var library = JSON.parse(localStorage.getItem('upload_library_v1') || '[]');
        var filtered = library.filter(function(ds) { return ds.name !== sheetName; });
        if (filtered.length !== library.length) {
          localStorage.setItem('upload_library_v1', JSON.stringify(filtered));
          console.log('[Loader] Removed from upload library: ' + sheetName);
        }
      } catch (err) {
        console.warn('[Loader] Could not clear upload library cache', err);
      }
    }
    
    // Placeholder XLSX processing (V2 full implementation)
    function processXLSXFile(file) {
      showToast('XLSX support coming soon. Use CSV for now.', 'info');
    }
    
    // Close disconnect menu when clicking elsewhere
    document.addEventListener('click', function(e) {
      var menu = document.getElementById('disconnect-menu');
      if (menu && menu.style.display !== 'none') {
        var badge = document.getElementById('active-badge');
        if (!badge || !badge.contains(e.target)) {
          menu.style.display = 'none';
        }
      }
    });
    
    // Get stored datasets from localStorage
    function getUploadLibrary() {
      try {
        var stored = localStorage.getItem('upload_library_v1');
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        return [];
      }
    }
    
    // Loader Modal functions
    var loaderModalTriggerEl = null;
    
    function openLoaderModal() {
      loaderModalTriggerEl = document.activeElement;
      hideLoaderError(); // Clear any previous errors
      document.getElementById('loader-modal-overlay').classList.add('active');
      document.body.style.overflow = 'hidden';
      document.addEventListener('keydown', loaderModalKeyHandler);
      var closeBtn = document.getElementById('loader-modal-close-btn');
      if (closeBtn) closeBtn.focus();
    }
    
    function closeLoaderModal(event) {
      if (event && event.target && event.target.id !== 'loader-modal-overlay') return;
      document.getElementById('loader-modal-overlay').classList.remove('active');
      document.body.style.overflow = '';
      document.removeEventListener('keydown', loaderModalKeyHandler);
      if (loaderModalTriggerEl && loaderModalTriggerEl.focus) {
        loaderModalTriggerEl.focus();
      }
      loaderModalTriggerEl = null;
    }
    
    function loaderModalKeyHandler(e) {
      if (e.key === 'Escape') {
        closeLoaderModal();
      }
      if (e.key === 'Tab') {
        var modal = document.getElementById('loader-modal');
        var focusables = modal.querySelectorAll('button, input, select, textarea, a[href]');
        if (focusables.length === 0) return;
        var first = focusables[0];
        var last = focusables[focusables.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    }
    
    // v1.4.5: Legacy alias removed - use openLoaderModal() directly
    function openLoaderDrawer() { openLoaderModal(); }
    
    // v1.4.5: Stub admin functions to prevent console errors
    function inspectJSON(type) {
      console.log('[Admin] inspectJSON called for:', type);
      showToast('Inspector: ' + type + ' (not yet implemented)', 'info');
    }
    
    function loadAdminConfig() {
      console.log('[Admin] loadAdminConfig called');
      showToast('Load Config (not yet implemented)', 'info');
    }
    
    function copyInspectorJSON() {
      console.log('[Admin] copyInspectorJSON called');
      showToast('Copy JSON (not yet implemented)', 'info');
    }
    function closeLoaderDrawer() { closeLoaderModal(); }
    
    // ============================================================
    // GRID FUNCTIONS (v1.4.3)
    // ============================================================
    var currentDataset = null;
    var gridState = {
      filter: 'all',
      sheet: '',
      search: '',
      visibleColumns: [],
      allColumns: [],
      // v1.6.28: Column ordering and display preferences
      columnOrder: null,  // User-defined column order (null = use default)
      hiddenColumns: ['file_url', 'File_URL_c', '_row_index', '_originalIdx', '_sheetRowIndex', 'sheet']  // Columns hidden by default
    };
    
    // v1.6.28: Get Excel-style column letter (A, B, C, ... Z, AA, AB, etc.)
    function getColumnLetter(index) {
      var letter = '';
      while (index >= 0) {
        letter = String.fromCharCode(65 + (index % 26)) + letter;
        index = Math.floor(index / 26) - 1;
      }
      return letter;
    }
    
    // v1.6.28: Get preferred column order for display
    function getPreferredColumnOrder(columns) {
      // Priority columns to show first (account/identity fields)
      var priorityFields = [
        'File_Name_c', 'file_name', 
        'Account_Name_c', 'account_name',
        'Artist_Name_pka_or_dba_c', 'artist_name',
        'contract_key'
      ];
      
      var ordered = [];
      var remaining = columns.slice();
      
      // Add priority fields first (in order)
      priorityFields.forEach(function(field) {
        var idx = remaining.findIndex(function(c) { 
          return c.toLowerCase() === field.toLowerCase(); 
        });
        if (idx !== -1) {
          ordered.push(remaining.splice(idx, 1)[0]);
        }
      });
      
      // Add remaining fields
      ordered = ordered.concat(remaining);
      
      // Filter out hidden columns for display
      return ordered.filter(function(col) {
        return !gridState.hiddenColumns.includes(col);
      });
    }
    
    // v1.6.28: Column drag and drop handlers
    var draggedColumnIdx = null;
    
    function handleColumnDragStart(event) {
      draggedColumnIdx = parseInt(event.target.closest('th').dataset.colIdx);
      event.target.closest('th').style.opacity = '0.5';
      event.dataTransfer.effectAllowed = 'move';
    }
    
    function handleColumnDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
      var th = event.target.closest('th');
      if (th && th.dataset.colIdx !== undefined) {
        th.style.borderLeft = '3px solid #1976d2';
      }
    }
    
    function handleColumnDrop(event) {
      event.preventDefault();
      var targetTh = event.target.closest('th');
      if (!targetTh || draggedColumnIdx === null) return;
      
      var targetIdx = parseInt(targetTh.dataset.colIdx);
      if (targetIdx === draggedColumnIdx) return;
      
      // Reorder columns
      var cols = gridState.visibleColumns.slice();
      var draggedCol = cols.splice(draggedColumnIdx, 1)[0];
      cols.splice(targetIdx, 0, draggedCol);
      
      // Save new order
      gridState.visibleColumns = cols;
      gridState.columnOrder = cols.slice();
      
      // Re-render grid with new column order
      renderGrid();
      showToast('Column order updated', 'success');
    }
    
    function handleColumnDragEnd(event) {
      // Reset styling on all headers
      var headers = document.querySelectorAll('#grid-header-row th');
      headers.forEach(function(th) {
        th.style.opacity = '1';
        th.style.borderLeft = '';
      });
      draggedColumnIdx = null;
    }
    
    function getGridDataset() {
      // Priority: workbook > allData > localStorage cache
      if (workbook.order.length > 0) {
        // Build dataset from workbook
        // v1.4.15: Store _sheetRowIndex for stable click handler identity
        var records = [];
        workbook.order.forEach(function(sheetName) {
          var sheet = workbook.sheets[sheetName];
          if (sheet && sheet.rows) {
            sheet.rows.forEach(function(row, sheetRowIndex) {
              var r = Object.assign({}, row);
              r.sheet = sheetName;
              r._sheetRowIndex = sheetRowIndex;
              records.push(r);
            });
          }
        });
        currentDataset = { sf_contract_results: records };
        console.log('[Grid] Dataset from workbook:', workbook.order.length, 'sheets,', records.length, 'records');
        return currentDataset;
      }
      
      if (currentDataset) return currentDataset;
      
      var cached = localStorage.getItem('sample_dataset');
      if (cached) {
        try { currentDataset = JSON.parse(cached); } catch(e) {}
      }
      if (!currentDataset && window.allData && window.allData.contractResults) {
        currentDataset = { sf_contract_results: window.allData.contractResults };
      }
      return currentDataset;
    }

    function initGrid() {
      // Parse query params from URL
      var hash = window.location.hash;
      var queryMatch = hash.match(/\?(.+)$/);
      if (queryMatch) {
        var params = new URLSearchParams(queryMatch[1]);
        gridState.filter = params.get('f') || 'all';
        gridState.sheet = params.get('sheet') || '';
        gridState.search = params.get('q') || '';
      }
      
      // Apply state to UI
      var searchInput = document.getElementById('grid-search');
      if (searchInput) searchInput.value = gridState.search;
      
      var sheetSelector = document.getElementById('grid-sheet-selector');
      if (sheetSelector) sheetSelector.value = gridState.sheet;
      
      updateGridFilterChips();
      populateGridSheetSelector();
      renderGrid();
    }

    function populateGridSheetSelector() {
      var selector = document.getElementById('grid-sheet-selector');
      if (!selector) return;
      
      selector.innerHTML = '<option value="">All Sheets</option>';
      var sheets = [];
      
      // Priority: workbook.order > dataset extraction
      if (workbook.order.length > 0) {
        sheets = workbook.order.slice();
      } else {
        var ds = getGridDataset();
        if (ds && ds.sf_contract_results) {
          var sheetSet = new Set();
          ds.sf_contract_results.forEach(function(r) {
            if (r.sheet) sheetSet.add(r.sheet);
          });
          sheets = Array.from(sheetSet).sort();
        }
      }
      
      // v1.6.4: Filter out meta sheets (change_log, RFIs, etc.)
      sheets = sheets.filter(function(s) { return !isMetaSheet(s); });
      
      // Sort deterministically
      sheets.sort();
      
      // v1.6.31: Default to first sheet instead of "All Sheets"
      if (!gridState.sheet && sheets.length > 0) {
        gridState.sheet = sheets[0];
      }
      
      sheets.forEach(function(sheet) {
        var opt = document.createElement('option');
        opt.value = sheet;
        opt.textContent = sheet;
        if (sheet === gridState.sheet) opt.selected = true;
        selector.appendChild(opt);
      });
      
      // Attach change handler
      selector.onchange = function() {
        gridState.sheet = selector.value;
        updateGridURL();
        renderGrid();
      };
    }

    function setGridFilter(filter) {
      gridState.filter = filter;
      updateGridFilterChips();
      updateGridURL();
      renderGrid();
    }

    function updateGridFilterChips() {
      var chips = document.querySelectorAll('#grid-status-chips .filter-chip');
      chips.forEach(function(chip) {
        if (chip.dataset.filter === gridState.filter) {
          chip.classList.add('active');
        } else {
          chip.classList.remove('active');
        }
      });
    }

    function updateGridURL() {
      var params = [];
      if (gridState.filter && gridState.filter !== 'all') params.push('f=' + encodeURIComponent(gridState.filter));
      if (gridState.sheet) params.push('sheet=' + encodeURIComponent(gridState.sheet));
      if (gridState.search) params.push('q=' + encodeURIComponent(gridState.search));
      
      var newHash = '#/grid' + (params.length > 0 ? '?' + params.join('&') : '');
      if (window.location.hash !== newHash) {
        history.replaceState(null, '', newHash);
      }
    }

    function renderGrid() {
      var perfT = perfStart();
      // v1.6.11: Show/hide change legend based on whether change map is active
      var legendEl = document.getElementById('grid-change-legend');
      if (legendEl) {
        legendEl.style.display = changeMapStore.enabled ? 'block' : 'none';
      }
      
      // v1.4.4: Improved empty state handling
      if (!dataLoaded) {
        document.getElementById('grid-tbody').innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 40px; color: #666;">' +
          '<div style="margin-bottom: 10px;">No data loaded</div>' +
          '<button class="top-toolbar-btn" onclick="openDataSourcePanel()">Add Data Source</button>' +
          '</td></tr>';
        document.getElementById('grid-row-count').textContent = '0 records';
        return;
      }
      
      var ds = getGridDataset();
      if (!ds) {
        // Workbook exists but getGridDataset returned null
        var sheetName = workbook.activeSheet || 'unknown';
        document.getElementById('grid-tbody').innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 40px; color: #666;">' +
          '<div style="font-weight: 600; margin-bottom: 5px;">0 rows in sheet: ' + escapeHtml(sheetName) + '</div>' +
          '<div style="font-size: 0.85em; color: #888;">The selected sheet has no data rows.</div>' +
          '</td></tr>';
        document.getElementById('grid-row-count').textContent = '0 records in ' + sheetName;
        return;
      }
      var records = ds.sf_contract_results || [];
      
      // Apply filters: sheet -> status -> search
      var filtered = records;
      
      // Sheet filter
      if (gridState.sheet) {
        filtered = filtered.filter(function(r) { return r.sheet === gridState.sheet; });
      }
      
      // Status filter
      if (gridState.filter && gridState.filter !== 'all') {
        filtered = filtered.filter(function(r) {
          var status = (r.status || '').toLowerCase().replace(/\s+/g, '_');
          return status === gridState.filter;
        });
      }
      
      // Search filter
      if (gridState.search) {
        var searchLower = gridState.search.toLowerCase();
        filtered = filtered.filter(function(r) {
          return Object.values(r).some(function(v) {
            return String(v).toLowerCase().includes(searchLower);
          });
        });
      }
      
      // v1.5.2: Reviewer mode - apply division/status filters from reviewerFilterState
      if (currentMode === 'reviewer') {
        // Refresh prStatusMap for accurate filtering
        renderReviewerGrid();
        
        // Filter by division if set (uses matchesDivisionFilter for Unassigned support)
        if (reviewerFilterState.division) {
          filtered = filtered.filter(function(r) {
            return matchesDivisionFilter(r);
          });
        }
        
        // Filter by PR status if set - only show records with matching PatchRequest status
        // Guard: only apply if prStatusMap is populated (PR data loaded)
        if (reviewerFilterState.status && window.reviewerPrStatusMap && Object.keys(window.reviewerPrStatusMap).length > 0) {
          filtered = filtered.filter(function(r) {
            var recordId = r.record_id || r.contract_key || '';
            var prInfo = window.reviewerPrStatusMap[recordId];
            if (!prInfo) return false; // No PatchRequest = not shown when status filter active
            return prInfo.status === reviewerFilterState.status;
          });
        } else if (reviewerFilterState.status && (!window.reviewerPrStatusMap || Object.keys(window.reviewerPrStatusMap).length === 0)) {
          // PR data not yet loaded - skip status filter and show toast
          console.log('[Reviewer] Status filter skipped - no PatchRequest data loaded yet');
        }
      }
      
      // Deterministic sorting: severity -> identity triplet -> original index
      // v1.6.18: Seed _originalIdx in O(n) upfront on full records array (not on filtered)
      // This avoids O(n^2) indexOf calls in the loop
      var perfT2 = perfStart();
      for (var i = 0; i < records.length; i++) {
        if (records[i]._originalIdx === undefined) {
          records[i]._originalIdx = i;
        }
      }
      perfLog('Seed _originalIdx', perfT2);
      
      filtered.sort(function(a, b) {
        // Severity order: blocking > warning > info
        var sevOrder = { blocking: 0, warning: 1, info: 2 };
        var sevA = sevOrder[(a.severity || 'info').toLowerCase()] || 2;
        var sevB = sevOrder[(b.severity || 'info').toLowerCase()] || 2;
        if (sevA !== sevB) return sevA - sevB;
        
        // Identity triplet
        var ckA = String(a.contract_key || '');
        var ckB = String(b.contract_key || '');
        if (ckA !== ckB) return ckA.localeCompare(ckB);
        
        var fuA = String(a.file_url || '');
        var fuB = String(b.file_url || '');
        if (fuA !== fuB) return fuA.localeCompare(fuB);
        
        var fnA = String(a.file_name || '');
        var fnB = String(b.file_name || '');
        if (fnA !== fnB) return fnA.localeCompare(fnB);
        
        // Fallback to stable original row index
        return (a._originalIdx || 0) - (b._originalIdx || 0);
      });
      
      // Determine columns from workbook sheet or fallback to defaults (v1.4.3 GRID-01)
      var columns = ['contract_key', 'file_name', 'file_url', 'status', 'subtype'];
      var activeSheetName = gridState.sheet || workbook.activeSheet;
      
      if (activeSheetName && workbook.sheets[activeSheetName]) {
        // Use headers from the active sheet
        columns = workbook.sheets[activeSheetName].headers.filter(function(h) {
          return h && h !== '_row_index';
        });
        console.log('[Grid] Using columns from sheet:', activeSheetName, columns.length, 'columns');
      } else if (filtered.length > 0) {
        // Extract columns from first record
        var sampleRow = filtered[0];
        columns = Object.keys(sampleRow).filter(function(k) {
          return k !== '_row_index' && k !== '_originalIdx' && k !== 'sheet';
        });
      }
      
      // v1.6.28: Apply preferred column order for display
      gridState.allColumns = columns.slice();
      gridState.visibleColumns = getPreferredColumnOrder(columns);
      
      // Render header with Excel-style column letters (A, B, C...)
      var headerRow = document.getElementById('grid-header-row');
      var headerHtml = '<th class="row-index" style="background: #f0f0f0; font-weight: 600;">#</th>';
      gridState.visibleColumns.forEach(function(col, idx) {
        var colLetter = getColumnLetter(idx);
        var displayName = col.replace(/_c$/i, '').replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
        if (displayName.length > 20) displayName = displayName.substring(0, 18) + '...';
        headerHtml += '<th draggable="true" data-col-idx="' + idx + '" data-col-name="' + col + '" ' +
          'ondragstart="handleColumnDragStart(event)" ondragover="handleColumnDragOver(event)" ' +
          'ondrop="handleColumnDrop(event)" ondragend="handleColumnDragEnd(event)" ' +
          'style="cursor: grab; user-select: none; min-width: 80px;">' +
          '<div style="font-size: 0.7em; color: #888; margin-bottom: 2px; font-weight: 600;">' + colLetter + '</div>' +
          '<div title="' + col + '" style="font-size: 0.85em;">' + displayName + '</div></th>';
      });
      headerRow.innerHTML = headerHtml;
      
      // Render body with virtualization for large datasets
      var tbody = document.getElementById('grid-tbody');
      var VIRTUALIZE_THRESHOLD = 2000;
      var BATCH_SIZE = 100;
      
      if (filtered.length === 0) {
        cleanupGridVirtualization();
        tbody.innerHTML = '<tr><td colspan="' + (gridState.visibleColumns.length + 1) + '" style="text-align: center; padding: 40px; color: #666;">No records match filters</td></tr>';
      } else if (filtered.length > VIRTUALIZE_THRESHOLD) {
        // Virtualized rendering: render first batch and add scroll listener
        renderGridBatch(filtered, 0, BATCH_SIZE, gridState.visibleColumns, true);
        console.log('[Grid] Virtualized render enabled for ' + filtered.length + ' rows');
      } else {
        // Cleanup virtualization when not needed
        cleanupGridVirtualization();
        // v1.5.2: Pass sheet name and original row index to click handler
        // Also apply reviewer highlighting if in reviewer mode
        var isReviewerMode = currentMode === 'reviewer';
        // v1.6.18: Status key normalization
        var STATUS_KEYS = ['status', 'Status', 'sf_contract_status', 'review_state', 'Review_State'];
        
        tbody.innerHTML = filtered.map(function(r, idx) {
          // v1.6.18: Normalize status field lookup
          var statusVal = '';
          for (var si = 0; si < STATUS_KEYS.length; si++) {
            if (r[STATUS_KEYS[si]]) { statusVal = r[STATUS_KEYS[si]]; break; }
          }
          var statusClass = 'status-' + (statusVal || '').toLowerCase().replace(/\s+/g, '_');
          var sheetName = escapeHtml(r.sheet || '');
          var sheetRowIdx = r._sheetRowIndex !== undefined ? r._sheetRowIndex : idx;
          // v1.5.3 Fix: Check _identity.record_id as well for newly loaded rows
          // v1.6.2 Fix: Match signalStore recordId derivation (sheetName:idx fallback)
          var recordId = r.record_id || (r._identity && r._identity.record_id) || r.contract_key || '';
          if (!recordId) {
            recordId = sheetName + ':' + sheetRowIdx;
          }
          
          // v1.6.18: Build row classes with change highlighting
          var rowClasses = ['clickable'];
          var changeSummary = getRecordChangeSummary(recordId);
          if (changeSummary && changeSummary.total > 0) {
            if (changeSummary.by_type.added) rowClasses.push('row-added');
            else if (changeSummary.by_type.blacklist) rowClasses.push('row-removed');
            else if (changeSummary.by_type.removed) rowClasses.push('row-removed');
            else rowClasses.push('row-changed'); // correction, rfi, system_change
          }
          
          // v1.5.2: Reviewer mode - apply PR status highlighting
          var rowStyle = '';
          var clickHandler = 'openRowReviewDrawer(\'' + sheetName + '\',' + sheetRowIdx + ')';
          
          if (isReviewerMode) {
            var highlight = getReviewerRowHighlight(recordId);
            if (highlight) {
              rowStyle = 'background: ' + highlight.bg + '; border-left: 3px solid ' + highlight.border + ';';
            }
            // Route reviewer clicks through handleReviewerRowClick
            clickHandler = 'handleReviewerRowClick(\'' + escapeHtml(recordId) + '\', \'' + sheetName + '\', ' + sheetRowIdx + ')';
          }
          
          // v1.6.2: Add row badges for signal counts
          var rowBadgesHtml = renderRowBadges(recordId);
          
          return '<tr class="' + rowClasses.join(' ') + '" style="' + rowStyle + '" data-sheet-name="' + sheetName + '" data-record-index="' + sheetRowIdx + '" data-record-id="' + escapeHtml(recordId) + '" onclick="' + clickHandler + '">' +
            '<td class="row-index">' + (idx + 1) + rowBadgesHtml + '</td>' +
            gridState.visibleColumns.map(function(col) {
              var val = r[col];
              if (val === null || val === undefined) val = '';
              if (typeof val === 'object') val = JSON.stringify(val);
              
              // v1.6.28: Make File_Name a clickable link using file_url
              var isFileNameCol = col.toLowerCase().includes('file_name');
              var cellContent = String(val);
              if (isFileNameCol && val) {
                var fileUrl = r.file_url || r.File_URL_c || '';
                if (fileUrl) {
                  var shortName = val.length > 40 ? val.substring(0, 38) + '...' : val;
                  cellContent = '<a href="' + fileUrl + '" target="_blank" onclick="event.stopPropagation();" style="color: #1976d2; text-decoration: none; display: inline-flex; align-items: center; gap: 4px;"><span style="font-size: 0.9em;">&#128279;</span>' + shortName + '</a>';
                }
              }
              
              // v1.6.18: Apply status class for any status-variant column
              var isStatusCol = STATUS_KEYS.indexOf(col) >= 0 || col.toLowerCase() === 'status';
              var cellClass = isStatusCol ? statusClass : '';
              // v1.6.2: Apply signal-based cell coloring (v1.6.18: pass record)
              var cellStyle = getGridCellStyle(recordId, col, r);
              return '<td class="' + cellClass + ' truncated" style="' + cellStyle + '" title="' + String(val).replace(/"/g, '&quot;') + '">' + cellContent + '</td>';
            }).join('') +
            '</tr>';
        }).join('');
      }
      
      // Update footer
      document.getElementById('grid-row-count').textContent = filtered.length + ' of ' + records.length + ' records';
      
      var filterInfo = [];
      if (gridState.sheet) filterInfo.push('Sheet: ' + gridState.sheet);
      if (gridState.filter !== 'all') filterInfo.push('Status: ' + gridState.filter);
      if (gridState.search) filterInfo.push('Search: "' + gridState.search + '"');
      document.getElementById('grid-filter-info').textContent = filterInfo.join(' | ');
      
      // Update per-sheet mini stats
      updateGridSheetStats(records, filtered);
      perfLog('renderGrid', perfT);
    }
    
    function updateGridSheetStats(allRecords, filtered) {
      // Compute stats for visible/filtered records
      var rowCount = filtered.length;
      var readyCount = 0, reviewCount = 0, blockedCount = 0;
      
      // Use filtered set for counts to match current view
      filtered.forEach(function(r) {
        var status = (r.status || '').toLowerCase().replace(/\s+/g, '_');
        if (status === 'ready') readyCount++;
        else if (status === 'needs_review') reviewCount++;
        else if (status === 'blocked') blockedCount++;
      });
      
      // For total context, also compute from sheet-level (unfiltered by status/search)
      var sheetTotal = gridState.sheet ? 
        allRecords.filter(function(r) { return r.sheet === gridState.sheet; }).length : 
        allRecords.length;
      
      document.querySelector('#grid-stat-rows .stat-value').textContent = rowCount + ' / ' + sheetTotal;
      document.querySelector('#grid-stat-ready .stat-value').textContent = readyCount;
      document.querySelector('#grid-stat-review .stat-value').textContent = reviewCount;
      document.querySelector('#grid-stat-blocked .stat-value').textContent = blockedCount;
      
      // Unknown columns count (admin only - already gated by CSS admin-only-content)
      var unknownCount = getUnknownColumnsCount(gridState.sheet);
      document.querySelector('#grid-stat-unknown .stat-value').textContent = unknownCount;
    }
    
    function getUnknownColumnsCount(sheetName) {
      var unknownCols = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
      if (sheetName && unknownCols[sheetName]) {
        return unknownCols[sheetName].length;
      }
      var total = 0;
      Object.keys(unknownCols).forEach(function(sheet) {
        total += (unknownCols[sheet] || []).length;
      });
      return total;
    }

    function toggleColumnMenu() {
      var menu = document.getElementById('grid-column-menu');
      if (menu.style.display === 'none') {
        // Build checkboxes
        var container = document.getElementById('grid-column-checkboxes');
        container.innerHTML = gridState.allColumns.map(function(col) {
          var checked = gridState.visibleColumns.includes(col) ? 'checked' : '';
          return '<label style="display: block; margin: 4px 0; cursor: pointer;"><input type="checkbox" ' + checked + ' onchange="toggleGridColumn(\'' + col + '\', this.checked)"> ' + 
            col.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }) + '</label>';
        }).join('');
        menu.style.display = 'block';
      } else {
        menu.style.display = 'none';
      }
    }

    function toggleGridColumn(col, visible) {
      if (visible && !gridState.visibleColumns.includes(col)) {
        gridState.visibleColumns.push(col);
      } else if (!visible) {
        gridState.visibleColumns = gridState.visibleColumns.filter(function(c) { return c !== col; });
      }
      renderGrid();
    }

    // Single Row Review state (v1.4.18 - Field Inspector patch flow)
    var srrState = {
      currentRecord: null,
      currentRowId: null,
      currentSheetName: null,
      currentArtifactId: null,  // v1.5.1: Artifact ID for Verifier/Admin review context
      currentDatasetId: null,   // v1.5.1: Dataset ID for record lookup
      isReadOnly: false,        // v1.5.1: Read-only mode for Verifier/Admin
      originalValues: {},
      editedValues: {},
      proposedChanges: {},
      lockedFields: {},  // v1.4.18: Fields locked after edit commit
      fieldStates: {},   // v1.4.20: Per-field states: todo, verified, rfi, patched
      rfiField: null,    // Field being questioned in RFI (key, label, value)
      activeFilter: 'all',
      activeGroup: 'all',
      searchQuery: '',   // v1.4.18: Search filter
      editingField: null,
      docPage: 1,
      docTotalPages: 1,
      zoom: 1,
      patchType: 'correction',  // v1.4.19: correction | blacklist | rfi (now auto-driven)
      overrideEnabled: false,   // v1.4.19: Override toggle state
      patchDraft: { 
        patch_type: 'correction',
        observation_type: '',
        expected_type: '',
        justification: '',
        repro_type: '', repro_file: null,
        rfi_target: '',
        blacklist_category: '',
        blacklist_subject: '',
        changes: [], 
        status: 'Draft' 
      }
    };
    
    // v1.5.7: Rules Bundle Cache - loaded on app init
    var rulesBundleCache = {
      loaded: false,
      loading: false,
      fieldMeta: null,      // field_meta.json
      hingeGroups: null,    // hinge_groups.json
      sheetOrder: null      // sheet_order.json
    };
    
    // v1.5.7: Account Name field key aliases (match any of these)
    var ACCOUNT_NAME_ALIASES = ['Account_Name', 'Account_Name_c', 'account_name', 'account_name_c'];
    
    // v1.5.7: Load rules bundles from /rules/rules_bundle/
    async function loadRulesBundle() {
      if (rulesBundleCache.loaded || rulesBundleCache.loading) return;
      rulesBundleCache.loading = true;
      console.log('[RulesBundle] Loading bundles...');
      
      try {
        var [fieldMetaRes, hingeGroupsRes, sheetOrderRes, qaFlagsRes] = await Promise.all([
          fetch('/rules/rules_bundle/field_meta.json'),
          fetch('/rules/rules_bundle/hinge_groups.json'),
          fetch('/rules/rules_bundle/sheet_order.json'),
          fetch('/rules/rules_bundle/qa_flags.json')
        ]);
        
        if (fieldMetaRes.ok) {
          rulesBundleCache.fieldMeta = await fieldMetaRes.json();
          console.log('[RulesBundle] field_meta loaded:', rulesBundleCache.fieldMeta.fields?.length || 0, 'fields');
        }
        if (hingeGroupsRes.ok) {
          rulesBundleCache.hingeGroups = await hingeGroupsRes.json();
          console.log('[RulesBundle] hinge_groups loaded:', rulesBundleCache.hingeGroups.hinges?.length || 0, 'hinges');
        }
        if (sheetOrderRes.ok) {
          rulesBundleCache.sheetOrder = await sheetOrderRes.json();
          console.log('[RulesBundle] sheet_order loaded:', rulesBundleCache.sheetOrder.order?.length || 0, 'sheets');
        }
        if (qaFlagsRes.ok) {
          rulesBundleCache.qaFlags = await qaFlagsRes.json();
          console.log('[RulesBundle] qa_flags loaded:', rulesBundleCache.qaFlags.flags?.length || 0, 'flags');
        }
        
        rulesBundleCache.loaded = true;
        console.log('[RulesBundle] All bundles loaded successfully');
      } catch (err) {
        console.warn('[RulesBundle] Failed to load bundles:', err);
      } finally {
        rulesBundleCache.loading = false;
      }
    }
    
    // v1.5.7: Normalize field key for comparison (lowercase, no underscores/special chars)
    function normalizeFieldKey(fieldKey) {
      return fieldKey.toLowerCase().replace(/[^a-z0-9]/g, '');
    }
    
    // v1.5.7: Check if field key matches Account Name aliases (use ACCOUNT_NAME_ALIASES)
    function isAccountNameField(fieldKey) {
      var normalized = normalizeFieldKey(fieldKey);
      for (var i = 0; i < ACCOUNT_NAME_ALIASES.length; i++) {
        if (normalizeFieldKey(ACCOUNT_NAME_ALIASES[i]) === normalized) return true;
      }
      return false;
    }
    
    // v1.5.7: Get hinge info for a field (sheet + field_key -> hinge_level)
    // Uses normalized comparison for case-insensitive matching
    function getHingeInfo(sheetName, fieldKey) {
      if (!rulesBundleCache.hingeGroups || !rulesBundleCache.hingeGroups.hinges) return null;
      var hinges = rulesBundleCache.hingeGroups.hinges;
      var normalizedKey = normalizeFieldKey(fieldKey);
      for (var i = 0; i < hinges.length; i++) {
        var h = hinges[i];
        if (h.sheet === sheetName && normalizeFieldKey(h.field_key) === normalizedKey) {
          return { level: h.hinge_level, why: h.why_it_hinges };
        }
      }
      return null;
    }
    
    // v1.5.7: Get all hinges for a sheet, grouped by level (stores normalized keys for lookup)
    function getSheetHinges(sheetName) {
      if (!rulesBundleCache.hingeGroups || !rulesBundleCache.hingeGroups.hinges) return { primary: [], secondary: [], primaryNorm: [], secondaryNorm: [] };
      var hinges = rulesBundleCache.hingeGroups.hinges.filter(function(h) { return h.sheet === sheetName; });
      var primary = hinges.filter(function(h) { return h.hinge_level === 'Primary'; }).map(function(h) { return h.field_key; });
      var secondary = hinges.filter(function(h) { return h.hinge_level === 'Secondary'; }).map(function(h) { return h.field_key; });
      return {
        primary: primary,
        secondary: secondary,
        primaryNorm: primary.map(normalizeFieldKey),
        secondaryNorm: secondary.map(normalizeFieldKey)
      };
    }
    
    // v1.5.7: Order fields for Field Inspector using rules_bundle
    // Returns: { groups: [{name, fields: [key]}], orderedKeys: [key] }
    function orderFieldsForInspector(record, sheetName) {
      var allKeys = Object.keys(record).filter(function(k) { return !k.startsWith('_'); });
      
      // Get hinge configuration for this sheet
      var hinges = getSheetHinges(sheetName);
      
      // Partition fields into groups using normalized comparison
      var accountNameKey = null;
      var primaryKeys = [];
      var secondaryKeys = [];
      var otherKeys = [];
      
      allKeys.forEach(function(k) {
        var normKey = normalizeFieldKey(k);
        if (isAccountNameField(k)) {
          // Use first match (deterministic - iterate in record order)
          if (!accountNameKey) accountNameKey = k;
        } else if (hinges.primaryNorm.indexOf(normKey) >= 0) {
          primaryKeys.push(k);
        } else if (hinges.secondaryNorm.indexOf(normKey) >= 0) {
          secondaryKeys.push(k);
        } else {
          otherKeys.push(k);
        }
      });
      
      // Sort each group: primary/secondary by hinge order (normalized), other alphabetically
      primaryKeys.sort(function(a, b) { 
        return hinges.primaryNorm.indexOf(normalizeFieldKey(a)) - hinges.primaryNorm.indexOf(normalizeFieldKey(b)); 
      });
      secondaryKeys.sort(function(a, b) { 
        return hinges.secondaryNorm.indexOf(normalizeFieldKey(a)) - hinges.secondaryNorm.indexOf(normalizeFieldKey(b)); 
      });
      otherKeys.sort();
      
      // Build groups array for rendering with headers
      var groups = [];
      
      // Account Name is always first (own group, no header)
      if (accountNameKey) {
        groups.push({ name: null, fields: [accountNameKey] });
      }
      
      // v1.6.7: Simplified group names (removed internal "Hinge" terminology)
      // Primary Fields
      if (primaryKeys.length > 0) {
        groups.push({ name: 'Primary Fields', type: 'primary', fields: primaryKeys });
      }
      
      // Secondary Fields
      if (secondaryKeys.length > 0) {
        groups.push({ name: 'Secondary Fields', type: 'secondary', fields: secondaryKeys });
      }
      
      // Other Fields
      if (otherKeys.length > 0) {
        groups.push({ name: 'Other Fields', type: 'other', fields: otherKeys });
      }
      
      // Build flat ordered keys for filtering/counting
      var orderedKeys = [];
      if (accountNameKey) orderedKeys.push(accountNameKey);
      orderedKeys = orderedKeys.concat(primaryKeys).concat(secondaryKeys).concat(otherKeys);
      
      return { groups: groups, orderedKeys: orderedKeys };
    }
    
    // Legacy fallback for schema order (used when bundle not loaded)
    var SRR_SCHEMA_ORDER = [
      'contract_key',
      'file_name',
      'file_url',
      'subtype',
      'status',
      'notes',
      'artist',
      'label'
    ];
    
    // ========================================================================
    // SIGNAL ENGINE v1 (v1.6.0)
    // Deterministic cell-level signal generation from rules_bundle
    // ========================================================================
    
    // Signal storage: dataset.signals_by_cell[record_id][field_key] = [signals]
    var signalStore = {
      signals_by_cell: {},
      stats: { total: 0, by_type: {} }
    };
    
    // Mojibake detection regex (replacement characters, common encoding issues)
    var MOJIBAKE_REGEX = /[\ufffd\u0000-\u001f\uffff]|ÃƒÂ¢|ÃƒÂ©|ÃƒÂ¨|Ãƒ |ÃƒÂ¼|Ã¢â‚¬â„¢|Ã¢â‚¬Å“|Ã¢â‚¬|Ã‚ |Ã‚Â©|Ã‚Â®/;
    
    // Signal types
    var SIGNAL_TYPES = {
      MISSING_REQUIRED: { severity: 'error', source: 'field_meta' },
      PICKLIST_INVALID: { severity: 'warning', source: 'field_meta' },
      QA_FLAG: { severity: 'info', source: 'qa_flags' },
      MOJIBAKE_DETECTED: { severity: 'warning', source: 'encoding_check' }
    };
    
    // v1.6.2: Central Signal Style Map - single source of truth for UI and export
    var SIGNAL_STYLE_MAP = {
      PATCH_REQUIRED: { 
        label: 'Patch Required', 
        bg: '#e3f2fd',  // soft blue
        text: '#1565c0',
        priority: 1
      },
      SALESFORCE_LOGIC: { 
        label: 'Salesforce Logic', 
        bg: '#fff3e0',  // soft orange
        text: '#e65100',
        priority: 2
      },
      MANUAL_REVIEW: { 
        label: 'Manual Review', 
        bg: '#fffde7',  // soft yellow
        text: '#f57f17',
        priority: 3
      },
      SYSTEM_CHANGE: { 
        label: 'System Change', 
        bg: '#f5f5f5',  // neutral gray
        text: '#616161',
        priority: 4
      },
      CLEAN: { 
        label: 'Validated', 
        bg: '#e8f5e9',  // very light green
        text: '#2e7d32',
        priority: 5
      }
    };
    
    // Cell styles metadata for export alignment
    var cellStylesStore = {};
    
    // ========================================================================
    // CHANGE MAP ENGINE v1.6.8
    // Parses meta sheets (change logs, RFIs) to build cell-level change map
    // ========================================================================
    
    // Change map storage: changeMapStore[record_id][field_key] = { type, actor, ... }
    var changeMapStore = {
      changes_by_cell: {},  // record_id -> field_key -> change info
      stats: { total: 0, by_type: {} },
      enabled: false  // Only enabled for modified dataset
    };
    
    // Change type colors for grid highlighting
    // v1.6.11: Strong DataDash-style cell colors for modified dataset
    var CHANGE_TYPE_STYLES = {
      correction: { bg: '#CFE8FF', border: '#1976d2', label: 'Correction', emoji: 'âœï¸', priority: 3 },
      rfi: { bg: '#FFE7B3', border: '#ff9800', label: 'RFI', emoji: 'â“', priority: 2 },
      system_change: { bg: '#EFEFEF', border: '#9e9e9e', label: 'System Change', emoji: 'âš™ï¸', priority: 4 },
      blacklist: { bg: '#FFD6D6', border: '#e53935', label: 'Blacklist', emoji: 'ðŸš«', priority: 1 },
      verified: { bg: '#DDF5DD', border: '#4caf50', label: 'Verified', emoji: 'âœ“', priority: 5 }
    };
    
    // v1.6.11: Priority order for overlapping changes (lower = higher priority)
    // Blacklist (1) > RFI (2) > Correction (3) > System Change (4) > Verified (5)
    
    // Build change map from meta sheets in workbook
    function buildChangeMapFromMetaSheets() {
      var perfT = perfStart();
      changeMapStore.changes_by_cell = {};
      changeMapStore.stats = { total: 0, by_type: {} };
      changeMapStore.enabled = false;
      
      if (!workbook || !workbook.sheets) {
        console.log('[ChangeMap] No workbook data');
        return;
      }
      
      // Check if modified dataset (has meta sheets)
      var hasMetaSheets = Object.keys(workbook.sheets).some(function(name) {
        return name.endsWith('_change_log') || name === 'RFIs & Analyst Notes';
      });
      
      if (!hasMetaSheets) {
        console.log('[ChangeMap] No meta sheets found - baseline dataset');
        return;
      }
      
      changeMapStore.enabled = true;
      var changeCount = 0;
      
      // v1.6.14: Helper to infer field name by matching old_value against target row
      function inferFieldFromValue(targetSheet, rowIdx, oldValue, newValue) {
        if (!oldValue && !newValue) return null;
        
        var sheet = workbook.sheets[targetSheet];
        if (!sheet || !sheet.rows || !sheet.rows[rowIdx]) return null;
        
        var targetRow = sheet.rows[rowIdx];
        var oldValStr = String(oldValue || '').trim().toLowerCase();
        var newValStr = String(newValue || '').trim().toLowerCase();
        
        // Try to find a field whose value matches old_value or new_value
        for (var key in targetRow) {
          if (key === 'record_id' || key === 'sheet' || key === 'row_index') continue;
          var cellVal = String(targetRow[key] || '').trim().toLowerCase();
          
          // Match on old_value (before change) or new_value (current value after change)
          if (oldValStr && cellVal === oldValStr) return key;
          if (newValStr && cellVal === newValStr) return key;
        }
        return null;
      }
      
      // 1. Parse change log sheets (*_change_log)
      var inferredCount = 0;
      var rowLevelCount = 0;
      var changeLogSheets = Object.keys(workbook.sheets).filter(function(n) { return n.endsWith('_change_log'); });
      console.log('[ChangeMap] Found change_log sheets:', changeLogSheets);
      
      Object.keys(workbook.sheets).forEach(function(sheetName) {
        if (!sheetName.endsWith('_change_log')) return;
        
        var sheet = workbook.sheets[sheetName];
        var rows = sheet.rows || [];
        console.log('[ChangeMap] Processing', sheetName, 'with', rows.length, 'rows');
        
        rows.forEach(function(row) {
          if (!row) return;
          
          var targetSheet = row.sheet_name || '';
          var rowIndex = parseFloat(row.row_index);
          var fieldName = row.field_name || '';
          var category = (row.category || '').toUpperCase();
          var changedBy = (row.changed_by || '').toLowerCase();
          
          if (!targetSheet || isNaN(rowIndex)) return;
          
          var rowIdx = Math.floor(rowIndex);
          
          // v1.6.14: Try to infer field if not provided
          if (!fieldName) {
            fieldName = inferFieldFromValue(targetSheet, rowIdx, row.old_value, row.new_value);
            if (fieldName) inferredCount++;
          }
          
          // Determine change type
          var changeType = 'correction';  // default
          if (category === 'SYSTEM_CHANGE' || changedBy === 'system') {
            changeType = 'system_change';
          } else if (category === 'BLACKLIST' || row.blacklist_value) {
            changeType = 'blacklist';
          }
          
          // Build record ID (sheet:index)
          var recordId = targetSheet + ':' + rowIdx;
          
          // Store change
          if (!changeMapStore.changes_by_cell[recordId]) {
            changeMapStore.changes_by_cell[recordId] = {};
          }
          
          // v1.6.14: Use _row_level marker if no field could be determined
          var storeKey = fieldName || '_row_level';
          if (!fieldName) rowLevelCount++;
          
          // Don't overwrite more specific field entries with row-level
          if (storeKey === '_row_level' && Object.keys(changeMapStore.changes_by_cell[recordId]).length > 0) {
            // Already have field-level changes, skip row-level marker
            return;
          }
          
          changeMapStore.changes_by_cell[recordId][storeKey] = {
            type: changeType,
            actor: changedBy === 'system' ? 'System' : 'Analyst',
            old_value: row.old_value || '',
            new_value: row.new_value || '',
            reason: row.reason || '',
            timestamp: row.changed_at || '',
            source: 'change_log'
          };
          
          changeCount++;
          changeMapStore.stats.by_type[changeType] = (changeMapStore.stats.by_type[changeType] || 0) + 1;
        });
      });
      
      console.log('[ChangeMap] Field inference: inferred=' + inferredCount + ', row-level=' + rowLevelCount);
      
      // v1.6.14: Debug logging for first few records with changes
      var sampleRecords = Object.keys(changeMapStore.changes_by_cell).slice(0, 3);
      if (sampleRecords.length > 0) {
        console.log('[ChangeMap] Sample records:', sampleRecords);
        sampleRecords.forEach(function(recId) {
          var fields = Object.keys(changeMapStore.changes_by_cell[recId]);
          console.log('[ChangeMap]   ' + recId + ': fields=' + fields.join(', '));
        });
      }
      
      // 2. Parse RFIs & Analyst Notes
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      var rfiInferred = 0;
      var rfiRowLevel = 0;
      
      if (rfiSheet && rfiSheet.rows) {
        rfiSheet.rows.forEach(function(row) {
          if (!row) return;
          
          var targetSheet = row['Sheet'] || '';
          var rowNum = parseFloat(row['Row #']);
          var fieldName = row['Field Name'] || '';
          var noteType = (row['Note Type'] || '').toUpperCase();
          var detectedBy = (row['Detected By'] || '').toLowerCase();
          
          if (!targetSheet || isNaN(rowNum)) return;
          
          var rowIdx = Math.floor(rowNum);
          
          // v1.6.14: Try to infer field from Summary if not provided
          if (!fieldName && row['Summary']) {
            // Check if summary mentions a field name pattern
            var summaryLower = (row['Summary'] || '').toLowerCase();
            var sheet = workbook.sheets[targetSheet];
            if (sheet && sheet.rows && sheet.rows[rowIdx]) {
              var targetRow = sheet.rows[rowIdx];
              for (var key in targetRow) {
                if (key === 'record_id' || key === 'sheet' || key === 'row_index') continue;
                var keyLower = key.toLowerCase().replace(/_c$/, '').replace(/_/g, ' ');
                if (summaryLower.includes(keyLower) && keyLower.length > 3) {
                  fieldName = key;
                  rfiInferred++;
                  break;
                }
              }
            }
          }
          
          // Determine change type from RFI data
          var changeType = 'rfi';  // default for this sheet
          if (noteType === 'BLACKLIST') {
            changeType = 'blacklist';
          } else if (detectedBy === 'system' || (row['Category'] || '').includes('AUTO')) {
            changeType = 'system_change';
          }
          
          var recordId = targetSheet + ':' + rowIdx;
          
          if (!changeMapStore.changes_by_cell[recordId]) {
            changeMapStore.changes_by_cell[recordId] = {};
          }
          
          // v1.6.14: Use _row_level marker if no field could be determined
          var storeKey = fieldName || '_row_level';
          if (!fieldName) rfiRowLevel++;
          
          // Don't overwrite existing change log entries (they have more detail)
          if (!changeMapStore.changes_by_cell[recordId][storeKey]) {
            changeMapStore.changes_by_cell[recordId][storeKey] = {
              type: changeType,
              actor: detectedBy === 'system' ? 'System' : 'Analyst',
              summary: row['Summary'] || '',
              details: row['Details'] || '',
              timestamp: row['Timestamp'] || '',
              source: 'rfi_notes'
            };
            
            changeCount++;
            changeMapStore.stats.by_type[changeType] = (changeMapStore.stats.by_type[changeType] || 0) + 1;
          }
        });
      }
      
      console.log('[ChangeMap] RFI inference: inferred=' + rfiInferred + ', row-level=' + rfiRowLevel);
      
      changeMapStore.stats.total = changeCount;
      
      console.log('[ChangeMap] Built change map:', changeCount, 'changes across', 
        Object.keys(changeMapStore.changes_by_cell).length, 'records');
      console.log('[ChangeMap] By type:', JSON.stringify(changeMapStore.stats.by_type));
      perfLog('buildChangeMapFromMetaSheets', perfT);
    }
    
    // ========== v1.6.31: SEED PATCH REQUESTS FROM META SHEET ==========
    // Parse RFIs & Analyst Notes sheet and create patch requests for Analyst Patch Queue
    // v1.6.31: Track if already seeded for this dataset
    var _patchSeedDatasetId = null;
    
    function seedPatchRequestsFromMetaSheet() {
      if (!workbook || !workbook.sheets) return;
      
      // v1.6.31: Only seed once per dataset
      var currentDatasetId = ARTIFACT_STORE.current_dataset_id || IDENTITY_CONTEXT.dataset_id || 'ds_default';
      if (_patchSeedDatasetId === currentDatasetId) {
        console.log('[PatchSeed] Already seeded for dataset:', currentDatasetId);
        return { imported: 0, skipped: 0 };
      }
      
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      if (!rfiSheet || !rfiSheet.rows || rfiSheet.rows.length === 0) {
        console.log('[PatchSeed] No RFIs & Analyst Notes sheet found');
        return { imported: 0, skipped: 0 };
      }
      
      var imported = 0;
      var skipped = 0;
      
      // Build a set of existing request keys for deduplication
      var existingKeys = new Set();
      PATCH_REQUEST_STORE.list().forEach(function(pr) {
        if (pr.source === 'meta_sheet_import') {
          var key = (pr.dataset_id || '') + '|' + (pr.record_id || '') + '|' + (pr.field_name || '') + '|' + (pr.summary || '');
          existingKeys.add(key);
        }
      });
      
      rfiSheet.rows.forEach(function(row, rowIdx) {
        if (!row) return;
        
        // Only process rows where Note Type == "RFI"
        var noteType = (row['Note Type'] || '').trim().toUpperCase();
        if (noteType !== 'RFI') return;
        
        var targetSheet = row['Sheet'] || '';
        var rowNum = parseFloat(row['Row #']);
        var fieldName = row['Field Name'] || '';
        var summary = row['Summary'] || '';
        var details = row['Details'] || '';
        var timestamp = row['Timestamp'] || new Date().toISOString();
        var category = row['Category'] || '';
        var detectedBy = row['Detected By'] || 'Analyst';
        var status = row['Status'] || 'Submitted';
        var response = row['Response'] || '';
        
        // v1.6.31: Field name may be empty for RFI comments - extract from summary if possible
        if (!fieldName && summary) {
          var match = summary.match(/on\s+([A-Za-z0-9_]+)$/);
          if (match) fieldName = match[1];
          else fieldName = '(general)';
        }
        if (!targetSheet || isNaN(rowNum)) return;
        
        // Build record_id (sheet + row mapping)
        var recordId = targetSheet + ':' + Math.floor(rowNum);
        var datasetId = ARTIFACT_STORE.current_dataset_id || IDENTITY_CONTEXT.dataset_id || 'ds_default';
        
        // Deduplication key
        var dupeKey = datasetId + '|' + recordId + '|' + fieldName + '|' + summary;
        if (existingKeys.has(dupeKey)) {
          skipped++;
          return;
        }
        existingKeys.add(dupeKey);
        
        // Map status from meta sheet to patch request status
        var prStatus = 'Submitted';
        var statusLower = (status || '').toLowerCase().trim();
        if (statusLower === 'pending' || statusLower === 'open') prStatus = 'Submitted';
        else if (statusLower === 'resolved' || statusLower === 'closed') prStatus = 'Approved';
        else if (statusLower === 'rejected') prStatus = 'Rejected';
        else if (statusLower === 'draft') prStatus = 'Draft';
        else if (statusLower.includes('review')) prStatus = 'Pending_Review';
        
        // Generate request ID
        var requestId = 'pr_rfi_' + targetSheet.toLowerCase().replace(/\s+/g, '_') + '_r' + Math.floor(rowNum) + '_' + rowIdx;
        
        // Build description from Summary + Details
        var description = summary;
        if (details && details !== summary) {
          description += ' â€” ' + details;
        }
        
        // Create the patch request directly
        var now = timestamp || new Date().toISOString();
        var request = {
          request_id: requestId,
          version: 1,
          status: prStatus,
          artifact_type: 'rfi',
          type: 'rfi',
          source: 'meta_sheet_import',
          dataset_id: datasetId,
          record_id: recordId,
          sheet: targetSheet,
          field_name: fieldName,
          summary: summary,
          description: description,
          category: category,
          target: 'field_clarification',
          when: 'Field requires clarification',
          then: summary,
          because: details || summary,
          rationale: details || summary,
          analyst: detectedBy,
          submitted_by: detectedBy,
          response: response,
          created_at_utc: now,
          submitted_at_utc: now,
          updated_at_utc: now,
          thread: [],
          history: [
            {
              at_utc: now,
              actor: detectedBy,
              role: 'Analyst',
              action: 'Created from RFI sheet',
              from_status: null,
              to_status: prStatus
            }
          ]
        };
        
        // Add response as a thread item if present
        if (response && response.trim()) {
          request.thread.push({
            id: requestId + '_resp_0',
            timestamp: now,
            author: 'Reviewer',
            role: 'reviewer',
            content: response,
            type: 'response'
          });
        }
        
        // Save to store
        PATCH_REQUEST_STORE.save(request);
        imported++;
      });
      
      console.log('[PatchSeed] Imported', imported, 'RFIs to Patch Request store (', skipped, 'duplicates skipped)');
      
      // v1.6.31: Mark as seeded for this dataset
      _patchSeedDatasetId = currentDatasetId;
      
      return { imported: imported, skipped: skipped };
    }
    
    // ========== v1.6.9: SEED VERIFIER RFI QUEUE FROM META SHEET ==========
    // Parse RFIs & Analyst Notes sheet and populate Verifier queue with RFI items
    function seedVerifierRFIQueueFromMetaSheet() {
      if (!workbook || !workbook.sheets) return;
      
      // Guard: verifierQueueState may not be initialized yet (defined later in file)
      if (typeof verifierQueueState === 'undefined' || !verifierQueueState) {
        console.log('[RFI Seed] Skipped - verifierQueueState not yet initialized');
        return;
      }
      
      var rfiSheet = workbook.sheets['RFIs & Analyst Notes'];
      if (!rfiSheet || !rfiSheet.rows || rfiSheet.rows.length === 0) {
        console.log('[RFI Seed] No RFIs & Analyst Notes sheet found');
        return;
      }
      
      var rfiCount = 0;
      var skippedDupes = 0;
      var importedRFIs = [];
      
      // Build a set of existing RFI keys for deduplication
      var existingKeys = new Set();
      verifierQueueState.payloads.forEach(function(p) {
        if (p.type === 'rfi' && p.source === 'legacy_rfi_import') {
          var key = (p.dataset_id || '') + '|' + p.record_id + '|' + p.field + '|' + (p.summary || '');
          existingKeys.add(key);
        }
      });
      
      rfiSheet.rows.forEach(function(row, rowIdx) {
        if (!row) return;
        
        // Only process rows where Note Type == "RFI"
        var noteType = (row['Note Type'] || '').trim().toUpperCase();
        if (noteType !== 'RFI') return;
        
        var targetSheet = row['Sheet'] || '';
        var rowNum = parseFloat(row['Row #']);
        var fieldName = row['Field Name'] || '';
        var summary = row['Summary'] || '';
        var details = row['Details'] || '';
        var timestamp = row['Timestamp'] || new Date().toISOString();
        var category = row['Category'] || '';
        var detectedBy = row['Detected By'] || 'Analyst';
        var sourceUrl = row['Source URL'] || '';
        
        // v1.6.31: Field name may be empty for RFI comments - extract from summary if possible
        if (!fieldName && summary) {
          var match = summary.match(/on\s+([A-Za-z0-9_]+)$/);
          if (match) fieldName = match[1];
          else fieldName = '(general)';
        }
        if (!targetSheet || isNaN(rowNum)) return;
        
        // Build record_id (sheet + row mapping)
        var recordId = targetSheet + ':' + Math.floor(rowNum);
        var datasetId = ARTIFACT_STORE.current_dataset_id || 'ds_default';
        
        // Deduplication key: dataset_id + record_id + field_key + summary
        var dupeKey = datasetId + '|' + recordId + '|' + fieldName + '|' + summary;
        if (existingKeys.has(dupeKey)) {
          skippedDupes++;
          return;
        }
        existingKeys.add(dupeKey);
        
        // Generate artifact ID
        var artifactId = 'art_rfi_' + targetSheet.toLowerCase().replace(/\s+/g, '_') + '_' + Math.floor(rowNum) + '_' + Date.now() + '_' + rowIdx;
        
        // Build comment from Summary + Details
        var comment = summary;
        if (details && details !== summary) {
          comment += (comment ? ' â€” ' : '') + details;
        }
        
        // Create artifact
        var artifact = createArtifact({
          artifact_id: artifactId,
          dataset_id: datasetId,
          record_id: recordId,
          field_key: fieldName,
          artifact_type: 'rfi',
          status: 'pending_review',
          created_by_actor_id: 'user',
          created_by_role: 'analyst',
          sheet_name: targetSheet,
          body: {
            summary: summary,
            details: details,
            category: category,
            source_url: sourceUrl,
            detected_by: detectedBy,
            original_timestamp: timestamp
          }
        });
        
        // Create verifier queue payload
        var payload = {
          id: artifactId,
          artifact_id: artifactId,
          type: 'rfi',
          status: 'pending',
          record_id: recordId,
          dataset_id: datasetId,
          field: fieldName,
          old_value: '',
          new_value: '',
          comment: comment,
          summary: summary,
          details: details,
          timestamp: timestamp,
          source: 'legacy_rfi_import',
          sheet_name: targetSheet,
          row_number: Math.floor(rowNum),
          category: category,
          detected_by: detectedBy,
          source_url: sourceUrl
        };
        
        verifierQueueState.payloads.push(payload);
        importedRFIs.push(payload);
        rfiCount++;
        
        // Create audit log entry
        logArtifactEvent('RFI_IMPORTED', {
          artifact_id: artifactId,
          artifact_type: 'rfi',
          record_id: recordId,
          field_key: fieldName,
          action: 'RFI_IMPORTED',
          actor: 'user',
          source: 'legacy_rfi_import',
          summary: summary
        });
      });
      
      // Persist verifier queue to localStorage
      if (rfiCount > 0) {
        saveVerifierQueue();
      }
      
      console.log('[RFI Seed] Imported', rfiCount, 'RFIs to Verifier queue (', skippedDupes, 'duplicates skipped)');
      
      // Re-render verifier triage if visible
      if (typeof renderVerifierTriage === 'function') {
        renderVerifierTriage();
      }
      
      return { imported: rfiCount, skipped: skippedDupes, items: importedRFIs };
    }
    
    // Get change info for a specific cell
    // v1.6.14: Also check for row-level changes as fallback
    // v1.6.18: Helper to get record changes with key fallback
    function getRecordChangesWithFallback(recordId, record) {
      if (!changeMapStore.enabled) return null;
      
      // Try primary key first
      var recordChanges = changeMapStore.changes_by_cell[recordId];
      if (recordChanges) return recordChanges;
      
      // v1.6.18: Fallback 1 - try record_id if join triplet failed
      if (record && record.record_id && record.record_id !== recordId) {
        recordChanges = changeMapStore.changes_by_cell[record.record_id];
        if (recordChanges) return recordChanges;
      }
      
      // v1.6.18: Fallback 2 - try sheet:rowIndex format
      if (record && record.sheet && record._sheetRowIndex !== undefined) {
        var sheetRowKey = record.sheet + ':' + record._sheetRowIndex;
        if (sheetRowKey !== recordId) {
          recordChanges = changeMapStore.changes_by_cell[sheetRowKey];
          if (recordChanges) return recordChanges;
        }
      }
      
      return null;
    }
    
    function getCellChangeInfo(recordId, fieldKey, record) {
      if (!changeMapStore.enabled) return null;
      var recordChanges = getRecordChangesWithFallback(recordId, record);
      if (!recordChanges) return null;
      
      // Try exact match first
      if (recordChanges[fieldKey]) return recordChanges[fieldKey];
      
      // Try normalized match
      var normKey = normalizeFieldKey(fieldKey);
      for (var key in recordChanges) {
        if (key !== '_row_level' && normalizeFieldKey(key) === normKey) {
          return recordChanges[key];
        }
      }
      
      // v1.6.14: Fall back to row-level change if no field match found
      if (recordChanges['_row_level']) {
        return recordChanges['_row_level'];
      }
      
      return null;
    }
    
    // Get all changes for a record (for badge tooltips)
    // v1.6.18: Updated to use fallback key resolution
    function getRecordChanges(recordId, record) {
      if (!changeMapStore.enabled) return {};
      return getRecordChangesWithFallback(recordId, record) || {};
    }
    
    // Get change summary for a record (for badge display)
    function getRecordChangeSummary(recordId) {
      var changes = getRecordChanges(recordId);
      var fieldKeys = Object.keys(changes);
      if (fieldKeys.length === 0) return null;
      
      var byType = {};
      fieldKeys.forEach(function(key) {
        var type = changes[key].type || 'correction';
        byType[type] = (byType[type] || 0) + 1;
      });
      
      return {
        total: fieldKeys.length,
        by_type: byType,
        fields: fieldKeys
      };
    }
    
    // Build tooltip text from change summary
    function buildChangeTooltip(summary) {
      if (!summary || summary.total === 0) return '';
      
      var parts = [];
      var typeOrder = ['correction', 'rfi', 'system_change', 'blacklist'];
      typeOrder.forEach(function(type) {
        var count = summary.by_type[type];
        if (count) {
          var style = CHANGE_TYPE_STYLES[type];
          parts.push(style.label + ' (' + count + ')');
        }
      });
      
      return summary.total + ' change' + (summary.total > 1 ? 's' : '') + ': ' + parts.join(', ');
    }
    
    // Map raw signal types to style categories
    function mapSignalToStyleCategory(signalType, severity) {
      switch (signalType) {
        case 'MISSING_REQUIRED':
        case 'PICKLIST_INVALID':
          return 'PATCH_REQUIRED';
        case 'QA_FLAG':
          if (severity === 'error' || severity === 'warning') return 'SALESFORCE_LOGIC';
          return 'SYSTEM_CHANGE';
        case 'MOJIBAKE_DETECTED':
          return 'MANUAL_REVIEW';
        default:
          return 'CLEAN';
      }
    }
    
    // Get highest priority style for a cell (priority: 1=highest)
    function getCellHighestPriorityStyle(recordId, fieldKey) {
      var signals = getSignalsForCell(recordId, fieldKey);
      if (!signals || signals.length === 0) {
        return SIGNAL_STYLE_MAP.CLEAN;
      }
      
      var bestCategory = 'CLEAN';
      var bestPriority = 99;
      
      for (var i = 0; i < signals.length; i++) {
        var sig = signals[i];
        var category = mapSignalToStyleCategory(sig.signal_type, sig.severity);
        var style = SIGNAL_STYLE_MAP[category];
        if (style && style.priority < bestPriority) {
          bestPriority = style.priority;
          bestCategory = category;
        }
      }
      
      return SIGNAL_STYLE_MAP[bestCategory];
    }
    
    // Get row signal counts for badge display
    function getRowSignalCounts(recordId) {
      var recordSignals = signalStore.signals_by_cell[recordId];
      if (!recordSignals) return null;
      
      var counts = {
        PATCH_REQUIRED: 0,
        SALESFORCE_LOGIC: 0,
        MANUAL_REVIEW: 0,
        SYSTEM_CHANGE: 0
      };
      
      var fieldKeys = Object.keys(recordSignals);
      for (var i = 0; i < fieldKeys.length; i++) {
        var signals = recordSignals[fieldKeys[i]];
        for (var j = 0; j < signals.length; j++) {
          var category = mapSignalToStyleCategory(signals[j].signal_type, signals[j].severity);
          if (counts[category] !== undefined) {
            counts[category]++;
          }
        }
      }
      
      var total = counts.PATCH_REQUIRED + counts.SALESFORCE_LOGIC + counts.MANUAL_REVIEW + counts.SYSTEM_CHANGE;
      return total > 0 ? counts : null;
    }
    
    // Populate cell_styles metadata for export alignment
    function populateCellStyles() {
      cellStylesStore = {};
      var recordIds = Object.keys(signalStore.signals_by_cell);
      
      for (var i = 0; i < recordIds.length; i++) {
        var recordId = recordIds[i];
        var recordSignals = signalStore.signals_by_cell[recordId];
        cellStylesStore[recordId] = {};
        
        var fieldKeys = Object.keys(recordSignals);
        for (var j = 0; j < fieldKeys.length; j++) {
          var fieldKey = fieldKeys[j];
          var style = getCellHighestPriorityStyle(recordId, fieldKey);
          var signals = recordSignals[fieldKey];
          var category = 'CLEAN';
          
          if (signals.length > 0) {
            category = mapSignalToStyleCategory(signals[0].signal_type, signals[0].severity);
          }
          
          cellStylesStore[recordId][fieldKey] = {
            status: category,
            color: style.bg,
            label: style.label
          };
        }
      }
      
      console.log('[CellStyles] Populated metadata for', recordIds.length, 'records');
      return cellStylesStore;
    }
    
    // Get field metadata from rules bundle (normalized lookup)
    function getFieldMeta(sheetName, fieldKey) {
      if (!rulesBundleCache.fieldMeta || !rulesBundleCache.fieldMeta.fields) return null;
      var fields = rulesBundleCache.fieldMeta.fields;
      var normKey = normalizeFieldKey(fieldKey);
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        if (f.sheet === sheetName && normalizeFieldKey(f.field_key) === normKey) {
          return f;
        }
      }
      return null;
    }
    
    // Check if value is blank (empty, null, undefined, whitespace only, or common null-like strings)
    // v1.6.8: Expanded to include N/A, NULL, â€” to avoid false positive picklist signals
    var BLANK_VALUE_STRINGS = ['', 'n/a', 'na', 'null', 'â€”', '-', 'none', 'undefined'];
    function isBlankValue(value) {
      if (value === null || value === undefined) return true;
      if (typeof value === 'string') {
        var normalized = value.trim().toLowerCase();
        if (normalized === '' || BLANK_VALUE_STRINGS.indexOf(normalized) >= 0) return true;
      }
      return false;
    }
    
    // Generate signals for a single cell
    function generateCellSignals(record, fieldKey, sheetName, recordId) {
      var signals = [];
      var value = record[fieldKey];
      var meta = getFieldMeta(sheetName, fieldKey);
      
      // 1. MISSING_REQUIRED: Required field is blank
      if (meta && meta.requiredness === 'required' && isBlankValue(value)) {
        signals.push({
          signal_type: 'MISSING_REQUIRED',
          severity: 'error',
          message: 'Required field is blank',
          source: 'field_meta',
          field_label: meta.field_label || fieldKey
        });
      }
      
      // 2. PICKLIST_INVALID: Picklist field with value not in options
      // v1.6.8: Only validate if:
      //   a) Dataset has enable_picklist_validation = true
      //   b) Field is explicitly marked as picklist (meta.picklist === true)
      //   c) Field has defined options (meta.options.length > 0)
      //   d) Value is not blank/empty/null-like
      // v1.6.10: Only validate on primary data sheets, skip meta sheets
      var PRIMARY_DATA_SHEETS = ['Accounts', 'Opportunity', 'Financials', 'Catalog', 'Schedule', 'Schedule Catalog', 'V2 Add Ons', 'Contacts'];
      var isMetaSheet = sheetName && (sheetName.includes('_change_log') || sheetName === 'RFIs & Analyst Notes');
      var isPrimarySheet = PRIMARY_DATA_SHEETS.indexOf(sheetName) >= 0;
      
      if (meta && meta.picklist === true && meta.options && meta.options.length > 0 && !isBlankValue(value) && !isMetaSheet && isPrimarySheet) {
        // Check dataset-level toggle before validating
        if (isPicklistValidationEnabled()) {
          var valueStr = String(value).trim();
          // v1.6.10: Skip empty-like values (N/A, NULL, etc.)
          var emptyLikeValues = ['', 'n/a', 'null', 'none', '-'];
          if (emptyLikeValues.indexOf(valueStr.toLowerCase()) < 0) {
            var isValid = meta.options.some(function(opt) {
              return String(opt).trim().toLowerCase() === valueStr.toLowerCase();
            });
            if (!isValid) {
              signals.push({
                signal_type: 'PICKLIST_INVALID',
                severity: 'warning',
                message: 'Value "' + valueStr + '" not in picklist options',
                source: 'field_meta',
                field_label: meta.field_label || fieldKey,
                valid_options: meta.options.slice(0, 5) // Show first 5 options
              });
            }
          }
        }
      }
      
      // 3. MOJIBAKE_DETECTED: Encoding issues
      if (!isBlankValue(value) && typeof value === 'string' && MOJIBAKE_REGEX.test(value)) {
        signals.push({
          signal_type: 'MOJIBAKE_DETECTED',
          severity: 'warning',
          message: 'Possible encoding issue detected',
          source: 'encoding_check',
          field_label: meta ? meta.field_label : fieldKey
        });
      }
      
      // 4. QA_FLAG: Attach informational flags from qa_flags.json
      // For v1, attach as informational markers based on field metadata presence
      // v1.6.19: Disabled QA_FLAG generation for missing required (F-REQ-001) since
      // MISSING_REQUIRED signal already covers this case. This prevents duplicate
      // entries in triage queues (one in Patch Queue, one in SF Logic Flags).
      // QA_FLAG should only be used for flags that don't have a dedicated signal type.
      
      // Sort signals alphabetically by signal_type for determinism
      signals.sort(function(a, b) {
        return a.signal_type.localeCompare(b.signal_type);
      });
      
      return signals;
    }
    
    // v1.6.8: Check if picklist validation is enabled for current dataset
    function isPicklistValidationEnabled() {
      // Check for dataset-level flag (from loaded JSON)
      try {
        var storedDataset = localStorage.getItem(STORAGE_KEY_DATASET);
        if (storedDataset) {
          var dataset = JSON.parse(storedDataset);
          // Default to false if flag is missing (avoid noisy signals)
          if (dataset.enable_picklist_validation === true) return true;
          return false;
        }
      } catch (e) { /* ignore parse errors */ }
      return false;  // Default: disabled
    }
    
    // Generate signals for entire dataset
    function generateSignalsForDataset() {
      // Stage: Validating rules
      if (stagedLoader.startTime) stagedLoader.setStage('validating');
      
      if (!rulesBundleCache.loaded) {
        console.warn('[SignalEngine] Rules bundle not loaded, skipping signal generation');
        return;
      }
      
      // v1.6.8: Check dataset-level picklist validation toggle
      var picklistEnabled = isPicklistValidationEnabled();
      console.log('[SignalEngine] Picklist validation enabled:', picklistEnabled);
      
      // Reset signal store
      signalStore.signals_by_cell = {};
      signalStore.stats = { total: 0, by_type: {} };
      
      var recordCount = 0;
      var signalCount = 0;
      
      // Iterate over all sheets and records in workbook
      if (!workbook || !workbook.sheets) {
        console.warn('[SignalEngine] No workbook data to scan');
        return;
      }
      
      Object.keys(workbook.sheets).sort().forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        var rows = sheet ? sheet.rows : [];
        if (!rows || rows.length === 0) return;
        
        rows.forEach(function(row, idx) {
          if (!row) return;
          recordCount++;
          
          // Get record_id (from _identity or generate)
          var recordId = (row._identity && row._identity.record_id) 
            ? row._identity.record_id 
            : sheetName + ':' + idx;
          
          // Initialize cell map for this record
          if (!signalStore.signals_by_cell[recordId]) {
            signalStore.signals_by_cell[recordId] = {};
          }
          
          // Get all field keys (excluding internal fields)
          var fieldKeys = Object.keys(row).filter(function(k) {
            return !k.startsWith('_');
          }).sort(); // Sort for determinism
          
          // Generate signals for each cell
          fieldKeys.forEach(function(fieldKey) {
            var signals = generateCellSignals(row, fieldKey, sheetName, recordId);
            if (signals.length > 0) {
              signalStore.signals_by_cell[recordId][fieldKey] = signals;
              signalCount += signals.length;
              
              // Update stats
              signals.forEach(function(s) {
                signalStore.stats.by_type[s.signal_type] = (signalStore.stats.by_type[s.signal_type] || 0) + 1;
              });
            }
          });
        });
      });
      
      signalStore.stats.total = signalCount;
      
      // v1.6.0: Set dataset load timestamp for triage display
      datasetLoadTimestamp = new Date().toISOString();
      
      // Debug console log
      console.log('[SignalEngine] Scan complete:');
      console.log('  - Records scanned:', recordCount);
      console.log('  - Signals generated:', signalCount);
      
      // Top 5 signal types
      var typeEntries = Object.entries(signalStore.stats.by_type)
        .sort(function(a, b) { return b[1] - a[1]; })
        .slice(0, 5);
      
      if (typeEntries.length > 0) {
        console.log('  - Top signal types:');
        typeEntries.forEach(function(entry) {
          console.log('      ' + entry[0] + ': ' + entry[1]);
        });
      }
      
      // v1.6.2: Populate cell_styles metadata for export alignment
      populateCellStyles();
      
      // Stage: Building change map
      if (stagedLoader.startTime) stagedLoader.setStage('changemap');
      
      // v1.6.8: Build change map from meta sheets (for modified dataset)
      buildChangeMapFromMetaSheets();
      
      // Note: v1.6.9 RFI seeding is done in loadAnalystTriageFromStore after verifierQueueState is ready
      
      // v1.6.31: Update progress block after signals generated
      if (typeof updateProgressBlock === 'function') {
        updateProgressBlock();
      }
      
      return signalStore;
    }
    
    // Get signals for a specific record
    function getSignalsForRecord(recordId) {
      return signalStore.signals_by_cell[recordId] || {};
    }
    
    // Get signals for a specific cell
    function getSignalsForCell(recordId, fieldKey) {
      var recordSignals = signalStore.signals_by_cell[recordId];
      if (!recordSignals) return [];
      return recordSignals[fieldKey] || [];
    }
    
    // Get signal stats
    function getSignalStats() {
      return signalStore.stats;
    }
    
    // v1.6.2: Render row badges HTML for grid (v1.6.6: with detailed tooltips)
    // v1.6.8: Enhanced with change map integration for modified dataset
    function renderRowBadges(recordId) {
      // v1.6.8: Check change map first for modified dataset
      var changeSummary = getRecordChangeSummary(recordId);
      if (changeSummary && changeSummary.total > 0) {
        // Use change map for badge rendering
        var badges = [];
        var byType = changeSummary.by_type;
        
        if (byType.correction > 0) {
          var tooltip = buildChangeTooltip({ total: byType.correction, by_type: { correction: byType.correction } });
          badges.push('<span class="row-badge badge-patch" title="' + escapeHtml(tooltip) + '">' + byType.correction + '</span>');
        }
        if (byType.rfi > 0) {
          var tooltip = buildChangeTooltip({ total: byType.rfi, by_type: { rfi: byType.rfi } });
          badges.push('<span class="row-badge badge-sflogic" title="' + escapeHtml(tooltip) + '">' + byType.rfi + '</span>');
        }
        if (byType.system_change > 0) {
          var tooltip = buildChangeTooltip({ total: byType.system_change, by_type: { system_change: byType.system_change } });
          badges.push('<span class="row-badge badge-system" title="' + escapeHtml(tooltip) + '">' + byType.system_change + '</span>');
        }
        if (byType.blacklist > 0) {
          var tooltip = buildChangeTooltip({ total: byType.blacklist, by_type: { blacklist: byType.blacklist } });
          badges.push('<span class="row-badge badge-blacklist" title="' + escapeHtml(tooltip) + '">' + byType.blacklist + '</span>');
        }
        
        return badges.length > 0 ? '<div class="row-badges">' + badges.join('') + '</div>' : '';
      }
      
      // Fallback to signal-based badges (for baseline dataset)
      var counts = getRowSignalCounts(recordId);
      if (!counts) return '';
      
      // v1.6.6: Build patch summary for tooltip
      var summary = getRecordPatchSummary(recordId);
      
      var badges = [];
      if (counts.PATCH_REQUIRED > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'correction');
        badges.push('<span class="row-badge badge-patch">' + counts.PATCH_REQUIRED + tooltip + '</span>');
      }
      if (counts.SALESFORCE_LOGIC > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'rfi');
        badges.push('<span class="row-badge badge-sflogic">' + counts.SALESFORCE_LOGIC + tooltip + '</span>');
      }
      if (counts.MANUAL_REVIEW > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'correction');
        badges.push('<span class="row-badge badge-manual">' + counts.MANUAL_REVIEW + tooltip + '</span>');
      }
      if (counts.SYSTEM_CHANGE > 0) {
        var tooltip = buildPatchBadgeTooltip(summary, 'system_change');
        badges.push('<span class="row-badge badge-system">' + counts.SYSTEM_CHANGE + tooltip + '</span>');
      }
      
      return badges.length > 0 ? '<div class="row-badges">' + badges.join('') + '</div>' : '';
    }
    
    // v1.6.6: Build tooltip HTML for patch badge (filters by kind for specific badges)
    function buildPatchBadgeTooltip(summary, filterKind) {
      if (!summary || !summary.items || summary.items.length === 0) {
        return '<div class="patch-tooltip"><div class="patch-tooltip-title">No details</div></div>';
      }
      
      // Map signal categories to patch kinds for filtering
      var kindMatches = function(itemKind, targetKind) {
        if (targetKind === 'correction') return itemKind === 'correction';
        if (targetKind === 'rfi') return itemKind === 'rfi';
        if (targetKind === 'blacklist') return itemKind === 'blacklist';
        if (targetKind === 'system_change') return itemKind === 'system_change';
        return true; // show all if no filter
      };
      
      // Get unique fields for this badge type only
      var seenFields = {};
      var items = [];
      for (var i = 0; i < summary.items.length; i++) {
        var item = summary.items[i];
        // Filter by kind if specified
        if (filterKind && !kindMatches(item.patch_kind, filterKind)) continue;
        var fieldNorm = normalizeFieldKey(item.field_key);
        if (!seenFields[fieldNorm]) {
          seenFields[fieldNorm] = true;
          items.push(item);
        }
      }
      
      if (items.length === 0) {
        return '<div class="patch-tooltip"><div class="patch-tooltip-title">No details</div></div>';
      }
      
      // Limit to first 5 fields to keep tooltip readable
      var displayItems = items.slice(0, 5);
      var hasMore = items.length > 5;
      
      var html = '<div class="patch-tooltip">';
      html += '<div class="patch-tooltip-title">' + items.length + ' ' + formatPatchKind(filterKind || 'patch') + (items.length !== 1 ? 's' : '') + '</div>';
      
      for (var j = 0; j < displayItems.length; j++) {
        var item = displayItems[j];
        var chipClass = getPatchChipClass(item.patch_kind);
        var sourceLabel = item.source === 'legacy_diff_import' ? ' (legacy)' : '';
        html += '<div class="patch-tooltip-item">';
        html += '<span class="patch-tooltip-field">' + escapeHtml(item.field_key) + '</span>';
        html += '<span class="patch-chip ' + chipClass + '">' + formatPatchKind(item.patch_kind) + sourceLabel + '</span>';
        html += '</div>';
      }
      
      if (hasMore) {
        html += '<div class="patch-tooltip-item" style="color: #888; font-style: italic;">+' + (items.length - 5) + ' more...</div>';
      }
      
      html += '</div>';
      return html;
    }
    
    // v1.6.2: Get cell style for grid coloring
    // v1.6.8: Enhanced with change map highlighting for modified dataset
    // v1.6.18: Updated to pass record for key fallback
    function getGridCellStyle(recordId, fieldKey, record) {
      var normKey = normalizeFieldKey(fieldKey);
      
      // v1.6.8: Check change map first (for modified dataset)
      var changeInfo = getCellChangeInfo(recordId, fieldKey, record);
      if (changeInfo) {
        var changeStyle = CHANGE_TYPE_STYLES[changeInfo.type];
        if (changeStyle) {
          return 'background: ' + changeStyle.bg + '; border-left: 3px solid ' + changeStyle.border + ';';
        }
      }
      
      // Fallback to signal-based styling
      var style = getCellHighestPriorityStyle(recordId, normKey);
      if (!style || style.priority >= 5) return ''; // CLEAN cells get no extra coloring
      return 'background: ' + style.bg + ';';
    }
    
    // ========================================================================
    // END SIGNAL ENGINE
    // ========================================================================
    
    // ========================================================================
    // v1.6.6: PATCH SUMMARY ENGINE
    // ========================================================================
    
    // Store for per-record patch summaries
    var recordPatchSummaryStore = {};
    
    // Build patch summary for a record from signals
    function buildPatchSummaryForRecord(recordId) {
      var recordSignals = signalStore.signals_by_cell[recordId];
      if (!recordSignals) return null;
      
      var items = [];
      var fieldKeys = Object.keys(recordSignals);
      
      for (var i = 0; i < fieldKeys.length; i++) {
        var fieldKey = fieldKeys[i];
        var signals = recordSignals[fieldKey];
        
        for (var j = 0; j < signals.length; j++) {
          var sig = signals[j];
          var patchKind = 'correction';  // default
          var source = 'system_rule';
          var reasonCategory = sig.signal_type || 'unknown';
          
          // Determine patch_kind from signal type
          if (sig.signal_type === 'SYSTEM_CHANGE' || reasonCategory.indexOf('system') >= 0) {
            patchKind = 'system_change';
            source = 'system_rule';
          } else if (sig.signal_type === 'QA_FLAG' || reasonCategory.indexOf('qa') >= 0) {
            patchKind = 'rfi';
            source = 'qa_flag';
          } else if (sig.signal_type === 'BLACKLIST' || reasonCategory.indexOf('blacklist') >= 0) {
            patchKind = 'blacklist';
            source = 'system_rule';
          } else if (sig.signal_type === 'PICKLIST_INVALID' || sig.signal_type === 'MISSING_REQUIRED') {
            patchKind = 'correction';
            source = 'field_meta';
          } else if (sig.signal_type === 'LEGACY_DIFF' || reasonCategory.indexOf('legacy') >= 0) {
            patchKind = 'correction';
            source = 'legacy_diff_import';
          }
          
          items.push({
            field_key: fieldKey,
            patch_kind: patchKind,
            reason_category: reasonCategory,
            source: source,
            severity: sig.severity || 'info'
          });
        }
      }
      
      if (items.length === 0) return null;
      
      var summary = {
        record_id: recordId,
        total_count: items.length,
        items: items
      };
      
      recordPatchSummaryStore[recordId] = summary;
      return summary;
    }
    
    // Get or build patch summary for record
    function getRecordPatchSummary(recordId) {
      if (recordPatchSummaryStore[recordId]) {
        return recordPatchSummaryStore[recordId];
      }
      return buildPatchSummaryForRecord(recordId);
    }
    
    // Get patch summary item for a specific field
    // v1.6.8: Enhanced to use change map first (for modified dataset)
    function getFieldPatchInfo(recordId, fieldKey) {
      // v1.6.8: Check change map first (takes precedence for modified dataset)
      var changeInfo = getCellChangeInfo(recordId, fieldKey);
      if (changeInfo) {
        return {
          field_key: fieldKey,
          patch_kind: changeInfo.type,
          source: changeInfo.source,
          reason: changeInfo.reason || changeInfo.summary || '',
          actor: changeInfo.actor
        };
      }
      
      // Fallback to signal-based patch summary
      var summary = getRecordPatchSummary(recordId);
      if (!summary) return null;
      
      var normKey = normalizeFieldKey(fieldKey);
      for (var i = 0; i < summary.items.length; i++) {
        if (normalizeFieldKey(summary.items[i].field_key) === normKey) {
          return summary.items[i];
        }
      }
      return null;
    }
    
    // Format patch kind for display
    function formatPatchKind(kind) {
      var labels = {
        'correction': 'Correction',
        'rfi': 'RFI',
        'blacklist': 'Blacklist',
        'system_change': 'System Change'
      };
      return labels[kind] || kind;
    }
    
    // Get CSS class for patch chip
    function getPatchChipClass(kind) {
      var classes = {
        'correction': 'patch-chip-correction',
        'rfi': 'patch-chip-rfi',
        'blacklist': 'patch-chip-blacklist',
        'system_change': 'patch-chip-system'
      };
      return classes[kind] || 'patch-chip-correction';
    }
    
    // v1.6.6: Auto-scroll to first patch field in Field Inspector
    function srrScrollToFirstPatchField() {
      var container = document.getElementById('srr-field-list');
      if (!container) return;
      
      // Find first field card with has-patch class
      var firstPatchField = container.querySelector('.srr-field-card.has-patch');
      if (firstPatchField) {
        // Scroll smoothly into view
        firstPatchField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Briefly highlight with pulse
        firstPatchField.style.transition = 'box-shadow 0.3s ease';
        firstPatchField.style.boxShadow = '0 0 12px rgba(21, 101, 192, 0.5)';
        setTimeout(function() {
          firstPatchField.style.boxShadow = '';
        }, 1500);
        console.log('[SRR] Auto-scrolled to first patch field:', firstPatchField.dataset.field);
      }
    }
    
    // ========================================================================
    // END PATCH SUMMARY ENGINE
    // ========================================================================
    
    // Stub field groups (legacy - now derived from hinge_groups.json)
    var SRR_FIELD_GROUPS = {
      'identity': ['contract_key', 'file_name', 'file_url'],
      'metadata': ['artist', 'label', 'subtype'],
      'status': ['status', 'notes']
    };
    
    // Stub required fields (schema stub)
    var SRR_REQUIRED_FIELDS = ['contract_key', 'status'];
    
    // v1.6.5: Hidden fields - not shown in Field Inspector (analyst view)
    // File_Name_c: shown in header only, File_URL_c: internal for PDF loading
    // Metrics fields: internal change tracking, not for analyst review
    var SRR_HIDDEN_FIELDS = [
      'File_Name_c', 'File_URL_c',  // File fields
      'Change_Count', 'System_Change_Count', 'User_Change_Count',  // Exact keys
      'Row_Complete', 'Row_Verified'  // Status flags
    ];
    
    // v1.6.5: Pattern-based hidden field matching (for variations)
    var SRR_HIDDEN_PATTERNS = [
      'change count', 'system change', 'user change', 
      'row complete', 'row verified'
    ];
    
    // v1.6.5: Check if a field should be hidden from analyst view
    function isHiddenField(fieldKey) {
      if (!fieldKey) return false;
      // Check exact match
      if (SRR_HIDDEN_FIELDS.indexOf(fieldKey) >= 0) return true;
      // Check pattern match (case-insensitive)
      var keyLower = fieldKey.toLowerCase().replace(/_/g, ' ');
      return SRR_HIDDEN_PATTERNS.some(function(pattern) {
        return keyLower.indexOf(pattern) >= 0;
      });
    }

    // v1.4.15: Get active sheet name from grid state or sidebar
    function getActiveSheetName() {
      // Priority: gridState.sheet (set by sheet selector) > workbook first sheet
      if (typeof gridState !== 'undefined' && gridState.sheet) {
        return gridState.sheet;
      }
      // Fallback to sidebar selector if available
      var sidebarSelector = document.getElementById('sidebar-sheet-selector');
      if (sidebarSelector && sidebarSelector.value) {
        return sidebarSelector.value;
      }
      // Last resort: first sheet in workbook
      if (workbook.order.length > 0) {
        return workbook.order[0];
      }
      return null;
    }

    // v1.4.15: Resolve record from workbook using explicit sheetName and recordIndex
    // Signature: openRowReviewDrawer(sheetName, recordIndex)
    // Backwards compat: openRowReviewDrawer(rowId) for legacy callers
    // v1.4.16: Fixed rowId/undefined bug - always define rowId consistently
    function openRowReviewDrawer(arg1, arg2) {
      // v1.5.3 Fix: Determine read-only mode based on current role at render time
      // Analyst mode: always editable (isReadOnly = false)
      // Reviewer/Admin mode WITH artifact context: read-only (isReadOnly = true)
      // Reviewer/Admin mode WITHOUT artifact context (direct grid nav): still read-only for field inspector
      if (currentMode === 'analyst') {
        // Analyst can always edit - reset read-only state
        srrState.isReadOnly = false;
        srrState.reviewerMode = false;
      } else if (currentMode === 'reviewer' || currentMode === 'admin') {
        // Reviewer/Admin: read-only mode for field inspector
        // Only set reviewerMode if coming from artifact context (vrOpenSingleRowReview sets this)
        srrState.isReadOnly = true;
      } else {
        // Default to editable
        srrState.isReadOnly = false;
      }
      
      var record = null;
      var sheetName = null;
      var rowIndex = -1;
      var rowId = null;  // v1.4.16: Always define rowId
      
      // v1.4.15: New signature (sheetName, recordIndex) from grid click handlers
      if (typeof arg1 === 'string' && typeof arg2 === 'number') {
        sheetName = arg1;
        rowIndex = arg2;
        rowId = rowIndex;  // v1.4.16: Use rowIndex as rowId for new signature
        
        var sheet = workbook.sheets[sheetName];
        if (sheet && sheet.rows && rowIndex >= 0 && rowIndex < sheet.rows.length) {
          record = sheet.rows[rowIndex];
        }
        
        if (!record) {
          // Log failure with diagnostic context
          console.log('[SRR_OPEN_FAIL]', JSON.stringify({
            sheetName: sheetName,
            recordIndex: rowIndex,
            availableSheets: workbook.order,
            sheetRowCount: sheet ? (sheet.rows ? sheet.rows.length : 0) : 0
          }));
          showToast('Record not found: ' + sheetName + '[' + rowIndex + ']', 'warning');
          return;
        }
      } else {
        // Legacy signature: openRowReviewDrawer(rowId) - for backwards compatibility
        rowId = arg1;  // v1.4.16: Use existing rowId variable (no redeclaration)
        rowIndex = parseInt(rowId, 10);
        
        if (workbook.order.length > 0) {
          sheetName = getActiveSheetName();
          if (!sheetName) {
            showToast('No active sheet selected', 'warning');
            return;
          }
          var sheet = workbook.sheets[sheetName];
          
          if (sheet && sheet.rows) {
            var foundIdx = sheet.rows.findIndex(function(r) {
              return String(r.contract_key) === String(rowId);
            });
            
            if (foundIdx >= 0) {
              record = sheet.rows[foundIdx];
              rowIndex = foundIdx;
            } else if (!isNaN(rowIndex) && rowIndex >= 0 && rowIndex < sheet.rows.length) {
              record = sheet.rows[rowIndex];
            }
          }
        } else {
          var ds = getGridDataset();
          if (ds && ds.sf_contract_results) {
            record = ds.sf_contract_results.find(function(r) {
              return String(r.contract_key) === String(rowId);
            });
            if (!record && !isNaN(rowIndex) && rowIndex >= 0 && rowIndex < ds.sf_contract_results.length) {
              record = ds.sf_contract_results[rowIndex];
            }
            sheetName = record ? (record.sheet || 'unknown') : 'unknown';
          }
        }
      }
      
      if (!record) {
        console.log('[SRR_OPEN_FAIL] Record resolution failed:', { arg1: arg1, arg2: arg2, sheetName: sheetName, rowIndex: rowIndex });
        showToast('Record not found', 'warning');
        return;
      }
      
      // Build record identity for logging/caching
      var recordKey = record.contract_key || (sheetName + ':' + rowIndex);
      
      // Store in state with extended context
      srrState.currentRecord = record;
      srrState.currentRowId = rowId;
      srrState.currentSheetName = sheetName;
      srrState.currentRowIndex = rowIndex;
      srrState.currentRecordKey = recordKey;
      
      // v1.4.15: Single structured log per SRR open (use field resolver for Salesforce-style columns)
      var fileUrl = srrResolveFieldValue(record, 'file_url');
      var fileName = srrResolveFieldValue(record, 'file_name');
      console.log('[SRR_OPEN]', JSON.stringify({
        sheetName: sheetName,
        rowIndex: rowIndex,
        recordKey: recordKey,
        file_name: fileName,
        file_url: fileUrl.length > 60 ? fileUrl.substring(0, 60) + '...' : fileUrl,
        availableKeys: Object.keys(record).slice(0, 8)
      }));
      
      // v1.4.16: Validate rowId before navigation (prevent row/undefined)
      if (rowId === null || rowId === undefined || (typeof rowId === 'number' && isNaN(rowId))) {
        console.warn('[SRR] Invalid rowId, using rowIndex:', rowIndex);
        rowId = rowIndex;
      }
      
      // Navigate to page and render
      navigateTo('row');
      renderSingleRowReview(record, rowId);
      
      // Update URL without triggering hashchange loop
      var hashTarget = '#/row/' + rowId;
      if (window.location.hash !== hashTarget) {
        history.pushState(null, '', hashTarget);
      }
    }
    
    function renderSingleRowReview(record, rowId) {
      // Update top bar
      document.getElementById('srr-record-id').textContent = record.contract_key || rowId || 'â€”';
      var stateBadge = document.getElementById('srr-state-badge');
      var status = (record.status || 'unknown').toLowerCase().replace(/\s+/g, '_');
      stateBadge.textContent = record.status || 'Unknown';
      stateBadge.className = 'srr-state-badge ' + status;
      
      // v1.6.7: Update footer with file name (moved from page header)
      var fileName = srrResolveFieldValue(record, 'file_name');
      var fileNameEl = document.getElementById('srr-file-name');
      if (fileNameEl) {
        if (fileName) {
          // v1.6.7: Format file name for display - remove underscores, convert .pdf to (PDF)
          var formattedName = fileName
            .replace(/_/g, ' ')  // Replace underscores with spaces
            .replace(/\.pdf$/i, '')  // Remove .pdf extension (case insensitive)
            .trim();
          // Add (PDF) suffix if original had .pdf extension
          if (/\.pdf$/i.test(fileName)) {
            formattedName += ' (PDF)';
          }
          fileNameEl.textContent = formattedName;
          fileNameEl.title = fileName;  // Original file name on hover
        } else {
          fileNameEl.textContent = '';
          fileNameEl.title = '';
        }
      }
      
      // Store original values for edit tracking
      srrState.originalValues = {};
      Object.keys(record).forEach(function(k) {
        if (!k.startsWith('_')) {
          srrState.originalValues[k] = record[k];
        }
      });
      
      // Reset edit state for new record
      srrState.editedValues = {};
      srrState.proposedChanges = {};
      srrState.lockedFields = {};  // v1.4.18: Reset locked fields
      srrState.editingField = null;
      srrState.activeFilter = 'todo';  // Default to To Do queue
      srrState.activeGroup = 'all';
      srrState.searchQuery = '';  // v1.4.18: Reset search
      
      // Reset filter chips - default to To Do
      document.querySelectorAll('.srr-filter-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.filter === 'todo') chip.classList.add('active');
      });
      
      // v1.4.18: Reset search input
      var searchInput = document.getElementById('srr-field-search');
      if (searchInput) searchInput.value = '';
      
      // Render Field Inspector
      renderSrrFields(record);
      
      // v1.6.6: Auto-scroll to first patch field if any
      setTimeout(function() {
        srrScrollToFirstPatchField();
      }, 100);
      
      // v1.4.19: Reset patch type and override state
      srrState.patchType = srrState.patchDraft.patch_type || 'correction';
      srrState.overrideEnabled = srrState.patchDraft.override_enabled || false;
      
      // Update patch type chips
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === srrState.patchType) chip.classList.add('active');
      });
      var overrideToggle = document.getElementById('srr-override-toggle');
      if (overrideToggle) overrideToggle.classList.toggle('active', srrState.overrideEnabled);
      
      // v1.4.19: Load Evidence Pack (simplified structure)
      document.getElementById('srr-observation-type').value = srrState.patchDraft.observation_type || '';
      document.getElementById('srr-expected-type').value = srrState.patchDraft.expected_type || '';
      document.getElementById('srr-justification').value = srrState.patchDraft.justification || '';
      document.getElementById('srr-repro-type').value = srrState.patchDraft.repro_type || '';
      // RFI target stub - no input to restore (coming soon)
      
      // v1.4.18: Render Patch Editor
      srrRenderPatchEditor();
      
      // v1.4.19: Update form sections based on patch type
      srrUpdatePatchFormSections();
      
      // Load PDF for this record (v1.4.10)
      srrLoadPdfForRecord(record);
      
      // v1.5.3: Initialize Reviewer SRR mode if applicable
      if (srrState.reviewerMode) {
        initReviewerSRRMode();
      }
    }
    
    function renderSrrFields(record) {
      var container = document.getElementById('srr-field-list');
      if (!record) {
        container.innerHTML = '<div class="srr-empty-state">No fields loaded</div>';
        document.getElementById('srr-field-count').textContent = '0 fields';
        return;
      }
      
      // v1.5.7: Use rules_bundle for ordering if loaded, else fallback to legacy schema-based order
      var sheetName = srrState.currentSheetName || 'Accounts';
      var ordering;
      
      if (rulesBundleCache.loaded) {
        ordering = orderFieldsForInspector(record, sheetName);
      } else {
        // Legacy fallback: schema order first, then unknown fields alphabetically
        var allRecordKeys = Object.keys(record).filter(function(k) { return !k.startsWith('_'); });
        var schemaKeys = [];
        var unknownKeys = [];
        allRecordKeys.forEach(function(k) {
          if (SRR_SCHEMA_ORDER.indexOf(k) >= 0) {
            schemaKeys.push(k);
          } else {
            unknownKeys.push(k);
          }
        });
        schemaKeys.sort(function(a, b) {
          return SRR_SCHEMA_ORDER.indexOf(a) - SRR_SCHEMA_ORDER.indexOf(b);
        });
        unknownKeys.sort();
        var legacyKeys = schemaKeys.concat(unknownKeys);
        ordering = { groups: [{ name: null, fields: legacyKeys }], orderedKeys: legacyKeys };
      }
      
      // Get all keys from groups for filtering
      var allKeys = [];
      ordering.groups.forEach(function(g) { allKeys = allKeys.concat(g.fields); });
      
      // v1.6.5: Filter out hidden fields (File_Name_c shown in header, File_URL_c internal, metrics hidden)
      allKeys = allKeys.filter(function(k) { return !isHiddenField(k); });
      
      // v1.4.18: Apply search filter to orderedKeys
      var filteredKeys = allKeys;
      if (srrState.searchQuery) {
        var query = srrState.searchQuery.toLowerCase();
        filteredKeys = allKeys.filter(function(k) {
          var val = srrState.editedValues.hasOwnProperty(k) ? srrState.editedValues[k] : srrState.originalValues[k];
          var valStr = val ? String(val).toLowerCase() : '';
          return k.toLowerCase().indexOf(query) >= 0 || valStr.indexOf(query) >= 0;
        });
      }
      
      // Apply field state filter - verified/submitted hidden from To Do by default
      filteredKeys = filteredKeys.filter(function(k) {
        var state = srrState.fieldStates[k] || 'todo';
        
        if (srrState.activeFilter === 'all') return true;
        if (srrState.activeFilter === 'todo') {
          return state === 'todo' || state === 'modified' || state === 'rfi_pending';
        }
        if (srrState.activeFilter === 'verified') return state === 'verified';
        if (srrState.activeFilter === 'rfi') return state === 'rfi' || state === 'rfi_pending';
        if (srrState.activeFilter === 'patched') return state === 'patched' || state === 'submitted';
        if (srrState.activeFilter === 'blocked') return state === 'blocked';
        return true;
      });
      
      // Create a Set for O(1) lookup of filtered keys
      var filteredSet = {};
      filteredKeys.forEach(function(k) { filteredSet[k] = true; });
      
      // v1.4.20: Update filter chip counts
      srrUpdateFilterCounts();
      
      document.getElementById('srr-field-count').textContent = filteredKeys.length + ' fields';
      
      // v1.5.7: Build HTML with group headers using hinge-based ordering
      // Helper function to render a single field card
      function renderFieldCard(key) {
        var originalVal = srrState.originalValues[key];
        var currentVal = srrState.editedValues.hasOwnProperty(key) ? srrState.editedValues[key] : originalVal;
        if (currentVal === null || currentVal === undefined) currentVal = '';
        if (typeof currentVal === 'object') currentVal = JSON.stringify(currentVal);
        
        var isEdited = srrState.editedValues.hasOwnProperty(key);
        var isLocked = srrState.lockedFields.hasOwnProperty(key);  // v1.4.18: locked after commit
        var change = srrState.proposedChanges[key];
        var isRequired = SRR_REQUIRED_FIELDS.indexOf(key) >= 0;
        var fieldState = srrState.fieldStates[key] || 'todo';  // v1.4.20: field state
        
        // Build badges based on field state (exact labels per spec)
        var chips = '';
        if (fieldState === 'verified') {
          chips += '<span class="srr-chip srr-chip-verified">Verified</span>';
        } else if (fieldState === 'modified') {
          chips += '<span class="srr-chip srr-chip-modified">Modified</span>';
        } else if (fieldState === 'submitted') {
          chips += '<span class="srr-chip srr-chip-submitted">Patch Submitted</span>';
        } else if (fieldState === 'rfi' || fieldState === 'rfi_pending') {
          chips += '<span class="srr-chip srr-chip-rfi">RFI</span>';
        } else if (fieldState === 'blocked') {
          chips += '<span class="srr-chip srr-chip-blocked">Blocked</span>';
        }
        // No badge for 'todo' (default state)
        if (isRequired && fieldState === 'todo') chips += '<span class="srr-chip srr-chip-required">Required</span>';
        
        // v1.6.7: Human-friendly label (convert snake_case to Title Case, remove trailing _c suffix)
        var label = key
          .replace(/_c$/i, '')  // Remove trailing _c (Salesforce suffix)
          .replace(/_/g, ' ')   // Convert underscores to spaces
          .replace(/\b\w/g, function(l) { return l.toUpperCase(); })  // Title case
          .trim();
        
        // v1.6.10: Get picklist metadata for dropdown rendering
        var fieldMeta = getFieldMeta(srrState.currentSheet || 'Accounts', key);
        var isPicklistField = fieldMeta && fieldMeta.picklist === true && fieldMeta.options && fieldMeta.options.length > 0;
        var picklistOptions = isPicklistField ? fieldMeta.options : [];
        
        // v1.6.10: Check if current value is valid for picklist
        var isInvalidPicklistValue = false;
        if (isPicklistField && currentVal) {
          var valLower = String(currentVal).trim().toLowerCase();
          var emptyLikeValues = ['', 'n/a', 'null', 'none', '-'];
          if (emptyLikeValues.indexOf(valLower) < 0) {
            isInvalidPicklistValue = !picklistOptions.some(function(opt) {
              return String(opt).trim().toLowerCase() === valLower;
            });
          }
        }
        
        // v1.6.15: Asterisk markers for picklist/invalid fields (replaces pills)
        var labelSuffix = '';
        if (isPicklistField) {
          labelSuffix += '<span class="srr-required-marker" title="Options field">*</span>';
        }
        if (isInvalidPicklistValue) {
          labelSuffix += '<span class="srr-invalid-marker" title="Value not in options list">**</span>';
        }
        
        // Add state-based classes (patchedâ†’submitted, rfi_pendingâ†’rfi for styling)
        var cardClass = 'srr-field-card';
        var displayState = fieldState === 'patched' ? 'submitted' : (fieldState === 'rfi_pending' ? 'rfi' : fieldState);
        if (displayState !== 'todo') cardClass += ' state-' + displayState;
        if (isLocked) cardClass += ' locked';
        if (srrState.selectedField === key) cardClass += ' active';
        if (isPicklistField) cardClass += ' is-picklist';
        if (isInvalidPicklistValue) cardClass += ' has-invalid-value';
        
        // v1.6.6: Check for patch highlight
        var patchInfo = getFieldPatchInfo(srrState.currentRecordKey, key);
        var patchIndicatorHtml = '';
        if (patchInfo) {
          cardClass += ' has-patch';
          if (patchInfo.patch_kind === 'rfi') cardClass += ' patch-rfi';
          else if (patchInfo.patch_kind === 'blacklist') cardClass += ' patch-blacklist';
          else if (patchInfo.patch_kind === 'system_change') cardClass += ' patch-system';
          // Build inline patch chip
          var patchChipClass = patchInfo.patch_kind;
          var sourceLabel = patchInfo.source === 'legacy_diff_import' ? 'legacy' : '';
          patchIndicatorHtml = '<div class="field-patch-indicator">' +
            '<span class="field-patch-chip ' + patchChipClass + '">' + formatPatchKind(patchInfo.patch_kind) + '</span>' +
            (sourceLabel ? '<span class="field-patch-chip legacy">' + sourceLabel + '</span>' : '') +
          '</div>';
        }
        
        // v1.4.20: Build action buttons based on state
        // v1.4.20: Feather SVGs for field actions (order: Blacklist, RFI, Verify)
        var iconFlag = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" y1="22" x2="4" y2="15"/></svg>';
        var iconEdit = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/></svg>';
        var iconCheck = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
        var iconReset = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14l-4-4 4-4"/><path d="M5 10h11a4 4 0 110 8h-1"/></svg>';
        
        var actionsHtml = '<div class="srr-field-actions">';
        // v1.5.3 Fix: Reviewer can action non-verified fields, verified fields are read-only
        // Analyst: all actions available based on field state
        // Reviewer/Admin: actions available for non-verified/non-submitted states
        var isFieldActionable = !srrState.isReadOnly || 
          (srrState.reviewerMode && fieldState !== 'verified' && fieldState !== 'submitted');
        
        if (isFieldActionable) {
          if (fieldState === 'todo') {
            actionsHtml += '<button class="srr-field-action blacklist" onclick="event.stopPropagation(); srrBlacklistField(\'' + key + '\')" title="Block this field">' + iconFlag + '</button>';
            actionsHtml += '<button class="srr-field-action rfi" onclick="event.stopPropagation(); srrRfiField(\'' + key + '\')" title="Request for Info">' + iconEdit + '</button>';
            actionsHtml += '<button class="srr-field-action verify" onclick="event.stopPropagation(); srrVerifyField(\'' + key + '\')" title="Verify (mark as correct)">' + iconCheck + '</button>';
          } else if (fieldState === 'modified') {
            // Modified: no action icons (user moved on after editing)
          } else if (fieldState === 'verified') {
            // Verified: read-only for reviewers, reset for analysts
            if (!srrState.isReadOnly) {
              actionsHtml += '<button class="srr-field-action reset" onclick="event.stopPropagation(); srrResetFieldState(\'' + key + '\')" title="Reset to TODO">' + iconReset + '</button>';
            }
          } else if (fieldState === 'submitted') {
            // Patch Submitted: no actions needed
          } else {
            // rfi, blocked, patched, rfi_pending: show reset
            actionsHtml += '<button class="srr-field-action reset" onclick="event.stopPropagation(); srrResetFieldState(\'' + key + '\')" title="Reset to TODO">' + iconReset + '</button>';
          }
        }
        actionsHtml += '</div>';
        
        var cardHtml = '<div class="' + cardClass + '" data-field="' + key + '">' +
          '<div class="srr-field-card-header" onclick="srrSelectField(\'' + key + '\')">' +
            '<div>' +
              '<div class="srr-field-card-label">' + label + labelSuffix + '</div>' +
              '<div class="srr-field-card-api">' + key + '</div>' +
            '</div>' +
            '<div class="srr-field-card-chips">' + chips + patchIndicatorHtml + '</div>' +
            actionsHtml +
          '</div>' +
          '<div class="srr-field-card-body">' +
            '<div class="srr-field-value-display' + (isPicklistField ? ' is-dropdown' : '') + '" onclick="srrStartEdit(\'' + key + '\')" title="Click to ' + (isPicklistField ? 'select' : 'edit') + '" data-is-picklist="' + (isPicklistField ? 'true' : 'false') + '" data-picklist-options="' + (isPicklistField ? encodeURIComponent(JSON.stringify(picklistOptions)) : '') + '">' + 
              (String(currentVal) || '<span style="color:#999;font-style:italic;">Empty</span>') + 
              (isPicklistField ? ' <span class="dropdown-indicator">â–¼</span>' : '') +
            '</div>';
        
        // Show mini patch prompt if this field was just edited
        if (isEdited && srrState.editingField === key) {
          var existingJustification = change ? (change.justification || '') : '';
          var existingComment = change ? (change.comment || '') : '';
          var existingCategory = change ? (change.category || 'Correction') : 'Correction';
          
          cardHtml += '<div class="srr-mini-patch">' +
            '<div class="srr-mini-patch-label">Patch Details</div>' +
            '<select class="srr-patch-type" id="srr-patch-type-' + key + '" onchange="srrUpdateChangeCategory(\'' + key + '\', this.value)">' +
              '<option value="Correction"' + (existingCategory === 'Correction' ? ' selected' : '') + '>Correction</option>' +
              '<option value="Blacklist Flag"' + (existingCategory === 'Blacklist Flag' ? ' selected' : '') + '>Blacklist Flag</option>' +
              '<option value="RFI"' + (existingCategory === 'RFI' ? ' selected' : '') + '>RFI</option>' +
            '</select>' +
            '<input type="text" class="srr-mini-patch-input" id="srr-mini-just-' + key + '" placeholder="Justification (required)" value="' + existingJustification.replace(/"/g, '&quot;') + '">' +
            '<input type="text" class="srr-mini-patch-input" id="srr-mini-comment-' + key + '" placeholder="Comment (optional)" value="' + existingComment.replace(/"/g, '&quot;') + '">' +
            '<div class="srr-mini-patch-actions">' +
              '<button class="srr-mini-patch-btn undo" onclick="srrUndoChange(\'' + key + '\')">Undo Change</button>' +
              '<button class="srr-mini-patch-btn save" onclick="srrSaveMiniPatch(\'' + key + '\')">Save Patch Draft</button>' +
            '</div>' +
          '</div>';
        }
        
        cardHtml += '</div></div>';
        return cardHtml;
      }
      
      // v1.5.7: Build HTML with group headers
      var html = '';
      ordering.groups.forEach(function(group) {
        // Filter group fields to only include those that passed search/state filters
        var groupFields = group.fields.filter(function(k) { return filteredSet[k]; });
        
        if (groupFields.length === 0) return;  // Skip empty groups
        
        // Add group header if group has a name (Account Name has null name)
        if (group.name) {
          var groupTypeClass = group.type ? ' group-' + group.type : '';
          html += '<div class="srr-field-group-header' + groupTypeClass + '">' + group.name + ' <span class="srr-group-count">(' + groupFields.length + ')</span></div>';
        }
        
        // Render field cards in this group
        groupFields.forEach(function(key) {
          html += renderFieldCard(key);
        });
      });
      
      container.innerHTML = html || '<div class="srr-empty-state">No fields match current filter</div>';
    }
    
    // SRR Filter functions
    function srrSetFilter(filter) {
      srrState.activeFilter = filter;
      document.querySelectorAll('.srr-filter-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.filter === filter) chip.classList.add('active');
      });
      renderSrrFields(srrState.currentRecord);
    }
    
    // v1.4.20: Update filter chip counts
    function srrUpdateFilterCounts() {
      // v1.6.5: Exclude hidden fields from counts
      var allKeys = Object.keys(srrState.originalValues).filter(function(k) { return !isHiddenField(k); });
      var counts = { all: allKeys.length, todo: 0, verified: 0, modified: 0, submitted: 0, rfi: 0, blocked: 0, patched: 0 };
      allKeys.forEach(function(k) {
        var state = srrState.fieldStates[k] || 'todo';
        counts[state] = (counts[state] || 0) + 1;
      });
      // Todo count includes modified and rfi_pending (still in To Do queue)
      var todoCount = counts.todo + counts.modified + (counts.rfi_pending || 0);
      // Patched count includes submitted for backwards compat
      var patchedCount = counts.patched + counts.submitted;
      // RFI count includes both sent and pending
      var rfiCount = counts.rfi + (counts.rfi_pending || 0);
      
      var allEl = document.getElementById('srr-count-all');
      var todoEl = document.getElementById('srr-count-todo');
      var verifiedEl = document.getElementById('srr-count-verified');
      var rfiEl = document.getElementById('srr-count-rfi');
      var patchedEl = document.getElementById('srr-count-patched');
      if (allEl) allEl.textContent = '(' + counts.all + ')';
      if (todoEl) todoEl.textContent = '(' + todoCount + ')';
      if (verifiedEl) verifiedEl.textContent = '(' + counts.verified + ')';
      if (rfiEl) rfiEl.textContent = '(' + rfiCount + ')';
      if (patchedEl) patchedEl.textContent = '(' + patchedCount + ')';
    }
    
    // v1.4.20: Field action - Verify (mark as correct)
    function srrVerifyField(fieldKey) {
      srrState.fieldStates[fieldKey] = 'verified';
      console.log('[SRR] Field VERIFIED:', fieldKey);
      
      // Animate out the field card then remove from DOM
      var card = document.querySelector('.srr-field-card[data-field="' + fieldKey + '"]');
      if (card) {
        card.classList.add('removing');
        // Remove card from DOM after animation
        setTimeout(function() {
          if (card.parentNode) card.parentNode.removeChild(card);
        }, 250);
      }
      
      // Update filter counts immediately
      srrUpdateFilterCounts();
      
      // Check if all fields are now verified (record fully validated)
      var allVerified = true;
      var fieldKeys = Object.keys(srrState.originalValues || {}).filter(function(k) {
        return !k.startsWith('_');
      });
      for (var i = 0; i < fieldKeys.length; i++) {
        var k = fieldKeys[i];
        var state = srrState.fieldStates[k] || 'todo';
        if (state === 'todo') {
          allVerified = false;
          break;
        }
      }
      
      if (allVerified && fieldKeys.length > 0) {
        // Delay finalization to allow animation
        setTimeout(function() {
          console.log('[SRR] All fields verified - record validated, routing to To Do queue');
          var recordKey = srrState.currentRecordKey;
          if (recordKey && window.localState && window.localState.recordStatus) {
            window.localState.recordStatus[recordKey] = 'finalized';
          }
          updateTriageCounts();
          showToast('Record validated - all fields verified');
          navigateTo('triage');
        }, 300);
      }
    }
    
    // v1.4.20: Field action - Blacklist Flag
    function srrBlacklistField(fieldKey) {
      var currentVal = srrState.editedValues.hasOwnProperty(fieldKey) 
        ? srrState.editedValues[fieldKey] 
        : srrState.originalValues[fieldKey];
      var label = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      
      // v1.5.2: Select field for quick actions
      srrPeSelectField(fieldKey, label);
      
      // Set field state to blocked (red header + Blocked badge)
      srrState.fieldStates[fieldKey] = 'blocked';
      
      // Auto-set patch type to blacklist
      srrState.patchType = 'blacklist';
      srrState.patchDraft.patch_type = 'blacklist';
      
      // Auto-populate blacklist subject
      srrState.patchDraft.blacklist_subject = label + ': ' + (currentVal || '(empty)');
      
      console.log('[SRR] Field BLACKLIST:', fieldKey, 'subject:', srrState.patchDraft.blacklist_subject);
      srrUpdatePatchFormSections();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
    }
    
    // v1.4.20: Field action - RFI (question)
    function srrRfiField(fieldKey) {
      // Store RFI field info for display
      var currentVal = srrState.editedValues.hasOwnProperty(fieldKey) 
        ? srrState.editedValues[fieldKey] 
        : srrState.originalValues[fieldKey];
      var label = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      
      // v1.5.2: Select field for quick actions
      srrPeSelectField(fieldKey, label);
      
      // Set to rfi_pending (stays in To Do until Send RFI)
      srrState.fieldStates[fieldKey] = 'rfi_pending';
      srrState.rfiField = {
        key: fieldKey,
        label: label,
        value: currentVal
      };
      
      // Auto-set patch type to RFI
      srrState.patchType = 'rfi';
      srrState.patchDraft.patch_type = 'rfi';
      
      console.log('[SRR] Field RFI (pending):', fieldKey);
      srrUpdatePatchFormSections();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
    }
    
    // v1.4.20: Reset field state to TODO
    function srrResetFieldState(fieldKey) {
      var prevState = srrState.fieldStates[fieldKey];
      delete srrState.fieldStates[fieldKey];
      
      // If was patched, also clear proposed change
      if (prevState === 'patched' && srrState.proposedChanges[fieldKey]) {
        delete srrState.proposedChanges[fieldKey];
        delete srrState.lockedFields[fieldKey];
        delete srrState.editedValues[fieldKey];
      }
      
      console.log('[SRR] Field reset to TODO:', fieldKey);
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
    }
    
    // v1.4.20: Check if there are unresolved PATCHED or RFI fields
    function srrHasUnresolvedFields() {
      for (var key in srrState.fieldStates) {
        var state = srrState.fieldStates[key];
        if (state === 'patched' || state === 'rfi') return true;
      }
      return false;
    }
    
    // v1.4.20: Get count of unresolved fields
    function srrGetUnresolvedCount() {
      var count = 0;
      for (var key in srrState.fieldStates) {
        var state = srrState.fieldStates[key];
        if (state === 'patched' || state === 'rfi') count++;
      }
      return count;
    }
    
    function srrFilterByGroup(group) {
      srrState.activeGroup = group;
      renderSrrFields(srrState.currentRecord);
    }
    
    // v1.4.18: Search filter function
    function srrFilterFields() {
      var searchInput = document.getElementById('srr-field-search');
      srrState.searchQuery = searchInput ? searchInput.value : '';
      renderSrrFields(srrState.currentRecord);
    }
    
    // SRR Inline Edit functions
    function srrStartEdit(fieldKey) {
      // v1.5.2: Get field label for selection tracking
      var fieldLabel = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
      
      // v1.5.2: Select field for quick actions (works even in read-only mode)
      srrPeSelectField(fieldKey, fieldLabel);
      
      // v1.5.1: Prevent editing in read-only mode (Verifier/Admin)
      if (srrState.isReadOnly) {
        showToast('Read-only mode: Use Patch Tester tab to review', 'info');
        return;
      }
      
      // v1.4.18: Prevent editing locked fields
      if (srrState.lockedFields.hasOwnProperty(fieldKey)) {
        showToast('Field is locked after change. Use Patch Editor to modify.', 'info');
        return;
      }
      
      var card = document.querySelector('.srr-field-card[data-field="' + fieldKey + '"]');
      if (!card) return;
      
      var valueDisplay = card.querySelector('.srr-field-value-display');
      var currentVal = srrState.editedValues.hasOwnProperty(fieldKey) 
        ? srrState.editedValues[fieldKey] 
        : (srrState.originalValues[fieldKey] || '');
      
      // v1.6.10: Check if this is a picklist field with options
      var isPicklist = valueDisplay.getAttribute('data-is-picklist') === 'true';
      var picklistOptionsStr = valueDisplay.getAttribute('data-picklist-options');
      var picklistOptions = [];
      if (isPicklist && picklistOptionsStr) {
        try {
          picklistOptions = JSON.parse(decodeURIComponent(picklistOptionsStr));
        } catch (e) {
          picklistOptions = [];
        }
      }
      
      // v1.6.10: Render dropdown for picklist fields, text input for others
      // v1.6.21: Fixed double-click issue - track editing state and prevent re-creation
      if (isPicklist && picklistOptions.length > 0) {
        // Check if we're already editing this field (prevent double-click recreation)
        if (srrState.editingField === fieldKey) {
          return; // Already editing, don't recreate
        }
        srrState.editingField = fieldKey;
        
        // Build dropdown HTML
        var selectHtml = '<select class="srr-field-value-select" id="srr-edit-input-' + fieldKey + '" onclick="event.stopPropagation();">';
        // Add empty option
        selectHtml += '<option value=""' + (!currentVal ? ' selected' : '') + '>-- Select --</option>';
        // Check if current value is in options (for invalid value handling)
        var currentValLower = String(currentVal).trim().toLowerCase();
        var foundCurrentVal = false;
        picklistOptions.forEach(function(opt) {
          var isSelected = String(opt).trim().toLowerCase() === currentValLower;
          if (isSelected) foundCurrentVal = true;
          selectHtml += '<option value="' + String(opt).replace(/"/g, '&quot;') + '"' + (isSelected ? ' selected' : '') + '>' + String(opt) + '</option>';
        });
        // If current value not in options, add it as an invalid option
        if (currentVal && !foundCurrentVal) {
          selectHtml += '<option value="' + String(currentVal).replace(/"/g, '&quot;') + '" selected style="color:#c62828;">' + String(currentVal) + ' (invalid)</option>';
        }
        selectHtml += '</select>';
        valueDisplay.innerHTML = selectHtml;
        
        var select = document.getElementById('srr-edit-input-' + fieldKey);
        if (!select) return;
        
        // v1.6.21: Open dropdown automatically on first click
        select.focus();
        // Try to programmatically open the dropdown (works in modern browsers)
        if (typeof select.showPicker === 'function') {
          try { select.showPicker(); } catch (e) {}
        }
        
        // Handle change and blur
        select.addEventListener('change', function() {
          srrCommitEdit(fieldKey, select.value);
        });
        select.addEventListener('blur', function() {
          // Small delay to allow change event to fire first
          setTimeout(function() {
            if (srrState.editingField === fieldKey) {
              srrCommitEdit(fieldKey, select.value);
            }
          }, 150);
        });
      } else {
        // Regular text input
        // v1.6.21: Track editing state for text inputs too
        if (srrState.editingField === fieldKey) {
          return; // Already editing, don't recreate
        }
        srrState.editingField = fieldKey;
        
        valueDisplay.innerHTML = '<input type="text" class="srr-field-value-input" id="srr-edit-input-' + fieldKey + '" value="' + String(currentVal).replace(/"/g, '&quot;') + '" onclick="event.stopPropagation();">';
        
        var input = document.getElementById('srr-edit-input-' + fieldKey);
        if (!input) return;
        
        input.focus();
        input.select();
        
        // Handle blur and Enter
        input.addEventListener('blur', function() {
          srrCommitEdit(fieldKey, input.value);
        });
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            srrCommitEdit(fieldKey, input.value);
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            srrState.editingField = null;
            renderSrrFields(srrState.currentRecord);
          }
        });
      }
    }
    
    function srrCommitEdit(fieldKey, newValue) {
      var originalVal = srrState.originalValues[fieldKey];
      if (originalVal === null || originalVal === undefined) originalVal = '';
      
      // Check if value actually changed
      if (String(newValue) !== String(originalVal)) {
        srrState.editedValues[fieldKey] = newValue;
        srrState.editingField = null;  // v1.4.18: Clear editing state
        
        // v1.4.18: Lock field after commit (AC-01)
        srrState.lockedFields[fieldKey] = true;
        
        // Set field state to modified (routes to Correction, not RFI)
        srrState.fieldStates[fieldKey] = 'modified';
        
        // Auto-set patch type to correction (via edit action)
        srrState.patchType = 'correction';
        srrState.patchDraft.patch_type = 'correction';
        srrUpdatePatchTypeDisplay();
        
        // Create or update proposed change
        if (!srrState.proposedChanges[fieldKey]) {
          srrState.proposedChanges[fieldKey] = {
            field: fieldKey,
            label: fieldKey.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); }),
            from: originalVal,
            to: newValue,
            category: 'Correction',
            justification: '',
            comment: ''
          };
        } else {
          srrState.proposedChanges[fieldKey].to = newValue;
        }
        
        // Update patch draft changes array
        srrSyncProposedChanges();
        
        console.log('[SRR] Field committed (locked):', fieldKey, 'from:', originalVal, 'to:', newValue);
        showToast('Field changed and locked: ' + fieldKey, 'success');
      } else {
        srrState.editingField = null;
      }
      
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();  // v1.4.18: Update Patch Editor
    }
    
    function srrUndoChange(fieldKey) {
      delete srrState.editedValues[fieldKey];
      delete srrState.proposedChanges[fieldKey];
      delete srrState.lockedFields[fieldKey];  // v1.4.18: Unlock field
      srrState.editingField = null;
      
      srrSyncProposedChanges();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();  // v1.4.18: Update Patch Editor
      
      showToast('Change reverted: ' + fieldKey, 'info');
      console.log('[SRR] Undo change:', fieldKey);
    }
    
    // v1.4.18: Patch Editor rendering (AC-02)
    function srrRenderPatchEditor() {
      var container = document.getElementById('srr-patch-editor-fields');
      var countEl = document.getElementById('srr-change-count');
      var changes = Object.values(srrState.proposedChanges);
      var patchType = srrState.patchType;
      
      if (!container) return;
      
      // For RFI, show the RFI field info instead of changes
      if (patchType === 'rfi' && srrState.rfiField) {
        var rfi = srrState.rfiField;
        var valDisplay = rfi.value === null || rfi.value === undefined || rfi.value === '' ? '(empty)' : String(rfi.value);
        countEl.textContent = '1 field';
        container.innerHTML = '<div class="srr-patch-editor-field">' +
          '<div class="srr-patch-editor-label" style="font-weight: 600; margin-bottom: 6px;">' + rfi.label + '</div>' +
          '<div class="srr-patch-editor-row">' +
            '<label style="color: #666;">Value:</label>' +
            '<div class="srr-patch-editor-old" style="background: #fff3e0; border-color: #ffe0b2;" title="' + valDisplay.replace(/"/g, '&quot;') + '">' + valDisplay + '</div>' +
          '</div>' +
        '</div>';
        return;
      }
      
      countEl.textContent = changes.length + ' change' + (changes.length !== 1 ? 's' : '');
      
      if (changes.length === 0) {
        // Show appropriate helper based on patch type
        var helperText = patchType === 'blacklist' 
          ? 'Click the Block icon on a field to flag it for blacklist.'
          : 'Click a field value to edit. Changed fields appear here.';
        container.innerHTML = '<div class="srr-patch-editor-empty" id="srr-action-box-helper">' + helperText + '</div>';
        return;
      }
      
      var html = changes.map(function(change) {
        var oldVal = change.from === null || change.from === undefined || change.from === '' ? '(empty)' : String(change.from);
        var newVal = change.to === null || change.to === undefined ? '' : String(change.to);
        
        // v1.5.2: Make field clickable to select for quick actions
        return '<div class="srr-patch-editor-field" data-field="' + change.field + '" onclick="srrPeSelectField(\'' + change.field + '\', \'' + change.label.replace(/'/g, "\\'") + '\')" style="cursor: pointer;">' +
          '<div class="srr-patch-editor-label">' + change.label + 
            '<button class="srr-patch-remove-btn" onclick="event.stopPropagation(); srrUndoChange(\'' + change.field + '\')" title="Remove change">âœ•</button>' +
          '</div>' +
          '<div class="srr-patch-editor-row">' +
            '<label>Old:</label>' +
            '<div class="srr-patch-editor-old" title="' + oldVal.replace(/"/g, '&quot;') + '">' + oldVal + '</div>' +
          '</div>' +
          '<div class="srr-patch-editor-row">' +
            '<label>New:</label>' +
            '<div class="srr-patch-editor-new">' +
              '<input type="text" id="srr-pe-new-' + change.field + '" value="' + newVal.replace(/"/g, '&quot;') + '" ' +
                'onclick="event.stopPropagation()" onchange="srrUpdatePatchEditorValue(\'' + change.field + '\', this.value)">' +
            '</div>' +
          '</div>' +
        '</div>';
      }).join('');
      
      container.innerHTML = html;
    }
    
    // v1.4.18: Update new value from Patch Editor (AC-02)
    function srrUpdatePatchEditorValue(fieldKey, newValue) {
      if (srrState.proposedChanges[fieldKey]) {
        srrState.proposedChanges[fieldKey].to = newValue;
        srrState.editedValues[fieldKey] = newValue;
        srrSyncProposedChanges();
        renderSrrFields(srrState.currentRecord);  // Update Field Inspector display
        console.log('[SRR] Patch Editor updated:', fieldKey, 'to:', newValue);
      }
    }
    
    // v1.5.2: Track selected field for Patch Type chip actions
    var srrPeSelectedField = null;
    
    function srrPeSelectField(fieldKey, fieldLabel) {
      srrPeSelectedField = { key: fieldKey, label: fieldLabel };
      
      // Update chip area to show selection
      var chipsContainer = document.getElementById('srr-patch-type-chips');
      var labelEl = document.getElementById('srr-patch-type-selected-field');
      
      if (chipsContainer) {
        chipsContainer.classList.remove('no-selection');
      }
      if (labelEl) {
        labelEl.textContent = 'Selected: ' + fieldLabel;
        labelEl.style.background = '#e8f5e9';
        labelEl.style.color = '#2e7d32';
      }
      console.log('[SRR] Field selected for action:', fieldKey);
    }
    
    function srrPeClearSelection() {
      srrPeSelectedField = null;
      
      var chipsContainer = document.getElementById('srr-patch-type-chips');
      var labelEl = document.getElementById('srr-patch-type-selected-field');
      
      if (chipsContainer) {
        chipsContainer.classList.add('no-selection');
      }
      if (labelEl) {
        labelEl.textContent = 'Select a field to apply action';
        labelEl.style.background = '#f5f5f5';
        labelEl.style.color = '#666';
      }
    }
    
    function srrUpdateChangeCategory(fieldKey, category) {
      if (srrState.proposedChanges[fieldKey]) {
        srrState.proposedChanges[fieldKey].category = category;
        srrSyncProposedChanges();
        srrRenderPatchEditor();
      }
    }
    
    function srrSaveMiniPatch(fieldKey) {
      var justInput = document.getElementById('srr-mini-just-' + fieldKey);
      var commentInput = document.getElementById('srr-mini-comment-' + fieldKey);
      
      if (srrState.proposedChanges[fieldKey]) {
        srrState.proposedChanges[fieldKey].justification = justInput ? justInput.value : '';
        srrState.proposedChanges[fieldKey].comment = commentInput ? commentInput.value : '';
      }
      
      srrState.editingField = null;
      srrSyncProposedChanges();
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditor();
      
      showToast('Patch draft saved for: ' + fieldKey, 'success');
    }
    
    function srrSyncProposedChanges() {
      // Sync proposed changes to patch draft changes array
      srrState.patchDraft.changes = Object.values(srrState.proposedChanges).map(function(c) {
        return {
          path: c.field,
          label: c.label,
          before: c.from,
          after: c.to,
          category: c.category,
          justification: c.justification,
          comment: c.comment
        };
      });
    }
    
    // Check for unsaved changes
    function srrHasUnsavedChanges() {
      var editedFields = Object.keys(srrState.editedValues);
      if (editedFields.length === 0) return false;
      
      // Check if any edited field has incomplete patch data
      for (var i = 0; i < editedFields.length; i++) {
        var key = editedFields[i];
        var change = srrState.proposedChanges[key];
        if (!change || !change.justification) {
          return true;
        }
      }
      return false;
    }
    
    // Navigation guard
    // v1.4.20: Back to Grid with guard for unresolved fields
    function srrBackToGrid() {
      if (srrHasUnresolvedFields()) {
        srrShowGuardModal();
      } else {
        navigateTo('grid');
      }
    }
    
    function srrGuardCancel() {
      srrHideGuardModal();
    }
    
    // v1.4.20: Discard all changes and clear field states
    function srrGuardDiscardAll() {
      // Clear all PATCHED and RFI states
      for (var key in srrState.fieldStates) {
        var state = srrState.fieldStates[key];
        if (state === 'patched' || state === 'rfi') {
          delete srrState.fieldStates[key];
          delete srrState.proposedChanges[key];
          delete srrState.lockedFields[key];
          delete srrState.editedValues[key];
        }
      }
      srrState.patchDraft.changes = [];
      srrHideGuardModal();
      navigateTo('grid');
    }
    
    // ========== v1.5.1: PATCH TESTER TAB (Reviewer SSR) ==========
    var srrPatchTesterState = {
      artifactId: null,
      field: null,
      oldValue: null,
      proposedValue: null
    };
    
    function srrSwitchRightTab(tabName) {
      // Switch between editor and tester tabs
      var editorTab = document.getElementById('srr-tab-editor');
      var testerTab = document.getElementById('srr-tab-tester');
      var tabBtns = document.querySelectorAll('.srr-panel-tab');
      
      tabBtns.forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
      });
      
      if (editorTab) editorTab.style.display = tabName === 'editor' ? 'block' : 'none';
      if (testerTab) testerTab.style.display = tabName === 'tester' ? 'block' : 'none';
      
      // Update panel title
      var titleEl = document.getElementById('srr-right-panel-title');
      if (titleEl) {
        titleEl.textContent = tabName === 'tester' ? 'Patch Tester' : 'Patch Editor';
      }
    }
    
    function srrShowPatchTesterTabs() {
      // v1.5.1: Show tabs for verifier (reviewer) AND admin roles (not analyst)
      // Only show for explicit Correction/Blacklist types (not RFI, not unknown)
      // Note: In codebase, 'reviewer' = Verifier role (UI name differs from internal name)
      var tabsEl = document.getElementById('srr-panel-tabs');
      if (!tabsEl) return;
      
      var isVerifierOrAdmin = (currentMode === 'reviewer' || currentMode === 'admin');
      
      // Check current artifact type from srrState
      var artifactId = srrState.currentArtifactId;
      var artifact = artifactId ? getArtifact(artifactId) : null;
      
      // Explicitly require Correction or Blacklist patch type
      // Hidden for: RFI, missing type, unknown type, generic patch_request without explicit type
      var isCorrectionOrBlacklist = false;
      if (artifact) {
        // Prefer body.patch_type for explicit type, fall back to artifact_type only for blacklist
        var patchType = artifact.body?.patch_type;
        var artifactType = artifact.artifact_type;
        
        // Normalize to lowercase for comparison
        var normalizedPatchType = patchType ? String(patchType).toLowerCase() : '';
        var normalizedArtifactType = artifactType ? String(artifactType).toLowerCase() : '';
        
        // Check explicit patch_type first
        if (normalizedPatchType === 'correction' || 
            normalizedPatchType === 'blacklist' || 
            normalizedPatchType === 'blacklist flag') {
          isCorrectionOrBlacklist = true;
        }
        // Only accept artifact_type='blacklist' as secondary (not generic 'patch_request')
        else if (normalizedArtifactType === 'blacklist') {
          isCorrectionOrBlacklist = true;
        }
        // Reject RFI explicitly
        if (normalizedPatchType === 'rfi' || normalizedArtifactType === 'rfi') {
          isCorrectionOrBlacklist = false;
        }
      }
      
      console.log('[SRR_TABS] Role:', currentMode, 'isCorrectionOrBlacklist:', isCorrectionOrBlacklist, 'isVerifierOrAdmin:', isVerifierOrAdmin);
      
      // Show tabs only if: (verifier or admin) AND explicit Correction/Blacklist AND artifact exists
      if (isVerifierOrAdmin && isCorrectionOrBlacklist && artifactId) {
        tabsEl.style.display = 'flex';
      } else {
        tabsEl.style.display = 'none';
        srrSwitchRightTab('editor');  // Reset to editor tab when hidden
      }
    }
    
    function srrHidePatchTesterTabs() {
      var tabsEl = document.getElementById('srr-panel-tabs');
      if (tabsEl) tabsEl.style.display = 'none';
      srrSwitchRightTab('editor');  // Reset to editor tab
    }
    
    function srrLoadPatchTesterData(artifactId) {
      // Load artifact data into Patch Tester tab
      var artifact = getArtifact(artifactId);
      if (!artifact) {
        console.log('[SRR_TESTER] No artifact found:', artifactId);
        return;
      }
      
      srrPatchTesterState.artifactId = artifactId;
      srrPatchTesterState.field = artifact.field_key || 'â€”';
      srrPatchTesterState.oldValue = artifact.old_value || 'â€”';
      srrPatchTesterState.proposedValue = artifact.new_value || '';
      
      // Populate UI
      var fieldEl = document.getElementById('srr-tester-field');
      var oldEl = document.getElementById('srr-tester-old-value');
      var proposedEl = document.getElementById('srr-tester-proposed-value');
      var newValueEl = document.getElementById('srr-tester-new-value');
      
      if (fieldEl) fieldEl.textContent = srrPatchTesterState.field;
      if (oldEl) oldEl.textContent = srrPatchTesterState.oldValue;
      if (proposedEl) proposedEl.textContent = srrPatchTesterState.proposedValue;
      if (newValueEl) newValueEl.value = srrPatchTesterState.proposedValue;
      
      // Clear notes
      var notesEl = document.getElementById('srr-tester-notes');
      if (notesEl) notesEl.value = '';
    }
    
    function srrSendBackToAnalyst() {
      var artifactId = srrPatchTesterState.artifactId;
      if (!artifactId) {
        showToast('No patch loaded to send back', 'warning');
        return;
      }
      
      var newValueEl = document.getElementById('srr-tester-new-value');
      var notesEl = document.getElementById('srr-tester-notes');
      
      var adjustedValue = newValueEl ? newValueEl.value.trim() : '';
      var reviewerNotes = notesEl ? notesEl.value.trim() : '';
      
      if (!reviewerNotes) {
        showToast('Please add reviewer notes explaining the changes', 'warning');
        return;
      }
      
      // Update artifact with reviewer feedback
      var artifact = getArtifact(artifactId);
      if (artifact) {
        artifact.status = 'needs_clarification';
        artifact.reviewer_adjusted_value = adjustedValue;
        artifact.reviewer_notes = reviewerNotes;
        artifact.updated_at = Date.now();
        saveArtifact(artifact);
        
        // v1.5.1: Append thread message with feedback details
        if (artifact.thread_id) {
          var feedbackMsg = 'Patch Tester Feedback:\n';
          feedbackMsg += 'Field: ' + srrPatchTesterState.field + '\n';
          feedbackMsg += 'Proposed Value: ' + srrPatchTesterState.proposedValue + '\n';
          if (adjustedValue !== srrPatchTesterState.proposedValue) {
            feedbackMsg += 'Adjusted Value: ' + adjustedValue + '\n';
          }
          feedbackMsg += 'Notes: ' + reviewerNotes;
          addThreadMessage(artifact.thread_id, feedbackMsg);
        }
        
        // Log event
        logArtifactEvent({
          event_type: 'PATCH_TESTER_FEEDBACK',
          artifact_id: artifactId,
          actor: getActorForRole(currentMode),
          payload: {
            adjusted_value: adjustedValue,
            reviewer_notes: reviewerNotes,
            original_value: srrPatchTesterState.proposedValue
          }
        });
      }
      
      showToast('Sent back to Analyst for clarification', 'success');
      
      // Clear tester state and SRR artifact context
      srrPatchTesterState = { artifactId: null, field: null, oldValue: null, proposedValue: null };
      srrState.currentArtifactId = null;
      srrState.isReadOnly = false;
      
      // Reset UI
      srrSwitchRightTab('editor');
      
      // Navigate back to triage (reviewer remains in review workflow)
      navigateTo('triage');
    }
    
    function srrSelectField(fieldKey) {
      // Highlight selected field
      document.querySelectorAll('.srr-field-item').forEach(function(el) {
        el.classList.remove('active');
      });
      var selected = document.querySelector('.srr-field-item[data-field="' + fieldKey + '"]');
      if (selected) selected.classList.add('active');
      
      srrState.selectedField = fieldKey;
      
      // Update document viewer highlight placeholder
      srrUpdateViewerHighlight(fieldKey);
      
      // Update evidence anchors list
      srrUpdateAnchorList(fieldKey);
      
      // v1.5.3 Fix: Update Patch Editor to reflect the selected field's patch type
      var fieldState = srrState.fieldStates[fieldKey] || 'todo';
      var fieldChange = srrState.patchDraft.changes ? srrState.patchDraft.changes[fieldKey] : null;
      
      // v1.5.3 Fix: For reviewer mode, derive patch type from submitted change in payload
      var fieldPatchType = 'correction';
      if (srrState.reviewerMode && srrState.reviewerPayload) {
        var payload = srrState.reviewerPayload;
        var submittedChange = null;
        
        // Find submitted change for this field
        if (payload.field === fieldKey) {
          submittedChange = { category: payload.patch_type || payload.category };
        }
        if (payload.changes && Array.isArray(payload.changes)) {
          payload.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
        if (payload.body && payload.body.changes) {
          payload.body.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
        
        // Derive patch type from submitted change
        if (submittedChange && submittedChange.category) {
          var cat = submittedChange.category.toLowerCase();
          if (cat === 'rfi' || cat.includes('rfi')) fieldPatchType = 'rfi';
          else if (cat === 'blacklist' || cat === 'blacklist flag') fieldPatchType = 'blacklist';
        } else if (submittedChange && submittedChange.patch_type) {
          fieldPatchType = submittedChange.patch_type;
        }
      } else {
        // Analyst mode: derive from field state or draft changes
        if (fieldState === 'rfi' || fieldState === 'rfi_pending') {
          fieldPatchType = 'rfi';
        } else if (fieldState === 'blocked') {
          fieldPatchType = 'blacklist';
        } else if (fieldChange && fieldChange.category) {
          if (fieldChange.category === 'RFI') fieldPatchType = 'rfi';
          else if (fieldChange.category === 'Blacklist Flag') fieldPatchType = 'blacklist';
        }
      }
      
      // v1.5.3 Fix: Always update patch editor when selecting a field (not just when type changes)
      srrState.patchType = fieldPatchType;
      
      // Update patch type chips
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === fieldPatchType) chip.classList.add('active');
      });
      
      // Update form sections visibility
      srrUpdatePatchFormSections();
      
      // v1.5.3 Fix: Use different rendering for reviewer mode vs analyst mode
      if (srrState.reviewerMode) {
        // Reviewer mode: show read-only summary for the selected field
        srrRenderPatchEditorForField(fieldKey);
      } else {
        // Analyst mode: use interactive patch editor
        srrRenderPatchEditor();
      }
      
      console.log('[SRR] Selected field:', fieldKey, 'state:', fieldState, 'patchType:', fieldPatchType);
    }
    
    function srrRenderPatchEditorForField(fieldKey) {
      // v1.5.3: Render Patch Review for reviewer mode - shows submitted patch data with actions
      var container = document.getElementById('srr-patch-editor-fields');
      if (!container) return;
      
      var fieldState = srrState.fieldStates[fieldKey] || 'todo';
      var record = srrState.currentRecord;
      var currentVal = record ? record[fieldKey] : '';
      
      // v1.5.3 Fix: Load submitted patch data from reviewer payload (not just local draft)
      var payload = srrState.reviewerPayload;
      var submittedChange = null;
      
      // Check if payload has this field's change
      if (payload) {
        // Single-field payload
        if (payload.field === fieldKey) {
          submittedChange = {
            old_value: payload.old_value,
            new_value: payload.new_value,
            justification: payload.justification,
            category: payload.patch_type || payload.category
          };
        }
        // Multi-field payload (changes array)
        if (payload.changes && Array.isArray(payload.changes)) {
          payload.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
        // PatchRequest with body.changes
        if (payload.body && payload.body.changes && Array.isArray(payload.body.changes)) {
          payload.body.changes.forEach(function(c) {
            if (c.field === fieldKey || c.fieldKey === fieldKey) {
              submittedChange = c;
            }
          });
        }
      }
      
      // Fallback to local draft if no submitted change found
      if (!submittedChange && srrState.patchDraft.changes) {
        submittedChange = srrState.patchDraft.changes[fieldKey];
      }
      
      // v1.5.3 Fix: Derive patch type from submitted change category (per-field, not global)
      var fieldPatchType = 'correction';
      if (submittedChange && submittedChange.category) {
        var cat = submittedChange.category.toLowerCase();
        if (cat === 'rfi' || cat.includes('rfi')) fieldPatchType = 'rfi';
        else if (cat === 'blacklist' || cat === 'blacklist flag') fieldPatchType = 'blacklist';
      } else if (submittedChange && submittedChange.patch_type) {
        fieldPatchType = submittedChange.patch_type;
      } else {
        // Fallback to field state
        if (fieldState === 'rfi' || fieldState === 'rfi_pending') fieldPatchType = 'rfi';
        else if (fieldState === 'blocked') fieldPatchType = 'blacklist';
      }
      
      var typeColor = fieldPatchType === 'rfi' ? '#7b1fa2' : (fieldPatchType === 'blacklist' ? '#c62828' : '#1565c0');
      var typeLabel = fieldPatchType.toUpperCase();
      
      var html = '<div style="padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ' + typeColor + ';">';
      html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">';
      html += '<span style="font-weight: 600;">Field: ' + fieldKey + '</span>';
      html += '<span style="background: ' + typeColor + '; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em;">' + typeLabel + '</span>';
      html += '</div>';
      
      // Current/Old value
      var oldValue = (submittedChange && submittedChange.old_value !== undefined) ? submittedChange.old_value : currentVal;
      html += '<div style="margin-bottom: 8px;">';
      html += '<span style="font-size: 0.75em; color: #888;">Current Value:</span> ';
      html += '<span style="font-family: monospace; color: #666; text-decoration: ' + (submittedChange ? 'line-through' : 'none') + ';">' + (oldValue || '(empty)') + '</span>';
      html += '</div>';
      
      // Show submitted change details
      if (submittedChange) {
        if (submittedChange.new_value !== undefined) {
          html += '<div style="margin-bottom: 8px;">';
          html += '<span style="font-size: 0.75em; color: #888;">Proposed Value:</span> ';
          html += '<span style="font-family: monospace; color: #2e7d32; font-weight: 600;">' + (submittedChange.new_value || '(empty)') + '</span>';
          html += '</div>';
        }
        if (submittedChange.justification) {
          html += '<div style="margin-bottom: 8px;">';
          html += '<span style="font-size: 0.75em; color: #888;">Justification:</span> ';
          html += '<span>' + submittedChange.justification + '</span>';
          html += '</div>';
        }
        if (submittedChange.comment) {
          html += '<div style="margin-bottom: 8px;">';
          html += '<span style="font-size: 0.75em; color: #888;">Comment:</span> ';
          html += '<span style="font-style: italic;">' + submittedChange.comment + '</span>';
          html += '</div>';
        }
      }
      
      // Field state indicator
      html += '<div style="margin-bottom: 8px;">';
      html += '<span style="font-size: 0.75em; color: #888;">Review Status:</span> ';
      var stateColor = fieldState === 'verified' ? '#2e7d32' : 
                       fieldState === 'rfi_pending' ? '#7b1fa2' : 
                       fieldState === 'blocked' ? '#c62828' : '#1565c0';
      var stateLabel = fieldState === 'verified' ? 'APPROVED' : 
                       fieldState === 'rfi_pending' ? 'NEEDS CLARIFICATION' : 
                       fieldState === 'blocked' ? 'REJECTED' : 'PENDING REVIEW';
      html += '<span style="color: ' + stateColor + '; font-weight: 500;">' + stateLabel + '</span>';
      html += '</div>';
      
      // v1.5.3: Add reviewer action buttons for non-final states
      if (fieldState !== 'verified' && fieldState !== 'submitted') {
        html += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e0e0e0; display: flex; gap: 8px; flex-wrap: wrap;">';
        html += '<button onclick="reviewerApproveField(\'' + fieldKey + '\')" style="padding: 6px 12px; background: #2e7d32; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Approve</button>';
        html += '<button onclick="reviewerRequestClarification(\'' + fieldKey + '\')" style="padding: 6px 12px; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Request Clarification</button>';
        html += '<button onclick="reviewerRejectField(\'' + fieldKey + '\')" style="padding: 6px 12px; background: #c62828; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Reject</button>';
        html += '</div>';
      }
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    function reviewerApproveField(fieldKey) {
      // v1.5.3: Reviewer approves a field change - integrates with canonical workflow
      var patchRequestId = srrState.currentPatchRequestId;
      var patchRequest = patchRequestId ? PATCH_REQUEST_STORE.get(patchRequestId) : null;
      
      srrState.fieldStates[fieldKey] = 'verified';
      
      // Update PatchRequest and log audit event
      if (patchRequest) {
        if (!patchRequest.field_decisions) patchRequest.field_decisions = {};
        patchRequest.field_decisions[fieldKey] = {
          decision: 'approved',
          by: currentMode,
          at: new Date().toISOString()
        };
        
        // Check if all fields are approved - update overall status
        var allApproved = checkAllFieldsApproved(patchRequest);
        if (allApproved) {
          patchRequest.status = currentMode === 'admin' ? 'resolved' : 'sent_to_admin';
        }
        
        // Log audit event (canonical pattern)
        if (!patchRequest.audit_log) patchRequest.audit_log = [];
        patchRequest.audit_log.push({
          event: 'FIELD_APPROVED',
          field: fieldKey,
          by: currentMode,
          actor: getActorForRole(currentMode),
          at: new Date().toISOString()
        });
        
        PATCH_REQUEST_STORE.update(patchRequestId, patchRequest);
      }
      
      // Update Verifier Review state if we're in that context
      if (vrState.currentPatchId && patchRequest) {
        vrState.reviewState = 'Under_Review';
        vrUpdateStateBadge();
        vrUpdateActionButtons();
      }
      
      showToast('Approved: ' + fieldKey, 'success');
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditorForField(fieldKey);
      console.log('[Reviewer] Approved field:', fieldKey);
    }
    
    function reviewerRequestClarification(fieldKey) {
      // v1.5.3: Reviewer requests clarification - integrates with canonical workflow
      var patchRequestId = srrState.currentPatchRequestId;
      var patchRequest = patchRequestId ? PATCH_REQUEST_STORE.get(patchRequestId) : null;
      
      srrState.fieldStates[fieldKey] = 'rfi_pending';
      
      // Update PatchRequest and log audit event
      if (patchRequest) {
        if (!patchRequest.field_decisions) patchRequest.field_decisions = {};
        patchRequest.field_decisions[fieldKey] = {
          decision: 'needs_clarification',
          by: currentMode,
          at: new Date().toISOString()
        };
        patchRequest.status = 'needs_clarification';
        
        // Log audit event (canonical pattern)
        if (!patchRequest.audit_log) patchRequest.audit_log = [];
        patchRequest.audit_log.push({
          event: 'REQUEST_CLARIFICATION',
          field: fieldKey,
          by: currentMode,
          actor: getActorForRole(currentMode),
          at: new Date().toISOString()
        });
        
        PATCH_REQUEST_STORE.update(patchRequestId, patchRequest);
      }
      
      // Update Verifier Review state
      if (vrState.currentPatchId) {
        vrState.reviewState = 'Needs_Clarification';
        vrUpdateStateBadge();
        vrUpdateActionButtons();
        vrRenderDecisionSummary();
      }
      
      showToast('Clarification requested: ' + fieldKey, 'info');
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditorForField(fieldKey);
      console.log('[Reviewer] Request clarification for field:', fieldKey);
    }
    
    function reviewerRejectField(fieldKey) {
      // v1.5.3: Reviewer rejects a field change - integrates with canonical workflow
      var patchRequestId = srrState.currentPatchRequestId;
      var patchRequest = patchRequestId ? PATCH_REQUEST_STORE.get(patchRequestId) : null;
      
      srrState.fieldStates[fieldKey] = 'blocked';
      
      // Update PatchRequest and log audit event
      if (patchRequest) {
        if (!patchRequest.field_decisions) patchRequest.field_decisions = {};
        patchRequest.field_decisions[fieldKey] = {
          decision: 'rejected',
          by: currentMode,
          at: new Date().toISOString()
        };
        
        // Log audit event (canonical pattern)
        if (!patchRequest.audit_log) patchRequest.audit_log = [];
        patchRequest.audit_log.push({
          event: 'FIELD_REJECTED',
          field: fieldKey,
          by: currentMode,
          actor: getActorForRole(currentMode),
          at: new Date().toISOString()
        });
        
        PATCH_REQUEST_STORE.update(patchRequestId, patchRequest);
      }
      
      showToast('Rejected: ' + fieldKey, 'warning');
      renderSrrFields(srrState.currentRecord);
      srrRenderPatchEditorForField(fieldKey);
      console.log('[Reviewer] Rejected field:', fieldKey);
    }
    
    function checkAllFieldsApproved(patchRequest) {
      // v1.5.3: Check if all fields in the PatchRequest have been approved
      if (!patchRequest.field_decisions) return false;
      
      var changedFields = [];
      
      // Collect all changed field keys
      if (patchRequest.field) changedFields.push(patchRequest.field);
      if (patchRequest.changes) {
        patchRequest.changes.forEach(function(c) {
          if (c.field) changedFields.push(c.field);
        });
      }
      if (patchRequest.body && patchRequest.body.changes) {
        patchRequest.body.changes.forEach(function(c) {
          if (c.field) changedFields.push(c.field);
        });
      }
      
      // Check all fields have approved decision
      for (var i = 0; i < changedFields.length; i++) {
        var fk = changedFields[i];
        var decision = patchRequest.field_decisions[fk];
        if (!decision || decision.decision !== 'approved') {
          return false;
        }
      }
      
      return changedFields.length > 0;
    }
    
    // v1.6.12: Highlight state for auto-dismiss
    var srrHighlightTimer = null;
    
    function srrClearHighlight() {
      // Clear any pending timer
      if (srrHighlightTimer) {
        clearTimeout(srrHighlightTimer);
        srrHighlightTimer = null;
      }
      
      var toast = document.getElementById('srr-pdf-highlight-toast');
      var box = document.getElementById('srr-pdf-highlight-box');
      
      if (toast) {
        toast.classList.add('fading');
        setTimeout(function() {
          toast.style.display = 'none';
          toast.classList.remove('fading');
        }, 300);
      }
      if (box) {
        box.classList.add('fading');
        setTimeout(function() {
          box.style.display = 'none';
          box.classList.remove('fading');
        }, 300);
      }
    }
    
    function srrUpdateViewerHighlight(fieldKey) {
      var toast = document.getElementById('srr-pdf-highlight-toast');
      var label = document.getElementById('srr-pdf-highlight-label');
      var box = document.getElementById('srr-pdf-highlight-box');
      
      // Clear any existing highlight first
      if (srrHighlightTimer) {
        clearTimeout(srrHighlightTimer);
        srrHighlightTimer = null;
      }
      
      // If no field selected, just clear
      if (!fieldKey) {
        srrClearHighlight();
        return;
      }
      
      // Check if we have anchor data for this field (stub: always false for now)
      var hasAnchor = false; // TODO: Check actual anchor data when available
      
      if (!hasAnchor) {
        // Show toast notification that no anchor exists
        showToast('No anchor found for: ' + fieldKey, 'info');
      }
      
      // Format field label for display
      var displayLabel = fieldKey.replace(/_c$/, '').replace(/_/g, ' ');
      
      // Show non-blocking toast
      if (toast && label) {
        toast.classList.remove('fading');
        toast.style.display = 'flex';
        label.textContent = 'ðŸ” ' + displayLabel;
      }
      
      // Show highlight box placeholder (positioned in center for demo)
      if (box) {
        box.classList.remove('fading');
        box.style.display = 'block';
        box.style.top = '30%';
        box.style.left = '10%';
        box.style.width = '80%';
        box.style.height = '15%';
      }
      
      // Auto-dismiss after 2.5 seconds
      srrHighlightTimer = setTimeout(function() {
        srrClearHighlight();
      }, 2500);
    }
    
    // v1.6.12: ESC key handler for clearing highlight
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        var toast = document.getElementById('srr-pdf-highlight-toast');
        if (toast && toast.style.display !== 'none') {
          srrClearHighlight();
        }
      }
    });
    
    // v1.6.12: Click outside to clear highlight
    document.addEventListener('click', function(e) {
      var toast = document.getElementById('srr-pdf-highlight-toast');
      var box = document.getElementById('srr-pdf-highlight-box');
      if (toast && toast.style.display !== 'none') {
        // If click is not on the toast or box, clear
        if (!toast.contains(e.target) && (!box || !box.contains(e.target))) {
          srrClearHighlight();
        }
      }
    });
    
    function srrUpdateAnchorList(fieldKey) {
      var container = document.getElementById('srr-anchor-list');
      
      if (!fieldKey) {
        container.innerHTML = '<div style="font-size: 0.8em; font-weight: 600; color: #666; margin-bottom: 8px;">Evidence Anchors</div>' +
          '<div class="srr-empty-state" style="padding: 10px;">No anchors defined</div>';
        return;
      }
      
      // Stub anchor for selected field
      container.innerHTML = '<div style="font-size: 0.8em; font-weight: 600; color: #666; margin-bottom: 8px;">Evidence Anchors for: ' + fieldKey + '</div>' +
        '<div class="srr-anchor-item" onclick="srrJumpToAnchor(\'' + fieldKey + '\', 0)">' +
          '<div style="font-weight: 500;">' + fieldKey + ' â€” Source</div>' +
          '<div style="font-size: 0.75em; color: #888;">Page 1 â€¢ Click to highlight</div>' +
        '</div>';
    }
    
    function srrJumpToAnchor(fieldKey, anchorIdx) {
      console.log('[SRR] Jumping to anchor: ' + fieldKey + ', index: ' + anchorIdx);
      showToast('Anchor navigation: ' + fieldKey, 'info');
    }
    
    function renderSrrPatchList() {
      var container = document.getElementById('srr-patch-list');
      var changes = srrState.patchDraft.changes || [];
      var patchStatus = srrState.patchDraft.status || 'Draft';
      
      if (changes.length === 0) {
        container.innerHTML = '<div class="srr-empty-state" style="padding: 12px;">No changes proposed yet</div>';
        return;
      }
      
      // Status-based badge styling
      var statusBadge = patchStatus === 'Submitted' 
        ? '<span class="srr-patch-status submitted">Submitted</span>'
        : '<span class="srr-patch-status draft">Draft</span>';
      
      var html = '<div class="srr-patch-header">Proposed Changes ' + statusBadge + '</div>';
      html += changes.map(function(c, idx) {
        var categoryColor = c.category === 'RFI' ? '#673ab7' : (c.category === 'Blacklist Flag' ? '#f44336' : '#1565c0');
        var fromVal = c.before !== null && c.before !== undefined && c.before !== '' ? c.before : '(empty)';
        var toVal = c.after !== null && c.after !== undefined && c.after !== '' ? c.after : '(empty)';
        
        return '<div class="srr-proposed-change">' +
          '<div class="srr-proposed-change-header">' +
            '<div class="srr-proposed-change-field">' + (c.label || c.path) + ' <span style="font-weight: normal; color: #888; font-size: 0.8em;">(' + c.path + ')</span></div>' +
            '<span style="font-size: 0.7em; padding: 2px 6px; border-radius: 8px; background: ' + categoryColor + '; color: white;">' + (c.category || 'Correction') + '</span>' +
          '</div>' +
          '<div class="srr-proposed-change-values">' +
            '<span class="srr-proposed-change-from">' + fromVal + '</span>' +
            '<span style="color: #666;">â†’</span>' +
            '<span class="srr-proposed-change-to">' + toVal + '</span>' +
          '</div>' +
          (c.justification ? '<div style="font-size: 0.75em; color: #666; margin-top: 4px;"><strong>Why:</strong> ' + c.justification + '</div>' : '') +
        '</div>';
      }).join('');
      
      container.innerHTML = html;
    }
    
    // PDF Viewer State Persistence
    var SRR_PDF_STATE_KEY = 'orchestrate.srr_pdf_state.v1';
    
    function getSrrPdfStateKey(record) {
      if (!record) return null;
      // v1.4.15: Use field resolver for cache key with Salesforce-style columns
      return (record.contract_key || '') + '|' + srrResolveFieldValue(record, 'file_url') + '|' + srrResolveFieldValue(record, 'file_name');
    }
    
    function loadSrrPdfState(record) {
      try {
        var key = getSrrPdfStateKey(record);
        if (!key) return { page: 1, zoom: 1 };
        var allState = JSON.parse(localStorage.getItem(SRR_PDF_STATE_KEY) || '{}');
        return allState[key] || { page: 1, zoom: 1 };
      } catch (e) { return { page: 1, zoom: 1 }; }
    }
    
    function saveSrrPdfState(record) {
      try {
        var key = getSrrPdfStateKey(record);
        if (!key) return;
        var allState = JSON.parse(localStorage.getItem(SRR_PDF_STATE_KEY) || '{}');
        allState[key] = { page: srrState.docPage, zoom: srrState.zoom };
        localStorage.setItem(SRR_PDF_STATE_KEY, JSON.stringify(allState));
      } catch (e) { console.warn('[SRR] Failed to save PDF state:', e); }
    }
    
    // v1.4.13: Helper to coerce and validate PDF URL
    function srrNormalizePdfValue(val) {
      if (val === null || val === undefined) return '';
      return String(val).trim();
    }
    
    // v1.4.15: Resolve file_url/file_name from record using column mapping or case-insensitive key scan
    var SRR_FILE_URL_ALIASES = ['file_url', 'fileurl', 'file url', 'url', 'contract source', 'contract url', 'pdf url', 'source', 'document_url', 'doc_url', 'link', 'file_url_c', 'file_url__c'];
    var SRR_FILE_NAME_ALIASES = ['file_name', 'filename', 'file name', 'contract file', 'contract file name', 'document', 'doc_name', 'file_name_c', 'file_name__c'];
    
    function srrResolveFieldValue(record, fieldType) {
      if (!record) return '';
      
      // First try column mapping state (set during workbook parsing)
      if (fieldType === 'file_url' && COLUMN_MAPPING_STATE.fileUrlColumn) {
        var val = record[COLUMN_MAPPING_STATE.fileUrlColumn];
        if (val) return srrNormalizePdfValue(val);
      }
      if (fieldType === 'file_name' && COLUMN_MAPPING_STATE.fileNameColumn) {
        var val = record[COLUMN_MAPPING_STATE.fileNameColumn];
        if (val) return srrNormalizePdfValue(val);
      }
      
      // Fallback: scan all record keys for aliases (case-insensitive)
      var aliases = fieldType === 'file_url' ? SRR_FILE_URL_ALIASES : SRR_FILE_NAME_ALIASES;
      var keys = Object.keys(record);
      
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var keyLower = key.toLowerCase().replace(/__/g, '_').replace(/_c$/, '');
        
        for (var j = 0; j < aliases.length; j++) {
          var alias = aliases[j].toLowerCase().replace(/_/g, '').replace(/\s+/g, '');
          var keyNorm = keyLower.replace(/_/g, '');
          
          if (keyNorm === alias || keyLower === aliases[j]) {
            var val = record[key];
            if (val) return srrNormalizePdfValue(val);
          }
        }
      }
      
      return '';
    }
    
    function srrIsValidPdfUrl(url) {
      if (!url || typeof url !== 'string') return false;
      var lower = url.toLowerCase();
      if (!lower.startsWith('http://') && !lower.startsWith('https://')) return false;
      var pathPart = lower.split('?')[0];
      return pathPart.endsWith('.pdf') || lower.includes('.pdf?') || lower.includes('/pdf');
    }
    
    function srrHidePdfError() {
      var errorEl = document.getElementById('srr-pdf-error');
      if (errorEl) errorEl.style.display = 'none';
    }
    
    function srrShowPdfError(title, msg, networkUrl, hasLocalFallback) {
      var errorEl = document.getElementById('srr-pdf-error');
      var titleEl = document.getElementById('srr-pdf-error-title');
      var msgEl = document.getElementById('srr-pdf-error-msg');
      var openTabEl = document.getElementById('srr-pdf-open-tab');
      var useLocalBtn = document.getElementById('srr-pdf-use-local');
      
      if (!errorEl) return;
      
      if (titleEl) titleEl.textContent = title || 'PDF failed to render';
      if (msgEl) msgEl.textContent = msg || 'The document could not be displayed in the viewer.';
      
      if (openTabEl) {
        if (networkUrl) {
          openTabEl.href = networkUrl;
          openTabEl.style.display = 'inline';
        } else {
          openTabEl.style.display = 'none';
        }
      }
      
      if (useLocalBtn) {
        useLocalBtn.style.display = hasLocalFallback ? 'inline-block' : 'none';
      }
      
      errorEl.style.display = 'block';
    }
    
    function srrSwitchToLocalAttachment() {
      if (!srrState.localAttachmentFallback) {
        console.warn('[SRR_PDF] No local attachment fallback available');
        return;
      }
      
      srrHidePdfError();
      srrState.currentPdfUrl = srrState.localAttachmentFallback.url;
      srrState.pdfSourceType = 'Local Attachment';
      srrState.useFragmentZoom = true; // Local object URLs support fragments
      
      var sourceTypeEl = document.getElementById('srr-doc-source-type');
      var sourceNameEl = document.getElementById('srr-doc-source-name');
      if (sourceTypeEl) sourceTypeEl.textContent = 'Local Attachment:';
      if (sourceNameEl) sourceNameEl.textContent = srrState.localAttachmentFallback.name || '';
      
      srrUpdateIframeSrc();
      console.log('[SRR_PDF_LOAD] Switched to local attachment:', srrState.localAttachmentFallback.name);
    }
    
    // v1.4.13: Cache-aware PDF loading with offline support
    // v1.4.14: Build structured log entry with sheet/row context
    function srrBuildLogEntry(sourceType, cacheStatus, url) {
      return {
        sheetName: srrState.currentSheetName || 'unknown',
        rowIndex: srrState.currentRowIndex !== undefined ? srrState.currentRowIndex : -1,
        recordKey: srrState.currentRecordKey || 'unknown',
        file_name: srrState.currentRecord ? srrResolveFieldValue(srrState.currentRecord, 'file_name') : '',
        file_url: url ? (url.length > 60 ? url.substring(0, 60) + '...' : url) : '',
        sourceType: sourceType,
        cacheStatus: cacheStatus
      };
    }
    
    function srrLoadPdfForRecord(record) {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var iframeEl = document.getElementById('srr-pdf-object');
      var sourceEl = document.getElementById('srr-doc-source');
      var sourceTypeEl = document.getElementById('srr-doc-source-type');
      var sourceNameEl = document.getElementById('srr-doc-source-name');
      
      if (!emptyEl || !containerEl || !iframeEl) return;
      
      srrHidePdfError();
      srrState.localAttachmentFallback = null;
      srrState.useFragmentZoom = true;
      srrState.networkPdfUrl = null;
      srrState.cacheStatus = null;
      
      var attachments = [];
      try {
        attachments = JSON.parse(localStorage.getItem(STORAGE_KEY_PDF_ATTACHMENTS) || '[]');
      } catch (e) {}
      
      // v1.4.14: Use recordKey from srrState, fall back to record fields
      var recordId = srrState.currentRecordKey || (record ? (record.contract_key || record.id || 'unknown') : 'no-record');
      // v1.4.15: Use field resolver for Salesforce-style columns (File_URL_c, File_Name_c, etc)
      var fileUrl = record ? srrResolveFieldValue(record, 'file_url') : '';
      var fileName = record ? srrResolveFieldValue(record, 'file_name') : '';
      
      // Compute cache key for this record
      var cacheKey = computePdfCacheKey(recordId, fileUrl);
      
      // Check if network URL is valid
      var hasNetworkUrl = srrIsValidPdfUrl(fileUrl);
      
      // Track local fallback
      if (hasNetworkUrl && attachments.length > 0) {
        var fallbackMatch = fileName ? attachments.find(function(a) { return a.file_name === fileName; }) : attachments[0];
        if (fallbackMatch && fallbackMatch.local_object_url) {
          srrState.localAttachmentFallback = { url: fallbackMatch.local_object_url, name: fallbackMatch.file_name };
        }
      }
      
      // Try cache first for network URLs
      if (hasNetworkUrl) {
        srrState.networkPdfUrl = fileUrl;
        
        getCachedPdf(cacheKey).then(function(cachedBlob) {
          if (cachedBlob) {
            // Cache hit - render from cached blob
            var objectUrl = URL.createObjectURL(cachedBlob);
            srrState.cacheStatus = 'hit';
            srrRenderPdf(record, objectUrl, 'Cached', fileName || fileUrl.split('/').pop().split('?')[0], srrBuildLogEntry('Cached', 'hit', fileUrl));
            console.log('[PDF_CACHE] Cache hit for:', cacheKey);
          } else {
            // Cache miss - fetch from network
            srrFetchAndCachePdf(record, fileUrl, fileName, cacheKey, attachments);
          }
        });
      } else {
        // No network URL - try local attachments
        var pdfUrl = null;
        var sourceType = null;
        var sourceName = null;
        
        if (fileName && attachments.length > 0) {
          var match = attachments.find(function(a) { return a.file_name === fileName; });
          if (match && match.local_object_url) {
            pdfUrl = match.local_object_url;
            sourceType = 'Local Attachment';
            sourceName = match.file_name;
          }
        }
        
        if (!pdfUrl && attachments.length > 0 && attachments[0].local_object_url) {
          pdfUrl = attachments[0].local_object_url;
          sourceType = 'Local Attachment';
          sourceName = attachments[0].file_name;
        }
        
        if (pdfUrl) {
          srrRenderPdf(record, pdfUrl, sourceType, sourceName, srrBuildLogEntry(sourceType, 'local', 'local-attachment'));
        } else {
          srrShowEmptyState();
        }
      }
    }
    
    // v1.4.13: Fetch PDF from network and cache it
    // v1.4.14: Use structured log entries
    // v1.4.16: Route through FastAPI proxy to avoid CORS and download prompts
    function srrFetchAndCachePdf(record, networkUrl, fileName, cacheKey, attachments) {
      var recordId = srrState.currentRecordKey || (record ? (record.contract_key || record.id || 'unknown') : 'no-record');
      
      // v1.4.16: Build proxy URL if enabled
      var fetchUrl = networkUrl;
      var usingProxy = false;
      
      if (PDF_PROXY_CONFIG.ENABLED && networkUrl) {
        fetchUrl = PDF_PROXY_CONFIG.BASE_URL + '?url=' + encodeURIComponent(networkUrl);
        usingProxy = true;
        console.log('[SRR_PDF] Fetching via', PDF_PROXY_CONFIG.PROXY_TYPE, 'proxy:', fetchUrl.substring(0, 80));
      }
      
      // v1.4.17: Add auth header for Supabase proxy
      var fetchOptions = {};
      if (usingProxy && PDF_PROXY_CONFIG.AUTH_HEADER) {
        fetchOptions.headers = { 'Authorization': PDF_PROXY_CONFIG.AUTH_HEADER };
      } else if (!usingProxy) {
        fetchOptions.mode = 'cors';
      }
      
      fetch(fetchUrl, fetchOptions)
        .then(function(response) {
          if (!response.ok) throw new Error('HTTP ' + response.status);
          return response.blob();
        })
        .then(function(blob) {
          // Validate PDF signature (basic check: starts with %PDF)
          return blob.slice(0, 5).text().then(function(sig) {
            if (!sig.startsWith('%PDF')) {
              throw new Error('Invalid PDF signature');
            }
            return blob;
          });
        })
        .then(function(blob) {
          var objectUrl = URL.createObjectURL(blob);
          var sourceName = fileName || networkUrl.split('/').pop().split('?')[0];
          var sourceLabel = usingProxy ? 'Proxy' : 'URL';
          
          // Check if file is too large to cache
          if (blob.size > PDF_CACHE_CONFIG.MAX_FILE_BYTES) {
            srrState.cacheStatus = 'too-large';
            console.log('[PDF_CACHE] File too large to cache:', (blob.size / 1024 / 1024).toFixed(2), 'MB');
            srrRenderPdf(record, objectUrl, sourceLabel + ' (not cached)', sourceName, srrBuildLogEntry(sourceLabel, 'too-large', networkUrl));
          } else {
            // Cache the PDF
            cachePdf(cacheKey, networkUrl, blob).then(function(cached) {
              srrState.cacheStatus = cached ? 'cached' : 'cache-failed';
              srrRenderPdf(record, objectUrl, cached ? sourceLabel + ' (cached)' : sourceLabel, sourceName, srrBuildLogEntry(sourceLabel, cached ? 'cached' : 'cache-failed', networkUrl));
            });
          }
        })
        .catch(function(err) {
          console.warn('[SRR_PDF] Fetch failed:', err.message, usingProxy ? '(proxy)' : '(direct)');
          srrState.cacheStatus = usingProxy ? 'proxy-failed' : 'cors-blocked';
          
          // v1.4.16: If proxy failed, show clear message
          if (usingProxy) {
            // Proxy unavailable - show deterministic message
            if (srrState.localAttachmentFallback) {
              srrRenderPdf(record, srrState.localAttachmentFallback.url, 'Local Attachment (proxy unavailable)', srrState.localAttachmentFallback.name, srrBuildLogEntry('Local Attachment', 'proxy-fallback', 'local-attachment'));
              showToast('Proxy unavailable - using local attachment', 'warning');
            } else {
              srrShowOfflineStub(networkUrl);
              showToast('Proxy unavailable - start server/pdf_proxy.py', 'error');
            }
            return;
          }
          
          // v1.4.15: CORS fallback - try direct iframe src if local fallback unavailable
          if (srrState.localAttachmentFallback) {
            srrRenderPdf(record, srrState.localAttachmentFallback.url, 'Local Attachment (offline fallback)', srrState.localAttachmentFallback.name, srrBuildLogEntry('Local Attachment', 'offline-fallback', 'local-attachment'));
          } else if (networkUrl && srrIsValidPdfUrl(networkUrl)) {
            // CORS blocked but URL is valid - try direct iframe (not cached)
            var sourceName = fileName || networkUrl.split('/').pop().split('?')[0];
            console.log('[SRR_PDF] CORS blocked, trying direct iframe for:', networkUrl.substring(0, 60));
            srrRenderPdf(record, networkUrl, 'Network PDF (not cached)', sourceName, srrBuildLogEntry('URL-Direct', 'cors-blocked', networkUrl));
            showToast('Viewing network PDF (not cached due to CORS)', 'info');
          } else {
            // Show offline stub
            srrShowOfflineStub(networkUrl);
          }
        });
    }
    
    // v1.4.13: Render PDF in iframe
    function srrRenderPdf(record, pdfUrl, sourceType, sourceName, logEntry) {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var iframeEl = document.getElementById('srr-pdf-object');
      var sourceEl = document.getElementById('srr-doc-source');
      var sourceTypeEl = document.getElementById('srr-doc-source-type');
      var sourceNameEl = document.getElementById('srr-doc-source-name');
      
      var savedState = loadSrrPdfState(record);
      srrState.docPage = savedState.page || 1;
      srrState.zoom = savedState.zoom || 100;
      srrState.docTotalPages = null;
      srrState.currentPdfUrl = pdfUrl;
      srrState.pdfSourceType = sourceType;
      
      logEntry.page = srrState.docPage;
      logEntry.zoom = srrState.zoom;
      
      if (emptyEl) emptyEl.style.display = 'none';
      if (containerEl) containerEl.style.display = 'block';
      
      if (sourceEl && sourceTypeEl && sourceNameEl) {
        sourceEl.style.display = 'block';
        sourceTypeEl.textContent = sourceType + ':';
        sourceNameEl.textContent = sourceName || '';
      }
      
      srrSetupIframeHandlers(iframeEl);
      srrUpdateIframeSrc();
      srrUpdateZoomDisplay();
      srrUpdatePageDisplay();
      
      console.log('[SRR_PDF_LOAD]', JSON.stringify(logEntry));
    }
    
    // v1.4.13: Show empty state
    // v1.4.14: Use structured log with sheet/row context
    function srrShowEmptyState() {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var iframeEl = document.getElementById('srr-pdf-object');
      var sourceEl = document.getElementById('srr-doc-source');
      
      srrState.docPage = 1;
      srrState.docTotalPages = null;
      srrState.zoom = 100;
      srrState.currentPdfUrl = null;
      srrState.pdfSourceType = null;
      
      if (emptyEl) emptyEl.style.display = 'block';
      if (containerEl) containerEl.style.display = 'none';
      if (sourceEl) sourceEl.style.display = 'none';
      if (iframeEl) iframeEl.data = 'about:blank';
      srrUpdateZoomDisplay();
      srrUpdatePageDisplay();
      
      console.log('[SRR_PDF_LOAD]', JSON.stringify(srrBuildLogEntry('none', 'empty', '')));
    }
    
    // v1.4.13: Show offline stub when network unavailable and no local fallback
    // v1.4.14: Use structured log with sheet/row context
    function srrShowOfflineStub(networkUrl) {
      var emptyEl = document.getElementById('srr-doc-empty');
      var containerEl = document.getElementById('srr-doc-container');
      var sourceEl = document.getElementById('srr-doc-source');
      
      srrState.docPage = 1;
      srrState.zoom = 100;
      srrState.currentPdfUrl = null;
      srrState.pdfSourceType = null;
      
      if (containerEl) containerEl.style.display = 'none';
      if (sourceEl) sourceEl.style.display = 'none';
      
      // Show offline stub in empty state area
      if (emptyEl) {
        emptyEl.style.display = 'block';
        emptyEl.innerHTML = '<div style="font-size: 3em; margin-bottom: 10px;">ðŸ“µ</div>' +
          '<div style="font-weight: 500; color: #e65100;">Document not available offline</div>' +
          '<div style="font-size: 0.85em; color: #999; margin-top: 8px;">This PDF has not been cached. Connect to the network to view.</div>' +
          (networkUrl ? '<a href="' + networkUrl + '" target="_blank" style="display: inline-block; margin-top: 12px; color: #1565c0; text-decoration: underline;">Open in New Tab (when online)</a>' : '');
      }
      
      console.log('[SRR_PDF_LOAD]', JSON.stringify(srrBuildLogEntry('none', 'offline-no-cache', networkUrl || '')));
    }
    
    // v1.4.13: Setup iframe load/error handlers for best-effort failure detection
    function srrSetupIframeHandlers(iframeEl) {
      if (!iframeEl) return;
      
      iframeEl.onload = function() {
        console.log('[SRR_PDF] Iframe onload fired');
        srrHidePdfError();
      };
      
      iframeEl.onerror = function() {
        console.warn('[SRR_PDF] Iframe onerror fired');
        srrShowPdfError(
          'PDF failed to render',
          'The document could not be loaded. Try opening in a new tab.',
          srrState.networkPdfUrl,
          !!srrState.localAttachmentFallback
        );
      };
    }
    
    // v1.4.13: Update iframe src with fragment compatibility fallback
    function srrUpdateIframeSrc() {
      var iframeEl = document.getElementById('srr-pdf-object');
      if (!iframeEl || !srrState.currentPdfUrl) return;
      
      var baseUrl = srrState.currentPdfUrl.split('#')[0];
      
      // Build fragment: page is always included, zoom only if useFragmentZoom is true
      // Some PDF renderers break with zoom fragment, so we keep it UI-only in those cases
      // v1.6.13: Add navpanes=0 to hide thumbnail sidebar, scrollbar=1 for continuous scroll
      var fragment = '#page=' + srrState.docPage + '&navpanes=0&scrollbar=1&toolbar=1&view=FitH';
      if (srrState.useFragmentZoom !== false) {
        fragment += '&zoom=' + srrState.zoom;
      }
      
      var newSrc = baseUrl + fragment;
      
      // Only update if data changed (prevents unnecessary reloads)
      // v1.4.18: Use .data attribute for <object> element instead of .src for <iframe>
      if (iframeEl.data !== newSrc) {
        iframeEl.data = newSrc;
        // Also update the fallback link
        var openTabLink = document.getElementById('srr-pdf-open-tab');
        if (openTabLink) openTabLink.href = newSrc;
        console.log('[SRR_PDF] Set object data:', newSrc.length > 100 ? newSrc.substring(0, 100) + '...' : newSrc);
      }
    }
    
    // v1.4.13: Fallback to page-only fragment if zoom causes issues
    function srrDisableFragmentZoom() {
      srrState.useFragmentZoom = false;
      console.log('[SRR_PDF] Disabled fragment zoom, using UI-only zoom indicator');
      srrUpdateIframeSrc();
    }
    
    function srrUpdateZoomDisplay() {
      var zoomEl = document.getElementById('srr-zoom-indicator');
      var zoomInBtn = document.getElementById('srr-zoom-in');
      var zoomOutBtn = document.getElementById('srr-zoom-out');
      if (zoomEl) zoomEl.textContent = srrState.zoom + '%';
      if (zoomInBtn) zoomInBtn.disabled = srrState.zoom >= 300;
      if (zoomOutBtn) zoomOutBtn.disabled = srrState.zoom <= 50;
    }
    
    function srrUpdatePageDisplay() {
      var pageEl = document.getElementById('srr-page-indicator');
      var headerPageEl = document.getElementById('srr-doc-page');
      // Show "Page X" without total (total pages unknown with iframe rendering)
      var text = 'Page ' + srrState.docPage;
      if (pageEl) pageEl.textContent = text;
      if (headerPageEl) headerPageEl.textContent = text;
      
      var prevBtn = document.getElementById('srr-prev-btn');
      var nextBtn = document.getElementById('srr-next-btn');
      // Prev disabled at page 1; Next always enabled (total unknown)
      if (prevBtn) prevBtn.disabled = srrState.docPage <= 1;
      if (nextBtn) nextBtn.disabled = false;
    }
    
    function srrPrevPage() {
      if (srrState.docPage > 1) {
        srrState.docPage--;
        srrUpdateIframeSrc();
        srrUpdatePageDisplay();
        saveSrrPdfState(srrState.currentRecord);
        console.log('[SRR] Page:', srrState.docPage);
      }
    }
    
    function srrNextPage() {
      // Allow increment (total pages unknown with iframe)
      srrState.docPage++;
      srrUpdateIframeSrc();
      srrUpdatePageDisplay();
      saveSrrPdfState(srrState.currentRecord);
      console.log('[SRR] Page:', srrState.docPage);
    }
    
    function srrZoomIn() {
      if (srrState.zoom < 300) {
        srrState.zoom = Math.min(srrState.zoom + 25, 300);
        srrUpdateIframeSrc();
        srrUpdateZoomDisplay();
        saveSrrPdfState(srrState.currentRecord);
        console.log('[SRR] Zoom:', srrState.zoom + '%');
      }
    }
    
    function srrZoomOut() {
      if (srrState.zoom > 50) {
        srrState.zoom = Math.max(srrState.zoom - 25, 50);
        srrUpdateIframeSrc();
        srrUpdateZoomDisplay();
        saveSrrPdfState(srrState.currentRecord);
        console.log('[SRR] Zoom:', srrState.zoom + '%');
      }
    }
    
    // Patch actions
    // v1.4.18: Save Evidence Pack draft (AC-03)
    // v1.4.19: Set patch type and update form sections
    // v1.4.20: Internal patch type setter (now auto-driven, not user-clickable)
    function srrSetPatchType(type) {
      srrState.patchType = type;
      srrState.patchDraft.patch_type = type;
      srrUpdatePatchTypeDisplay();
      srrUpdatePatchFormSections();
      srrSaveEvidenceDraft();
      console.log('[SRR] Patch type auto-set:', type);
    }
    
    // v1.4.20: Update patch type display (read-only indicator)
    function srrUpdatePatchTypeDisplay() {
      // Update chips to match current patch type
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === srrState.patchType) chip.classList.add('active');
      });
      // Update form sections
      srrUpdatePatchFormSections();
    }
    
    // v1.4.20: Guard modal for leaving SRR with unresolved fields
    function srrShowGuardModal() {
      var count = srrGetUnresolvedCount();
      var modal = document.getElementById('srr-guard-modal');
      var countEl = document.getElementById('srr-guard-count');
      if (countEl) countEl.textContent = count;
      if (modal) modal.classList.add('visible');
    }
    
    function srrHideGuardModal() {
      var modal = document.getElementById('srr-guard-modal');
      if (modal) modal.classList.remove('visible');
    }
    
    
    // v1.4.19: Update form sections based on patch type
    function srrUpdatePatchFormSections() {
      var type = srrState.patchType;
      var isCorrection = type === 'correction';
      var isBlacklist = type === 'blacklist';
      var isRfi = type === 'rfi';
      
      // Observation/Expected blocks (Correction only)
      var obsBlock = document.getElementById('srr-observation-block');
      var expBlock = document.getElementById('srr-expected-block');
      if (obsBlock) obsBlock.classList.toggle('srr-section-hidden', !isCorrection);
      if (expBlock) expBlock.classList.toggle('srr-section-hidden', !isCorrection);
      
      // Repro block (Correction only, when not override)
      var reproBlock = document.getElementById('srr-repro-block');
      if (reproBlock) {
        var showRepro = isCorrection && !srrState.overrideEnabled;
        reproBlock.classList.toggle('srr-section-hidden', !showRepro);
      }
      
      // Override section (Correction only, when applicable)
      var overrideSection = document.getElementById('srr-override-section');
      if (overrideSection) {
        var showOverride = isCorrection && srrIsOverrideApplicable();
        overrideSection.classList.toggle('srr-section-hidden', !showOverride);
      }
      
      // Override badge
      var overrideBadge = document.getElementById('srr-override-badge');
      if (overrideBadge) {
        overrideBadge.classList.toggle('srr-section-hidden', !srrState.overrideEnabled);
      }
      
      // Blacklist Subject (Blacklist Flag only)
      var blacklistSection = document.getElementById('srr-blacklist-section');
      if (blacklistSection) {
        blacklistSection.classList.toggle('srr-section-hidden', !isBlacklist);
        if (isBlacklist) srrUpdateBlacklistSubject();
      }
      
      // RFI Assignment stub (RFI only)
      var rfiSection = document.getElementById('srr-rfi-section');
      if (rfiSection) rfiSection.classList.toggle('srr-section-hidden', !isRfi);
      
      // Update action box title based on patch type
      var actionBoxTitle = document.getElementById('srr-action-box-title');
      if (actionBoxTitle) {
        if (isCorrection) {
          actionBoxTitle.textContent = 'Changed Fields';
        } else if (isBlacklist) {
          actionBoxTitle.textContent = 'Blacklist Request';
        } else if (isRfi) {
          actionBoxTitle.textContent = 'RFI Request';
        }
      }
      
      // Update helper text based on patch type
      var helperEl = document.getElementById('srr-action-box-helper');
      if (helperEl && !Object.keys(srrState.proposedChanges).length) {
        if (isCorrection) {
          helperEl.textContent = 'Click a field value to edit. Changed fields appear here.';
        } else if (isBlacklist) {
          helperEl.textContent = 'Click the Block icon on a field to flag it for blacklist.';
        } else if (isRfi) {
          helperEl.textContent = 'Click the RFI icon on a field to request clarification.';
        }
      }
      
      // Update justification label (Comment for RFI)
      var justLabel = document.getElementById('srr-justification-label');
      var justTextarea = document.getElementById('srr-justification');
      if (justLabel) {
        if (isRfi) {
          justLabel.innerHTML = 'Comment';
          if (justTextarea) justTextarea.placeholder = 'Add your question or note for the team...';
        } else {
          justLabel.innerHTML = 'Justification <span class="srr-evidence-alias">(BECAUSE)</span>';
          if (justTextarea) justTextarea.placeholder = 'Explain why this change/flag is necessary...';
        }
      }
      
      // Update patch type chips
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === type) chip.classList.add('active');
      });
      
      // Update submit button text and style based on patch type
      var submitBtn = document.getElementById('srr-submit-btn');
      if (submitBtn) {
        if (isRfi) {
          submitBtn.textContent = 'Send RFI';
          submitBtn.style.background = '#f57c00';  // Orange for RFI
        } else if (isBlacklist) {
          submitBtn.textContent = 'Submit Blacklist';
          submitBtn.style.background = '#d32f2f';  // Red for blacklist
        } else {
          submitBtn.textContent = 'Submit Patch Request';
          submitBtn.style.background = '#1565c0';  // Blue default
        }
      }
    }
    
    // Handle patch type dropdown change
    function srrOnPatchTypeChange(newType) {
      // v1.5.2: If a field is selected, apply the action to that field
      if (srrPeSelectedField) {
        var fieldKey = srrPeSelectedField.key;
        var fieldLabel = srrPeSelectedField.label;
        var record = srrState.currentRecord;
        var currentValue = record ? record[fieldKey] : '';
        
        console.log('[SRR] Patch type chip action:', newType, 'on field:', fieldKey);
        
        if (newType === 'rfi') {
          // Same as srrRfiField
          srrState.rfiField = { key: fieldKey, label: fieldLabel, value: currentValue };
          srrState.fieldStates[fieldKey] = 'rfi_pending';
          showToast('RFI started for: ' + fieldLabel, 'info');
        } else if (newType === 'blacklist') {
          // Same as srrBlacklistField
          srrState.fieldStates[fieldKey] = 'blocked';
          srrState.patchDraft.blacklist_subject = fieldLabel + ': ' + (currentValue || '(empty)');
          var subjectEl = document.getElementById('srr-blacklist-subject-value');
          if (subjectEl) {
            subjectEl.textContent = fieldLabel + ': ' + (currentValue || '(empty)');
          }
          showToast('Blacklist flag set for: ' + fieldLabel, 'info');
        } else if (newType === 'correction') {
          // Set up for correction / edit mode
          if (!srrState.proposedChanges[fieldKey]) {
            srrState.proposedChanges[fieldKey] = {
              field: fieldKey,
              label: fieldLabel,
              from: currentValue,
              to: currentValue,
              category: 'correction'
            };
          }
          srrState.fieldStates[fieldKey] = 'modified';
          showToast('Correction mode for: ' + fieldLabel, 'info');
        }
        
        // Refresh Field Inspector
        renderSrrFields(srrState.currentRecord);
      }
      
      // Update patch type state
      srrState.patchType = newType;
      srrState.patchDraft.patch_type = newType;
      srrUpdatePatchFormSections();
      srrRenderPatchEditor();
      srrSaveEvidenceDraft();
      console.log('[SRR] Patch type changed to:', newType);
    }
    
    // v1.4.19: Check if override is applicable based on observation/expected
    function srrIsOverrideApplicable() {
      var obsType = document.getElementById('srr-observation-type').value;
      var expType = document.getElementById('srr-expected-type').value;
      return obsType === 'override_needed' || expType === 'allow_override';
    }
    
    // v1.4.19: Toggle override
    function srrToggleOverride() {
      srrState.overrideEnabled = !srrState.overrideEnabled;
      var toggle = document.getElementById('srr-override-toggle');
      if (toggle) toggle.classList.toggle('active', srrState.overrideEnabled);
      srrUpdatePatchFormSections();
      srrSaveEvidenceDraft();
      console.log('[SRR] Override toggled:', srrState.overrideEnabled);
    }
    
    // v1.4.19: Update Blacklist Subject from selected field
    function srrUpdateBlacklistSubject() {
      var changes = Object.values(srrState.proposedChanges);
      var subjectEl = document.getElementById('srr-blacklist-subject-value');
      if (!subjectEl) return;
      
      if (changes.length === 0) {
        subjectEl.textContent = '(No field selected â€” edit a field first)';
      } else if (changes.length === 1) {
        subjectEl.textContent = changes[0].label + ': ' + (changes[0].to || changes[0].from);
      } else {
        subjectEl.textContent = changes.length + ' fields: ' + changes.map(function(c) { return c.label; }).join(', ');
      }
    }
    
    // v1.4.19: Handle observation change (show/hide override)
    function srrOnObservationChange() {
      srrSaveEvidenceDraft();
      srrUpdatePatchFormSections();
    }
    
    // v1.4.19: Handle expected change (show/hide override)
    function srrOnExpectedChange() {
      srrSaveEvidenceDraft();
      srrUpdatePatchFormSections();
    }
    
    function srrSaveEvidenceDraft() {
      srrState.patchDraft.patch_type = srrState.patchType;
      srrState.patchDraft.observation_type = document.getElementById('srr-observation-type').value;
      srrState.patchDraft.expected_type = document.getElementById('srr-expected-type').value;
      srrState.patchDraft.justification = document.getElementById('srr-justification').value;
      srrState.patchDraft.repro_type = document.getElementById('srr-repro-type').value;
      // RFI target stub - no input field yet (coming soon)
      srrState.patchDraft.rfi_target = '';
      srrState.patchDraft.override_enabled = srrState.overrideEnabled;
    }
    
    // v1.4.18: Handle repro file attachment
    function srrHandleReproFile(input) {
      if (input.files && input.files[0]) {
        srrState.patchDraft.repro_file = input.files[0];
        document.getElementById('srr-repro-file-name').textContent = input.files[0].name;
        console.log('[SRR] Repro file attached:', input.files[0].name);
      }
    }
    
    function srrSaveDraft() {
      srrSaveEvidenceDraft();
      
      // Emit audit event (stub)
      console.log('[SRR] PATCH_DRAFTED:', srrState.patchDraft);
      showToast('Draft saved', 'success');
    }
    
    function srrSubmitPatchRequest() {
      // Save current values
      srrSaveEvidenceDraft();
      
      var patchType = srrState.patchType;
      var changeCount = Object.keys(srrState.proposedChanges).length;
      var justification = srrState.patchDraft.justification;
      
      // v1.4.19: Validation based on patch type
      if (patchType === 'correction') {
        // Correction: Observation + Expected + Justification required
        var obsType = srrState.patchDraft.observation_type;
        var expType = srrState.patchDraft.expected_type;
        
        if (!obsType) {
          showToast('Please select an Observation type', 'warning');
          return;
        }
        if (!expType) {
          showToast('Please select an Expected behavior type', 'warning');
          return;
        }
        if (changeCount === 0) {
          showToast('Please make at least one field change', 'warning');
          return;
        }
        // Repro required unless override is enabled
        if (!srrState.overrideEnabled && !srrState.patchDraft.repro_type) {
          showToast('Please select a Repro method (or enable Override)', 'warning');
          return;
        }
        // Doc Evidence Mismatch requires file attachment
        if (srrState.patchDraft.repro_type === 'doc_evidence_mismatch' && !srrState.patchDraft.repro_file) {
          showToast('Doc Evidence Mismatch requires a file attachment', 'warning');
          return;
        }
      } else {
        // Blacklist Flag or RFI: Justification only required
        if (!justification || justification.trim().length < 10) {
          showToast('Please provide a justification (minimum 10 characters)', 'warning');
          return;
        }
      }
      
      // v1.4.19: Build patch request based on type
      var changes = Object.values(srrState.proposedChanges);
      var changeSummary = changes.length > 0 ? changes.map(function(c) {
        return c.label + ': ' + (c.from || '(empty)') + ' â†’ ' + c.to;
      }).join('; ') : '(no field changes)';
      
      var record = srrState.currentRecord || {};
      var author = getCurrentUserName();  // v1.6.31: Use logged-in user
      
      // Determine action type based on patch type
      var actionType = patchType === 'correction' ? 'SET_VALUE' : (patchType === 'blacklist' ? 'BLACKLIST' : 'RFI');
      var whenText = patchType === 'correction' ? 'Field value is incorrect' : 
                     (patchType === 'blacklist' ? 'Value should be blacklisted' : 'Clarification needed');
      
      // v1.5.2: Get stable record_id from record identity
      var recordId = (record._identity && record._identity.record_id) || record.record_id || record.contract_key || srrState.currentRecordKey;
      var datasetId = (record._identity && record._identity.dataset_id) || IDENTITY_CONTEXT.dataset_id || sessionState.fileName || 'default';
      
      var request = createPatchRequest({
        author: author,
        author_role: currentMode || 'Analyst',
        // v1.5.2: Include record_id and dataset_id
        record_id: recordId,
        dataset_id: datasetId,
        tenant_id: IDENTITY_CONTEXT.tenant_id,
        division_id: IDENTITY_CONTEXT.division_id,
        contract_key: record.contract_key || srrState.currentRecordKey,
        file_url: srrResolveFieldValue(record, 'file_url'),
        file_name: srrResolveFieldValue(record, 'file_name'),
        sheet: srrState.currentSheetName,
        field: changes.length === 1 ? changes[0].field : (changes.length > 1 ? '(multiple)' : '(none)'),
        target: 'field_values',
        target_field: changes.length === 1 ? changes[0].field : null,
        condition_type: 'FIELD_VALUE',
        action_type: actionType,
        patch_type: patchType,
        patch_kind: patchType,
        override_enabled: srrState.overrideEnabled,
        old_value: changes.length > 0 ? changes[0].from : '',
        new_value: changes.length > 0 ? changes[0].to : '',
        proposed_changes: changes.map(function(c) { return { field: c.field, old_value: c.from, new_value: c.to }; }),
        when: whenText,
        then: changeSummary,
        because: justification || '',
        evidence_observation: patchType === 'correction' ? srrState.patchDraft.observation_type : '',
        evidence_expected: patchType === 'correction' ? srrState.patchDraft.expected_type : '',
        evidence_justification: justification,
        evidence_repro: patchType === 'correction' ? srrState.patchDraft.repro_type : '',
        rfi_target: patchType === 'rfi' ? srrState.patchDraft.rfi_target : '',
        rationale: changeSummary
      });
      
      // Submit the patch request
      var submittedRequest = submitPatchRequest(request.request_id, author, currentMode || 'Analyst');
      
      // v1.5.1: Create artifact in artifact store (primary)
      var fieldKey = changes.length > 0 ? changes[0].field : (srrState.rfiField ? srrState.rfiField.key : 'N/A');
      // v1.5.2: Use stable recordId and datasetId from identity model
      var artifact = createArtifact({
        dataset_id: datasetId,
        record_id: recordId,
        field_key: fieldKey,
        artifact_type: patchType === 'rfi' ? 'rfi' : 'patch_request',
        status: 'open',
        created_by_actor_id: author,
        created_by_role: currentMode || 'analyst',
        sheet_name: srrState.currentSheetName,
        file_url: srrResolveFieldValue(record, 'file_url'),
        file_name: srrResolveFieldValue(record, 'file_name'),
        body: {
          patch_type: patchType,
          patch_request_id: request.request_id,
          old_value: changes.length > 0 ? changes[0].from : (srrState.rfiField ? srrState.rfiField.value : ''),
          new_value: changes.length > 0 ? changes[0].to : '',
          comment: justification,
          changes: changes,
          override_enabled: srrState.overrideEnabled,
          evidence: {
            observation_type: srrState.patchDraft.observation_type,
            expected_type: srrState.patchDraft.expected_type,
            repro_type: srrState.patchDraft.repro_type,
            justification: justification
          },
          legacy_request_id: request.request_id
        }
      });
      
      // v1.5.2: Add to verifier queue with proper identity fields
      addVerifierPayload({
        id: artifact.artifact_id,
        type: patchType,
        // v1.5.2: Use stable record_id and include dataset_id + patch_request_id
        record_id: recordId,
        dataset_id: datasetId,
        patch_request_id: request.request_id,
        division_id: IDENTITY_CONTEXT.division_id,
        field: fieldKey,
        old_value: changes.length > 0 ? changes[0].from : (srrState.rfiField ? srrState.rfiField.value : ''),
        new_value: changes.length > 0 ? changes[0].to : '',
        comment: justification,
        analyst_id: author,
        timestamp: new Date().toISOString(),
        status: 'pending',
        artifact_id: artifact.artifact_id
      });
      
      // Update local state
      srrState.patchDraft.status = 'Submitted';
      
      // Update field states based on patch type
      if (patchType === 'correction') {
        // Correction: Set all modified fields to 'submitted' (clears from To Do)
        Object.keys(srrState.proposedChanges).forEach(function(fieldKey) {
          srrState.fieldStates[fieldKey] = 'submitted';
        });
      }
      // v1.5.3 Fix: RFI submit should only clear the selected field, preserve other pending RFIs
      if (patchType === 'rfi') {
        // Only change the selected field's state, not all rfi_pending fields
        var selectedField = srrState.selectedField || srrState.rfiField?.key;
        if (selectedField && srrState.fieldStates[selectedField] === 'rfi_pending') {
          srrState.fieldStates[selectedField] = 'rfi';
        }
        // If specific field from changes, use that
        if (changes.length === 1 && changes[0].field) {
          srrState.fieldStates[changes[0].field] = 'rfi';
        }
      }
      // Blocked fields stay as 'blocked' (already set when Blacklist clicked)
      
      // Re-render field list to reflect state changes
      renderSrrFields(srrState.currentRecord);
      
      // Emit audit events
      console.log('[SRR] PATCH_SUBMITTED (' + patchType + '):', request);
      console.log('[SRR] REVIEW_REQUESTED: patch_id=' + request.request_id);
      
      // Show appropriate toast based on patch type
      if (patchType === 'rfi') {
        showToast('RFI sent â€” analyst handoff complete', 'success');
      } else if (patchType === 'blacklist') {
        showToast('Blacklist submitted â€” visible in Patch Console', 'success');
      } else {
        showToast('Patch Request submitted â€” visible in Patch Console', 'success');
      }
      
      // v1.5.0: Reset Patch Editor state after submission
      resetPatchEditorState();
    }
    
    function resetPatchEditorState() {
      // Reset patch draft in srrState
      srrState.patchDraft = {
        patch_type: 'correction',
        observation_type: '',
        expected_type: '',
        justification: '',
        repro_type: '',
        repro_file: null,
        rfi_target: '',
        blacklist_category: '',
        blacklist_subject: '',
        changes: [],
        status: 'Draft'
      };
      srrState.patchType = 'correction';
      srrState.overrideEnabled = false;
      srrState.rfiField = null;
      srrState.proposedChanges = {};
      srrState.lockedFields = {};
      
      // Reset form inputs
      var obsEl = document.getElementById('srr-observation-type');
      var expEl = document.getElementById('srr-expected-type');
      var justEl = document.getElementById('srr-justification');
      var reproEl = document.getElementById('srr-repro-type');
      
      if (obsEl) obsEl.value = '';
      if (expEl) expEl.value = '';
      if (justEl) justEl.value = '';
      if (reproEl) reproEl.value = '';
      
      // Reset patch type chips
      document.querySelectorAll('.srr-patch-chip').forEach(function(chip) {
        chip.classList.toggle('active', chip.dataset.patchtype === 'correction');
      });
      
      // Clear override toggle
      var overrideToggle = document.getElementById('srr-override-toggle');
      if (overrideToggle) overrideToggle.checked = false;
      
      // Clear blacklist subject display
      var blacklistEl = document.getElementById('srr-blacklist-subject');
      if (blacklistEl) blacklistEl.textContent = '';
      
      // Clear RFI display
      var rfiEl = document.getElementById('srr-rfi-request-display');
      if (rfiEl) rfiEl.innerHTML = '';
      
      // Clear old/new value displays in patch editor
      var oldValEl = document.getElementById('srr-patch-old-value');
      var newValEl = document.getElementById('srr-patch-new-value');
      if (oldValEl) oldValEl.textContent = '';
      if (newValEl) newValEl.value = '';
      
      // Update visibility of conditional sections
      if (typeof updatePatchEditorSections === 'function') {
        updatePatchEditorSections();
      }
      
      console.log('[SRR] Patch Editor state reset');
    }
    
    // v1.6.4: Show audit log for current record using meta sheet data
    function showAuditLogForRecord() {
      var rowId = srrState.currentRowId;
      console.log('[SRR] Opening audit log for record:', rowId);
      
      // Build record object with current SRR context
      var record = {
        sheet: srrState.currentSheet,
        rowIndex: srrState.currentRowIndex,
        recordKey: srrState.currentSheet + ':' + srrState.currentRowIndex
      };
      
      // Get audit entries from meta sheets
      var auditEntries = getAuditEntriesForRecord(record);
      
      if (auditEntries.length === 0) {
        showToast('No audit log entries for this record', 'info');
        return;
      }
      
      // Show audit log in a modal or drawer
      showAuditLogModal(auditEntries);
    }
    
    // v1.6.4: Get audit entries from meta sheets for a specific record
    function getAuditEntriesForRecord(record) {
      var entries = [];
      if (!workbook || !workbook.sheets) return entries;
      
      // Get current record info for filtering - use record param if available, else srrState
      var currentSheet = '';
      var currentRowIndex = -1;
      var recordKey = '';
      
      if (record && record.sheet && typeof record.rowIndex !== 'undefined') {
        currentSheet = record.sheet;
        currentRowIndex = record.rowIndex;
        recordKey = record.recordKey || (record.sheet + ':' + record.rowIndex);
      } else {
        currentSheet = srrState.currentSheet || '';
        currentRowIndex = typeof srrState.currentRowIndex === 'number' ? srrState.currentRowIndex : -1;
        recordKey = currentSheet + ':' + currentRowIndex;
      }
      
      if (!currentSheet || currentRowIndex < 0) return entries;
      
      var metaSheets = getMetaSheets();
      metaSheets.forEach(function(sheetName) {
        var sheet = workbook.sheets[sheetName];
        if (!sheet || !sheet.rows) return;
        
        sheet.rows.forEach(function(row, idx) {
          // v1.6.4: Filter entries to match current record
          var rowSheet = row.Sheet || row.sheet || row.Source_Sheet || '';
          var rowNumRaw = row['Row #'] || row.Row || row.row_index || row.RowIndex || '';
          var rowRecordKey = row.RecordKey || row.record_key || row.Record_ID || '';
          
          // Normalize row number: meta sheets typically use 1-based, SRR uses 0-based
          var rowNum = rowNumRaw !== '' ? parseInt(rowNumRaw, 10) : -1;
          var matchesRow0Based = rowNum === currentRowIndex;
          var matchesRow1Based = rowNum === (currentRowIndex + 1);
          
          // Exact sheet match only
          var matchesSheet = rowSheet === currentSheet;
          
          // Match by sheet+row (either 0-based or 1-based) OR by record key
          var matchesByRecordKey = rowRecordKey && rowRecordKey === recordKey;
          var matchesBySheetRow = matchesSheet && (matchesRow0Based || matchesRow1Based);
          
          if (matchesBySheetRow || matchesByRecordKey) {
            entries.push({
              sheet: sheetName,
              row_index: idx,
              timestamp: row.Timestamp || row.timestamp || row.Created_Date || new Date().toISOString(),
              action: row.Action || row.action || row.Change_Type || row.Note_Type || 'Update',
              field: row.Field || row.field || row.Changed_Field || row['Field Name'] || '',
              old_value: row.Old_Value || row.old_value || row.Previous || '',
              new_value: row.New_Value || row.new_value || row.Current || '',
              summary: row.Summary || row.summary || row.Notes || row.Comment || row.Note_Text || '',
              done_by: 'Done by user' // v1.6.4: All entries show "Done by user"
            });
          }
        });
      });
      
      // Sort by timestamp descending
      entries.sort(function(a, b) {
        return new Date(b.timestamp) - new Date(a.timestamp);
      });
      
      return entries;
    }
    
    // v1.6.4: Show audit log modal
    function showAuditLogModal(entries) {
      var html = '<div style="max-height: 60vh; overflow-y: auto;">';
      html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">';
      html += '<thead><tr style="background: #f5f5f5;"><th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Action</th><th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Field</th><th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Summary</th><th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Done By</th></tr></thead>';
      html += '<tbody>';
      
      entries.slice(0, 50).forEach(function(entry) {
        html += '<tr style="border-bottom: 1px solid #eee;">';
        html += '<td style="padding: 8px;"><span style="background: #e3f2fd; color: #1565c0; padding: 2px 6px; border-radius: 4px; font-size: 0.8em;">' + escapeHtml(entry.action) + '</span></td>';
        html += '<td style="padding: 8px; font-family: monospace; font-size: 0.85em;">' + escapeHtml(entry.field || '-') + '</td>';
        html += '<td style="padding: 8px;">' + escapeHtml(entry.summary || '-') + '</td>';
        html += '<td style="padding: 8px; color: #666;">' + escapeHtml(entry.done_by) + '</td>';
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      if (entries.length > 50) {
        html += '<div style="padding: 10px; text-align: center; color: #666;">Showing 50 of ' + entries.length + ' entries</div>';
      }
      html += '</div>';
      
      showInfoModal('Audit Log (' + entries.length + ' entries)', html);
    }
    
    // v1.6.4: Simple info modal helper
    function showInfoModal(title, contentHtml) {
      var overlay = document.createElement('div');
      overlay.className = 'modal-overlay active';
      overlay.id = 'info-modal-overlay';
      overlay.onclick = function(e) { if (e.target === overlay) overlay.remove(); };
      
      overlay.innerHTML = '<div class="modal" style="max-width: 700px;">' +
        '<div class="modal-header"><h3>' + escapeHtml(title) + '</h3><button class="modal-close" onclick="document.getElementById(\'info-modal-overlay\').remove()">&times;</button></div>' +
        '<div class="modal-body">' + contentHtml + '</div>' +
        '<div class="modal-footer"><button class="modal-btn modal-btn-secondary" onclick="document.getElementById(\'info-modal-overlay\').remove()">Close</button></div>' +
        '</div>';
      
      document.body.appendChild(overlay);
    }

    // ========== VERIFIER TRIAGE & PAYLOAD SYSTEM (v1.5.2) ==========
    var verifierQueueState = {
      activeQueue: 'pending',
      payloads: JSON.parse(localStorage.getItem('srr_verifier_queue_v1') || '[]')
    };
    
    // v1.5.2: Reviewer filter state with persistence
    var reviewerFilterState = {
      division: localStorage.getItem('reviewer_filter_division') || '',
      status: localStorage.getItem('reviewer_filter_status') || '',
      patchType: localStorage.getItem('reviewer_filter_patchtype') || ''
    };
    
    function onReviewerFilterChange() {
      var divisionEl = document.getElementById('reviewer-filter-division');
      var statusEl = document.getElementById('reviewer-filter-status');
      
      reviewerFilterState.division = divisionEl ? divisionEl.value : '';
      reviewerFilterState.status = statusEl ? statusEl.value : '';
      
      // Persist to localStorage
      localStorage.setItem('reviewer_filter_division', reviewerFilterState.division);
      localStorage.setItem('reviewer_filter_status', reviewerFilterState.status);
      
      // Re-render triage with filters
      renderVerifierTriage();
      
      // Also re-render grid if in reviewer mode
      if (currentMode === 'reviewer') {
        renderReviewerGrid();
      }
      
      console.log('[Reviewer] Filter changed:', reviewerFilterState);
    }
    
    function setReviewerPatchType(ptype) {
      reviewerFilterState.patchType = ptype;
      localStorage.setItem('reviewer_filter_patchtype', ptype);
      
      // Update tab styling
      document.querySelectorAll('.pt-tab').forEach(function(tab) {
        var tabPtype = tab.getAttribute('data-ptype');
        if (tabPtype === ptype) {
          tab.style.background = '#e3f2fd';
          tab.style.color = '#1565c0';
          tab.style.border = '1px solid #1565c0';
        } else {
          tab.style.background = '#f5f5f5';
          tab.style.color = '#333';
          tab.style.border = '1px solid #ddd';
        }
      });
      
      renderVerifierTriage();
      console.log('[Reviewer] Patch type changed:', ptype);
    }
    
    function initReviewerFilters() {
      // Populate division dropdown from PatchRequest store
      var divisions = new Set();
      var hasUnassigned = false;
      var allPRs = PATCH_REQUEST_STORE.list();
      
      allPRs.forEach(function(pr) {
        if (pr.division_id) {
          divisions.add(pr.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      // Also scan verifier queue payloads
      verifierQueueState.payloads.forEach(function(p) {
        if (p.division_id) {
          divisions.add(p.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      var divisionEl = document.getElementById('reviewer-filter-division');
      if (divisionEl) {
        divisionEl.innerHTML = '<option value="">All Divisions</option>';
        // Add Unassigned option if there are items without division_id
        if (hasUnassigned) {
          var unassignedOpt = document.createElement('option');
          unassignedOpt.value = '__unassigned__';
          unassignedOpt.textContent = 'Unassigned';
          divisionEl.appendChild(unassignedOpt);
        }
        Array.from(divisions).sort().forEach(function(div) {
          var opt = document.createElement('option');
          opt.value = div;
          opt.textContent = div;
          divisionEl.appendChild(opt);
        });
        
        // Restore saved filter
        divisionEl.value = reviewerFilterState.division;
      }
      
      var statusEl = document.getElementById('reviewer-filter-status');
      if (statusEl) {
        statusEl.value = reviewerFilterState.status;
      }
      
      // Restore patch type tab styling
      if (reviewerFilterState.patchType) {
        setReviewerPatchType(reviewerFilterState.patchType);
      } else {
        updatePatchTypeCounts();
      }
      
      // Also init grid filter dropdowns
      initReviewerGridFilters();
    }
    
    function updatePatchTypeCounts() {
      var counts = { all: 0, correction: 0, blacklist: 0, rfi: 0 };
      verifierQueueState.payloads.forEach(function(p) {
        counts.all++;
        if (p.type === 'correction') counts.correction++;
        else if (p.type === 'blacklist') counts.blacklist++;
        else if (p.type === 'rfi') counts.rfi++;
      });
      
      var allEl = document.getElementById('pt-count-all');
      var corrEl = document.getElementById('pt-count-correction');
      var blEl = document.getElementById('pt-count-blacklist');
      var rfiEl = document.getElementById('pt-count-rfi');
      
      if (allEl) allEl.textContent = '(' + counts.all + ')';
      if (corrEl) corrEl.textContent = '(' + counts.correction + ')';
      if (blEl) blEl.textContent = '(' + counts.blacklist + ')';
      if (rfiEl) rfiEl.textContent = '(' + counts.rfi + ')';
    }
    
    function initReviewerGridFilters() {
      // Populate grid division dropdown (same data as triage)
      var divisions = new Set();
      var hasUnassigned = false;
      var allPRs = PATCH_REQUEST_STORE.list();
      
      allPRs.forEach(function(pr) {
        if (pr.division_id) {
          divisions.add(pr.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      verifierQueueState.payloads.forEach(function(p) {
        if (p.division_id) {
          divisions.add(p.division_id);
        } else {
          hasUnassigned = true;
        }
      });
      
      var divisionEl = document.getElementById('reviewer-grid-filter-division');
      if (divisionEl) {
        divisionEl.innerHTML = '<option value="">All Divisions</option>';
        // Add Unassigned option if there are items without division_id
        if (hasUnassigned) {
          var unassignedOpt = document.createElement('option');
          unassignedOpt.value = '__unassigned__';
          unassignedOpt.textContent = 'Unassigned';
          divisionEl.appendChild(unassignedOpt);
        }
        Array.from(divisions).sort().forEach(function(div) {
          var opt = document.createElement('option');
          opt.value = div;
          opt.textContent = div;
          divisionEl.appendChild(opt);
        });
        divisionEl.value = reviewerFilterState.division;
      }
      
      var statusEl = document.getElementById('reviewer-grid-filter-status');
      if (statusEl) {
        statusEl.value = reviewerFilterState.status;
      }
    }
    
    function onReviewerGridFilterChange() {
      var divisionEl = document.getElementById('reviewer-grid-filter-division');
      var statusEl = document.getElementById('reviewer-grid-filter-status');
      
      reviewerFilterState.division = divisionEl ? divisionEl.value : '';
      reviewerFilterState.status = statusEl ? statusEl.value : '';
      
      // Persist
      localStorage.setItem('reviewer_filter_division', reviewerFilterState.division);
      localStorage.setItem('reviewer_filter_status', reviewerFilterState.status);
      
      // Sync triage dropdowns
      var triageDivisionEl = document.getElementById('reviewer-filter-division');
      var triageStatusEl = document.getElementById('reviewer-filter-status');
      if (triageDivisionEl) triageDivisionEl.value = reviewerFilterState.division;
      if (triageStatusEl) triageStatusEl.value = reviewerFilterState.status;
      
      // Re-render grid with new filters applied
      renderGrid();
      
      console.log('[Reviewer] Grid filter changed:', reviewerFilterState);
    }
    
    function renderReviewerGrid() {
      // v1.5.2: Reviewer-specific grid with status highlighting and read-only behavior
      // This enhances the normal grid render with PR status highlighting
      
      // First, build a map of record_id -> PatchRequest status
      var prStatusMap = {};
      var allPRs = PATCH_REQUEST_STORE.list();
      
      allPRs.forEach(function(pr) {
        var recordId = pr.record_id || '';
        var prInfo = {
          status: pr.status,
          patch_request_id: pr.request_id || pr.patch_request_id,
          dataset_id: pr.dataset_id,
          division_id: pr.division_id
        };
        
        // v1.5.3 Fix: Index by multiple aliases for reliable lookup
        if (recordId) {
          prStatusMap[recordId] = prInfo;
        }
        // Also index by contract_key if present
        if (pr.contract_key && pr.contract_key !== recordId) {
          prStatusMap[pr.contract_key] = prInfo;
        }
        // Also index by record_identity.contract_key if different
        if (pr.record_identity && pr.record_identity.contract_key) {
          var ck = pr.record_identity.contract_key;
          if (ck !== recordId) {
            prStatusMap[ck] = prInfo;
          }
        }
      });
      
      // Also scan verifier queue payloads
      verifierQueueState.payloads.forEach(function(p) {
        var recordId = p.record_id || '';
        var prInfo = {
          status: p.status,
          patch_request_id: p.patch_request_id || p.id,
          artifact_id: p.artifact_id || p.id,
          dataset_id: p.dataset_id,
          division_id: p.division_id
        };
        
        // v1.5.3 Fix: Index by multiple aliases
        if (recordId) {
          prStatusMap[recordId] = prInfo;
        }
        // Also index by contract_key as alias
        if (p.contract_key && p.contract_key !== recordId) {
          prStatusMap[p.contract_key] = prInfo;
        }
      });
      
      // Store for use in row click handler and grid filtering
      window.reviewerPrStatusMap = prStatusMap;
      
      // Update count display
      var countEl = document.getElementById('reviewer-grid-filter-count');
      if (countEl) {
        var activeCount = Object.keys(prStatusMap).length;
        var filterText = activeCount + ' records with active PatchRequests';
        if (reviewerFilterState.division || reviewerFilterState.status) {
          filterText += ' (filtered)';
        }
        countEl.textContent = filterText;
      }
      
      console.log('[Reviewer] Grid status map built:', Object.keys(prStatusMap).length, 'records');
    }
    
    function getReviewerRowHighlight(recordId) {
      // v1.5.2: Return highlight color based on PatchRequest status
      if (!window.reviewerPrStatusMap) return null;
      var prInfo = window.reviewerPrStatusMap[recordId];
      if (!prInfo) return null;
      
      var status = prInfo.status;
      switch (status) {
        case 'pending':
        case 'pending_review':
          return { bg: '#fffde7', border: '#fff59d' }; // Subtle yellow
        case 'needs_clarification':
          return { bg: '#fff3e0', border: '#ffcc80' }; // Orange
        case 'sent_to_admin':
          return { bg: '#e3f2fd', border: '#90caf9' }; // Blue
        case 'resolved':
          return { bg: '#e8f5e9', border: '#a5d6a7' }; // Green
        default:
          return null;
      }
    }
    
    function handleReviewerRowClick(recordId, sheetName, rowIndex) {
      // v1.5.3 Fix: Reviewer row click - route to Verifier Review via patch_request_id
      // Try multiple lookup keys for robustness
      var prInfo = null;
      var keysChecked = [];
      
      if (window.reviewerPrStatusMap) {
        // Try record_id first
        if (recordId) {
          keysChecked.push(recordId);
          prInfo = window.reviewerPrStatusMap[recordId];
        }
        
        // Fallback: try sheetName:rowIndex pattern
        if (!prInfo) {
          var aliasKey = sheetName + ':' + rowIndex;
          keysChecked.push(aliasKey);
          prInfo = window.reviewerPrStatusMap[aliasKey];
        }
      }
      
      if (prInfo && prInfo.patch_request_id) {
        // Open Verifier Review with this patch_request_id
        console.log('[Reviewer] Opening Verifier Review for:', prInfo.patch_request_id, 'record:', recordId);
        openVerifierReviewDetail(prInfo.patch_request_id);
      } else {
        // No PatchRequest found - provide detailed debug info
        var knownRecordIds = window.reviewerPrStatusMap ? Object.keys(window.reviewerPrStatusMap) : [];
        
        console.warn('[Reviewer] No PatchRequest for record. Keys checked:', keysChecked.join(', '),
          '| Known PRs (' + knownRecordIds.length + '):', knownRecordIds.slice(0, 8).join(', ') + (knownRecordIds.length > 8 ? '...' : ''));
        
        // Show more helpful message
        if (knownRecordIds.length === 0) {
          showToast('No PatchRequests loaded. Submit a patch from Analyst view first.', 'warning');
        } else {
          showToast('No PatchRequest found for record ' + recordId + '. Checked keys: ' + keysChecked.join(', '), 'info');
        }
      }
    }

    // v1.5.3 Fix: Reload reviewer queues from canonical stores (independent of analyst SRR state)
    function reloadReviewerQueuesFromStore() {
      console.log('[Reviewer] Reloading queues from canonical stores...');
      
      // Step 1: Load from localStorage-persisted verifier queue
      var savedQueue = localStorage.getItem('srr_verifier_queue_v1');
      if (savedQueue) {
        try {
          var parsed = JSON.parse(savedQueue);
          if (Array.isArray(parsed)) {
            verifierQueueState.payloads = parsed;
            console.log('[Reviewer] Loaded', parsed.length, 'items from saved queue');
          }
        } catch (e) {
          console.warn('[Reviewer] Failed to parse saved queue:', e);
        }
      }
      
      // Step 2: Build comprehensive existingIds set (includes all ID types)
      var existingIds = new Set();
      verifierQueueState.payloads.forEach(function(p) {
        if (p.id) existingIds.add(p.id);
        if (p.patch_request_id) existingIds.add(p.patch_request_id);
        if (p.artifact_id) existingIds.add(p.artifact_id);
      });
      
      // Step 3: Sync with PATCH_REQUEST_STORE (canonical source) - add missing items
      var allPRs = PATCH_REQUEST_STORE.list();
      allPRs.forEach(function(pr) {
        var prId = pr.request_id || pr.id;
        var artId = pr.artifact_id;
        
        // Skip if already in queue (by any ID type)
        if (existingIds.has(prId) || (artId && existingIds.has(artId))) return;
        
        // Add to queue as payload
        var newPayload = {
          id: artId || prId,
          type: pr.patch_type || pr.patch_kind || 'correction',
          record_id: pr.record_id,
          dataset_id: pr.dataset_id,
          patch_request_id: prId,
          division_id: pr.division_id,
          field: pr.field || pr.target_field,
          old_value: pr.old_value || '',
          new_value: pr.new_value || '',
          comment: pr.because || pr.evidence_justification || '',
          analyst_id: pr.author,
          timestamp: pr.created_at,
          status: pr.status || 'pending',
          artifact_id: artId
        };
        verifierQueueState.payloads.push(newPayload);
        
        // v1.5.3 Fix: Update existingIds to prevent duplicates in Step 4
        existingIds.add(prId);
        if (artId) existingIds.add(artId);
        console.log('[Reviewer] Added PR from store:', prId);
      });
      
      // Step 4: Sync with ArtifactStore - add missing artifacts (checks updated existingIds)
      var allArtifacts = listArtifacts ? listArtifacts() : [];
      allArtifacts.forEach(function(art) {
        // v1.5.3 Fix: Check all ID types to prevent duplicates
        if (existingIds.has(art.artifact_id)) return;
        var linkedPrId = art.body?.patch_request_id || art.body?.legacy_request_id;
        if (linkedPrId && existingIds.has(linkedPrId)) return;
        
        // Add artifact to queue
        var newPayload = {
          id: art.artifact_id,
          type: art.body?.patch_type || (art.artifact_type === 'rfi' ? 'rfi' : 'correction'),
          record_id: art.record_id,
          dataset_id: art.dataset_id,
          patch_request_id: linkedPrId,
          division_id: art.division_id,
          field: art.field_key,
          old_value: art.body?.old_value || '',
          new_value: art.body?.new_value || '',
          comment: art.body?.comment || '',
          analyst_id: art.created_by_actor_id,
          timestamp: art.created_at,
          status: art.status || 'pending',
          artifact_id: art.artifact_id
        };
        verifierQueueState.payloads.push(newPayload);
        
        // Update existingIds
        existingIds.add(art.artifact_id);
        if (linkedPrId) existingIds.add(linkedPrId);
        console.log('[Reviewer] Added artifact from store:', art.artifact_id);
      });
      
      // Step 5: Final de-dupe pass by id (safety net)
      var seenIds = new Set();
      verifierQueueState.payloads = verifierQueueState.payloads.filter(function(p) {
        var key = p.id || p.patch_request_id || p.artifact_id;
        if (seenIds.has(key)) return false;
        seenIds.add(key);
        return true;
      });
      
      // Save merged queue
      saveVerifierQueue();
      console.log('[Reviewer] Queue reload complete. Total items:', verifierQueueState.payloads.length);
    }
    
    function addVerifierPayload(payload) {
      verifierQueueState.payloads.push(payload);
      saveVerifierQueue();
      console.log('[Verifier] Payload added:', payload);
    }

    function saveVerifierQueue() {
      localStorage.setItem('srr_verifier_queue_v1', JSON.stringify(verifierQueueState.payloads));
    }

    function setVerifierQueue(queue) {
      verifierQueueState.activeQueue = queue;
      document.querySelectorAll('.v-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.vqueue === queue);
        t.style.background = t.dataset.vqueue === queue ? '#e3f2fd' : 'transparent';
        t.style.color = t.dataset.vqueue === queue ? '#1565c0' : '#666';
      });
      renderVerifierTriage();
    }

    function matchesDivisionFilter(item) {
      // Helper to check if item matches division filter, handling Unassigned
      if (!reviewerFilterState.division) return true;
      if (reviewerFilterState.division === '__unassigned__') {
        return !item.division_id;
      }
      return item.division_id === reviewerFilterState.division;
    }
    
    // =====================
    // ANALYST TRIAGE (v1.5.5) - Multi-queue dashboard
    // =====================
    
    var analystTriageState = {
      manualItems: [],
      sflogicItems: [],
      patchItems: [],
      systemItems: []
    };
    
    // Map PatchRequest status to pipeline section
    var ANALYST_STATUS_MAP = {
      'Submitted': { section: 'pending', label: 'Pending Review', color: '#e65100' },
      'Reviewer_Responded': { section: 'verifier', label: 'At Verifier', color: '#1565c0' },
      'Reviewer_Approved': { section: 'admin', label: 'At Admin', color: '#7b1fa2' },
      'Admin_Hold': { section: 'admin', label: 'Admin Hold', color: '#7b1fa2' },
      'Needs_Clarification': { section: 'clarification', label: 'Needs Response', color: '#f57f17' },
      'Admin_Approved': { section: 'approved', label: 'Approved', color: '#2e7d32' },
      'Applied': { section: 'approved', label: 'Applied', color: '#2e7d32' },
      'Sent_to_Kiwi': { section: 'approved', label: 'In Progress', color: '#2e7d32' },
      'Kiwi_Returned': { section: 'approved', label: 'Kiwi Returned', color: '#2e7d32' },
      'Rejected': { section: 'rejected', label: 'Rejected', color: '#c62828' },
      'Cancelled': { section: 'rejected', label: 'Cancelled', color: '#c62828' },
      'Draft': { section: 'pending', label: 'Draft', color: '#757575' }
    };
    
    // v1.6.0: Dataset load timestamp for signal items
    var datasetLoadTimestamp = null;
    
    function loadAnalystTriageFromStore() {
      // v1.6.31: Seed Patch Requests from meta sheet (RFIs from modified dataset)
      seedPatchRequestsFromMetaSheet();
      
      // v1.6.9: Seed Verifier RFI queue from meta sheet (if not already done)
      seedVerifierRFIQueueFromMetaSheet();
      
      var allPRs = PATCH_REQUEST_STORE.list();
      console.log('[AnalystTriage] Loading from store, found:', allPRs.length);
      
      // Map all patch requests to triage items (existing behavior)
      var patchRequestItems = allPRs.map(function(pr) {
        var statusInfo = ANALYST_STATUS_MAP[pr.status] || { section: 'pending', label: pr.status || 'Unknown', color: '#757575' };
        
        var patchType = 'correction';
        if (pr.artifact_type === 'rfi') patchType = 'rfi';
        else if (pr.type) patchType = pr.type;
        else if (pr.intent && pr.intent.category === 'blacklist') patchType = 'blacklist';
        
        return {
          request_id: pr.request_id,
          type: patchType,
          record_id: pr.record_id || pr.payload?.record_id || 'Unknown',
          contract_key: pr.contract_key || pr.payload?.contract_key,
          field_name: pr.field_name || (pr.payload?.changes ? Object.keys(pr.payload.changes)[0] : 'Multiple'),
          status: pr.status,
          section: statusInfo.section,
          status_label: statusInfo.label,
          status_color: statusInfo.color,
          updated_at: pr.updated_at_utc || pr.submitted_at_utc || pr.created_at_utc,
          notes: pr.clarification_notes || pr.rejection_reason,
          thread: pr.thread,
          source: 'patch_request'
        };
      }).sort(function(a, b) {
        return (b.updated_at || '').localeCompare(a.updated_at || '');
      });
      
      // v1.6.0: Populate queues from signalStore
      var signalItems = getSignalTriageItems();
      
      // Manual Review: MOJIBAKE_DETECTED
      analystTriageState.manualItems = signalItems.filter(function(item) {
        return item.signal_type === 'MOJIBAKE_DETECTED';
      });
      
      // Salesforce Logic Flags: QA_FLAG with ERROR or WARNING severity
      analystTriageState.sflogicItems = signalItems.filter(function(item) {
        return item.signal_type === 'QA_FLAG' && (item.severity === 'error' || item.severity === 'warning');
      });
      
      // v1.6.31: Patch Queue - only show actual patch requests (RFIs, corrections, etc.)
      // Validation signals (MISSING_REQUIRED, PICKLIST_INVALID) moved to Manual Review
      // Sort by updated_at descending to show most recent first
      patchRequestItems.sort(function(a, b) {
        var aTime = a.updated_at || a.updated_at_utc || '';
        var bTime = b.updated_at || b.updated_at_utc || '';
        return bTime.localeCompare(aTime);
      });
      analystTriageState.patchItems = patchRequestItems;
      
      // v1.6.31: Add validation signals to Manual Review queue (not Patch Queue)
      var validationSignals = signalItems.filter(function(item) {
        return item.signal_type === 'MISSING_REQUIRED' || item.signal_type === 'PICKLIST_INVALID';
      });
      analystTriageState.manualItems = analystTriageState.manualItems.concat(validationSignals);
      
      // System Changes: QA_FLAG with INFO severity
      analystTriageState.systemItems = signalItems.filter(function(item) {
        return item.signal_type === 'QA_FLAG' && item.severity === 'info';
      });
      
      console.log('[AnalystTriage] Queue counts from signals: Manual=' + analystTriageState.manualItems.length + 
        ', SFLogic=' + analystTriageState.sflogicItems.length + 
        ', Patch=' + analystTriageState.patchItems.length + 
        ', System=' + analystTriageState.systemItems.length);
    }
    
    // v1.6.0: Convert signalStore to triage items
    function getSignalTriageItems() {
      var items = [];
      var loadTime = datasetLoadTimestamp || new Date().toISOString();
      
      // Iterate over signalStore.signals_by_cell
      var recordIds = Object.keys(signalStore.signals_by_cell).sort();
      
      recordIds.forEach(function(recordId) {
        var fieldSignals = signalStore.signals_by_cell[recordId];
        var fieldKeys = Object.keys(fieldSignals).sort();
        
        fieldKeys.forEach(function(fieldKey) {
          var signals = fieldSignals[fieldKey];
          
          signals.forEach(function(signal) {
            items.push({
              id: recordId + '|' + fieldKey + '|' + signal.signal_type,
              signal_type: signal.signal_type,
              type: mapSignalTypeToTriageType(signal.signal_type),
              record_id: recordId,
              field_name: signal.field_label || fieldKey,
              field_key: fieldKey,
              status: signal.signal_type,
              status_label: mapSignalTypeToLabel(signal.signal_type),
              status_color: mapSignalSeverityToColor(signal.severity),
              severity: signal.severity,
              message: signal.message,
              updated_at: loadTime,
              source: 'signal'
            });
          });
        });
      });
      
      return items;
    }
    
    // v1.6.0: Map signal types to triage display types
    function mapSignalTypeToTriageType(signalType) {
      switch (signalType) {
        case 'MISSING_REQUIRED': return 'required';
        case 'PICKLIST_INVALID': return 'picklist';
        case 'MOJIBAKE_DETECTED': return 'encoding';
        case 'QA_FLAG': return 'qa';
        default: return 'signal';
      }
    }
    
    function mapSignalTypeToLabel(signalType) {
      switch (signalType) {
        case 'MISSING_REQUIRED': return 'Required';
        case 'PICKLIST_INVALID': return 'Invalid Value';
        case 'MOJIBAKE_DETECTED': return 'Encoding Issue';
        case 'QA_FLAG': return 'QA Flag';
        default: return signalType;
      }
    }
    
    function mapSignalSeverityToColor(severity) {
      switch (severity) {
        case 'error': return '#c62828';
        case 'warning': return '#f57f17';
        case 'warn': return '#f57f17';  // Handle both 'warn' and 'warning'
        case 'info': return '#1565c0';
        default: return '#757575';
      }
    }
    
    function renderTriageQueueTable(items, containerId, emptyMessage) {
      var container = document.getElementById(containerId);
      if (!container) return;
      
      if (items.length === 0) {
        container.innerHTML = '<tr><td colspan="6" style="padding: 24px; text-align: center; color: #999;">' + emptyMessage + '</td></tr>';
        return;
      }
      
      container.innerHTML = items.map(function(item) {
        // v1.6.0: Handle both signal items and patch request items
        var typeLabel = getTriageTypeLabel(item.type);
        var typeBadgeColor = getTriageTypeColor(item.type);
        
        var timestamp = item.updated_at ? new Date(item.updated_at).toLocaleString() : 'Unknown';
        var statusBadge = '<span style="display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: ' + 
          item.status_color + '15; color: ' + item.status_color + ';">' + item.status_label + '</span>';
        var notesIndicator = item.notes ? '<span title="Has reviewer notes" style="margin-left: 4px; color: #f57f17;">ðŸ’¬</span>' : '';
        
        var recordDisplay = item.contract_key || item.record_id || 'Unknown';
        if (recordDisplay.length > 20) recordDisplay = recordDisplay.substring(0, 18) + '...';
        
        var rowStyle = item.section === 'clarification' ? 'background: #fff8e1;' : '';
        
        // v1.6.0: Different click handlers for signal vs patch request items
        var clickHandler = item.source === 'signal' 
          ? 'openSignalTriageItem(\'' + item.record_id + '\', \'' + item.field_key + '\')'
          : 'openAnalystTriageItem(\'' + item.request_id + '\')';
        
        var viewHandler = item.source === 'signal'
          ? 'openSignalTriageItem(\'' + item.record_id + '\', \'' + item.field_key + '\')'
          : 'openAnalystTriageItem(\'' + item.request_id + '\')';
        
        return '<tr style="border-bottom: 1px solid #eee; cursor: pointer; ' + rowStyle + '" onclick="' + clickHandler + '">' +
          '<td style="padding: 10px 12px;"><span style="display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; background: ' + typeBadgeColor + '15; color: ' + typeBadgeColor + ';">' + typeLabel + '</span></td>' +
          '<td style="padding: 10px 12px; font-family: monospace; font-size: 0.85em;">' + recordDisplay + '</td>' +
          '<td style="padding: 10px 12px;">' + (item.field_name || '-') + '</td>' +
          '<td style="padding: 10px 12px;">' + statusBadge + notesIndicator + '</td>' +
          '<td style="padding: 10px 12px; color: #666; font-size: 0.85em;">' + timestamp + '</td>' +
          '<td style="padding: 10px 12px;"><button class="btn-secondary" style="padding: 4px 8px; font-size: 0.75em;" onclick="event.stopPropagation(); ' + viewHandler + '">View</button></td>' +
          '</tr>';
      }).join('');
    }
    
    // v1.6.0: Get type label for triage display
    function getTriageTypeLabel(type) {
      switch (type) {
        case 'rfi': return 'RFI';
        case 'blacklist': return 'Blacklist';
        case 'qa': return 'QA';
        case 'required': return 'Required';
        case 'picklist': return 'Picklist';
        case 'encoding': return 'Encoding';
        case 'correction': return 'Correction';
        case 'extraction': return 'Extraction';
        case 'logic': return 'Logic';
        default: return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Signal';
      }
    }
    
    // v1.6.0: Get type color for triage display
    function getTriageTypeColor(type) {
      switch (type) {
        case 'rfi': return '#1565c0';
        case 'blacklist': return '#c62828';
        case 'qa': return '#ff9800';
        case 'required': return '#c62828';
        case 'picklist': return '#f57f17';
        case 'encoding': return '#9c27b0';
        case 'correction': return '#2e7d32';
        case 'extraction': return '#9c27b0';
        case 'logic': return '#00bcd4';
        default: return '#757575';
      }
    }
    
    // v1.6.0: Open SRR at specific field from signal triage item
    function openSignalTriageItem(recordId, fieldKey) {
      console.log('[AnalystTriage] Opening signal item:', recordId, fieldKey);
      
      // Find record in workbook or canonical store
      var found = findRecordById(recordId);
      
      if (found) {
        // Open SRR with the record
        openRowReviewDrawer(found.row, found.rowIndex, recordId);
        
        // After SRR opens, scroll to and focus the field
        setTimeout(function() {
          focusFieldInInspector(fieldKey);
        }, 300);
      } else {
        // Try loading from canonical store
        var storeKeys = Object.keys(localStorage).filter(function(k) {
          return k.includes('/records/') && k.endsWith('/' + recordId + '.json');
        });
        
        if (storeKeys.length > 0) {
          try {
            var record = JSON.parse(localStorage.getItem(storeKeys[0]));
            openRowReviewDrawer(record, 0, recordId);
            
            setTimeout(function() {
              focusFieldInInspector(fieldKey);
            }, 300);
          } catch (e) {
            console.error('[AnalystTriage] Error loading record from store:', e);
            showToast('Could not load record data', 'error');
          }
        } else {
          showToast('Record not found. Please load the dataset first.', 'warning');
        }
      }
    }
    
    // v1.6.0: Focus a specific field in the Field Inspector
    function focusFieldInInspector(fieldKey) {
      // Find the field card by looking for the field key in card attributes (uses data-field attribute)
      var card = document.querySelector('.srr-field-card[data-field="' + fieldKey + '"]');
      
      // Try normalized lookup if exact match not found
      if (!card) {
        var fieldCards = document.querySelectorAll('.srr-field-card');
        for (var i = 0; i < fieldCards.length; i++) {
          var cardFieldKey = fieldCards[i].getAttribute('data-field');
          if (cardFieldKey && normalizeFieldKey(cardFieldKey) === normalizeFieldKey(fieldKey)) {
            card = fieldCards[i];
            break;
          }
        }
      }
      
      if (card) {
        // Scroll into view
        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Add highlight effect
        card.style.boxShadow = '0 0 0 3px #1565c0';
        setTimeout(function() {
          card.style.boxShadow = '';
        }, 2000);
        // Click to select
        card.click();
        console.log('[FieldInspector] Focused field:', fieldKey);
      } else {
        console.warn('[FieldInspector] Field not found:', fieldKey);
      }
    }
    
    function renderAnalystTriage() {
      // Reload from store
      loadAnalystTriageFromStore();
      
      // Update queue counts
      var manualCount = analystTriageState.manualItems.length;
      var sflogicCount = analystTriageState.sflogicItems.length;
      var patchCount = analystTriageState.patchItems.length;
      var systemCount = analystTriageState.systemItems.length;
      
      var manualCountEl = document.getElementById('manual-queue-count');
      var sflogicCountEl = document.getElementById('sflogic-queue-count');
      var patchCountEl = document.getElementById('patch-queue-count');
      var systemCountEl = document.getElementById('system-queue-count');
      
      if (manualCountEl) manualCountEl.textContent = '(' + manualCount + ')';
      if (sflogicCountEl) sflogicCountEl.textContent = '(' + sflogicCount + ')';
      if (patchCountEl) patchCountEl.textContent = '(' + patchCount + ')';
      if (systemCountEl) systemCountEl.textContent = '(' + systemCount + ')';
      
      // Render each queue table
      renderTriageQueueTable(analystTriageState.manualItems, 'manual-queue-list', 'No manual review items');
      renderTriageQueueTable(analystTriageState.sflogicItems, 'sflogic-queue-list', 'No Salesforce logic flags');
      renderTriageQueueTable(analystTriageState.patchItems, 'patch-queue-list', 'No patch requests yet');
      renderTriageQueueTable(analystTriageState.systemItems, 'system-queue-list', 'No system changes');
    }
    
    function openAnalystTriageItem(requestId) {
      console.log('[AnalystTriage] Opening item:', requestId);
      var pr = PATCH_REQUEST_STORE.get(requestId);
      if (!pr) {
        console.error('[AnalystTriage] PatchRequest not found:', requestId);
        showToast('Could not find patch request', 'error');
        return;
      }
      
      // Navigate to SRR with this record
      var recordId = pr.record_id || pr.payload?.record_id;
      if (recordId) {
        // Try to load from canonical record store first
        var recordKey = 'kiwi/v1/' + (pr.tenant_id || IDENTITY_CONTEXT.tenant_id) + '/records/' + (pr.dataset_id || IDENTITY_CONTEXT.dataset_id) + '/' + recordId + '.json';
        var storedRecord = localStorage.getItem(recordKey);
        
        if (storedRecord) {
          try {
            var record = JSON.parse(storedRecord);
            openRowReviewDrawer(record, 0, recordId);
            
            // If needs clarification, show the notes in thread
            if (pr.status === 'Needs_Clarification' && pr.clarification_notes) {
              setTimeout(function() {
                showToast('Reviewer requested clarification: ' + pr.clarification_notes.substring(0, 100), 'warning');
              }, 500);
            }
          } catch (e) {
            console.error('[AnalystTriage] Error loading record:', e);
            showToast('Could not load record data', 'error');
          }
        } else {
          // Try finding in current workbook
          if (workbook && workbook.data) {
            var found = findRecordById(recordId);
            if (found) {
              openRowReviewDrawer(found.row, found.rowIndex, recordId);
            } else {
              showToast('Record not found. Please load the dataset first.', 'warning');
            }
          } else {
            showToast('Please load the associated dataset to view this record.', 'warning');
          }
        }
      } else {
        showToast('Record ID not available for this patch request.', 'warning');
      }
    }
    
    function renderVerifierTriage() {
      const container = document.getElementById('verifier-queue-list');
      if (!container) return;

      const queue = verifierQueueState.activeQueue;
      
      // Update patch type counts first
      updatePatchTypeCounts();
      
      // v1.5.3: Apply division + status + patchType filters
      var filtered = verifierQueueState.payloads.filter(function(p) {
        // Filter by queue tab first
        if (p.status !== queue) return false;
        
        // Apply division filter (handles Unassigned)
        if (!matchesDivisionFilter(p)) return false;
        
        // Apply patch type filter
        if (reviewerFilterState.patchType && p.type !== reviewerFilterState.patchType) return false;
        
        return true;
      });
      
      // If status dropdown is set (overrides tab), apply that instead
      if (reviewerFilterState.status) {
        filtered = verifierQueueState.payloads.filter(function(p) {
          if (p.status !== reviewerFilterState.status) return false;
          if (!matchesDivisionFilter(p)) return false;
          if (reviewerFilterState.patchType && p.type !== reviewerFilterState.patchType) return false;
          return true;
        });
      }

      // Update counts (unfiltered by division for tab badges)
      const counts = { pending: 0, needs_clarification: 0, sent_to_admin: 0, resolved: 0 };
      verifierQueueState.payloads.forEach(p => counts[p.status] = (counts[p.status] || 0) + 1);
      
      document.getElementById('v-count-pending').textContent = `(${counts.pending})`;
      document.getElementById('v-count-clarification').textContent = `(${counts.needs_clarification})`;
      document.getElementById('v-count-admin').textContent = `(${counts.sent_to_admin})`;
      document.getElementById('v-count-resolved').textContent = `(${counts.resolved})`;
      
      // Update filter count indicator (show queue-scoped count)
      var filterCountEl = document.getElementById('reviewer-filter-count');
      if (filterCountEl) {
        var queueCount = verifierQueueState.payloads.filter(function(p) { return p.status === queue; }).length;
        if (reviewerFilterState.division || reviewerFilterState.status || reviewerFilterState.patchType) {
          filterCountEl.textContent = filtered.length + ' of ' + queueCount + ' items (filtered)';
        } else {
          filterCountEl.textContent = queueCount + ' items';
        }
      }

      if (filtered.length === 0) {
        var msg = 'No reviewer items match the selected filters.';
        if (!reviewerFilterState.division && !reviewerFilterState.status && !reviewerFilterState.patchType) {
          msg = 'No payloads in this queue';
        }
        container.innerHTML = '<tr><td colspan="7" style="padding: 40px; text-align: center; color: #999;">' + msg + '</td></tr>';
        return;
      }

      container.innerHTML = filtered.map(p => {
        const typeLabel = p.type.toUpperCase();
        const typeColor = p.type === 'rfi' ? '#ff9800' : (p.type === 'blacklist' ? '#d32f2f' : '#1565c0');
        const time = new Date(p.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        let actions = '';
        
        // RFI rows: view-only actions (no Approve in table)
        if (p.type === 'rfi') {
          actions = `
            <button onclick="event.stopPropagation(); openVerifierReviewDetail('${p.id}')" style="background:#1565c0; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Open Review</button>
            <button onclick="event.stopPropagation(); openRecordFromPayload('${p.id}')" style="background:#f5f5f5; color:#333; border:1px solid #ddd; padding:4px 8px; border-radius:4px; cursor:pointer;">Open Record</button>
          `;
        } else {
          // Correction/Blacklist: keep existing status-based actions
          if (p.status === 'pending') {
            actions = `
              <button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'sent_to_admin')" style="background:#2e7d32; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Approve</button>
              <button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'needs_clarification')" style="background:#f57c00; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">RFI</button>
            `;
          } else if (p.status === 'needs_clarification') {
            actions = `<button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'pending')" style="background:#1565c0; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Re-check</button>`;
          } else if (p.status === 'sent_to_admin') {
            actions = `<button onclick="event.stopPropagation(); updatePayloadStatus('${p.id}', 'resolved')" style="background:#7b1fa2; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">Finalize</button>`;
          }
        }

        return `
          <tr style="border-bottom: 1px solid #eee; cursor: pointer;" onclick="openRecordFromPayload('${p.id}')" onmouseover="this.style.background='#f5f8ff'" onmouseout="this.style.background='transparent'">
            <td style="padding:12px;"><span style="background:${typeColor}; color:white; padding:2px 6px; border-radius:10px; font-size:0.8em;">${typeLabel}</span></td>
            <td style="padding:12px; font-weight:600;">${p.record_id}</td>
            <td style="padding:12px; font-family:monospace;">${p.field}</td>
            <td style="padding:12px;">${p.new_value || p.old_value || '(none)'}</td>
            <td style="padding:12px; color:#666; max-width:200px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="${p.comment}">${p.comment}</td>
            <td style="padding:12px; color:#888;">${time}</td>
            <td style="padding:12px; display:flex; gap:6px;">${actions}</td>
          </tr>
        `;
      }).join('');
    }

    function updatePayloadStatus(payloadId, newStatus) {
      const payload = verifierQueueState.payloads.find(p => p.id === payloadId);
      if (payload) {
        payload.status = newStatus;
        saveVerifierQueue();
        
        // v1.5.1: Also update artifact store and log event
        var artifact = getArtifact(payloadId);
        if (artifact) {
          updateArtifact(payloadId, { status: newStatus });
          
          // Log appropriate event based on status change
          var eventType = null;
          if (newStatus === 'sent_to_admin') {
            eventType = 'VERIFIER_APPROVED';
          } else if (newStatus === 'needs_clarification') {
            eventType = 'VERIFIER_CLARIFICATION_REQUESTED';
          } else if (newStatus === 'rejected') {
            eventType = 'VERIFIER_REJECTED';
          } else if (newStatus === 'resolved') {
            eventType = 'ADMIN_APPROVED';
          }
          
          if (eventType) {
            logArtifactEvent(eventType, {
              artifact_id: payloadId,
              artifact_type: artifact.artifact_type,
              record_id: artifact.record_id,
              field_key: artifact.field_key,
              new_status: newStatus
            });
          }
        }
        
        renderVerifierTriage();
        
        // Show appropriate toast
        var toastMsg = newStatus === 'sent_to_admin' ? 'Approved â€” sent to Admin queue' : 
                       newStatus === 'needs_clarification' ? 'Clarification requested' :
                       newStatus === 'rejected' ? 'Rejected' :
                       newStatus === 'resolved' ? 'Finalized' :
                       newStatus.replace(/_/g, ' ');
        showToast(toastMsg, newStatus === 'rejected' ? 'warning' : 'success');
      }
    }
    
    function openRecordFromPayload(payloadId) {
      // v1.5.3: Open record in Reviewer SRR mode with PatchRequest-first loading
      
      // Step 1: Get artifact and payload first to find patch_request_id
      var artifact = getArtifact(payloadId);
      var payload = verifierQueueState.payloads.find(function(p) { return p.id === payloadId; });
      
      // Step 2: Determine patch_request_id - could be payloadId itself or a linked field
      var patchRequestId = payloadId;
      if (payload && payload.patch_request_id) {
        patchRequestId = payload.patch_request_id;
      } else if (artifact && artifact.patch_request_id) {
        patchRequestId = artifact.patch_request_id;
      }
      
      // Step 3: Load PatchRequest from CANONICAL PATCH_REQUEST_STORE
      var patchRequest = null;
      
      // Try direct lookup first using resolved patchRequestId
      patchRequest = PATCH_REQUEST_STORE.get(patchRequestId);
      
      // If not found by patchRequestId, try payloadId as fallback
      if (!patchRequest && payloadId !== patchRequestId) {
        patchRequest = PATCH_REQUEST_STORE.get(payloadId);
      }
      
      // If still not found, try scanning all PRs for matching IDs (fallback for legacy data)
      if (!patchRequest) {
        var allPRs = PATCH_REQUEST_STORE.list();
        patchRequest = allPRs.find(function(pr) {
          return pr.request_id === patchRequestId || 
                 pr.id === patchRequestId ||
                 pr.request_id === payloadId || 
                 pr.id === payloadId;
        });
        if (patchRequest) {
          console.log('[Reviewer SRR] Found PatchRequest via scan:', patchRequest.request_id);
        }
      }
      
      // Debug: Log available PR IDs if not found
      if (!patchRequest) {
        var knownPRIds = PATCH_REQUEST_STORE.list().map(function(pr) { return pr.request_id; });
        console.warn('[Reviewer SRR] PatchRequest not found. Looking for:', patchRequestId, 
          'Available IDs:', knownPRIds.slice(0, 10).join(', ') + (knownPRIds.length > 10 ? '...' : ''));
      }
      
      // Step 4: Check if PatchRequest was expected but not found (strict mode)
      var patchRequestExpected = patchRequestId !== payloadId || (payload && payload.patch_request_id) || (artifact && artifact.patch_request_id);
      if (patchRequestExpected && !patchRequest) {
        console.warn('[Reviewer SRR] PatchRequest expected but not found:', patchRequestId);
        // Continue with artifact/payload fallback but log warning
      }
      
      // Step 5: Resolve record_id - prefer PatchRequest, then artifact, then payload
      var recordId = null;
      var datasetId = null;
      var tenantId = null;
      var fieldKey = null;
      var patchType = null;
      
      if (patchRequest) {
        recordId = patchRequest.record_id;
        datasetId = patchRequest.dataset_id;
        tenantId = patchRequest.tenant_id;
        fieldKey = patchRequest.field_key;
        patchType = patchRequest.patch_kind || patchRequest.patch_type || 'correction';
        console.log('[Reviewer SRR] Loaded PatchRequest:', patchRequestId, 'record_id:', recordId);
      }
      
      // Fallback to artifact if no PatchRequest record_id
      if (!recordId && artifact) {
        recordId = artifact.record_id;
        datasetId = datasetId || artifact.dataset_id;
        tenantId = tenantId || artifact.tenant_id;
        fieldKey = fieldKey || artifact.field_key;
        patchType = patchType || artifact.type || 'correction';
      }
      
      // Fallback to payload if still no record_id
      if (!recordId && payload) {
        recordId = payload.record_id;
        datasetId = datasetId || payload.dataset_id;
        tenantId = tenantId || payload.tenant_id;
        fieldKey = fieldKey || payload.field;
        patchType = patchType || payload.type || 'correction';
      }
      
      // Also populate missing identity fields from any available source
      if (!datasetId) datasetId = (artifact && artifact.dataset_id) || (payload && payload.dataset_id);
      if (!tenantId) tenantId = (artifact && artifact.tenant_id) || (payload && payload.tenant_id);
      
      // Step 5: Validate record_id exists
      if (!recordId) {
        showBlockingError('Missing record_id', 
          'Cannot open record: PatchRequest ' + payloadId + ' has no record_id.\n\n' +
          'Key: patch_request_id=' + payloadId);
        console.error('[Reviewer SRR] Missing record_id in PatchRequest:', payloadId);
        return;
      }
      
      // Step 7: Validate identity fields are available for store lookup
      var effectiveDatasetId = datasetId || IDENTITY_CONTEXT.dataset_id;
      var effectiveTenantId = tenantId || IDENTITY_CONTEXT.tenant_id;
      
      if (!effectiveTenantId) {
        showBlockingError('Missing tenant_id', 
          'Cannot open record: No tenant context available.\n\n' +
          'record_id=' + recordId + ', patch_request_id=' + payloadId);
        console.error('[Reviewer SRR] Missing tenant_id for record lookup:', recordId);
        return;
      }
      
      if (!effectiveDatasetId) {
        showBlockingError('Missing dataset_id', 
          'Cannot open record: No dataset context available.\n\n' +
          'record_id=' + recordId + ', tenant_id=' + effectiveTenantId + ', patch_request_id=' + payloadId);
        console.error('[Reviewer SRR] Missing dataset_id for record lookup:', recordId);
        return;
      }
      
      // Step 8: Find record using enhanced lookup with store fallback
      var recordInfo = findRecordById(recordId, effectiveDatasetId, effectiveTenantId);
      
      if (!recordInfo) {
        // v1.5.3 Fix: Enhanced debug info for record not found
        var storeKey = getRecordStorageKey(effectiveTenantId, effectiveDatasetId, recordId);
        var workbookSheets = workbook && workbook.sheets ? Object.keys(workbook.sheets) : [];
        var workbookRowCount = 0;
        workbookSheets.forEach(function(s) {
          if (workbook.sheets[s] && workbook.sheets[s].rows) {
            workbookRowCount += workbook.sheets[s].rows.length;
          }
        });
        
        var debugInfo = [
          'tenant_id: ' + effectiveTenantId,
          'dataset_id: ' + effectiveDatasetId,
          'record_id: ' + recordId,
          'patch_request_id: ' + payloadId,
          '',
          'Store key checked: ' + storeKey,
          'Workbook sheets: ' + workbookSheets.join(', '),
          'Workbook rows: ' + workbookRowCount
        ].join('\n');
        
        showBlockingError('Record not found', 
          'Cannot open record: No matching record in dataset or store.\n\n' + debugInfo);
        console.error('[Reviewer SRR] Record not found:', recordId, 
          'dataset:', effectiveDatasetId, 
          'storeKey:', storeKey,
          'workbookSheets:', workbookSheets);
        return;
      }
      
      // Step 9: Set up Reviewer SRR state
      srrState.currentSheetName = recordInfo.sheetName;
      srrState.focusFieldKey = fieldKey || null;
      srrState.reviewerMode = true;
      srrState.reviewerPayload = patchRequest || payload || artifact;
      srrState.reviewerPatchType = patchType;
      srrState.reviewerPayloadId = payloadId;
      
      // Navigate to SRR
      navigateTo('row/' + recordInfo.rowIndex);
      console.log('[Reviewer SRR] Opened record:', recordId, 'patchType:', patchType, 'field:', fieldKey, 'fromStore:', !!recordInfo.fromStore);
    }
    
    function showBlockingError(title, message) {
      // v1.5.3: Show blocking error modal for critical failures
      var existingModal = document.getElementById('blocking-error-modal');
      if (existingModal) existingModal.remove();
      
      var modal = document.createElement('div');
      modal.id = 'blocking-error-modal';
      modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:9999; display:flex; align-items:center; justify-content:center;';
      modal.innerHTML = 
        '<div style="background:white; padding:24px; border-radius:8px; max-width:500px; box-shadow:0 4px 24px rgba(0,0,0,0.3);">' +
          '<h3 style="margin:0 0 12px 0; color:#c62828;">' + escapeHtml(title) + '</h3>' +
          '<pre style="margin:0 0 16px 0; padding:12px; background:#f5f5f5; border-radius:4px; white-space:pre-wrap; font-size:0.85em; max-height:200px; overflow:auto;">' + escapeHtml(message) + '</pre>' +
          '<button onclick="document.getElementById(\'blocking-error-modal\').remove()" style="padding:8px 16px; background:#1976d2; color:white; border:none; border-radius:4px; cursor:pointer;">Close</button>' +
        '</div>';
      document.body.appendChild(modal);
    }
    
    function initReviewerSRRMode() {
      // v1.5.3: Initialize Reviewer SRR mode with read-only field inspector and Patch Review/Tester tabs
      if (!srrState.reviewerMode) return;
      
      // Set read-only flag to prevent field editing (but allow actions on non-verified fields)
      srrState.isReadOnly = true;
      
      var patchType = srrState.reviewerPatchType || 'correction';
      var payload = srrState.reviewerPayload;
      
      // v1.5.3 Fix: Populate field states from PatchRequest for multi-issue records
      if (payload) {
        // If payload has a field property, set its state based on patch type
        var fieldKey = payload.field || payload.fieldKey;
        if (fieldKey) {
          if (patchType === 'rfi') {
            srrState.fieldStates[fieldKey] = 'rfi_pending';
          } else if (patchType === 'blacklist') {
            srrState.fieldStates[fieldKey] = 'blocked';
          } else if (patchType === 'correction') {
            srrState.fieldStates[fieldKey] = 'modified';
          }
        }
        
        // If payload has changes array, populate all field states
        if (payload.changes && Array.isArray(payload.changes)) {
          payload.changes.forEach(function(change) {
            var fk = change.field || change.fieldKey;
            if (fk) {
              var cat = (change.category || change.patch_type || 'correction').toLowerCase();
              if (cat === 'rfi') {
                srrState.fieldStates[fk] = 'rfi_pending';
              } else if (cat === 'blacklist flag' || cat === 'blacklist') {
                srrState.fieldStates[fk] = 'blocked';
              } else {
                srrState.fieldStates[fk] = 'modified';
              }
            }
          });
        }
        
        // Also check if payload is a PatchRequest with body.changes
        if (payload.body && payload.body.changes && Array.isArray(payload.body.changes)) {
          payload.body.changes.forEach(function(change) {
            var fk = change.field || change.fieldKey;
            if (fk) {
              var cat = (change.category || change.patch_type || 'correction').toLowerCase();
              if (cat === 'rfi') {
                srrState.fieldStates[fk] = 'rfi_pending';
              } else if (cat === 'blacklist flag' || cat === 'blacklist') {
                srrState.fieldStates[fk] = 'blocked';
              } else {
                srrState.fieldStates[fk] = 'modified';
              }
            }
          });
        }
        
        console.log('[Reviewer SRR] Populated field states:', Object.keys(srrState.fieldStates).length, 'fields');
      }
      
      // Update right panel title and tabs
      var panelTitle = document.getElementById('srr-right-panel-title');
      var panelTabs = document.getElementById('srr-panel-tabs');
      
      if (panelTitle) panelTitle.textContent = 'Patch Review';
      
      if (panelTabs) {
        // v1.5.3: Show tabs for all patch types in reviewer mode
        panelTabs.style.display = 'flex';
        // Update tab labels for reviewer mode
        var tabBtns = panelTabs.querySelectorAll('.srr-panel-tab');
        tabBtns.forEach(function(btn) {
          if (btn.getAttribute('data-tab') === 'editor') {
            btn.textContent = 'Patch Review';
          }
        });
      }
      
      // v1.5.3 Fix: Keep patch type chips visible for navigation in reviewer mode
      var patchTypeSelector = document.querySelector('.srr-patch-type-selector');
      if (patchTypeSelector) patchTypeSelector.style.display = '';  // Keep visible
      
      // Update patch type chips to show current type
      document.querySelectorAll('.srr-patch-type-chip').forEach(function(chip) {
        chip.classList.remove('active');
        if (chip.dataset.type === patchType) chip.classList.add('active');
      });
      
      // Populate Patch Review tab with submitted patch data
      populateReviewerPatchReview(payload, patchType);
      
      // Populate Patch Tester if applicable
      if (patchType !== 'rfi' && payload) {
        populateReviewerPatchTester(payload);
      }
      
      // For RFI, show comment thread instead of patch editor
      if (patchType === 'rfi') {
        showRFICommentThread(payload);
      }
      
      // v1.5.3 Fix: Rerender field list with updated states and select first actionable field
      if (srrState.currentRecord) {
        renderSrrFields(srrState.currentRecord);
        
        // Select the first field with a non-final state (actionable)
        var firstActionableField = null;
        var fieldKeys = Object.keys(srrState.fieldStates);
        for (var i = 0; i < fieldKeys.length; i++) {
          var fk = fieldKeys[i];
          var fs = srrState.fieldStates[fk];
          if (fs !== 'verified' && fs !== 'submitted') {
            firstActionableField = fk;
            break;
          }
        }
        
        // If no actionable field found, try the focus field from payload
        if (!firstActionableField && srrState.focusFieldKey) {
          firstActionableField = srrState.focusFieldKey;
        }
        
        // Select and highlight the first actionable field
        if (firstActionableField) {
          srrSelectField(firstActionableField);
        }
      }
      
      console.log('[Reviewer SRR] Mode initialized for patch type:', patchType);
    }
    
    function populateReviewerPatchReview(payload, patchType) {
      // v1.5.3: Populate the Patch Review (read-only) view with analyst's submitted patch
      var container = document.getElementById('srr-patch-editor-fields');
      if (!container || !payload) return;
      
      var typeLabel = (patchType || 'correction').toUpperCase();
      var typeColor = patchType === 'rfi' ? '#ff9800' : (patchType === 'blacklist' ? '#d32f2f' : '#1565c0');
      
      var html = '<div style="margin-bottom: 16px; padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ' + typeColor + ';">';
      html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">';
      html += '<span style="font-weight: 600;">Submitted Patch</span>';
      html += '<span style="background: ' + typeColor + '; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em;">' + typeLabel + '</span>';
      html += '</div>';
      
      // Field being modified
      html += '<div style="margin-bottom: 8px;">';
      html += '<span style="font-size: 0.75em; color: #888;">Field:</span> ';
      html += '<span style="font-family: monospace; font-weight: 500;">' + (payload.field || 'â€”') + '</span>';
      html += '</div>';
      
      // Old value
      if (payload.old_value !== undefined) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<span style="font-size: 0.75em; color: #888;">Current Value:</span> ';
        html += '<span style="color: #888; text-decoration: line-through;">' + (payload.old_value || '(empty)') + '</span>';
        html += '</div>';
      }
      
      // New value (for Correction/Blacklist)
      if (patchType !== 'rfi' && payload.new_value !== undefined) {
        html += '<div style="margin-bottom: 8px;">';
        html += '<span style="font-size: 0.75em; color: #888;">Proposed Value:</span> ';
        html += '<span style="color: #2e7d32; font-weight: 600;">' + (payload.new_value || '(empty)') + '</span>';
        html += '</div>';
      }
      
      // Comment/Justification
      if (payload.comment) {
        html += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px dashed #ddd;">';
        html += '<span style="font-size: 0.75em; color: #888;">Analyst Comment:</span>';
        html += '<div style="margin-top: 4px; font-size: 0.9em; color: #555; font-style: italic;">"' + payload.comment + '"</div>';
        html += '</div>';
      }
      
      html += '</div>';
      
      // Add read-only indicator
      html += '<div style="text-align: center; color: #888; font-size: 0.8em; padding: 12px; background: #f5f5f5; border-radius: 6px;">';
      html += '<span style="margin-right: 6px;">ðŸ‘</span> Read-only view â€” Use Patch Tester tab to modify';
      html += '</div>';
      
      container.innerHTML = html;
      
      // Hide change count and action box title for reviewer mode
      var changeCount = document.getElementById('srr-change-count');
      var actionBoxTitle = document.getElementById('srr-action-box-title');
      if (changeCount) changeCount.style.display = 'none';
      if (actionBoxTitle) actionBoxTitle.textContent = 'Submitted Patch';
    }
    
    function populateReviewerPatchTester(payload) {
      // v1.5.3: Pre-populate Patch Tester with payload data
      var fieldEl = document.getElementById('srr-tester-field');
      var oldEl = document.getElementById('srr-tester-old-value');
      var proposedEl = document.getElementById('srr-tester-proposed-value');
      var newValueInput = document.getElementById('srr-tester-new-value');
      
      if (fieldEl) fieldEl.textContent = payload.field || 'â€”';
      if (oldEl) oldEl.textContent = payload.old_value || '(empty)';
      if (proposedEl) proposedEl.textContent = payload.new_value || '(empty)';
      if (newValueInput) newValueInput.value = payload.new_value || '';
    }
    
    function showRFICommentThread(payload) {
      // v1.5.3: For RFI type, show comment thread instead of Patch Tester
      // v1.6.9: Enhanced for legacy RFI imports with summary, details, category
      var editorTab = document.getElementById('srr-tab-editor');
      if (!editorTab) return;
      
      // Determine if this is a legacy RFI import
      var isLegacyImport = payload.source === 'legacy_rfi_import';
      
      // Replace editor content with RFI comment thread
      var rfiHtml = '<div style="margin-bottom: 16px; padding: 12px; background: #fff3e0; border-radius: 8px; border-left: 4px solid #ff9800;">';
      rfiHtml += '<div style="font-weight: 600; margin-bottom: 8px; color: #e65100;">Request for Information';
      if (isLegacyImport) {
        rfiHtml += ' <span style="font-size: 0.7em; background: #78909c; color: white; padding: 2px 6px; border-radius: 3px; margin-left: 8px;">Imported</span>';
      }
      rfiHtml += '</div>';
      rfiHtml += '<div style="margin-bottom: 8px;">';
      rfiHtml += '<span style="font-size: 0.75em; color: #888;">Field:</span> ';
      rfiHtml += '<span style="font-family: monospace;">' + escapeHtml(payload.field || payload.field_key || 'â€”') + '</span>';
      rfiHtml += '</div>';
      
      // Show category if available (from legacy import)
      if (payload.category) {
        rfiHtml += '<div style="margin-bottom: 8px;">';
        rfiHtml += '<span style="font-size: 0.75em; color: #888;">Category:</span> ';
        rfiHtml += '<span style="background: #e3f2fd; padding: 2px 6px; border-radius: 4px; font-size: 0.85em;">' + escapeHtml(payload.category) + '</span>';
        rfiHtml += '</div>';
      }
      
      // Show detected by if available
      if (payload.detected_by) {
        rfiHtml += '<div style="margin-bottom: 8px;">';
        rfiHtml += '<span style="font-size: 0.75em; color: #888;">Detected By:</span> ';
        rfiHtml += '<span>' + escapeHtml(payload.detected_by) + '</span>';
        rfiHtml += '</div>';
      }
      
      rfiHtml += '<div style="margin-bottom: 8px;">';
      rfiHtml += '<span style="font-size: 0.75em; color: #888;">Current Value:</span> ';
      rfiHtml += '<span>' + escapeHtml(payload.old_value || '(empty)') + '</span>';
      rfiHtml += '</div>';
      
      // Show summary and details separately if available
      if (payload.summary || payload.details) {
        if (payload.summary) {
          rfiHtml += '<div style="margin-bottom: 8px; font-weight: 500; color: #333;">' + escapeHtml(payload.summary) + '</div>';
        }
        if (payload.details && payload.details !== payload.summary) {
          rfiHtml += '<div style="font-style: italic; color: #666; padding: 8px; background: #fafafa; border-radius: 4px;">' + escapeHtml(payload.details) + '</div>';
        }
      } else {
        rfiHtml += '<div style="font-style: italic; color: #666;">"' + escapeHtml(payload.comment || 'No question provided') + '"</div>';
      }
      
      // Show source URL if available
      if (payload.source_url) {
        rfiHtml += '<div style="margin-top: 8px;">';
        rfiHtml += '<a href="' + escapeHtml(payload.source_url) + '" target="_blank" style="font-size: 0.85em; color: #1565c0;">View Source Document</a>';
        rfiHtml += '</div>';
      }
      
      rfiHtml += '</div>';
      
      // Comment thread section
      rfiHtml += '<div style="font-size: 0.85em; font-weight: 600; margin-bottom: 12px;">Comment Thread</div>';
      rfiHtml += '<div id="srr-rfi-thread" style="background: #f8f9fa; border-radius: 8px; padding: 12px; margin-bottom: 16px; min-height: 100px;">';
      rfiHtml += '<div style="color: #888; font-size: 0.85em; text-align: center; padding: 20px;">No responses yet</div>';
      rfiHtml += '</div>';
      
      // Reply input
      rfiHtml += '<div style="margin-bottom: 16px;">';
      rfiHtml += '<textarea id="srr-rfi-reply" placeholder="Add a response to this RFI..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; resize: vertical;"></textarea>';
      rfiHtml += '</div>';
      
      rfiHtml += '<button class="srr-btn srr-btn-primary" style="width: 100%;" onclick="srrReplyToRFI()">Send Response</button>';
      
      // Update the container
      var container = document.getElementById('srr-patch-editor-fields');
      if (container) {
        container.innerHTML = rfiHtml;
      }
      
      // Hide evidence pack sections for RFI
      ['srr-observation-block', 'srr-expected-block', 'srr-repro-block'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
    }
    
    function srrReplyToRFI() {
      var replyInput = document.getElementById('srr-rfi-reply');
      if (!replyInput || !replyInput.value.trim()) {
        showToast('Please enter a response', 'warning');
        return;
      }
      
      showToast('Response sent to analyst', 'success');
      replyInput.value = '';
    }
    
    function resetReviewerSRRMode() {
      // v1.5.3: Reset SRR to analyst mode when leaving reviewer context
      srrState.reviewerMode = false;
      srrState.reviewerPayload = null;
      srrState.reviewerPatchType = null;
      srrState.reviewerPayloadId = null;
      srrState.isReadOnly = false;  // Restore editing capability
      
      // Restore panel title and tabs
      var panelTitle = document.getElementById('srr-right-panel-title');
      var panelTabs = document.getElementById('srr-panel-tabs');
      
      if (panelTitle) panelTitle.textContent = 'Patch Editor';
      if (panelTabs) {
        panelTabs.style.display = 'none';
        var tabBtns = panelTabs.querySelectorAll('.srr-panel-tab');
        tabBtns.forEach(function(btn) {
          if (btn.getAttribute('data-tab') === 'editor') {
            btn.textContent = 'Editor';
          }
        });
      }
      
      // Restore patch type chips
      var patchTypeSelector = document.querySelector('.srr-patch-type-selector');
      if (patchTypeSelector) patchTypeSelector.style.display = '';
      
      // Restore evidence pack sections
      ['srr-observation-block', 'srr-expected-block', 'srr-repro-block'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.style.display = '';
      });
      
      // Restore change count
      var changeCount = document.getElementById('srr-change-count');
      var actionBoxTitle = document.getElementById('srr-action-box-title');
      if (changeCount) changeCount.style.display = '';
      if (actionBoxTitle) actionBoxTitle.textContent = 'Changed Fields';
    }

    // ========== VERIFIER REVIEW STATE + FUNCTIONS (v1.4.5) ==========
    var vrState = {
      currentPatchId: null,
      reviewState: 'Submitted', // Submitted, Under_Review, Needs_Clarification, Verifier_Approved, Rejected
      reviewerActor: 'verifier@example.com',
      auditLog: [],
      notes: '',
      fromVerifierTriage: false,  // v1.5.0: Track if navigated from Verifier Triage
      currentPayload: null,       // v1.5.0: Store current payload for actions
      selectedPayloadId: null,    // v1.5.0: Store selected payload ID for navigation
      isAdminReview: false        // v1.5.1: Track if this is admin review context
    };
    
    function navigateBackFromVerifierReview() {
      // Reset header back to Verifier Review defaults
      var headerEl = document.querySelector('#page-verifier-review h2');
      if (headerEl) headerEl.textContent = 'Verifier Review';
      var descEl = document.querySelector('#page-verifier-review .page-desc');
      if (descEl) descEl.textContent = 'Review submitted Patch Requests, request clarification, approve or reject.';
      
      // Reset button handlers
      resetVerifierReviewButtons();
      
      // v1.5.1: Navigate back to appropriate queue
      if (vrState.isAdminReview) {
        vrState.isAdminReview = false;
        vrState.fromVerifierTriage = false;
        navigateTo('admin/patch-queue');
      } else if (vrState.fromVerifierTriage) {
        vrState.fromVerifierTriage = false;
        navigateTo('triage');  // Returns to triage which shows Verifier Triage in reviewer mode
      } else {
        navigateTo('triage');
      }
    }
    
    function resetVerifierReviewButtons() {
      var btnBegin = document.getElementById('vr-btn-begin');
      var btnClarify = document.getElementById('vr-btn-clarify');
      var btnApprove = document.getElementById('vr-btn-approve');
      var btnReject = document.getElementById('vr-btn-reject');
      
      if (btnBegin) btnBegin.style.display = '';
      if (btnClarify) btnClarify.style.display = '';
      if (btnApprove) {
        btnApprove.textContent = 'Approve';
        btnApprove.onclick = function() { vrApprove(); };
      }
      if (btnReject) {
        btnReject.onclick = function() { vrReject(); };
      }
    }
    
    // Sample patch data for demo (would come from SRR in real flow)
    var vrSamplePatch = {
      patch_id: 'PATCH-2026-0001',
      author: 'analyst@example.com',
      submitted_at: new Date().toISOString(),
      intent: {
        observation: 'Contract has missing label_vendor field despite being a licensing agreement.',
        expected: 'Label_vendor should be populated when contract_type = LICENSING.',
        justification: 'Licensing agreements require label_vendor for downstream royalty calculations.'
      },
      evidence: {
        observation: 'Row 142 shows contract_type=LICENSING but label_vendor is blank.',
        expected: 'label_vendor = "Sony Music" based on contract header data.',
        justification: 'Header section row 1 references Sony Music as the licensing partner.',
        repro: '1. Load ostereo_demo_v1.json\n2. Navigate to row 142\n3. Observe label_vendor is empty\n4. Cross-reference with contract header'
      },
      preflight: { schema: 'pass', conflicts: 'pass', evidence: 'pass' },
      revisions: []
    };
    
    function loadVerifierReviewData(payloadId) {
      console.log('[VR_LOAD] loadVerifierReviewData called with payloadId:', payloadId);
      
      // v1.5.3 Fix: Handle both PR_ (PatchRequest) and art_ (Artifact) prefixes
      var artifact = null;
      var payload = null;
      var patchRequest = null;
      
      if (payloadId) {
        // v1.5.3: Check for PR_ prefix first - load from PATCH_REQUEST_STORE
        if (payloadId.startsWith('PR_')) {
          patchRequest = PATCH_REQUEST_STORE.get(payloadId);
          if (patchRequest) {
            console.log('[VR_LOAD] Found PatchRequest:', patchRequest.request_id);
            // Convert PatchRequest to payload-like structure for display
            payload = {
              id: patchRequest.request_id,
              type: patchRequest.patch_type || patchRequest.patch_kind || 'correction',
              record_id: patchRequest.record_id,
              dataset_id: patchRequest.dataset_id,
              field: patchRequest.field || patchRequest.target_field,
              old_value: patchRequest.old_value || '',
              new_value: patchRequest.new_value || '',
              comment: patchRequest.because || patchRequest.evidence_justification || '',
              analyst_id: patchRequest.author || patchRequest.created_by,
              timestamp: patchRequest.created_at,
              status: patchRequest.status,
              patch_request: patchRequest  // Keep reference to full PatchRequest
            };
          } else {
            console.log('[VR_LOAD] PatchRequest not found:', payloadId);
          }
        }
        
        // Try artifact store if no PatchRequest or payloadId starts with art_
        if (!payload) {
          artifact = getArtifact(payloadId);
          if (artifact) {
            console.log('[VR_LOAD] Found artifact:', artifact.artifact_id, artifact.artifact_type);
            // Convert artifact to payload-like structure for display
            payload = {
              id: artifact.artifact_id,
              type: artifact.body.patch_type || (artifact.artifact_type === 'rfi' ? 'rfi' : 'correction'),
              record_id: artifact.record_id,
              field: artifact.field_key,
              old_value: artifact.body.old_value || '',
              new_value: artifact.body.new_value || '',
              comment: artifact.body.comment || '',
              analyst_id: artifact.created_by_actor_id,
              timestamp: artifact.created_at,
              status: artifact.status,
              thread_id: artifact.thread_id,
              artifact: artifact  // Keep reference to full artifact
            };
          }
        }
        
        // Fallback to legacy verifier queue
        if (!payload) {
          payload = verifierQueueState.payloads.find(function(p) { return p.id === payloadId; });
          console.log('[VR_LOAD] Found legacy payload:', payload ? 'yes' : 'no');
        }
      }
      
      // Hide all type-specific content blocks
      document.getElementById('vr-rfi-content').style.display = 'none';
      document.getElementById('vr-correction-content').style.display = 'none';
      document.getElementById('vr-blacklist-content').style.display = 'none';
      document.getElementById('vr-legacy-content').style.display = 'none';
      
      var typeBadge = document.getElementById('vr-type-badge');
      
      if (payload) {
        // Update type badge
        if (payload.type === 'rfi') {
          typeBadge.textContent = 'RFI';
          typeBadge.style.background = '#ff9800';
          document.getElementById('vr-rfi-content').style.display = 'block';
          
          // Populate RFI fields
          document.getElementById('vr-rfi-field').textContent = payload.field || 'â€”';
          document.getElementById('vr-rfi-value').textContent = payload.old_value || '(empty)';
          document.getElementById('vr-rfi-comment').textContent = payload.comment || 'â€”';
          
        } else if (payload.type === 'blacklist') {
          typeBadge.textContent = 'BLACKLIST';
          typeBadge.style.background = '#d32f2f';
          document.getElementById('vr-blacklist-content').style.display = 'block';
          
          // Populate Blacklist fields
          document.getElementById('vr-bl-field').textContent = payload.field || 'â€”';
          document.getElementById('vr-bl-value').textContent = payload.old_value || '(empty)';
          document.getElementById('vr-bl-subject').textContent = payload.field + ': ' + (payload.old_value || '(empty)');
          document.getElementById('vr-bl-comment').textContent = payload.comment || 'â€”';
          
        } else {
          typeBadge.textContent = 'CORRECTION';
          typeBadge.style.background = '#1565c0';
          document.getElementById('vr-correction-content').style.display = 'block';
          
          // Populate Correction fields
          document.getElementById('vr-corr-field').textContent = payload.field || 'â€”';
          document.getElementById('vr-corr-old').textContent = payload.old_value || '(empty)';
          document.getElementById('vr-corr-new').textContent = payload.new_value || '(no change)';
          document.getElementById('vr-corr-comment').textContent = payload.comment || 'â€”';
        }
        
        document.getElementById('vr-author-name').textContent = payload.analyst_id || 'analyst@example.com';
        document.getElementById('vr-author-time').textContent = new Date(payload.timestamp).toLocaleString();
        document.getElementById('vr-patch-id').textContent = payload.id;
        
        // Map payload status to vrState
        var statusMap = { 'pending': 'Submitted', 'needs_clarification': 'Needs_Clarification', 'sent_to_admin': 'Verifier_Approved', 'resolved': 'Admin_Approved' };
        vrState.currentPatchId = payload.id;
        vrState.reviewState = statusMap[payload.status] || 'Submitted';
        vrState.currentPayload = payload;
      } else {
        // Fallback to sample/legacy data
        typeBadge.textContent = 'CORRECTION';
        typeBadge.style.background = '#1565c0';
        document.getElementById('vr-legacy-content').style.display = 'block';
        
        document.getElementById('vr-intent-when').textContent = vrSamplePatch.intent.observation || 'â€”';
        document.getElementById('vr-intent-then').textContent = vrSamplePatch.intent.expected || 'â€”';
        document.getElementById('vr-intent-because').textContent = vrSamplePatch.intent.justification || 'â€”';
        
        document.getElementById('vr-ev-observation').textContent = vrSamplePatch.evidence.observation || 'â€”';
        document.getElementById('vr-ev-expected').textContent = vrSamplePatch.evidence.expected || 'â€”';
        document.getElementById('vr-ev-justification').textContent = vrSamplePatch.evidence.justification || 'â€”';
        document.getElementById('vr-ev-repro').textContent = vrSamplePatch.evidence.repro || 'â€”';
        
        document.getElementById('vr-author-name').textContent = vrSamplePatch.author;
        document.getElementById('vr-author-time').textContent = vrSamplePatch.submitted_at;
        document.getElementById('vr-patch-id').textContent = vrSamplePatch.patch_id;
        
        vrState.currentPatchId = vrSamplePatch.patch_id;
        vrState.reviewState = 'Submitted';
        vrState.currentPayload = null;
      }
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
    }
    
    function vrOpenSingleRowReview() {
      var payload = vrState.currentPayload;
      
      // v1.5.2: Load PatchRequest by patch_request_id first
      var patchRequest = null;
      var patchRequestId = payload?.patch_request_id || null;
      
      if (patchRequestId) {
        patchRequest = PATCH_REQUEST_STORE.get(patchRequestId);
        console.log('[VR_SRR] Loaded PatchRequest from store:', patchRequestId, patchRequest ? 'found' : 'NOT FOUND');
        
        if (!patchRequest) {
          // Show blocking error UI with exact storage key
          var storageKey = 'pr:' + ARTIFACT_STORE.environment + ':' + patchRequestId;
          showToast('PatchRequest not found: ' + storageKey, 'error');
          console.error('[VR_SRR] BLOCKING: PatchRequest missing. Key:', storageKey);
          // Update debug panel if visible
          updateDebugPanel({ patchRequest_load: 'FAILED', storageKey: storageKey });
          return;
        }
      }
      
      // v1.5.2: Use record_id from PatchRequest or payload
      var recordId = (patchRequest && patchRequest.record_id) || (payload && payload.record_id) || null;
      var datasetId = (patchRequest && patchRequest.dataset_id) || (payload && payload.dataset_id) || IDENTITY_CONTEXT.dataset_id || 'default';
      
      if (!recordId) {
        showToast('No record_id linked to this review', 'info');
        return;
      }
      
      var foundSheet = null;
      var foundIdx = -1;
      var foundRecord = null;
      
      // Search across all sheets for the record by record_id
      if (workbook && workbook.sheets) {
        Object.keys(workbook.sheets).forEach(function(sheetName) {
          if (foundRecord) return;
          var sheet = workbook.sheets[sheetName];
          var rows = sheet ? sheet.rows : [];
          if (!rows) return;
          for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            // Match by record_id (primary), _identity.record_id, or fallback to contract_key
            var rowRecordId = row.record_id || (row._identity && row._identity.record_id);
            if (rowRecordId === recordId || row.contract_key === recordId) {
              foundSheet = sheetName;
              foundIdx = i;
              foundRecord = row;
              break;
            }
          }
        });
      }
      
      if (foundRecord) {
        // v1.5.2: Set SRR context with proper binding
        srrState.currentSheetName = foundSheet;
        srrState.currentDatasetId = datasetId;
        srrState.currentRecordId = recordId;
        srrState.currentPatchRequestId = patchRequestId;
        srrState.currentArtifactId = payload?.artifact?.artifact_id || vrState.selectedPayloadId || null;
        srrState.isReadOnly = (currentMode === 'reviewer' || currentMode === 'admin');
        srrState.currentPatchRequest = patchRequest;  // Store for Patch Tester
        
        console.log('[VR_SRR] Opening SRR with context:', {
          sheetName: foundSheet,
          rowIdx: foundIdx,
          recordId: recordId,
          datasetId: datasetId,
          patchRequestId: patchRequestId,
          artifactId: srrState.currentArtifactId,
          isReadOnly: srrState.isReadOnly
        });
        
        // Update debug panel
        updateDebugPanel({
          role: currentMode,
          tenant_id: IDENTITY_CONTEXT.tenant_id,
          division_id: IDENTITY_CONTEXT.division_id,
          dataset_id: datasetId,
          record_id: recordId,
          patch_request_id: patchRequestId,
          patchRequest_load: patchRequest ? 'SUCCESS' : 'N/A',
          record_load: 'SUCCESS'
        });
        
        navigateTo('row/' + foundIdx);
        
        // Load Patch Tester data if artifact exists and not RFI
        if (srrState.currentArtifactId) {
          var artifact = getArtifact(srrState.currentArtifactId);
          var isRfi = false;
          if (artifact) {
            if (artifact.artifact_type === 'rfi') isRfi = true;
            if (artifact.body && artifact.body.patch_type === 'rfi') isRfi = true;
          }
          if (!isRfi) {
            srrLoadPatchTesterData(srrState.currentArtifactId);
          }
        }
      } else {
        // v1.5.3 Fix: Fallback to record store when workbook lookup fails
        console.log('[VR_SRR] Workbook lookup failed, trying record store...');
        var fallbackTenantId = (patchRequest && patchRequest.tenant_id) || IDENTITY_CONTEXT.tenant_id || 'tenant_default';
        var storedRecord = loadRecordFromStore(fallbackTenantId, datasetId, recordId);
        
        if (storedRecord && storedRecord.data) {
          console.log('[VR_SRR] Found record in store:', storedRecord.record_id);
          foundRecord = storedRecord.data;
          var srcPointers = storedRecord.source_pointers || {};
          foundSheet = srcPointers.sheet_name || datasetId;
          foundIdx = srcPointers.row_index || 0;
          
          // Inject into workbook for subsequent lookups
          if (!workbook.sheets[foundSheet]) {
            workbook.sheets[foundSheet] = { name: foundSheet, headers: Object.keys(foundRecord), rows: [] };
            if (workbook.order.indexOf(foundSheet) < 0) workbook.order.push(foundSheet);
          }
          if (!workbook.sheets[foundSheet].rows[foundIdx]) {
            workbook.sheets[foundSheet].rows[foundIdx] = foundRecord;
          }
          
          // Set SRR context and open
          srrState.currentSheetName = foundSheet;
          srrState.currentDatasetId = datasetId;
          srrState.currentRecordId = recordId;
          srrState.currentPatchRequestId = patchRequestId;
          var artifactId = (payload && payload.artifact && payload.artifact.artifact_id) || vrState.selectedPayloadId || null;
          srrState.currentArtifactId = artifactId;
          srrState.isReadOnly = (currentMode === 'reviewer' || currentMode === 'admin');
          srrState.currentPatchRequest = patchRequest;
          
          updateDebugPanel({
            role: currentMode,
            tenant_id: fallbackTenantId,
            dataset_id: datasetId,
            record_id: recordId,
            record_load: 'STORE_FALLBACK'
          });
          
          navigateTo('row/' + foundIdx);
        } else {
          var storeKey = 'kiwi/v1/' + fallbackTenantId + '/records/' + datasetId + '/' + recordId + '.json';
          showToast('Record not found in dataset or store: ' + recordId, 'warning');
          updateDebugPanel({ record_load: 'FAILED', record_id: recordId, store_key: storeKey });
        }
      }
    }
    
    function openVerifierReviewDetail(payloadId) {
      console.log('[VR_OPEN] Opening verifier review for payload:', payloadId);
      vrState.fromVerifierTriage = true;  // Track navigation source
      vrState.isAdminReview = false;  // Not admin review
      vrState.selectedPayloadId = payloadId;  // Store selected payload ID for navigation handler
      console.log('[VR_OPEN] vrState.selectedPayloadId set to:', vrState.selectedPayloadId);
      navigateTo('verifier-review');
    }
    
    // v1.5.1: Load data for Admin Review (from Admin Queue)
    function loadAdminReviewData(artifactId) {
      console.log('[AR_LOAD] loadAdminReviewData called with artifactId:', artifactId);
      
      vrState.isAdminReview = true;  // Track admin context
      vrState.fromVerifierTriage = true;
      vrState.selectedPayloadId = artifactId;
      
      // Update page header to show "Admin Review"
      var headerEl = document.querySelector('#page-verifier-review h2');
      if (headerEl) {
        headerEl.textContent = 'Admin Review';
      }
      var descEl = document.querySelector('#page-verifier-review .page-desc');
      if (descEl) {
        descEl.textContent = 'Final Admin review of Verifier-approved items. Finalize or reject.';
      }
      
      // Load the data (reuses verifier review data loading)
      loadVerifierReviewData(artifactId);
      
      // Update action buttons for admin context
      setTimeout(function() {
        vrUpdateActionButtonsForAdmin();
      }, 100);
    }
    
    function vrUpdateActionButtonsForAdmin() {
      // In admin review, show Finalize/Reject instead of Begin Review/Approve/Reject
      var btnBegin = document.getElementById('vr-btn-begin');
      var btnClarify = document.getElementById('vr-btn-clarify');
      var btnApprove = document.getElementById('vr-btn-approve');
      var btnReject = document.getElementById('vr-btn-reject');
      
      if (vrState.isAdminReview) {
        // Hide Begin Review for admin (already reviewed by verifier)
        if (btnBegin) btnBegin.style.display = 'none';
        if (btnClarify) btnClarify.style.display = 'none';
        
        // Rename Approve to Finalize
        if (btnApprove) {
          btnApprove.textContent = 'Finalize';
          btnApprove.disabled = false;
          btnApprove.onclick = function() { adminFinalizeFromReview(); };
        }
        if (btnReject) {
          btnReject.disabled = false;
          btnReject.onclick = function() { adminRejectFromReview(); };
        }
      }
    }
    
    function adminFinalizeFromReview() {
      if (!vrState.selectedPayloadId) return;
      updatePayloadStatus(vrState.selectedPayloadId, 'resolved');
      showToast('Item finalized and resolved', 'success');
      navigateTo('admin/patch-queue');
    }
    
    function adminRejectFromReview() {
      var notes = document.getElementById('vr-notes')?.value?.trim();
      if (!notes) {
        showToast('Please add notes explaining the rejection', 'warning');
        return;
      }
      if (!vrState.selectedPayloadId) return;
      updatePayloadStatus(vrState.selectedPayloadId, 'rejected');
      showToast('Item rejected', 'warning');
      navigateTo('admin/patch-queue');
    }
    
    function vrUpdateStateBadge() {
      var badge = document.getElementById('vr-state-badge');
      var stateClass = vrState.reviewState.toLowerCase().replace(/_/g, '-');
      badge.className = 'vr-state-badge ' + stateClass;
      badge.textContent = vrState.reviewState.replace(/_/g, ' ');
    }
    
    function vrUpdateActionButtons() {
      var btnBegin = document.getElementById('vr-btn-begin');
      var btnClarify = document.getElementById('vr-btn-clarify');
      var btnApprove = document.getElementById('vr-btn-approve');
      var btnReject = document.getElementById('vr-btn-reject');
      
      // Reset all
      btnBegin.disabled = true;
      btnClarify.disabled = true;
      btnApprove.disabled = true;
      btnReject.disabled = true;
      
      // Enable based on state
      if (vrState.reviewState === 'Submitted') {
        btnBegin.disabled = false;
      } else if (vrState.reviewState === 'Under_Review') {
        btnClarify.disabled = false;
        btnApprove.disabled = false;
        btnReject.disabled = false;
      }
      // Needs_Clarification, Verifier_Approved, Rejected = no actions available
    }
    
    function vrLogAuditEvent(eventType, details) {
      var event = {
        timestamp: new Date().toISOString(),
        event_type: eventType,
        patch_id: vrState.currentPatchId,
        actor: vrState.reviewerActor,
        details: details || {}
      };
      vrState.auditLog.push(event);
      console.log('[VR] AUDIT:', eventType, event);
    }
    
    function vrBeginReview() {
      if (vrState.reviewState !== 'Submitted') return;
      
      vrState.reviewState = 'Under_Review';
      vrLogAuditEvent('BEGIN_REVIEW', { from_state: 'Submitted' });
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Review started â€” patch is now Under Review', 'info');
    }
    
    function vrRequestClarification() {
      if (vrState.reviewState !== 'Under_Review') return;
      document.getElementById('vr-clarify-modal').classList.add('active');
    }
    
    function vrClarifyCancel() {
      document.getElementById('vr-clarify-modal').classList.remove('active');
      document.getElementById('vr-clarify-text').value = '';
    }
    
    function vrClarifySubmit() {
      var clarifyText = document.getElementById('vr-clarify-text').value.trim();
      if (!clarifyText) {
        showToast('Please describe the clarification needed', 'warning');
        return;
      }
      
      vrState.reviewState = 'Needs_Clarification';
      vrState.notes = document.getElementById('vr-notes').value;
      vrLogAuditEvent('REQUEST_CLARIFICATION', { question_text: clarifyText });
      
      document.getElementById('vr-clarify-modal').classList.remove('active');
      document.getElementById('vr-clarify-text').value = '';
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Clarification requested â€” author notified', 'info');
    }
    
    function vrApprove() {
      if (vrState.reviewState !== 'Under_Review') return;
      
      vrState.notes = document.getElementById('vr-notes').value;
      vrState.reviewState = 'Verifier_Approved';
      vrLogAuditEvent('VERIFIER_APPROVED', { checklist_confirmed: true, notes: vrState.notes });
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Patch approved by Verifier â€” routed to Admin Approval', 'success');
    }
    
    function vrReject() {
      if (vrState.reviewState !== 'Under_Review') return;
      
      var notes = document.getElementById('vr-notes').value.trim();
      if (!notes) {
        showToast('Please add review notes explaining the rejection reason', 'warning');
        return;
      }
      
      vrState.notes = notes;
      vrState.reviewState = 'Rejected';
      vrLogAuditEvent('REJECTED', { rejection_reason: notes });
      
      vrUpdateStateBadge();
      vrUpdateActionButtons();
      vrRenderDecisionSummary();
      showToast('Patch rejected', 'info');
    }
    
    function vrRenderDecisionSummary() {
      var container = document.getElementById('vr-decision-summary');
      
      if (vrState.reviewState === 'Submitted' || vrState.reviewState === 'Under_Review') {
        container.innerHTML = '';
        return;
      }
      
      var isRejected = vrState.reviewState === 'Rejected';
      var stateLabel = vrState.reviewState.replace(/_/g, ' ');
      var lastEvent = vrState.auditLog[vrState.auditLog.length - 1];
      
      container.innerHTML = '<div class="vr-decision-summary' + (isRejected ? ' rejected' : '') + '">' +
        '<strong>Decision:</strong> ' + stateLabel + '<br>' +
        '<span style="font-size: 0.85em; color: #666;">by ' + vrState.reviewerActor + ' at ' + (lastEvent ? lastEvent.timestamp : 'â€”') + '</span>' +
        (vrState.notes ? '<div style="margin-top: 8px; font-size: 0.85em;"><strong>Notes:</strong> ' + vrState.notes + '</div>' : '') +
      '</div>';
    }

    // ========== ADMIN APPROVAL STATE + FUNCTIONS (v1.4.5) ==========
    var aaState = {
      currentPatchId: null,
      reviewState: 'Verifier_Approved', // Verifier_Approved, Admin_Hold, Admin_Approved, Promoted
      adminActor: 'admin@example.com',
      auditLog: [],
      notes: '',
      smokeStatus: 'pass' // pass or fail
    };
    
    // Sample patch data for Admin Approval demo
    var aaSamplePatch = {
      patch_id: 'PATCH-2026-0001',
      author: 'analyst@example.com',
      submitted_at: new Date(Date.now() - 3600000).toISOString(),
      intent: {
        observation: 'Contract has missing label_vendor field despite being a licensing agreement.',
        expected: 'Label_vendor should be populated when contract_type = LICENSING.',
        justification: 'Licensing agreements require label_vendor for downstream royalty calculations.'
      },
      evidence: {
        observation: 'Row 142 shows contract_type=LICENSING but label_vendor is blank.',
        expected: 'label_vendor = "Sony Music" based on contract header data.',
        justification: 'Header section row 1 references Sony Music as the licensing partner.',
        repro: '1. Load ostereo_demo_v1.json\n2. Navigate to row 142\n3. Observe label_vendor is empty\n4. Cross-reference with contract header'
      },
      verifier: {
        actor: 'verifier@example.com',
        approved_at: new Date(Date.now() - 1800000).toISOString(),
        notes: 'All checklist items confirmed. Evidence is complete and consistent.'
      },
      preflight: { schema: 'pass', conflicts: 'pass', evidence: 'pass' },
      smoke: { status: 'pass', last_run: new Date().toISOString() },
      changelog: '## [1.4.6] - 2026-02-03\n\n### Changed\n- SF_R1_LABEL_NOT_ARTIST: Updated label_vendor requirement for LICENSING contracts',
      revisions: []
    };
    
    function loadAdminApprovalData() {
      // Load sample data into view
      document.getElementById('aa-intent-when').textContent = aaSamplePatch.intent.observation || 'â€”';
      document.getElementById('aa-intent-then').textContent = aaSamplePatch.intent.expected || 'â€”';
      document.getElementById('aa-intent-because').textContent = aaSamplePatch.intent.justification || 'â€”';
      
      document.getElementById('aa-ev-observation').textContent = aaSamplePatch.evidence.observation || 'â€”';
      document.getElementById('aa-ev-expected').textContent = aaSamplePatch.evidence.expected || 'â€”';
      document.getElementById('aa-ev-justification').textContent = aaSamplePatch.evidence.justification || 'â€”';
      document.getElementById('aa-ev-repro').textContent = aaSamplePatch.evidence.repro || 'â€”';
      
      document.getElementById('aa-verifier-name').textContent = aaSamplePatch.verifier.actor;
      document.getElementById('aa-verifier-time').textContent = aaSamplePatch.verifier.approved_at;
      document.getElementById('aa-verifier-notes').textContent = aaSamplePatch.verifier.notes;
      
      document.getElementById('aa-smoke-time').textContent = aaSamplePatch.smoke.last_run;
      document.getElementById('aa-changelog-preview').textContent = aaSamplePatch.changelog;
      
      aaState.currentPatchId = aaSamplePatch.patch_id;
      aaState.reviewState = 'Verifier_Approved';
      aaState.smokeStatus = aaSamplePatch.smoke.status;
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
    }
    
    function aaUpdateStateBadge() {
      var badge = document.getElementById('aa-state-badge');
      var stateClass = aaState.reviewState.toLowerCase().replace(/_/g, '-');
      badge.className = 'aa-state-badge ' + stateClass;
      badge.textContent = aaState.reviewState.replace(/_/g, ' ');
    }
    
    function aaUpdateActionButtons() {
      var btnApprove = document.getElementById('aa-btn-approve');
      var btnHold = document.getElementById('aa-btn-hold');
      var btnRelease = document.getElementById('aa-btn-release');
      var btnPromote = document.getElementById('aa-btn-promote');
      
      // Reset all
      btnApprove.disabled = true;
      btnHold.disabled = true;
      btnRelease.disabled = true;
      btnPromote.disabled = true;
      
      // Enable based on state
      if (aaState.reviewState === 'Verifier_Approved') {
        btnApprove.disabled = false;
        btnHold.disabled = false;
      } else if (aaState.reviewState === 'Admin_Hold') {
        btnRelease.disabled = false;
      } else if (aaState.reviewState === 'Admin_Approved') {
        btnPromote.disabled = aaState.smokeStatus !== 'pass';
      }
      // Promoted = no actions available
    }
    
    function aaLogAuditEvent(eventType, details) {
      var event = {
        timestamp: new Date().toISOString(),
        event_type: eventType,
        patch_id: aaState.currentPatchId,
        actor: aaState.adminActor,
        details: details || {}
      };
      aaState.auditLog.push(event);
      console.log('[AA] AUDIT:', eventType, event);
    }
    
    // v1.4.17: Patch Replay Gate functions
    var replayState = {
      status: 'not_run', // not_run | pass | fail
      checks: [],
      failureReason: null,
      lastRunAt: null
    };
    
    function aaRunReplay() {
      console.log('[AA] Running Patch Replay evaluation...');
      
      // Deterministic stub: evaluate based on patch content hash
      // Uses a simple hash of the current patch to produce consistent results
      var patchHash = 0;
      var intentText = (aaState.observation || '') + (aaState.expected || '') + (aaState.justification || '');
      for (var i = 0; i < intentText.length; i++) {
        patchHash = ((patchHash << 5) - patchHash) + intentText.charCodeAt(i);
        patchHash = patchHash & patchHash; // Convert to 32-bit integer
      }
      
      // Deterministic check results based on hash (not random)
      var checks = [
        { id: 'schema', label: 'Schema Validation', pass: true },
        { id: 'conflicts', label: 'Conflict Detection', pass: true },
        { id: 'baseline', label: 'Baseline Compatibility', pass: (patchHash % 7) !== 0 },
        { id: 'rules', label: 'Rule Evaluation', pass: (patchHash % 11) !== 0 },
        { id: 'output', label: 'Output Determinism', pass: true }
      ];
      
      var allPass = checks.every(function(c) { return c.pass; });
      var failedCheck = checks.find(function(c) { return !c.pass; });
      
      replayState.status = allPass ? 'pass' : 'fail';
      replayState.checks = checks;
      replayState.lastRunAt = new Date().toISOString();
      replayState.failureReason = failedCheck ? 'Check failed: ' + failedCheck.label + ' (hash=' + Math.abs(patchHash % 100) + ')' : null;
      
      // Update UI
      aaRenderReplayStatus();
      
      // Log audit event
      aaLogAuditEvent('REPLAY_EVALUATED', {
        result: replayState.status,
        checks: checks.map(function(c) { return { id: c.id, pass: c.pass }; }),
        failure_reason: replayState.failureReason
      });
      
      showToast('Replay evaluation: ' + replayState.status.toUpperCase(), replayState.status === 'pass' ? 'success' : 'warning');
    }
    
    function aaRenderReplayStatus() {
      var statusEl = document.getElementById('aa-replay-status');
      var badgeEl = document.getElementById('aa-replay-badge');
      var textEl = document.getElementById('aa-replay-status-text');
      var packetEl = document.getElementById('aa-replay-packet');
      var failureEl = document.getElementById('aa-replay-failure-reason');
      var failureTextEl = document.getElementById('aa-replay-failure-text');
      var btnEl = document.getElementById('aa-replay-btn');
      
      // Update status badge
      statusEl.className = 'aa-replay-status ' + replayState.status.replace('_', '-');
      badgeEl.className = 'aa-replay-badge ' + replayState.status.replace('_', '-');
      badgeEl.textContent = replayState.status.toUpperCase().replace('_', ' ');
      
      if (replayState.status === 'not_run') {
        textEl.textContent = 'Replay evaluation not yet performed';
        packetEl.style.display = 'none';
        failureEl.style.display = 'none';
        btnEl.textContent = 'Run Replay';
      } else {
        textEl.textContent = replayState.status === 'pass' 
          ? 'All checks passed at ' + new Date(replayState.lastRunAt).toLocaleTimeString()
          : 'Failed at ' + new Date(replayState.lastRunAt).toLocaleTimeString();
        
        // Show packet with per-check status
        packetEl.style.display = 'block';
        replayState.checks.forEach(function(check) {
          var checkEl = document.getElementById('aa-replay-check-' + check.id);
          if (checkEl) {
            checkEl.className = 'aa-replay-check ' + (check.pass ? 'pass' : 'fail');
            checkEl.querySelector('.aa-replay-check-icon').textContent = check.pass ? 'âœ“' : 'âœ—';
          }
        });
        
        // Show failure reason if failed
        if (replayState.status === 'fail') {
          failureEl.style.display = 'block';
          failureTextEl.textContent = replayState.failureReason || 'Unknown failure';
        } else {
          failureEl.style.display = 'none';
        }
        
        btnEl.textContent = 'Re-run Replay';
      }
    }
    
    function aaShowReplayAuditLog() {
      // Stub: show toast pointing to audit log
      showToast('Replay failure logged to Audit Log (entry ID: REPLAY_' + Date.now() + ')', 'info');
      console.log('[AA] Replay audit entry:', {
        event_type: 'REPLAY_FAILED',
        timestamp: replayState.lastRunAt,
        failure_reason: replayState.failureReason,
        checks: replayState.checks
      });
    }
    
    function aaAdminApprove() {
      if (aaState.reviewState !== 'Verifier_Approved') return;
      
      if (aaState.smokeStatus !== 'pass') {
        showToast('Smoke (Strict) must pass before Admin Approve', 'warning');
        return;
      }
      
      aaState.notes = document.getElementById('aa-notes').value;
      aaState.reviewState = 'Admin_Approved';
      aaLogAuditEvent('ADMIN_APPROVED', { smoke_evidence_ref: 'smoke_strict_' + Date.now(), notes: aaState.notes });
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Patch approved by Admin â€” ready to Promote', 'success');
    }
    
    function aaAdminHold() {
      if (aaState.reviewState !== 'Verifier_Approved') return;
      document.getElementById('aa-hold-modal').classList.add('active');
    }
    
    function aaHoldCancel() {
      document.getElementById('aa-hold-modal').classList.remove('active');
      document.getElementById('aa-hold-text').value = '';
    }
    
    function aaHoldSubmit() {
      var holdText = document.getElementById('aa-hold-text').value.trim();
      if (!holdText) {
        showToast('Please provide a hold reason', 'warning');
        return;
      }
      
      aaState.reviewState = 'Admin_Hold';
      aaState.notes = document.getElementById('aa-notes').value;
      aaLogAuditEvent('ADMIN_HOLD', { hold_reason: holdText });
      
      document.getElementById('aa-hold-modal').classList.remove('active');
      document.getElementById('aa-hold-text').value = '';
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Patch placed on Admin Hold', 'info');
    }
    
    function aaReleaseHold() {
      if (aaState.reviewState !== 'Admin_Hold') return;
      
      aaState.notes = document.getElementById('aa-notes').value;
      aaState.reviewState = 'Verifier_Approved'; // Returns to Verifier_Approved for re-evaluation
      aaLogAuditEvent('RELEASE_HOLD', { notes: aaState.notes });
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Hold released â€” patch returned to Verifier Approved state', 'info');
    }
    
    function aaPromoteToBaseline() {
      if (aaState.reviewState !== 'Admin_Approved') return;
      
      if (aaState.smokeStatus !== 'pass') {
        showToast('Smoke (Strict) must pass before Promote', 'warning');
        return;
      }
      
      aaState.notes = document.getElementById('aa-notes').value;
      aaState.reviewState = 'Promoted';
      aaLogAuditEvent('PROMOTE_TO_BASELINE', { 
        version: '1.4.6', 
        changelog_entry: aaSamplePatch.changelog,
        notes: aaState.notes 
      });
      
      aaUpdateStateBadge();
      aaUpdateActionButtons();
      aaRenderDecisionSummary();
      showToast('Patch promoted to baseline! Version 1.4.6 is now live.', 'success');
    }
    
    function aaRenderDecisionSummary() {
      var container = document.getElementById('aa-decision-summary');
      
      if (aaState.reviewState === 'Verifier_Approved') {
        container.innerHTML = '';
        return;
      }
      
      var stateLabel = aaState.reviewState.replace(/_/g, ' ');
      var lastEvent = aaState.auditLog[aaState.auditLog.length - 1];
      
      container.innerHTML = '<div class="aa-decision-summary">' +
        '<strong>Admin Decision:</strong> ' + stateLabel + '<br>' +
        '<span style="font-size: 0.85em; color: #666;">by ' + aaState.adminActor + ' at ' + (lastEvent ? lastEvent.timestamp : 'â€”') + '</span>' +
        (aaState.notes ? '<div style="margin-top: 8px; font-size: 0.85em;"><strong>Notes:</strong> ' + aaState.notes + '</div>' : '') +
      '</div>';
    }

    // Attach Grid event listeners
    document.addEventListener('DOMContentLoaded', function() {
      var gridSearch = document.getElementById('grid-search');
      if (gridSearch) {
        gridSearch.addEventListener('input', function() {
          gridState.search = gridSearch.value;
          updateGridURL();
          renderGrid();
        });
      }
    });
    var gridVirtualState = { data: [], rendered: 0, columns: [], active: false };
    
    function cleanupGridVirtualization() {
      var container = document.querySelector('.grid-table-container');
      if (container) {
        container.removeEventListener('scroll', gridLazyLoadHandler);
      }
      gridVirtualState.active = false;
    }
    
    function renderGridBatch(data, startIdx, batchSize, columns, isFirst) {
      var perfT = perfStart();
      var tbody = document.getElementById('grid-tbody');
      if (isFirst) {
        cleanupGridVirtualization();
        tbody.innerHTML = '';
        gridVirtualState = { data: data, rendered: 0, columns: columns, active: true };
        // Add scroll listener for lazy loading
        var container = document.querySelector('.grid-table-container');
        if (container) {
          container.addEventListener('scroll', gridLazyLoadHandler);
        }
      }
      
      var endIdx = Math.min(startIdx + batchSize, data.length);
      var fragment = document.createDocumentFragment();
      
      // v1.6.18: Status key normalization - check multiple possible header variants
      var STATUS_KEYS = ['status', 'Status', 'sf_contract_status', 'review_state', 'Review_State'];
      
      for (var idx = startIdx; idx < endIdx; idx++) {
        var r = data[idx];
        var tr = document.createElement('tr');
        
        // v1.4.15: Pass sheet name and original row index to click handler
        var sheetName = r.sheet || '';
        var sheetRowIdx = r._sheetRowIndex !== undefined ? r._sheetRowIndex : idx;
        // v1.6.2: Get record ID for signal styling (match signalStore derivation)
        var recordId = r.record_id || (r._identity && r._identity.record_id) || r.contract_key || '';
        if (!recordId) {
          recordId = sheetName + ':' + sheetRowIdx;
        }
        
        // v1.6.18: Build row classes - clickable + row-change classes
        var rowClasses = ['clickable'];
        var changeSummary = getRecordChangeSummary(recordId);
        if (changeSummary && changeSummary.total > 0) {
          // Determine primary change type for row class
          if (changeSummary.by_type.added) rowClasses.push('row-added');
          else if (changeSummary.by_type.blacklist) rowClasses.push('row-removed');
          else if (changeSummary.by_type.removed) rowClasses.push('row-removed');
          else rowClasses.push('row-changed'); // correction, rfi, system_change
        }
        tr.className = rowClasses.join(' ');
        
        tr.dataset.sheetName = sheetName;
        tr.dataset.recordIndex = sheetRowIdx;
        tr.dataset.recordId = recordId;
        tr.onclick = (function(sn, sri) { return function() { openRowReviewDrawer(sn, sri); }; })(sheetName, sheetRowIdx);
        
        // v1.6.18: Normalize status field lookup - try multiple header variants
        var statusVal = '';
        for (var si = 0; si < STATUS_KEYS.length; si++) {
          if (r[STATUS_KEYS[si]]) {
            statusVal = r[STATUS_KEYS[si]];
            break;
          }
        }
        var statusClass = 'status-' + (statusVal || '').toLowerCase().replace(/\s+/g, '_');
        
        // v1.6.2: Add row badges for signal counts
        var rowBadgesHtml = renderRowBadges(recordId);
        
        tr.innerHTML = '<td class="row-index">' + (idx + 1) + rowBadgesHtml + '</td>' +
          columns.map(function(col) {
            var val = r[col];
            if (val === null || val === undefined) val = '';
            if (typeof val === 'object') val = JSON.stringify(val);
            
            // v1.6.28: Make File_Name a clickable link using file_url
            var isFileNameCol = col.toLowerCase().includes('file_name');
            var cellContent = String(val);
            if (isFileNameCol && val) {
              var fileUrl = r.file_url || r.File_URL_c || '';
              if (fileUrl) {
                // Show truncated file name with link icon
                var shortName = val.length > 40 ? val.substring(0, 38) + '...' : val;
                cellContent = '<a href="' + fileUrl + '" target="_blank" onclick="event.stopPropagation();" style="color: #1976d2; text-decoration: none; display: flex; align-items: center; gap: 4px;">' +
                  '<span style="font-size: 0.9em;">&#128279;</span>' + shortName + '</a>';
              }
            }
            
            // v1.6.18: Apply status class for any status-variant column
            var isStatusCol = STATUS_KEYS.indexOf(col) >= 0 || col.toLowerCase() === 'status';
            var cellClass = isStatusCol ? statusClass : '';
            // v1.6.2: Apply signal-based cell coloring (v1.6.18: pass record for fallback)
            var cellStyle = getGridCellStyle(recordId, col, r);
            return '<td class="' + cellClass + ' truncated" style="' + cellStyle + '" title="' + String(val).replace(/"/g, '&quot;') + '">' + cellContent + '</td>';
          }).join('');
        
        fragment.appendChild(tr);
      }
      
      tbody.appendChild(fragment);
      gridVirtualState.rendered = endIdx;
      perfLog('renderGridBatch (' + (endIdx - startIdx) + ' rows)', perfT);
    }
    
    function gridLazyLoadHandler() {
      var container = document.querySelector('.grid-table-container');
      if (!container || gridVirtualState.rendered >= gridVirtualState.data.length) return;
      
      var scrollTop = container.scrollTop;
      var scrollHeight = container.scrollHeight;
      var clientHeight = container.clientHeight;
      
      // Load more when near bottom (within 200px)
      if (scrollTop + clientHeight >= scrollHeight - 200) {
        renderGridBatch(gridVirtualState.data, gridVirtualState.rendered, 100, gridVirtualState.columns, false);
      }
    }
    
    // ============================================================
    // END GRID FUNCTIONS
    
    // ============================================================
    // UNKNOWN COLUMNS FUNCTIONS (v1.4.4)
    // ============================================================
    
    var CANONICAL_FIELDS = ['contract_key', 'file_name', 'file_url', 'status', 'subtype', 'severity', 'sheet', 'notes'];
    
    function detectUnknownColumns(records, sheetName) {
      if (!records || records.length === 0) return [];
      
      var unknownCols = [];
      var seenCols = new Set();
      
      records.forEach(function(record) {
        Object.keys(record).forEach(function(key) {
          if (seenCols.has(key)) return;
          seenCols.add(key);
          
          var normalized = normalizeColumnName(key);
          if (!CANONICAL_FIELDS.includes(normalized) && !key.startsWith('_')) {
            var sampleValues = [];
            var nonEmptyCount = 0;
            
            records.slice(0, 20).forEach(function(r) {
              var val = r[key];
              if (val !== null && val !== undefined && val !== '') {
                nonEmptyCount++;
                if (sampleValues.length < 3) sampleValues.push(String(val).substring(0, 50));
              }
            });
            
            unknownCols.push({
              original_name: key,
              normalized_name: normalized,
              sample_values: sampleValues,
              count_nonempty: nonEmptyCount,
              suggested_canonical: null,
              decision: null
            });
          }
        });
      });
      
      // Store in localStorage
      var stored = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
      stored[sheetName || '_default'] = unknownCols;
      localStorage.setItem('unknown_columns', JSON.stringify(stored));
      
      return unknownCols;
    }
    
    function normalizeColumnName(name) {
      return String(name).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
    }
    
    function refreshUnknownColumnsTable() {
      var tbody = document.getElementById('unknown-cols-tbody');
      var stored = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      
      var allCols = [];
      Object.keys(stored).forEach(function(sheet) {
        (stored[sheet] || []).forEach(function(col) {
          col.sheet = sheet;
          col.decision = decisions[sheet + '::' + col.original_name] || null;
          allCols.push(col);
        });
      });
      
      if (allCols.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 40px; color: #888;">No unknown columns detected</td></tr>';
        return;
      }
      
      tbody.innerHTML = allCols.map(function(col) {
        var key = col.sheet + '::' + col.original_name;
        var actionHtml = '<select onchange="setUnknownColumnDecision(\'' + key.replace(/'/g, "\\'") + '\', this.value)" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc;">' +
          '<option value=""' + (!col.decision ? ' selected' : '') + '>-- Select --</option>' +
          '<option value="add_global"' + (col.decision === 'add_global' ? ' selected' : '') + '>Add to Global Standard</option>' +
          '<option value="source_specific"' + (col.decision === 'source_specific' ? ' selected' : '') + '>Mark Source-Specific</option>' +
          '<option value="ignore"' + (col.decision === 'ignore' ? ' selected' : '') + '>Ignore</option>' +
          '</select>';
        
        return '<tr>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee;">' + col.sheet + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace;">' + col.original_name + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace; color: #666;">' + col.normalized_name + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; font-size: 0.85em; color: #888;">' + col.sample_values.join(', ') + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">' + col.count_nonempty + '</td>' +
          '<td style="padding: 8px; border-bottom: 1px solid #eee;">' + actionHtml + '</td>' +
          '</tr>';
      }).join('');
      
      updateUnknownColumnsDecisionsDisplay();
    }
    
    function setUnknownColumnDecision(key, decision) {
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      if (decision) {
        decisions[key] = decision;
      } else {
        delete decisions[key];
      }
      localStorage.setItem('unknown_columns_decisions', JSON.stringify(decisions));
      updateUnknownColumnsDecisionsDisplay();
    }
    
    function updateUnknownColumnsDecisionsDisplay() {
      var container = document.getElementById('unknown-cols-decisions');
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      var keys = Object.keys(decisions);
      
      if (keys.length === 0) {
        container.innerHTML = '<em style="color: #888;">No decisions made yet.</em>';
        return;
      }
      
      var html = keys.map(function(key) {
        var parts = key.split('::');
        return '<div style="margin-bottom: 4px;"><span style="color: #1976d2;">' + parts[0] + '</span>.<span style="color: #333;">' + parts[1] + '</span> â†’ <span style="color: #2e7d32;">' + decisions[key] + '</span></div>';
      }).join('');
      
      container.innerHTML = html;
    }
    
    function exportUnknownColumnsRequest() {
      var decisions = JSON.parse(localStorage.getItem('unknown_columns_decisions') || '{}');
      var stored = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
      
      var requests = [];
      Object.keys(decisions).forEach(function(key) {
        var parts = key.split('::');
        var sheet = parts[0];
        var colName = parts[1];
        var decision = decisions[key];
        
        var colData = null;
        if (stored[sheet]) {
          colData = stored[sheet].find(function(c) { return c.original_name === colName; });
        }
        
        requests.push({
          request_id: 'SUR_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8),
          timestamp_utc: new Date().toISOString(),
          sheet: sheet,
          canonical_field_name: colData ? colData.normalized_name : normalizeColumnName(colName),
          source_aliases: [colName],
          classification: decision,
          source_tag_optional: decision === 'source_specific' ? sheet : null
        });
      });
      
      var artifact = {
        type: 'standard_update_request',
        version: '1.0',
        generated_at: new Date().toISOString(),
        requests: requests
      };
      
      var json = JSON.stringify(artifact, null, 2);
      navigator.clipboard.writeText(json).then(function() {
        showToast('Standard update request copied to clipboard (' + requests.length + ' items)');
      });
      
      localStorage.setItem('last_standard_update_request', json);
    }
    
    function clearUnknownColumnsDecisions() {
      if (confirm('Clear all pending decisions?')) {
        localStorage.removeItem('unknown_columns_decisions');
        refreshUnknownColumnsTable();
        showToast('Decisions cleared');
      }
    }
    
    // ============================================================
    // END UNKNOWN COLUMNS FUNCTIONS
    // ============================================================
    // ============================================================

    // v1.4.5: updateLoaderModalUI removed - logic moved to updateUIForDataState()
    
    function setupLoaderModalEvents() {
      var fileInput = document.getElementById('loader-drawer-file');
      if (fileInput) {
        fileInput.addEventListener('change', function(e) {
          var file = e.target.files[0];
          if (file) {
            handleFileImport(file);
          }
        });
      }
      
      // Drop zone
      var dropzone = document.getElementById('loader-drawer-dropzone');
      if (dropzone) {
        dropzone.addEventListener('dragover', function(e) {
          e.preventDefault();
          dropzone.classList.add('drag-over');
        });
        dropzone.addEventListener('dragleave', function() {
          dropzone.classList.remove('drag-over');
        });
        dropzone.addEventListener('drop', function(e) {
          e.preventDefault();
          dropzone.classList.remove('drag-over');
          var file = e.dataTransfer.files[0];
          if (file) {
            handleFileImport(file);
          }
        });
      }
      
      // Sample button
      var sampleBtn = document.getElementById('btn-load-sample-drawer');
      if (sampleBtn) {
        sampleBtn.addEventListener('click', function() {
          loadSampleDataset({ autoRedirect: false });
          closeLoaderModal();
          navigateTo('grid');
        });
      }
    }
    
    // v1.4.12: Unified file import handler with XLSX support via parseWorkbook
    function handleFileImport(file) {
      hideLoaderError();
      hideColumnMappingBanner();
      
      var ext = (file.name.split('.').pop() || '').toLowerCase();
      
      if (ext !== 'csv' && ext !== 'xlsx' && ext !== 'xls') {
        showLoaderError('Unsupported file type: .' + ext + '. Please use a CSV or XLSX file.');
        return;
      }
      
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var data = ext === 'csv' ? e.target.result : new Uint8Array(e.target.result);
          var result = parseWorkbook(data, file.name);
          
          if (result.errors.length > 0) {
            showLoaderError(result.errors.join('; '));
            return;
          }
          
          if (result.order.length === 0) {
            showLoaderError('No sheets detected in file. Please check the file format.');
            return;
          }
          
          // Show column mapping warning if not fully resolved
          if (result.mapping && result.mapping.missingColumns.length > 0) {
            showColumnMappingBanner(result.mapping.missingColumns);
          }
          
          // Populate workbook
          resetWorkbook();
          result.order.forEach(function(sheetName) {
            var sheet = result.sheets[sheetName];
            addSheet(sheetName, sheet.headers, sheet.rows, sheet.meta);
          });
          
          // Also populate allData for legacy compatibility
          var allRows = [];
          result.order.forEach(function(sheetName) {
            var sheet = result.sheets[sheetName];
            sheet.rows.forEach(function(r) {
              var row = Object.assign({}, r);
              row.sheet = sheetName;
              allRows.push(row);
            });
          });
          
          allData = {
            contractResults: allRows,
            issues: [],
            fieldActions: [],
            changeLog: [],
            summary: {
              total_contracts: allRows.length,
              ready: 0,
              needs_review: allRows.length,
              blocked: 0
            }
          };
          
          // Save to localStorage
          localStorage.setItem(STORAGE_KEY_DATASET, JSON.stringify({
            workbook: workbook,
            allData: allData,
            columnMapping: result.mapping
          }));
          saveToUploadLibrary({ workbook: workbook }, file.name, ext);
          
          dataLoaded = true;
          currentArtifactPath = file.name;
          currentDataset = null;
          updateUIForDataState();
          updateSessionChip();
          populateSubtypeDropdown();
          populateGridSheetSelector();
          renderAllTables();
          renderGrid();
          
          // v1.5.3: Persist all records to canonical store
          persistAllRecordsToStore();
          
          // v1.6.0: Generate signals for dataset
          generateSignalsForDataset();
          
          console.log('[Loader] Workbook imported:', file.name, 'sheets:', result.order.length, 'total rows:', allRows.length);
          showToast(ext.toUpperCase() + ' imported: ' + result.order.length + ' sheet(s), ' + allRows.length + ' rows', 'success');
          
          if (!validateWorkbookState()) {
            showLoaderError('Import completed but no data was loaded. Please check the file format.');
            return;
          }
          closeLoaderModal();
          navigateTo('grid');
        } catch (err) {
          console.error('[Loader] Import error:', err);
          showLoaderError('Failed to import file: ' + err.message);
        }
      };
      
      if (ext === 'csv') {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    }
    
    function showLoaderError(message) {
      var errorEl = document.getElementById('loader-error-display');
      var msgEl = document.getElementById('loader-error-message');
      if (errorEl && msgEl) {
        msgEl.textContent = message;
        errorEl.style.display = 'block';
      }
      console.error('[Loader] Error:', message);
    }
    
    function hideLoaderError() {
      var errorEl = document.getElementById('loader-error-display');
      if (errorEl) errorEl.style.display = 'none';
    }
    
    function validateWorkbookState() {
      // v1.4.4 FIX-01: Validate workbook invariants with specific error messages
      if (!workbook.order || workbook.order.length === 0) {
        console.error('[Loader] Validation failed: workbook.order is empty');
        showLoaderError('No sheets detected in file. Please check the file format.');
        return false;
      }
      if (!workbook.activeSheet || !workbook.sheets[workbook.activeSheet]) {
        console.error('[Loader] Validation failed: activeSheet not in sheets');
        showLoaderError('Active sheet not set correctly. Internal error - please try again.');
        return false;
      }
      var sheet = workbook.sheets[workbook.activeSheet];
      if (!sheet.headers || !Array.isArray(sheet.headers)) {
        console.error('[Loader] Validation failed: headers missing or invalid');
        showLoaderError('No headers detected in file. Please ensure the first row contains column headers.');
        return false;
      }
      if (sheet.headers.length === 0) {
        console.error('[Loader] Validation failed: headers array is empty');
        showLoaderError('Empty header row detected. Please ensure the first row contains column headers.');
        return false;
      }
      // Ensure rows array exists (can be empty but must exist)
      if (!Array.isArray(sheet.rows)) {
        sheet.rows = [];
      }
      console.log('[Loader] Validation passed: order=' + workbook.order.length + ', activeSheet=' + workbook.activeSheet + ', headers=' + sheet.headers.length + ', rows=' + sheet.rows.length);
      return true;
    }
    
    // Environment mode flag (v1.6.17: Playground/Production toggle)
    var DEMO_MODE_KEY = 'orchestrate.demo_mode';
    function isDemoMode() {
      var stored = localStorage.getItem(DEMO_MODE_KEY);
      return stored === null ? false : stored === 'true'; // Default to false (production mode)
    }
    
    function setDemoMode(enabled) {
      localStorage.setItem(DEMO_MODE_KEY, enabled ? 'true' : 'false');
    }
    
    // v1.6.24: Environment mode toggle (Playground/Production) - Admin only
    function setEnvMode(mode) {
      // Only admins can toggle playground mode
      var loggedInRole = getLoggedInUserRole();
      if (loggedInRole !== 'admin') {
        showToast('Only admins can toggle Playground mode', 'error');
        return;
      }
      
      var isPlayground = mode === 'playground';
      setDemoMode(isPlayground);
      setPlaygroundEnabledFlag(isPlayground); // v1.6.24: Store in demoUser
      updateEnvModeUI();
      renderUsersTable(); // Re-render to show/hide controls
      applyRoleBasedModeRestrictions(); // v1.6.24: Re-apply to update role switching
      showToast(isPlayground ? 'Playground mode enabled - role switching available' : 'Production mode - locked to Admin', 'info');
      console.log('[EnvMode] Set to:', mode, 'by', loggedInRole);
    }
    
    function updateEnvModeUI() {
      var isPlayground = isDemoMode();
      var loggedInRole = getLoggedInUserRole();
      var envModeToggle = document.getElementById('env-mode-toggle');
      var envModeSection = envModeToggle ? envModeToggle.closest('.admin-section') : null;
      var prodBtn = document.getElementById('env-mode-prod');
      var playBtn = document.getElementById('env-mode-playground');
      var addUserBtn = document.getElementById('add-user-btn');
      var modeDesc = document.getElementById('users-mode-desc');
      
      // v1.6.24: Hide entire Playground toggle section for non-admins
      if (envModeSection) {
        envModeSection.style.display = (loggedInRole === 'admin') ? 'block' : 'none';
      }
      
      if (prodBtn && playBtn) {
        if (isPlayground) {
          prodBtn.style.background = '#f5f5f5';
          prodBtn.style.color = '#666';
          playBtn.style.background = '#4caf50';
          playBtn.style.color = 'white';
        } else {
          prodBtn.style.background = '#1976d2';
          prodBtn.style.color = 'white';
          playBtn.style.background = '#f5f5f5';
          playBtn.style.color = '#666';
        }
      }
      
      if (addUserBtn) {
        // Only show add user button for admins in playground mode
        if (isPlayground && loggedInRole === 'admin') {
          addUserBtn.style.display = 'flex';
          addUserBtn.disabled = false;
        } else {
          addUserBtn.style.display = 'none';
        }
      }
      
      if (modeDesc) {
        if (loggedInRole !== 'admin') {
          modeDesc.textContent = 'Production mode: User management is read-only.';
        } else {
          modeDesc.textContent = isPlayground 
            ? 'Playground mode: You can add, edit, and delete users. Role switching is enabled.'
            : 'Production mode: User management is read-only. Role switching is disabled.';
        }
      }
    }
    
    // Record Drawer functions
    let currentRecordIndex = -1;
    let filteredContracts = [];
    
    function openRecordDrawer(contractKey, index, contracts) {
      filteredContracts = contracts || allData.contractResults || [];
      currentRecordIndex = index >= 0 ? index : filteredContracts.findIndex(c => 
        (c.contract_key || c.file_name) === contractKey
      );
      
      if (currentRecordIndex < 0) return;
      renderRecordDrawer();
      document.getElementById('record-drawer').classList.add('active');
    }
    
    function closeRecordDrawer() {
      document.getElementById('record-drawer').classList.remove('active');
    }
    
    function navigateRecord(direction) {
      const newIndex = currentRecordIndex + direction;
      if (newIndex >= 0 && newIndex < filteredContracts.length) {
        currentRecordIndex = newIndex;
        renderRecordDrawer();
      }
    }
    
    function renderRecordDrawer() {
      const contract = filteredContracts[currentRecordIndex];
      if (!contract) return;
      
      const titleEl = document.getElementById('record-drawer-title');
      const contentEl = document.getElementById('record-drawer-content');
      const posEl = document.getElementById('record-drawer-position');
      const prevBtn = document.getElementById('record-drawer-prev');
      const nextBtn = document.getElementById('record-drawer-next');
      
      const key = contract.contract_key || contract.file_name || 'Unknown';
      titleEl.textContent = key;
      posEl.textContent = `${currentRecordIndex + 1} / ${filteredContracts.length}`;
      prevBtn.disabled = currentRecordIndex <= 0;
      nextBtn.disabled = currentRecordIndex >= filteredContracts.length - 1;
      
      // Find related issues and field actions
      const joinKey = getJoinKey(contract);
      const issues = (allData.issues || []).filter(i => getJoinKey(i) === joinKey);
      const actions = (allData.fieldActions || []).filter(a => getJoinKey(a) === joinKey);
      
      const statusColor = {
        'ready': '#4caf50',
        'needs_review': '#ff9800',
        'blocked': '#f44336'
      }[contract.sf_contract_status?.toLowerCase()] || '#757575';
      
      let html = `
        <div style="margin-bottom: 20px;">
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
            <span style="background: ${statusColor}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; font-weight: 500;">
              ${contract.sf_contract_status || 'unknown'}
            </span>
            ${contract.detected_subtype ? `<span style="background: #e0e0e0; padding: 4px 10px; border-radius: 10px; font-size: 0.8em;">${typeof contract.detected_subtype === 'object' ? contract.detected_subtype.value : contract.detected_subtype}</span>` : ''}
          </div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <h4 style="margin: 0 0 10px 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Identity</h4>
          <table style="width: 100%; font-size: 0.9em; border-collapse: collapse;">
            <tr><td style="padding: 6px 0; color: #666; width: 100px;">Contract Key</td><td style="padding: 6px 0;">${contract.contract_key || '(none)'}</td></tr>
            <tr><td style="padding: 6px 0; color: #666;">File Name</td><td style="padding: 6px 0;">${contract.file_name || '(none)'}</td></tr>
            <tr><td style="padding: 6px 0; color: #666;">File URL</td><td style="padding: 6px 0; word-break: break-all;">${contract.file_url || '(none)'}</td></tr>
          </table>
        </div>
      `;
      
      if (issues.length > 0) {
        html += `
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 10px 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Issues (${issues.length})</h4>
            <div style="display: flex; flex-direction: column; gap: 8px;">
        `;
        issues.forEach(issue => {
          const sevColor = { blocking: '#f44336', warning: '#ff9800', info: '#2196f3' }[issue.severity] || '#757575';
          html += `
            <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; border-left: 3px solid ${sevColor};">
              <div style="font-weight: 500; margin-bottom: 4px;">${issue.issue_type || 'Unknown Issue'}</div>
              <div style="font-size: 0.85em; color: #666;">${issue.sheet || ''} ${issue.field ? '/ ' + issue.field : ''}</div>
              ${issue.details ? `<div style="font-size: 0.85em; margin-top: 6px;">${issue.details}</div>` : ''}
            </div>
          `;
        });
        html += '</div></div>';
      }
      
      if (actions.length > 0) {
        html += `
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 10px 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Field Actions (${actions.length})</h4>
            <div style="display: flex; flex-direction: column; gap: 6px;">
        `;
        actions.forEach(action => {
          html += `
            <div style="background: #e3f2fd; padding: 8px 10px; border-radius: 4px; font-size: 0.85em;">
              <strong>${action.action || 'action'}</strong>: ${action.sheet || ''}/${action.field || ''} ${action.proposed_value ? '= ' + action.proposed_value : ''}
              ${action.reason_text ? `<div style="color: #666; margin-top: 4px;">${action.reason_text}</div>` : ''}
            </div>
          `;
        });
        html += '</div></div>';
      }
      
      if (issues.length === 0 && actions.length === 0) {
        html += `<p style="color: #999; font-style: italic;">No issues or field actions for this contract.</p>`;
      }
      
      // Comments section
      const recordComments = getCommentsByTarget('record', key);
      html += `
        <div style="margin-bottom: 20px; border-top: 1px solid #e0e0e0; padding-top: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0; color: #333; font-size: 0.9em; text-transform: uppercase;">Comments (${recordComments.length})</h4>
            <button class="toolbar-btn" style="padding: 4px 10px; font-size: 0.8em;" onclick="openAddCommentModal('record', '${escapeHtml(key)}')">+ Add Comment</button>
          </div>
      `;
      
      if (recordComments.length > 0) {
        html += '<div style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto;">';
        recordComments.forEach(c => {
          const statusColors = {
            'Open': { bg: '#e3f2fd', border: '#1976d2' },
            'ReviewerResponded': { bg: '#fff3e0', border: '#e65100' },
            'Resolved': { bg: '#e8f5e9', border: '#388e3c' },
            'ElevatedToPatchRequest': { bg: '#ede7f6', border: '#5e35b1' },
            'Closed': { bg: '#f5f5f5', border: '#757575' }
          }[c.status] || { bg: '#f5f5f5', border: '#757575' };
          
          const date = new Date(c.created_at_utc).toLocaleDateString();
          var elevateBtn = c.status === 'Resolved' ? '<button class="toolbar-btn" style="padding: 2px 8px; font-size: 0.75em;" onclick="elevateCommentToPatchRequest(\'' + c.comment_id + '\')">Elevate to Patch</button>' : '';
          var resolveBtn = c.status === 'Open' ? '<button class="toolbar-btn" style="padding: 2px 8px; font-size: 0.75em;" onclick="resolveCommentById(\'' + c.comment_id + '\')">Resolve</button>' : '';
          html += '<div style="background: ' + statusColors.bg + '; padding: 10px; border-radius: 6px; border-left: 3px solid ' + statusColors.border + ';">' +
            '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">' +
            '<span style="font-weight: 500; font-size: 0.85em;">' + c.status + '</span>' +
            '<span style="font-size: 0.75em; color: #666;">' + date + '</span>' +
            '</div>' +
            '<div style="font-size: 0.9em;">' + escapeHtml(c.content) + '</div>' +
            '<div style="margin-top: 8px; display: flex; gap: 6px;">' + elevateBtn + resolveBtn + '</div>' +
            '</div>';
        });
        html += '</div>';
      } else {
        html += '<p style="color: #999; font-style: italic; font-size: 0.85em;">No comments for this record.</p>';
      }
      html += '</div>';
      
      contentEl.innerHTML = html;
    }
    
    function showEvidenceStatus() {
      // Navigate to patch studio to show preflight status
      navigateTo('patch');
      const preflightToggle = document.getElementById('preflight-toggle');
      if (preflightToggle) preflightToggle.click();
    }
    
    // Settings Management
    function loadUserSettings() {
      try {
        const saved = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (saved) {
          userSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
        }
      } catch (e) {
        console.warn('Failed to load user settings:', e);
      }
    }
    
    function saveUserSettings() {
      try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(userSettings));
      } catch (e) {
        console.warn('Failed to save user settings:', e);
      }
    }
    
    function checkFirstRun() {
      const dismissed = localStorage.getItem(FIRST_RUN_DISMISSED_KEY);
      const banner = document.getElementById('first-run-banner');
      
      // Show banner if: not configured AND not dismissed
      if (!userSettings.configured && !dismissed && banner) {
        banner.style.display = 'flex';
      }
    }
    
    function dismissFirstRunBanner() {
      const banner = document.getElementById('first-run-banner');
      if (banner) banner.style.display = 'none';
      localStorage.setItem(FIRST_RUN_DISMISSED_KEY, 'true');
    }
    
    async function autoSetupRepoMasters() {
      // Auto-load Repo Masters (dev baseline) when present
      if (!userSettings.use_repo_masters) return;
      
      try {
        const response = await fetch(RELATIVE_PRIMARY);
        if (response.ok) {
          const data = await response.json();
          if (data.sf_summary || data.sf_contract_results) {
            allData.contractResults = data.sf_contract_results || [];
            // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
            allData.issues = filterOutReferenceData(data.sf_issues || []);
            allData.fieldActions = filterOutReferenceData(data.sf_field_actions || []);
            allData.summary = data.sf_summary || {};
            allData.changeLog = data.changelog || [];
            dataLoaded = true;
            sessionState = { status: 'loaded', sourceType: 'fetch', loadedAt: new Date().toISOString() };
            currentArtifactPath = RELATIVE_PRIMARY;
            updateUIForDataState();
            renderSummary();
            renderAllTables();
            updateQueueCounts();
          }
        }
      } catch (e) {
        // Silently fail - user can manually load data
      }
    }
    
    let currentWizardStep = 0;
    const WIZARD_STEPS = [
      { id: 'WELCOME', title: 'Welcome' },
      { id: 'DATA_SOURCES', title: 'Data Sources' },
      { id: 'WORKFLOW_DEFAULTS', title: 'Workflow Defaults' },
      { id: 'DONE', title: 'Finish' }
    ];
    
    function openConfigureWizard() {
      currentWizardStep = 0;
      document.getElementById('configure-wizard-modal').classList.add('active');
      renderConfigureWizardStep(0);
    }
    
    function closeConfigureWizard() {
      document.getElementById('configure-wizard-modal').classList.remove('active');
    }
    
    // Config Flows Panel
    let currentConfigFlowStage = 'data_sources';
    let currentConfigFlowTab = 'plain-english';
    let masterEditMode = false;
    let masterDraft = {};
    let sessionConfig = {};
    let configHistory = [];
    
    const CONFIG_FLOW_STAGES = {
      data_sources: {
        title: 'Data Sources',
        desc: 'Configure where Preview and Reference packets are loaded from.',
        plainEnglish: `<p>This stage controls how data enters the system.</p>
          <p style="margin-top: 10px;"><strong>What it does:</strong> Defines the primary and comparison data sources for your session.</p>
          <ul style="margin: 10px 0 0 20px;">
            <li><strong>Repo Masters</strong> - Auto-load from repository (recommended for dev)</li>
            <li><strong>Paste JSON</strong> - Manual paste of Preview Packet data</li>
            <li><strong>Drag & Drop</strong> - Upload a file directly</li>
            <li><strong>Local Path Hint</strong> - Reference files by path</li>
          </ul>`
      },
      dataset_mapping: {
        title: 'Dataset Mapping',
        desc: 'Define how input sheets map to semantic entities.',
        plainEnglish: '<p>Maps incoming data columns to semantic fields. Ensures consistent naming across sources.</p>'
      },
      standardization: {
        title: 'Standardization',
        desc: 'Normalize data formats and values.',
        plainEnglish: '<p>Applies formatting rules to ensure data consistency (dates, currencies, text casing).</p>'
      },
      ruleset: {
        title: 'Ruleset',
        desc: 'WHEN/THEN rules that determine field actions and issues.',
        plainEnglish: '<p>The heart of semantic governance. Rules define:</p><ul style="margin: 10px 0 0 20px;"><li>When a condition is met (WHEN)</li><li>What action to take (THEN)</li><li>Severity level (info, warning, blocking)</li></ul>'
      },
      validation_gates: {
        title: 'Validation Gates',
        desc: 'Preflight checks before data can proceed.',
        plainEnglish: '<p>Evidence gates that must pass before publishing:</p><ul style="margin: 10px 0 0 20px;"><li>Validation: Schema and format checks</li><li>Conflicts: No duplicate or conflicting rules</li><li>Smoke Baseline: Expected output matches</li></ul>'
      },
      patch_generation: {
        title: 'Patch Generation',
        desc: 'Configure how patches are built from field actions.',
        plainEnglish: '<p>Controls how proposed fixes are packaged into patch format for review.</p>'
      },
      smoke_baselines: {
        title: 'Smoke Baselines',
        desc: 'Reference outputs for determinism checks.',
        plainEnglish: '<p>Golden files that define expected outputs. Used to verify changes don\'t break existing behavior.</p>'
      },
      export: {
        title: 'Export / PR Summary',
        desc: 'Bundle outputs for pull request review.',
        plainEnglish: '<p>Generate exportable bundles with:</p><ul style="margin: 10px 0 0 20px;"><li>Patch file</li><li>Changelog entry</li><li>Evidence summary</li><li>PR description template</li></ul>'
      }
    };
    
    function openConfigFlows() {
      if (currentMode !== 'admin') {
        alert('Config Flows requires Admin mode.');
        return;
      }
      document.getElementById('config-flows-drawer').classList.add('active');
      selectConfigFlowStage('data_sources');
    }
    
    function closeConfigFlows() {
      document.getElementById('config-flows-drawer').classList.remove('active');
      masterEditMode = false;
    }
    
    function escapeHtml(str) {
      if (!str) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
    
    function getMasterConfig(stage) {
      if (sessionConfig[stage]) return sessionConfig[stage];
      const defaults = {
        data_sources: { stage: 'data_sources', version: '1.0.0', sources: ['sf_packet.preview.json'] },
        field_mapping: { stage: 'field_mapping', version: '1.0.0', mappings: [] },
        rules_engine: { stage: 'rules_engine', version: '1.0.0', rules: [] },
        qa_checks: { stage: 'qa_checks', version: '1.0.0', checks: [] },
        resolution: { stage: 'resolution', version: '1.0.0', strategy: 'auto' },
        enrichment: { stage: 'enrichment', version: '1.0.0', enrichers: [] },
        approval: { stage: 'approval', version: '1.0.0', workflow: 'standard' },
        export: { stage: 'export', version: '1.0.0', format: 'json' }
      };
      return defaults[stage] || { stage, version: '1.0.0' };
    }
    
    function enterMasterEditMode() {
      masterEditMode = true;
      renderConfigFlowTabContent();
    }
    
    function cancelMasterEdit() {
      masterEditMode = false;
      renderConfigFlowTabContent();
    }
    
    function validateMasterConfig() {
      const textarea = document.getElementById('master-edit-area');
      const msgEl = document.getElementById('master-validation-msg');
      if (!textarea || !msgEl) return;
      
      try {
        JSON.parse(textarea.value);
        msgEl.style.display = 'block';
        msgEl.style.background = '#e8f5e9';
        msgEl.style.color = '#2e7d32';
        msgEl.textContent = 'Valid JSON configuration';
        return true;
      } catch (e) {
        msgEl.style.display = 'block';
        msgEl.style.background = '#ffebee';
        msgEl.style.color = '#c62828';
        msgEl.textContent = 'Invalid JSON: ' + e.message;
        return false;
      }
    }
    
    function saveMasterDraft() {
      const textarea = document.getElementById('master-edit-area');
      if (!textarea) return;
      
      if (!validateMasterConfig()) return;
      
      masterDraft[currentConfigFlowStage] = textarea.value;
      masterEditMode = false;
      renderConfigFlowTabContent();
      showToast('Draft saved for ' + CONFIG_FLOW_STAGES[currentConfigFlowStage]?.title);
    }
    
    function publishMasterConfig() {
      const stage = currentConfigFlowStage;
      const draftJson = masterDraft[stage];
      
      if (!draftJson) {
        showToast('No changes to publish', 'warning');
        return;
      }
      
      try {
        const config = JSON.parse(draftJson);
        const previousConfig = sessionConfig[stage] ? JSON.stringify(sessionConfig[stage]) : null;
        
        sessionConfig[stage] = config;
        configHistory.push({
          stage,
          timestamp: new Date().toISOString(),
          action: 'publish',
          previousValue: previousConfig,
          newValue: draftJson
        });
        
        delete masterDraft[stage];
        masterEditMode = false;
        renderConfigFlowTabContent();
        showToast('Published to session: ' + CONFIG_FLOW_STAGES[stage]?.title);
        refreshSessionFromConfig();
      } catch (e) {
        showToast('Failed to publish: ' + e.message, 'error');
      }
    }
    
    function revertMasterConfig() {
      delete masterDraft[currentConfigFlowStage];
      masterEditMode = false;
      renderConfigFlowTabContent();
      showToast('Reverted changes');
    }
    
    function refreshSessionFromConfig() {
      console.log('Session config updated:', sessionConfig);
      
      var configChip = document.getElementById('config-status-chip');
      if (configChip) {
        var customCount = Object.keys(sessionConfig).length;
        if (customCount > 0) {
          configChip.textContent = customCount + ' custom config(s)';
          configChip.style.background = '#e3f2fd';
          configChip.style.color = '#1565c0';
          configChip.style.display = 'inline-block';
        } else {
          configChip.style.display = 'none';
        }
      }
    }
    
    function showToast(message, type) {
      type = type || 'success';
      var existing = document.querySelector('.config-toast');
      if (existing) existing.remove();
      
      var toast = document.createElement('div');
      toast.className = 'config-toast';
      var bgColor = '#2e7d32';
      if (type === 'error') bgColor = '#c62828';
      else if (type === 'warning') bgColor = '#f57c00';
      toast.style.cssText = 'position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; background: ' + bgColor + '; color: white; border-radius: 6px; font-size: 0.9em; z-index: 10001; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(function() { toast.remove(); }, 3000);
    }
    
    // ========== DEBUG PANEL (v1.5.2) ==========
    // Show debug panel when ?debug=1 is in URL
    var debugPanelState = {
      visible: false,
      data: {}
    };
    
    function initDebugPanel() {
      var urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('debug') === '1') {
        debugPanelState.visible = true;
        createDebugPanelUI();
        console.log('[DEBUG] Debug panel enabled via ?debug=1');
      }
    }
    
    function createDebugPanelUI() {
      var panel = document.createElement('div');
      panel.id = 'debug-panel';
      panel.style.cssText = 'position: fixed; bottom: 80px; right: 20px; width: 320px; max-height: 400px; overflow-y: auto; background: #1a1a2e; color: #00ff88; font-family: monospace; font-size: 11px; padding: 12px; border-radius: 8px; z-index: 10002; box-shadow: 0 4px 20px rgba(0,0,0,0.5); border: 1px solid #00ff88;';
      panel.innerHTML = '<div style="font-weight: bold; margin-bottom: 8px; color: #fff; font-size: 12px;">DEBUG PANEL</div><div id="debug-content">Initializing...</div>';
      document.body.appendChild(panel);
      
      // Initial update
      updateDebugPanel({
        role: currentMode,
        tenant_id: IDENTITY_CONTEXT.tenant_id,
        division_id: IDENTITY_CONTEXT.division_id,
        dataset_id: IDENTITY_CONTEXT.dataset_id || '(not set)',
        record_id: '(none)',
        patch_request_id: '(none)'
      });
    }
    
    function updateDebugPanel(data) {
      if (!debugPanelState.visible) return;
      
      // Merge with existing data
      Object.assign(debugPanelState.data, data);
      
      var content = document.getElementById('debug-content');
      if (!content) return;
      
      var html = '';
      var keys = ['role', 'tenant_id', 'division_id', 'dataset_id', 'record_id', 'patch_request_id', 'patchRequest_load', 'record_load', 'storageKey'];
      keys.forEach(function(key) {
        var val = debugPanelState.data[key];
        if (val !== undefined) {
          var color = '#00ff88';
          if (val === 'FAILED') color = '#ff4444';
          else if (val === 'SUCCESS') color = '#44ff44';
          html += '<div style="margin: 4px 0;"><span style="color: #888;">' + key + ':</span> <span style="color: ' + color + ';">' + val + '</span></div>';
        }
      });
      
      // Add storage key info
      var prKey = debugPanelState.data.patch_request_id;
      if (prKey && prKey !== '(none)') {
        var storageKey = 'pr:' + ARTIFACT_STORE.environment + ':' + prKey;
        html += '<div style="margin: 8px 0 4px; color: #888; font-size: 10px;">Storage Key:</div>';
        html += '<div style="color: #ffa500; word-break: break-all; font-size: 10px;">' + storageKey + '</div>';
      }
      
      content.innerHTML = html;
    }
    
    // Initialize debug panel and rules bundle on load
    document.addEventListener('DOMContentLoaded', function() {
      initDebugPanel();
      loadRulesBundle();  // v1.5.7: Load rules bundle for Field Inspector ordering
    });
    
    // Global Search Stub (V2)
    function handleGlobalSearchKeydown(event) {
      if (event.key === 'Enter') {
        var query = event.target.value.trim();
        if (query) {
          showToast('Search coming soon (V2)', 'info');
        }
      }
    }
    
    // Global keyboard shortcut for search
    document.addEventListener('keydown', function(e) {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        var searchBar = document.getElementById('triage-search-bar');
        var searchInput = document.getElementById('global-search-input');
        if (searchBar) {
          searchBar.style.opacity = '1';
          searchBar.style.transform = 'translateY(0)';
        }
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        }
      }
    });
    
    // Scroll-aware search bar (hide on scroll, show on stop)
    (function() {
      var scrollTimeout = null;
      var lastScrollY = 0;
      var searchBar = null;
      
      function getSearchBar() {
        if (!searchBar) searchBar = document.getElementById('triage-search-bar');
        return searchBar;
      }
      
      function hideSearchBar() {
        var bar = getSearchBar();
        if (bar && document.activeElement !== document.getElementById('global-search-input')) {
          bar.style.opacity = '0';
          bar.style.transform = 'translateY(-10px)';
        }
      }
      
      function showSearchBar() {
        var bar = getSearchBar();
        if (bar) {
          bar.style.opacity = '1';
          bar.style.transform = 'translateY(0)';
        }
      }
      
      window.addEventListener('scroll', function() {
        var currentScrollY = window.scrollY;
        
        // If scrolling down, hide
        if (currentScrollY > lastScrollY && currentScrollY > 50) {
          hideSearchBar();
        }
        
        lastScrollY = currentScrollY;
        
        // Clear existing timeout
        if (scrollTimeout) clearTimeout(scrollTimeout);
        
        // Show after scroll stops (300ms delay)
        scrollTimeout = setTimeout(function() {
          showSearchBar();
        }, 300);
      }, { passive: true });
    })();
    
    function selectConfigFlowStage(stage) {
      masterEditMode = false;
      currentConfigFlowStage = stage;
      
      // Update rail selection
      document.querySelectorAll('.rail-item').forEach(item => {
        item.classList.toggle('active', item.dataset.stage === stage);
      });
      
      // Update header
      const stageConfig = CONFIG_FLOW_STAGES[stage] || {};
      document.getElementById('config-flow-stage-title').textContent = stageConfig.title || stage;
      document.getElementById('config-flow-stage-desc').textContent = stageConfig.desc || '';
      
      // Render current tab content
      renderConfigFlowTabContent();
    }
    
    function selectConfigFlowTab(tab) {
      currentConfigFlowTab = tab;
      
      // Update tab selection
      document.querySelectorAll('.stage-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
      });
      
      renderConfigFlowTabContent();
    }
    
    function renderConfigFlowTabContent() {
      const container = document.getElementById('config-flow-tab-content');
      const stageConfig = CONFIG_FLOW_STAGES[currentConfigFlowStage] || {};
      let html = '';
      
      if (currentConfigFlowTab === 'plain-english') {
        html = `<div style="padding: 15px; background: #f5f5f5; border-radius: 6px;">${stageConfig.plainEnglish || '<p>No documentation available.</p>'}</div>`;
      } else if (currentConfigFlowTab === 'payload') {
        const effectiveConfig = getMasterConfig(currentConfigFlowStage);
        const isCustom = sessionConfig[currentConfigFlowStage] !== undefined;
        html = `<div style="padding: 15px; background: #263238; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.85em;">
          <div style="margin-bottom: 10px; color: #78909c;">// Effective config (resolved view)</div>
          <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(JSON.stringify(effectiveConfig, null, 2))}</pre>
        </div>
        <div style="margin-top: 10px; display: flex; gap: 8px;">
          <span style="background: ${isCustom ? '#e3f2fd' : '#e8f5e9'}; color: ${isCustom ? '#1565c0' : '#2e7d32'}; padding: 4px 8px; border-radius: 4px; font-size: 0.75em;">${isCustom ? 'CUSTOM' : 'MASTER'}</span>
          ${!isCustom ? '<span style="background: #fff3e0; color: #e65100; padding: 4px 8px; border-radius: 4px; font-size: 0.75em;">DEFAULT</span>' : ''}
        </div>`;
      } else if (currentConfigFlowTab === 'master') {
        const masterConfig = getMasterConfig(currentConfigFlowStage);
        const configJson = JSON.stringify(masterConfig, null, 2);
        const hasChanges = masterDraft[currentConfigFlowStage] !== undefined;
        const draftJson = hasChanges ? masterDraft[currentConfigFlowStage] : configJson;
        
        if (masterEditMode) {
          html = `<div style="margin-bottom: 10px;">
            <div id="master-validation-msg" style="display: none; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px;"></div>
            <textarea id="master-edit-area" style="width: 100%; height: 200px; font-family: monospace; font-size: 0.85em; background: #263238; color: #eceff1; border: 2px solid #5c6bc0; border-radius: 6px; padding: 15px; resize: vertical;">${escapeHtml(draftJson)}</textarea>
          </div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="modal-btn modal-btn-secondary" onclick="validateMasterConfig()">Validate</button>
            <button class="modal-btn modal-btn-primary" onclick="saveMasterDraft()">Save Draft</button>
            <button class="modal-btn" style="background: #7c4dff; color: white;" onclick="publishMasterConfig()">Publish to Session</button>
            <button class="modal-btn" style="margin-left: auto;" onclick="cancelMasterEdit()">Cancel</button>
          </div>`;
        } else {
          html = `<div style="padding: 15px; background: #263238; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.85em; min-height: 150px;">
            <div style="margin-bottom: 10px; color: #78909c;">// Master config ${hasChanges ? '(unsaved changes)' : ''}</div>
            <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(hasChanges ? draftJson : configJson)}</pre>
          </div>
          <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="modal-btn modal-btn-secondary" onclick="enterMasterEditMode()">Edit</button>
            <button class="modal-btn modal-btn-primary" onclick="publishMasterConfig()" ${hasChanges ? '' : 'disabled'}>Publish to Session</button>
            <button class="modal-btn" style="margin-left: auto;" onclick="revertMasterConfig()" ${hasChanges ? '' : 'disabled'}>Revert</button>
          </div>`;
        }
      } else if (currentConfigFlowTab === 'diff') {
        const hasChanges = masterDraft[currentConfigFlowStage] !== undefined;
        if (hasChanges) {
          const masterConfig = getMasterConfig(currentConfigFlowStage);
          const currentJson = JSON.stringify(masterConfig, null, 2);
          const draftJson = masterDraft[currentConfigFlowStage];
          html = `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <div style="font-weight: 600; margin-bottom: 8px; color: #666;">Current (Published)</div>
              <div style="padding: 12px; background: #263238; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 200px; overflow: auto;">
                <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(currentJson)}</pre>
              </div>
            </div>
            <div>
              <div style="font-weight: 600; margin-bottom: 8px; color: #5c6bc0;">Draft (Pending)</div>
              <div style="padding: 12px; background: #1a237e; color: #eceff1; border-radius: 6px; font-family: monospace; font-size: 0.8em; max-height: 200px; overflow: auto; border: 2px solid #5c6bc0;">
                <pre style="margin: 0; white-space: pre-wrap;">${escapeHtml(draftJson)}</pre>
              </div>
            </div>
          </div>
          <div style="margin-top: 15px; display: flex; gap: 10px;">
            <button class="modal-btn" style="background: #7c4dff; color: white;" onclick="publishMasterConfig()">Publish Changes</button>
            <button class="modal-btn" onclick="revertMasterConfig()">Discard</button>
          </div>`;
        } else {
          html = `<div style="padding: 20px; text-align: center; color: #666;">
            <p>No differences detected.</p>
            <p style="font-size: 0.85em; margin-top: 10px;">Master and Effective Payload are identical.</p>
          </div>`;
        }
      } else if (currentConfigFlowTab === 'history') {
        const stageHistory = configHistory.filter(h => h.stage === currentConfigFlowStage);
        if (stageHistory.length > 0) {
          const historyItems = stageHistory.slice().reverse().map(h => `
            <div style="padding: 12px; background: #f5f5f5; border-radius: 6px; margin-bottom: 8px;">
              <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                <span style="font-weight: 600; color: #333;">${h.action === 'publish' ? 'Published' : h.action}</span>
                <span style="font-size: 0.8em; color: #666;">${new Date(h.timestamp).toLocaleString()}</span>
              </div>
              <div style="font-size: 0.85em; color: #666;">Configuration updated</div>
            </div>
          `).join('');
          html = `<div style="max-height: 300px; overflow-y: auto;">${historyItems}</div>`;
        } else {
          html = `<div style="padding: 20px; text-align: center; color: #666;">
            <p>No history entries.</p>
            <p style="font-size: 0.85em; margin-top: 10px;">Changes will be recorded here when you edit and publish.</p>
          </div>`;
        }
      }
      
      container.innerHTML = html;
    }
    
    function wizardBack() {
      if (currentWizardStep > 0) {
        currentWizardStep--;
        renderConfigureWizardStep(currentWizardStep);
      }
    }
    
    function wizardNext() {
      saveWizardStepData(currentWizardStep);
      
      if (currentWizardStep < WIZARD_STEPS.length - 1) {
        currentWizardStep++;
        renderConfigureWizardStep(currentWizardStep);
      } else {
        // Finish wizard
        userSettings.configured = true;
        saveUserSettings();
        closeConfigureWizard();
        dismissFirstRunBanner();
        
        // Apply settings immediately
        if (userSettings.use_repo_masters && !dataLoaded) {
          autoSetupRepoMasters();
        }
      }
    }
    
    function saveWizardStepData(step) {
      if (step === 0) {
        userSettings.use_repo_masters = document.getElementById('wiz-use-repo-masters')?.checked ?? true;
      } else if (step === 1) {
        userSettings.preferred_load_method = document.getElementById('wiz-load-method')?.value || 'Repo Masters';
        userSettings.local_data_root = document.getElementById('wiz-local-path')?.value || '';
      } else if (step === 2) {
        const checkboxes = document.querySelectorAll('.wiz-queue-checkbox:checked');
        userSettings.default_queues = Array.from(checkboxes).map(cb => cb.value);
        userSettings.compare_mode_default = document.getElementById('wiz-compare-default')?.checked ?? true;
      }
    }
    
    function renderConfigureWizardStep(step) {
      const titleEl = document.getElementById('wizard-step-title');
      const contentEl = document.getElementById('wizard-step-content');
      const backBtn = document.getElementById('wizard-back');
      const nextBtn = document.getElementById('wizard-next');
      
      // Update progress dots
      document.querySelectorAll('.wizard-step-dot').forEach((dot, i) => {
        dot.classList.toggle('active', i === step);
        dot.classList.toggle('completed', i < step);
      });
      
      titleEl.textContent = WIZARD_STEPS[step].title;
      backBtn.style.display = step === 0 ? 'none' : 'inline-block';
      nextBtn.textContent = step === WIZARD_STEPS.length - 1 ? 'Finish' : 'Next';
      
      let html = '';
      
      if (step === 0) {
        html = `
          <p style="margin-bottom: 20px; color: #555;">We'll set up where your files live and what you want to see first.</p>
          <div class="wizard-toggle">
            <input type="checkbox" id="wiz-use-repo-masters" ${userSettings.use_repo_masters ? 'checked' : ''}>
            <div class="wizard-toggle-label">
              <strong>Use Repo Masters</strong>
              <small>Recommended for dev/testing. Auto-loads preview data from the repository.</small>
            </div>
          </div>
        `;
      } else if (step === 1) {
        html = `
          <p style="margin-bottom: 20px; color: #555;">Choose how you'll load your Preview and Reference packets.</p>
          <div class="wizard-form-group">
            <label>Default Load Method</label>
            <select id="wiz-load-method" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px;">
              <option value="Repo Masters" ${userSettings.preferred_load_method === 'Repo Masters' ? 'selected' : ''}>Repo Masters</option>
              <option value="Paste JSON" ${userSettings.preferred_load_method === 'Paste JSON' ? 'selected' : ''}>Paste JSON</option>
              <option value="Drag & Drop" ${userSettings.preferred_load_method === 'Drag & Drop' ? 'selected' : ''}>Drag & Drop</option>
              <option value="Local Path Hint" ${userSettings.preferred_load_method === 'Local Path Hint' ? 'selected' : ''}>Local Path Hint</option>
            </select>
          </div>
          <div class="wizard-form-group">
            <label>Local Folder (optional)</label>
            <input type="text" id="wiz-local-path" value="${userSettings.local_data_root}" placeholder="e.g., out/" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px;">
            <div class="hint">Used only for path hints; nothing uploads or syncs.</div>
          </div>
        `;
      } else if (step === 2) {
        const queues = ['To Do', 'Needs Review', 'Flagged', 'Blocked', 'Finalized'];
        html = `
          <p style="margin-bottom: 20px; color: #555;">Pick what queues and panels you want visible by default.</p>
          <div class="wizard-form-group">
            <label>Queues to Show</label>
            <div class="wizard-multi-select">
              ${queues.map(q => `
                <label>
                  <input type="checkbox" class="wiz-queue-checkbox" value="${q}" ${userSettings.default_queues.includes(q) ? 'checked' : ''}>
                  ${q}
                </label>
              `).join('')}
            </div>
          </div>
          <div class="wizard-toggle" style="margin-top: 15px;">
            <input type="checkbox" id="wiz-compare-default" ${userSettings.compare_mode_default ? 'checked' : ''}>
            <div class="wizard-toggle-label">
              <strong>Enable Compare View by Default</strong>
              <small>Show comparison panel when loading data.</small>
            </div>
          </div>
        `;
      } else if (step === 3) {
        html = `
          <div style="text-align: center; padding: 20px 0;">
            <div style="font-size: 3em; margin-bottom: 15px;">&#10004;</div>
            <h3 style="margin: 0 0 10px; color: #4caf50;">You're All Set!</h3>
            <p style="color: #666;">You can change these anytime in Admin &rarr; Settings.</p>
            <div style="background: #f5f5f5; border-radius: 8px; padding: 15px; margin-top: 20px; text-align: left;">
              <div style="font-size: 0.85em; color: #666; margin-bottom: 8px;">Your settings:</div>
              <ul style="margin: 0; padding-left: 20px; font-size: 0.9em;">
                <li>Load method: <strong>${userSettings.preferred_load_method}</strong></li>
                <li>Auto-load repo masters: <strong>${userSettings.use_repo_masters ? 'Yes' : 'No'}</strong></li>
                <li>Default queues: <strong>${userSettings.default_queues.join(', ') || 'All'}</strong></li>
              </ul>
            </div>
          </div>
        `;
      }
      
      contentEl.innerHTML = html;
    }
    
    // Note: Primary resetSession is defined earlier. This is a legacy duplicate kept for reference.
    // The main resetSession() navigates to loader after clearing data.

    // Modal functions
    function openRulesetModal() {
      document.getElementById('ruleset-modal').classList.add('active');
    }
    function closeRulesetModal() {
      document.getElementById('ruleset-modal').classList.remove('active');
    }
    function openCompareModal() {
      document.getElementById('compare-modal').classList.add('active');
    }
    function closeCompareModal() {
      document.getElementById('compare-modal').classList.remove('active');
    }
    function openRunModal() {
      document.getElementById('run-modal').classList.add('active');
    }
    function closeRunModal() {
      document.getElementById('run-modal').classList.remove('active');
    }

    function setActiveQueue(queue) {
      document.querySelectorAll('.nav-item.queue-item').forEach(item => {
        if (item.dataset.queue === queue) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
      // Optionally filter the triage table by queue status
      if (typeof filterTriageByQueue === 'function') {
        filterTriageByQueue(queue);
      }
    }
    
    function initRouter() {
      document.querySelectorAll('.nav-item[data-page]').forEach(item => {
        item.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const page = item.dataset.page;
          const queue = item.dataset.queue;
          console.log('[Router] Click on nav-item, page:', page, 'queue:', queue);
          navigateTo(page);
          if (queue) {
            setActiveQueue(queue);
          }
        });
      });
      
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setMode(btn.dataset.mode);
        });
      });
      
      // v1.4.14: Track full route including params to prevent loops
      var currentRoute = 'triage';
      
      window.addEventListener('hashchange', () => {
        const hash = window.location.hash.replace('#/', '') || 'triage';
        // Prevent duplicate navigation - compare full route, not just page name
        if (currentRoute !== hash) {
          console.log('[Router] Hashchange to:', hash);
          currentRoute = hash;
          navigateTo(hash);
        }
      });
      
      // Load user settings and check for first run
      loadUserSettings();
      checkFirstRun();
      
      // Setup loader modal events
      setupLoaderModalEvents();
      
      // v1.4.24: Clear stale reviewer data BEFORE setMode loads queues
      if (!dataLoaded) {
        clearStaleReviewerData();
      }
      
      // v1.4.20: Check for role from landing page first, then viewer mode
      let savedMode = localStorage.getItem('currentRole') || localStorage.getItem('viewer_mode_v10');
      // Convert legacy 'operator' mode to 'analyst'
      if (savedMode === 'operator') savedMode = 'analyst';
      if (savedMode) setMode(savedMode);
      else setMode('analyst');
      
      // Sync landing page role back to viewer mode storage
      if (localStorage.getItem('currentRole')) {
        localStorage.setItem('viewer_mode_v10', localStorage.getItem('currentRole'));
      }
      
      // v1.6.22: Apply role-based mode restrictions
      applyRoleBasedModeRestrictions();
      
      // v1.4.22: Default route based on role
      const hash = window.location.hash.replace('#/', '') || '';
      if (hash && hash !== 'loader') {
        navigateTo(hash);
      } else {
        // No hash or loader - go to role default
        navigateToRoleDefault();
      }
      
      // Auto-setup repo masters if enabled
      if (userSettings.use_repo_masters && !dataLoaded) {
        autoSetupRepoMasters();
      }
      
    }

    function getRecordHash(record) {
      const sorted = sortObjectKeys(record);
      return JSON.stringify(sorted);
    }

    function getJoinKey(record) {
      const identity = getJoinIdentity(record);
      return `${identity.contract_key || ''}|${identity.file_url || ''}|${identity.file_name || ''}`;
    }

    function getRowKey(record, type) {
      const jk = getJoinKey(record);
      if (type === 'contractResults') {
        return jk;
      } else if (type === 'issues') {
        return `${jk}|${record.sheet || ''}|${record.field || ''}|${record.issue_type || ''}`;
      } else if (type === 'fieldActions') {
        return `${jk}|${record.sheet || ''}|${record.field || ''}|${record.action || ''}`;
      }
      return jk;
    }

    function computeRowChanges(primaryArr, compareArr, type) {
      const changes = {};
      const primaryMap = new Map();
      const compareMap = new Map();
      
      primaryArr.forEach(r => {
        const key = getRowKey(r, type);
        primaryMap.set(key, { record: r, hash: getRecordHash(r) });
      });
      
      compareArr.forEach(r => {
        const key = getRowKey(r, type);
        compareMap.set(key, { record: r, hash: getRecordHash(r) });
      });
      
      primaryMap.forEach((val, key) => {
        if (!compareMap.has(key)) {
          changes[key] = 'added';
        } else if (val.hash !== compareMap.get(key).hash) {
          changes[key] = 'changed';
        }
      });
      
      compareMap.forEach((val, key) => {
        if (!primaryMap.has(key)) {
          changes[key] = 'removed';
        }
      });
      
      return changes;
    }

    function computeDeltaStats(primary, compare) {
      const pSum = primary.sf_summary || {};
      const cSum = compare.sf_summary || {};
      
      return {
        contracts: (pSum.contracts || 0) - (cSum.contracts || 0),
        ready: (pSum.ready || 0) - (cSum.ready || 0),
        needsReview: (pSum.needs_review || 0) - (cSum.needs_review || 0),
        blocked: (pSum.blocked || 0) - (cSum.blocked || 0),
        issues: {
          added: Object.values(rowChanges.issues).filter(v => v === 'added').length,
          changed: Object.values(rowChanges.issues).filter(v => v === 'changed').length,
          removed: Object.values(rowChanges.issues).filter(v => v === 'removed').length
        },
        actions: {
          added: Object.values(rowChanges.fieldActions).filter(v => v === 'added').length,
          changed: Object.values(rowChanges.fieldActions).filter(v => v === 'changed').length,
          removed: Object.values(rowChanges.fieldActions).filter(v => v === 'removed').length
        }
      };
    }

    function renderDeltaSummary() {
      const container = document.getElementById('delta-container');
      if (!deltaStats) {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      
      const formatDelta = (val) => val > 0 ? `+${val}` : val.toString();
      const getClass = (val) => val > 0 ? 'positive' : val < 0 ? 'negative' : 'neutral';
      
      container.innerHTML = `
        <h2>Delta Summary (vs. Previous)</h2>
        <div class="compare-actions">
          <button class="compare-btn" id="copy-delta-summary">Copy Delta Summary (Markdown)</button>
        </div>
        <div class="compare-legend">
          <span class="compare-legend-item"><span class="compare-legend-dot added"></span> Added</span>
          <span class="compare-legend-item"><span class="compare-legend-dot changed"></span> Changed</span>
          <span class="compare-legend-item"><span class="compare-legend-dot removed"></span> Removed</span>
        </div>
        <div class="delta-summary">
          <div class="delta-card ${getClass(deltaStats.contracts)}">
            <div class="delta-value ${getClass(deltaStats.contracts)}">${formatDelta(deltaStats.contracts)}</div>
            <div class="delta-label">Contracts</div>
          </div>
          <div class="delta-card ${getClass(deltaStats.ready)}">
            <div class="delta-value ${getClass(deltaStats.ready)}">${formatDelta(deltaStats.ready)}</div>
            <div class="delta-label">Ready</div>
          </div>
          <div class="delta-card ${getClass(deltaStats.needsReview)}">
            <div class="delta-value ${getClass(deltaStats.needsReview)}">${formatDelta(deltaStats.needsReview)}</div>
            <div class="delta-label">Needs Review</div>
          </div>
          <div class="delta-card ${getClass(deltaStats.blocked)}">
            <div class="delta-value ${getClass(deltaStats.blocked)}">${formatDelta(deltaStats.blocked)}</div>
            <div class="delta-label">Blocked</div>
          </div>
          <div class="delta-card ${deltaStats.issues.added > 0 ? 'positive' : 'neutral'}">
            <div class="delta-value ${deltaStats.issues.added > 0 ? 'positive' : 'neutral'}">+${deltaStats.issues.added}</div>
            <div class="delta-label">Issues Added</div>
          </div>
          <div class="delta-card ${deltaStats.issues.changed > 0 ? 'neutral' : 'neutral'}">
            <div class="delta-value neutral">${deltaStats.issues.changed}</div>
            <div class="delta-label">Issues Changed</div>
          </div>
          <div class="delta-card ${deltaStats.issues.removed > 0 ? 'negative' : 'neutral'}">
            <div class="delta-value ${deltaStats.issues.removed > 0 ? 'negative' : 'neutral'}">${deltaStats.issues.removed > 0 ? '-' : ''}${deltaStats.issues.removed}</div>
            <div class="delta-label">Issues Removed</div>
          </div>
          <div class="delta-card ${deltaStats.actions.added > 0 ? 'positive' : 'neutral'}">
            <div class="delta-value ${deltaStats.actions.added > 0 ? 'positive' : 'neutral'}">+${deltaStats.actions.added}</div>
            <div class="delta-label">Actions Added</div>
          </div>
          <div class="delta-card ${deltaStats.actions.removed > 0 ? 'negative' : 'neutral'}">
            <div class="delta-value ${deltaStats.actions.removed > 0 ? 'negative' : 'neutral'}">${deltaStats.actions.removed > 0 ? '-' : ''}${deltaStats.actions.removed}</div>
            <div class="delta-label">Actions Removed</div>
          </div>
        </div>
      `;
      
      document.getElementById('copy-delta-summary')?.addEventListener('click', async () => {
        const md = generateDeltaMarkdown();
        const success = await copyToClipboard(md);
        const btn = document.getElementById('copy-delta-summary');
        const orig = btn.textContent;
        btn.textContent = success ? 'Copied!' : 'Failed';
        setTimeout(() => btn.textContent = orig, 1500);
      });
    }

    function generateDeltaMarkdown() {
      if (!deltaStats) return '# No comparison data\n';
      
      const formatDelta = (val) => val > 0 ? `+${val}` : val.toString();
      
      let md = `# Delta Summary\n\n`;
      md += `## Contract Status Changes\n\n`;
      md += `| Metric | Delta |\n`;
      md += `|--------|-------|\n`;
      md += `| Contracts | ${formatDelta(deltaStats.contracts)} |\n`;
      md += `| Ready | ${formatDelta(deltaStats.ready)} |\n`;
      md += `| Needs Review | ${formatDelta(deltaStats.needsReview)} |\n`;
      md += `| Blocked | ${formatDelta(deltaStats.blocked)} |\n`;
      md += `\n## Row-Level Changes\n\n`;
      md += `| Type | Added | Changed | Removed |\n`;
      md += `|------|-------|---------|----------|\n`;
      md += `| Issues | ${deltaStats.issues.added} | ${deltaStats.issues.changed} | ${deltaStats.issues.removed} |\n`;
      md += `| Field Actions | ${deltaStats.actions.added} | ${deltaStats.actions.changed} | ${deltaStats.actions.removed} |\n`;
      
      return md;
    }

    function normCmp(v) {
      if (v === null || v === undefined) return '';
      return String(v).trim().toLowerCase();
    }

    function isNullOrEmpty(v) {
      return v === null || v === undefined || String(v).trim() === '';
    }

    function normalizeToNull(v) {
      if (v === undefined || (typeof v === 'string' && v.trim() === '')) return null;
      return v;
    }

    function compareNullsLast(aVal, bVal) {
      const aEmpty = isNullOrEmpty(aVal);
      const bEmpty = isNullOrEmpty(bVal);
      if (aEmpty && bEmpty) return 0;
      if (aEmpty) return 1;
      if (bEmpty) return -1;
      return normCmp(aVal).localeCompare(normCmp(bVal));
    }

    function sortByJoinTriplet(arr, extraKeys = []) {
      return [...arr].sort((a, b) => {
        const ck = compareNullsLast(a.contract_key, b.contract_key);
        if (ck !== 0) return ck;
        const fu = compareNullsLast(a.file_url, b.file_url);
        if (fu !== 0) return fu;
        const fn = compareNullsLast(a.file_name, b.file_name);
        if (fn !== 0) return fn;
        for (const key of extraKeys) {
          const cmp = normCmp(a[key]).localeCompare(normCmp(b[key]));
          if (cmp !== 0) return cmp;
        }
        return 0;
      });
    }

    function sortBySeverityFirst(arr, extraKeys = []) {
      const sevOrder = { blocking: 0, warning: 1, info: 2 };
      return [...arr].sort((a, b) => {
        const aOrd = sevOrder[a.severity] ?? 3;
        const bOrd = sevOrder[b.severity] ?? 3;
        if (aOrd !== bOrd) return aOrd - bOrd;
        const ck = compareNullsLast(a.contract_key, b.contract_key);
        if (ck !== 0) return ck;
        const fu = compareNullsLast(a.file_url, b.file_url);
        if (fu !== 0) return fu;
        const fn = compareNullsLast(a.file_name, b.file_name);
        if (fn !== 0) return fn;
        for (const key of extraKeys) {
          const cmp = compareNullsLast(a[key], b[key]);
          if (cmp !== 0) return cmp;
        }
        return 0;
      });
    }

    function getJoinIdentity(record) {
      return {
        contract_key: normalizeToNull(record.contract_key),
        file_url: normalizeToNull(record.file_url),
        file_name: normalizeToNull(record.file_name)
      };
    }

    function joinIdentityEquals(a, b) {
      if (!a || !b) return false;
      const eq = (x, y) => {
        const nx = normalizeToNull(x);
        const ny = normalizeToNull(y);
        if (nx === null && ny === null) return true;
        if (nx === null || ny === null) return false;
        return nx === ny;
      };
      return eq(a.contract_key, b.contract_key) && eq(a.file_url, b.file_url) && eq(a.file_name, b.file_name);
    }

    function getPrimaryKey(identity) {
      if (identity.contract_key !== null) return 'contract_key';
      if (identity.file_url !== null) return 'file_url';
      if (identity.file_name !== null) return 'file_name';
      return null;
    }

    function formatJoinIdentityPill(identity) {
      const primary = getPrimaryKey(identity);
      const format = (key, label, val) => {
        const v = val ?? 'null';
        if (key === primary) return `<span class="identity-primary">${label}=${v}</span>`;
        return `<span class="identity-fallback">${label}=${v}</span>`;
      };
      return `${format('contract_key', 'ck', identity.contract_key)} | ${format('file_url', 'fu', identity.file_url)} | ${format('file_name', 'fn', identity.file_name)}`;
    }

    function formatJoinIdentityText(identity) {
      const ck = identity.contract_key ?? 'null';
      const fu = identity.file_url ?? 'null';
      const fn = identity.file_name ?? 'null';
      const primary = getPrimaryKey(identity);
      return `ck=${ck} | fu=${fu} | fn=${fn} (PRIMARY: ${primary || 'none'})`;
    }

    function getRelatedRecords(identity, dataArray) {
      return dataArray.filter(r => joinIdentityEquals(getJoinIdentity(r), identity));
    }

    function formatValue(v) {
      if (v === null || v === undefined) return '<span class="null-value">null</span>';
      if (typeof v === 'object') return JSON.stringify(v);
      return String(v);
    }

    function matchesSearch(row, search) {
      if (!search) return true;
      const lowerSearch = search.toLowerCase();
      return Object.values(row).some(v => {
        if (v === null || v === undefined) return false;
        return String(v).toLowerCase().includes(lowerSearch);
      });
    }

    function filterData(data, type) {
      return data.filter(row => {
        if (!matchesSearch(row, activeFilters.search)) return false;
        if (type === 'issues' || type === 'fieldActions') {
          if (!activeFilters.severities.includes(row.severity)) return false;
        }
        if (type === 'contractResults') {
          const status = (row.sf_contract_status || '').toLowerCase();
          if (!activeFilters.statuses.includes(status)) return false;
          if (activeFilters.subtype && row.detected_subtype !== activeFilters.subtype) return false;
        }
        return true;
      });
    }

    function renderSummary(summary) {
      summary = summary || allData.summary || {};
      const container = document.getElementById('summary-container');
      if (!container) return; // v1.5.4: Skip if analyst triage removed this element
      container.innerHTML = `
        <h2>Summary</h2>
        <div class="summary">
          <div class="summary-card contracts clickable" title="View all records" onclick="navigateToGridFiltered('all')"><div class="count">${summary.contracts || 0}</div><div class="label">Contracts</div></div>
          <div class="summary-card ready clickable" title="View ready records" onclick="navigateToGridFiltered('ready')"><div class="count">${summary.ready || 0}</div><div class="label">Ready</div></div>
          <div class="summary-card needs-review clickable" title="View records needing review" onclick="navigateToGridFiltered('needs_review')"><div class="count">${summary.needs_review || 0}</div><div class="label">Needs Review</div></div>
          <div class="summary-card blocked clickable" title="View blocked records" onclick="navigateToGridFiltered('blocked')"><div class="count">${summary.blocked || 0}</div><div class="label">Blocked</div></div>
        </div>
      `;
    }

    function renderTable(containerId, title, data, columns, type) {
      const container = document.getElementById(containerId);
      if (!container) return; // v1.5.4: Skip if container removed
      const filtered = filterData(data, type);
      
      if (!data || data.length === 0) {
        container.innerHTML = `<h2>${title}</h2><div class="info">No data</div>`;
        return;
      }
      
      const headers = columns.map(c => {
        var tooltip = getTooltip(humanLabel(c.key)) || getTooltip(c.label);
        var icon = tooltip ? ' <span class="info-icon" title="' + escapeHtml(tooltip) + '">&#9432;</span>' : '';
        return '<th>' + c.label + icon + '</th>';
      }).join('');
      const changes = rowChanges[type] || {};
      
      const rows = filtered.map((row, idx) => {
        const cells = columns.map(c => {
          let val = formatValue(row[c.key]);
          let cls = '';
          if (c.key === 'severity') cls = `severity-${row.severity}`;
          if (c.key === 'sf_contract_status') cls = `status-${(row.sf_contract_status || '').toLowerCase()}`;
          return `<td class="${cls}">${val}</td>`;
        }).join('');
        const rowKey = getRowKey(row, type);
        const changeType = changes[rowKey];
        const rowClass = changeType ? `row-${changeType}` : '';
        return `<tr data-type="${type}" data-idx="${data.indexOf(row)}" data-source="primary" class="${rowClass}">${cells}</tr>`;
      }).join('');
      
      let removedRows = '';
      if (compareData && Object.keys(changes).length > 0) {
        const removedKeys = Object.entries(changes)
          .filter(([k, v]) => v === 'removed')
          .map(([k]) => k);
        
        if (removedKeys.length > 0) {
          const compareArr = getCompareArray(type);
          const removedRecords = compareArr.filter(r => removedKeys.includes(getRowKey(r, type)));
          
          removedRows = removedRecords.map((row, idx) => {
            const cells = columns.map(c => {
              let val = formatValue(row[c.key]);
              let cls = '';
              if (c.key === 'severity') cls = `severity-${row.severity}`;
              if (c.key === 'sf_contract_status') cls = `status-${(row.sf_contract_status || '').toLowerCase()}`;
              return `<td class="${cls}">${val}</td>`;
            }).join('');
            return `<tr data-type="${type}" data-idx="${idx}" data-source="compare" class="row-removed">${cells}</tr>`;
          }).join('');
        }
      }
      
      const totalCount = data.length + (removedRows ? Object.values(changes).filter(v => v === 'removed').length : 0);
      
      container.innerHTML = `
        <h2>${title} (${filtered.length + (removedRows ? Object.values(changes).filter(v => v === 'removed').length : 0)}/${totalCount})</h2>
        <div class="table-container">
          <table><thead><tr>${headers}</tr></thead><tbody>${rows}${removedRows}</tbody></table>
        </div>
      `;
      
      container.querySelectorAll('tbody tr').forEach(tr => {
        if (tr.dataset.source === 'compare') return;
        tr.addEventListener('click', () => openDrawerFromType(type, parseInt(tr.dataset.idx)));
      });
    }

    function getCompareArray(type) {
      if (!compareData) return [];
      if (type === 'contractResults') return compareData.sf_contract_results || [];
      if (type === 'issues') return compareData.sf_issues || [];
      if (type === 'fieldActions') return compareData.sf_field_actions || [];
      return [];
    }

    function renderAllTables() {
      renderTable('contract-results-container', 'Contract Results', allData.contractResults, [
        { key: 'contract_key', label: 'Contract Key' },
        { key: 'file_name', label: 'File Name' },
        { key: 'file_url', label: 'File URL' },
        { key: 'detected_subtype', label: 'Subtype' },
        { key: 'sf_contract_status', label: 'Status' },
        { key: 'notes', label: 'Notes' }
      ], 'contractResults');
      
      renderTable('issues-container', 'Issues', allData.issues, [
        { key: 'severity', label: 'Severity' },
        { key: 'contract_key', label: 'Contract Key' },
        { key: 'file_name', label: 'File Name' },
        { key: 'sheet', label: 'Sheet' },
        { key: 'field', label: 'Field' },
        { key: 'issue_type', label: 'Issue Type' },
        { key: 'details', label: 'Details' }
      ], 'issues');
      
      renderTable('field-actions-container', 'Field Actions', allData.fieldActions, [
        { key: 'severity', label: 'Severity' },
        { key: 'contract_key', label: 'Contract Key' },
        { key: 'file_name', label: 'File Name' },
        { key: 'sheet', label: 'Sheet' },
        { key: 'field', label: 'Field' },
        { key: 'action', label: 'Action' },
        { key: 'proposed_value', label: 'Proposed Value' },
        { key: 'reason_text', label: 'Reason' }
      ], 'fieldActions');
    }

    function populateSubtypeDropdown() {
      const subtypes = [...new Set((allData.contractResults || []).map(r => r.detected_subtype).filter(Boolean))].sort();
      const select = document.getElementById('filter-subtype');
      if (!select) return; // v1.6.3: Skip if element not found
      select.innerHTML = '<option value="">All Subtypes</option>' + 
        subtypes.map(s => `<option value="${s}">${s}</option>`).join('');
    }

    function renderDrawerTab(tab) {
      const body = document.getElementById('drawer-body');
      const identity = currentSelection.joinIdentity;
      if (!identity) return;

      let content = '';
      let jsonData = null;

      if (tab === 'contract') {
        const contract = currentSelection.contractIdx !== null 
          ? allData.contractResults[currentSelection.contractIdx]
          : allData.contractResults.find(r => joinIdentityEquals(getJoinIdentity(r), identity));
        if (contract) {
          jsonData = contract;
          content = `<div class="json-header">Internal JSON (advanced)</div><pre class="drawer-json">${JSON.stringify(contract, null, 2)}</pre>`;
        } else {
          content = '<div class="drawer-empty">No contract record found for this join identity.</div>';
        }
      } else if (tab === 'issues') {
        const related = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
        jsonData = related;
        if (related.length === 0) {
          content = '<div class="drawer-empty">No related issues for this join identity.</div>';
        } else {
          content = renderSelectionControls('issues', related.length) + renderDrawerTable(related, [
            { key: 'severity', label: 'Severity' },
            { key: 'sheet', label: 'Sheet' },
            { key: 'field', label: 'Field' },
            { key: 'issue_type', label: 'Type' },
            { key: 'details', label: 'Details' }
          ], 'issues');
        }
      } else if (tab === 'actions') {
        const related = sortBySeverityFirst(getRelatedRecords(identity, allData.fieldActions), ['sheet', 'field', 'action']);
        jsonData = related;
        if (related.length === 0) {
          content = '<div class="drawer-empty">No related field actions for this join identity.</div>';
        } else {
          content = renderSelectionControls('actions', related.length) + renderDrawerTable(related, [
            { key: 'severity', label: 'Severity' },
            { key: 'sheet', label: 'Sheet' },
            { key: 'field', label: 'Field' },
            { key: 'action', label: 'Action' },
            { key: 'proposed_value', label: 'Value' },
            { key: 'reason_text', label: 'Reason' }
          ], 'actions');
        }
      } else if (tab === 'changelog') {
        const related = sortBySeverityFirst(getRelatedRecords(identity, allData.changeLog), ['sheet', 'field', 'notes']);
        jsonData = related;
        if (related.length === 0) {
          content = '<div class="drawer-empty">No related change log entries for this join identity.</div>';
        } else {
          content = renderSelectionControls('changelog', related.length) + renderDrawerTable(related, [
            { key: 'severity', label: 'Severity' },
            { key: 'sheet', label: 'Sheet' },
            { key: 'field', label: 'Field' },
            { key: 'notes', label: 'Notes' }
          ], 'changelog');
        }
      }

      body.innerHTML = content;
      body.dataset.json = JSON.stringify(jsonData, null, 2);
      body.dataset.tabType = tab;
      body.dataset.records = JSON.stringify(jsonData);
    }

    function getRecordKey(record) {
      const ck = normalizeToNull(record.contract_key) ?? '';
      const fu = normalizeToNull(record.file_url) ?? '';
      const fn = normalizeToNull(record.file_name) ?? '';
      const sh = record.sheet ?? '';
      const fi = record.field ?? '';
      const ty = record.issue_type ?? record.action ?? record.notes ?? '';
      return `${ck}|${fu}|${fn}|${sh}|${fi}|${ty}`;
    }

    function renderDrawerTable(data, columns, tabType) {
      const selectionSet = selectedRecords[tabType];
      const headers = (tabType ? '<th></th>' : '') + columns.map(c => `<th>${c.label}</th>`).join('');
      const rows = data.map((row, idx) => {
        const key = getRecordKey(row);
        const checked = selectionSet?.has(key) ? 'checked' : '';
        const checkbox = tabType ? `<td><input type="checkbox" data-key="${key}" data-idx="${idx}" ${checked}></td>` : '';
        const cells = columns.map(c => {
          let val = formatValue(row[c.key]);
          let cls = '';
          if (c.key === 'severity') cls = `severity-${row.severity}`;
          return `<td class="${cls}">${val}</td>`;
        }).join('');
        return `<tr>${checkbox}${cells}</tr>`;
      }).join('');
      return `<table class="drawer-table"><thead><tr>${headers}</tr></thead><tbody>${rows}</tbody></table>`;
    }

    function renderSelectionControls(tabType, totalCount) {
      const selectedCount = selectedRecords[tabType]?.size || 0;
      return `
        <div class="selection-controls">
          <button class="selection-btn" data-action="select-all" data-tab="${tabType}">Select All</button>
          <button class="selection-btn" data-action="clear" data-tab="${tabType}">Clear</button>
          <button class="selection-btn" data-action="add-to-patch" data-tab="${tabType}" style="background: #2e7d32; color: white; border-color: #2e7d32;">Add Selected to Patch</button>
          <span class="selection-count">${selectedCount} of ${totalCount} selected</span>
        </div>
      `;
    }

    function updateTabCounts(identity) {
      const issuesCount = getRelatedRecords(identity, allData.issues).length;
      const actionsCount = getRelatedRecords(identity, allData.fieldActions).length;
      const changelogCount = getRelatedRecords(identity, allData.changeLog).length;
      document.getElementById('issues-count').textContent = issuesCount;
      document.getElementById('actions-count').textContent = actionsCount;
      document.getElementById('changelog-count').textContent = changelogCount;
    }

    function openDrawerFromType(type, idx) {
      const dataMap = { contractResults: allData.contractResults, issues: allData.issues, fieldActions: allData.fieldActions };
      const record = dataMap[type]?.[idx];
      if (!record) return;
      
      // For contract results, use the new Record Drawer for a cleaner experience
      if (type === 'contractResults') {
        openRecordDrawer(record.contract_key || record.file_name, idx, allData.contractResults);
        return;
      }

      const identity = getJoinIdentity(record);
      currentSelection.joinIdentity = identity;
      currentSelection.sourceType = type;

      const matchingContracts = allData.contractResults.filter(r => joinIdentityEquals(getJoinIdentity(r), identity));
      if (type === 'contractResults') {
        currentSelection.contractIdx = idx;
      } else {
        const contractIdx = allData.contractResults.findIndex(r => joinIdentityEquals(getJoinIdentity(r), identity));
        currentSelection.contractIdx = contractIdx >= 0 ? contractIdx : null;
      }
      currentSelection.activeTab = 'contract';

      document.getElementById('identity-pill').innerHTML = formatJoinIdentityPill(identity);
      updateTabCounts(identity);

      const warning = document.getElementById('drawer-warning');
      if (matchingContracts.length > 1) {
        warning.textContent = `Warning: ${matchingContracts.length} contracts share this join identity. Showing first match deterministically.`;
        warning.style.display = 'block';
      } else {
        warning.style.display = 'none';
      }

      document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
      document.querySelector('.drawer-tab[data-tab="contract"]').classList.add('active');

      renderDrawerTab('contract');

      document.getElementById('drawer').classList.add('active');
      document.getElementById('drawer-overlay').classList.add('active');

      saveSelection();
    }

    function openDrawer(idx) {
      openDrawerFromType('contractResults', idx);
    }

    function closeDrawer() {
      document.getElementById('drawer').classList.remove('active');
      document.getElementById('drawer-overlay').classList.remove('active');
      currentSelection.joinIdentity = null;
      clearSelection();
    }

    function saveSelection() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(currentSelection));
      } catch (e) {}
    }

    function clearSelection() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (e) {}
    }

    function restoreSelection() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) return;
        const sel = JSON.parse(stored);
        if (!sel.joinIdentity) return;

        let contractIdx = sel.contractIdx;
        if (contractIdx !== null && contractIdx !== undefined) {
          const storedRecord = allData.contractResults[contractIdx];
          if (!storedRecord || !joinIdentityEquals(getJoinIdentity(storedRecord), sel.joinIdentity)) {
            contractIdx = allData.contractResults.findIndex(r => joinIdentityEquals(getJoinIdentity(r), sel.joinIdentity));
          }
        } else {
          contractIdx = allData.contractResults.findIndex(r => joinIdentityEquals(getJoinIdentity(r), sel.joinIdentity));
        }

        if (contractIdx < 0) {
          clearSelection();
          return;
        }

        const validTabs = ['contract', 'issues', 'actions', 'changelog'];
        if (!validTabs.includes(sel.activeTab)) {
          sel.activeTab = 'contract';
        }

        sel.contractIdx = contractIdx;
        currentSelection = sel;
        document.getElementById('identity-pill').innerHTML = formatJoinIdentityPill(sel.joinIdentity);
        updateTabCounts(sel.joinIdentity);

        document.querySelectorAll('.drawer-tab').forEach(t => {
          t.classList.toggle('active', t.dataset.tab === sel.activeTab);
        });

        renderDrawerTab(sel.activeTab);

        document.getElementById('drawer').classList.add('active');
        document.getElementById('drawer-overlay').classList.add('active');
      } catch (e) {
        clearSelection();
      }
    }

    function openCommandModal(cmdKey) {
      const cmd = commands.commands?.[cmdKey];
      const desc = commands.descriptions?.[cmdKey] || '';
      if (!cmd) return;
      
      document.getElementById('modal-title').textContent = cmdKey.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      document.getElementById('modal-description').textContent = desc;
      document.getElementById('modal-command').textContent = cmd;
      document.getElementById('modal-status').style.display = 'none';
      updateRunButton();
      document.getElementById('command-modal').classList.add('active');
    }

    function closeModal() {
      document.getElementById('command-modal').classList.remove('active');
    }

    function updateRunButton() {
      const confirmChecked = document.getElementById('confirm-run').checked;
      const runBtn = document.getElementById('modal-run');
      runBtn.disabled = !confirmChecked;
      runBtn.textContent = confirmChecked ? 'Run Command' : 'Run (Confirm Required)';
    }

    function showModalStatus(message, type) {
      const status = document.getElementById('modal-status');
      status.textContent = message;
      status.className = 'modal-status ' + type;
      status.style.display = 'block';
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (e) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        return true;
      }
    }

    async function loadCommands() {
      try {
        const resp = await fetch(COMMANDS_PATH);
        if (resp.ok) {
          commands = await resp.json();
        }
      } catch (e) {
        console.warn('Could not load run_commands.json');
      }
    }

    async function loadData() {
      const errorContainer = document.getElementById('error-container');
      const sourceInfo = document.getElementById('source-info');
      
      // First try to restore from localStorage
      if (restoreSessionFromStorage()) {
        sourceInfo.textContent = `Data source: ${sessionState.sourceType} (restored from browser)`;
        restoreSelection();
        return;
      }
      
      // v1.6.3: Default to ostereo_demo_v1.json on cold start
      console.log('[Loader] Cold start - loading default dataset (ostereo_demo_v1.json)...');
      await loadSampleDataset({ autoRedirect: false });
      return;
      
      // Legacy: Try sf_packet files (kept for reference, now bypassed)
      let data = null;
      let source = '';
      let isFallback = false;
      
      try {
        const resp = await fetch(RELATIVE_PRIMARY);
        if (resp.ok) {
          data = await resp.json();
          source = PRIMARY_PATH;
        }
      } catch (e) {}
      
      if (!data) {
        try {
          const resp = await fetch(RELATIVE_FALLBACK);
          if (resp.ok) {
            data = await resp.json();
            source = FALLBACK_PATH + ' (fallback)';
            isFallback = true;
          }
        } catch (e) {}
      }
      
      if (!data) {
        // v1.6.3: No sf_packet available - auto-load ostereo_demo_v1 as default
        console.log('[Loader] No sf_packet found, loading default dataset...');
        await loadSampleDataset({ autoRedirect: false });
        return;
      }
      
      if (sourceInfo) sourceInfo.textContent = `Data source: ${source}`;
      
      renderSummary(data.sf_summary || {});
      
      allData.contractResults = sortByJoinTriplet(data.sf_contract_results || []);
      // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
      allData.issues = filterOutReferenceData(sortBySeverityFirst(data.sf_issues || [], ['sheet', 'field', 'issue_type']));
      allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(data.sf_field_actions || [], ['sheet', 'field', 'action']));
      allData.changeLog = sortBySeverityFirst(data.sf_change_log || [], ['sheet', 'field', 'notes']);
      allData.summary = data.sf_summary || {};
      
      // Set session state based on source
      sessionState.status = isFallback ? 'fallback' : 'loaded';
      sessionState.sourceType = isFallback ? 'example' : 'fetch';
      sessionState.loadedAt = Date.now();
      sessionState.previewData = data;
      
      // Set data loaded state
      dataLoaded = true;
      currentArtifactPath = source;
      updateUIForDataState();
      updateSessionChip();
      
      populateSubtypeDropdown();
      renderAllTables();
      populateTargetFieldDropdown();
      restoreSelection();
    }

    // Legacy toolbar handler (Run page was removed, but keep for safety)
    const legacyToolbar = document.getElementById('toolbar');
    if (legacyToolbar) {
      legacyToolbar.addEventListener('click', async e => {
        const btn = e.target.closest('.toolbar-btn');
        if (btn) {
          const cmdKey = btn.dataset.cmd;
          const cmd = commands.commands?.[cmdKey];
          if (cmd) {
            const success = await copyToClipboard(cmd);
            openCommandModal(cmdKey);
            showModalStatus(success ? 'Command copied to clipboard!' : 'Could not auto-copy', success ? 'success' : 'error');
          }
        }
      });
    }

    document.getElementById('modal-close')?.addEventListener('click', closeModal);
    document.getElementById('modal-cancel')?.addEventListener('click', closeModal);
    document.getElementById('command-modal')?.addEventListener('click', e => {
      if (e.target.id === 'command-modal') closeModal();
    });

    document.getElementById('modal-copy')?.addEventListener('click', async () => {
      const cmd = document.getElementById('modal-command')?.textContent;
      if (cmd) {
        const success = await copyToClipboard(cmd);
        showModalStatus(success ? 'Copied to clipboard!' : 'Copy failed', success ? 'success' : 'error');
      }
    });

    document.getElementById('modal-run')?.addEventListener('click', () => {
      showModalStatus('Execution is not available in browser environment. Please run the copied command in your terminal.', 'info');
    });

    document.getElementById('confirm-run')?.addEventListener('change', updateRunButton);

    document.getElementById('drawer-close')?.addEventListener('click', closeDrawer);
    document.getElementById('drawer-overlay')?.addEventListener('click', closeDrawer);

    document.getElementById('drawer-tabs')?.addEventListener('click', e => {
      const tab = e.target.closest('.drawer-tab');
      if (!tab) return;
      const tabName = tab.dataset.tab;
      currentSelection.activeTab = tabName;
      document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      
      const patchStudioPanel = document.getElementById('patch-studio-panel');
      const drawerBody = document.getElementById('drawer-body');
      const actionsDefault = document.getElementById('drawer-actions-default');
      const actionsPatchStudio = document.getElementById('drawer-actions-patch-studio');
      
      if (tabName === 'patch-studio') {
        patchStudioPanel.style.display = 'flex';
        patchStudioPanel.style.flexDirection = 'column';
        drawerBody.style.display = 'none';
        if (actionsDefault) actionsDefault.style.display = 'none';
        if (actionsPatchStudio) actionsPatchStudio.style.display = 'block';
        populatePatchStudioFromContext();
      } else {
        patchStudioPanel.style.display = 'none';
        drawerBody.style.display = 'block';
        if (actionsDefault) actionsDefault.style.display = 'block';
        if (actionsPatchStudio) actionsPatchStudio.style.display = 'none';
        renderDrawerTab(tabName);
      }
      saveSelection();
    });
    
    document.querySelectorAll('.patch-studio-sub-tab').forEach(function(tab) {
      tab.addEventListener('click', function() {
        const subtab = this.dataset.subtab;
        document.querySelectorAll('.patch-studio-sub-tab').forEach(function(t) {
          t.style.background = '#263238';
          t.style.color = '#aaa';
          t.classList.remove('active');
        });
        this.style.background = '#1a1a2e';
        this.style.color = 'white';
        this.classList.add('active');
        
        document.querySelectorAll('.patch-studio-sub-panel').forEach(function(panel) {
          panel.style.display = 'none';
        });
        document.getElementById('subtab-' + subtab).style.display = 'block';
      });
    });
    
    function populatePatchStudioFromContext() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return;
      
      const issues = getRelatedRecords(identity, allData.issues);
      if (issues.length > 0) {
        const firstIssue = issues[0];
        var targetFieldSel = document.getElementById('ps-target-field');
        if (targetFieldSel) {
          var fieldVal = (firstIssue.sheet || '') + '.' + (firstIssue.field || '');
          var opt = targetFieldSel.querySelector('option[value="' + fieldVal + '"]');
          if (opt) {
            targetFieldSel.value = fieldVal;
          }
        }
      }
    }
    
    function populateTargetFieldDropdown() {
      var select = document.getElementById('ps-target-field');
      if (!select || !allData) return;
      
      select.innerHTML = '<option value="">-- Select field --</option>';
      var fields = new Set();
      
      // Primary source: use field_index from bundle (computed from sheet_packets)
      var bundle = getCurrentBundle();
      if (bundle && bundle.field_index) {
        bundle.field_index.forEach(function(entry) {
          fields.add(entry.full_path);
        });
      }
      
      // Fallback: also add fields from issues and field_actions
      if (allData.issues) {
        allData.issues.forEach(function(issue) {
          if (issue.sheet && issue.field) {
            fields.add(issue.sheet + '.' + issue.field);
          }
        });
      }
      if (allData.fieldActions) {
        allData.fieldActions.forEach(function(action) {
          if (action.sheet && action.field) {
            fields.add(action.sheet + '.' + action.field);
          }
        });
      }
      
      Array.from(fields).sort().forEach(function(f) {
        var opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        select.appendChild(opt);
      });
      
      var otherOpt = document.createElement('option');
      otherOpt.value = 'OTHER';
      otherOpt.textContent = 'Other (type manually)';
      select.appendChild(otherOpt);
    }
    
    function updateIntentPreview() {
      var targetField = document.getElementById('ps-target-field')?.value || '';
      var conditionType = document.getElementById('ps-condition-type')?.value || '';
      var conditionOther = document.getElementById('ps-condition-other')?.value || '';
      var actionType = document.getElementById('ps-action-type')?.value || '';
      var actionOther = document.getElementById('ps-action-other')?.value || '';
      var because = document.getElementById('ps-intent-because')?.value || '';
      
      var whenText = '';
      if (targetField && targetField !== 'OTHER') {
        whenText = 'Field "' + targetField + '"';
      } else if (targetField === 'OTHER') {
        whenText = 'Field (custom)';
      }
      if (conditionType) {
        var cond = CONDITION_TYPES.find(function(c) { return c.value === conditionType; });
        if (cond) {
          whenText += ' ' + cond.label.toLowerCase();
        }
      }
      if (conditionType === 'OTHER' && conditionOther) {
        whenText += ': ' + conditionOther;
      }
      
      var thenText = '';
      if (actionType) {
        var act = ACTION_TYPES.find(function(a) { return a.value === actionType; });
        if (act) {
          thenText = act.label;
        }
      }
      if (actionType === 'OTHER' && actionOther) {
        thenText += ': ' + actionOther;
      }
      
      document.getElementById('preview-when').textContent = whenText || '(select field and condition)';
      document.getElementById('preview-then').textContent = thenText || '(select action)';
      document.getElementById('preview-because').textContent = because || '(enter comment)';
    }
    
    document.getElementById('ps-condition-type')?.addEventListener('change', function(e) {
      var wrap = document.getElementById('ps-condition-other-wrap');
      if (e.target.value === 'OTHER') {
        wrap.style.display = 'block';
      } else {
        wrap.style.display = 'none';
      }
      updateIntentPreview();
    });
    
    document.getElementById('ps-action-type')?.addEventListener('change', function(e) {
      var wrap = document.getElementById('ps-action-other-wrap');
      if (e.target.value === 'OTHER') {
        wrap.style.display = 'block';
      } else {
        wrap.style.display = 'none';
      }
      updateIntentPreview();
    });
    
    document.getElementById('ps-target-field')?.addEventListener('change', updateIntentPreview);
    document.getElementById('ps-condition-other')?.addEventListener('input', updateIntentPreview);
    document.getElementById('ps-action-other')?.addEventListener('input', updateIntentPreview);
    document.getElementById('ps-intent-because')?.addEventListener('input', updateIntentPreview);
    
    function getPatchStudioDraft() {
      var targetField = document.getElementById('ps-target-field')?.value || '';
      var conditionType = document.getElementById('ps-condition-type')?.value || '';
      var conditionOther = document.getElementById('ps-condition-other')?.value || '';
      var actionType = document.getElementById('ps-action-type')?.value || '';
      var actionOther = document.getElementById('ps-action-other')?.value || '';
      var because = document.getElementById('ps-intent-because')?.value || '';
      
      var intentStructured = {
        target_field: targetField !== 'OTHER' ? targetField : null,
        condition_type: conditionType || 'OTHER',
        condition_params: conditionType === 'OTHER' && conditionOther ? { custom: conditionOther } : null,
        action_type: actionType || 'OTHER',
        action_params: actionType === 'OTHER' && actionOther ? { custom: actionOther } : null,
        because: because
      };
      
      return {
        intent_structured: intentStructured,
        target: document.getElementById('ps-target')?.value || 'proposed_changes',
        risk: document.getElementById('ps-risk')?.value || 'low',
        rationale: document.getElementById('ps-rationale')?.value || '',
        evidence: {
          observation: document.getElementById('ps-evidence-observation')?.value || '',
          expected_behavior: document.getElementById('ps-evidence-expected')?.value || '',
          rule_justification: document.getElementById('ps-evidence-justification')?.value || '',
          repro_steps: document.getElementById('ps-evidence-repro')?.value || ''
        }
      };
    }
    
    function clearPatchStudioForm() {
      document.getElementById('ps-target-field').value = '';
      document.getElementById('ps-condition-type').value = '';
      document.getElementById('ps-condition-other').value = '';
      document.getElementById('ps-condition-other-wrap').style.display = 'none';
      document.getElementById('ps-action-type').value = '';
      document.getElementById('ps-action-other').value = '';
      document.getElementById('ps-action-other-wrap').style.display = 'none';
      document.getElementById('ps-intent-because').value = '';
      document.getElementById('ps-target').value = 'proposed_changes';
      document.getElementById('ps-risk').value = 'low';
      document.getElementById('ps-rationale').value = '';
      document.getElementById('ps-evidence-observation').value = '';
      document.getElementById('ps-evidence-expected').value = '';
      document.getElementById('ps-evidence-justification').value = '';
      document.getElementById('ps-evidence-repro').value = '';
      updateIntentPreview();
    }
    
    function validatePatchStudioForm() {
      var targetField = document.getElementById('ps-target-field')?.value || '';
      var conditionType = document.getElementById('ps-condition-type')?.value || '';
      var conditionOther = document.getElementById('ps-condition-other')?.value || '';
      var actionType = document.getElementById('ps-action-type')?.value || '';
      var actionOther = document.getElementById('ps-action-other')?.value || '';
      var because = document.getElementById('ps-intent-because')?.value || '';
      
      var errors = [];
      if (!targetField) errors.push('Target Field is required');
      if (!conditionType) errors.push('Condition Type is required');
      if (conditionType === 'OTHER' && !conditionOther) errors.push('Please describe the condition');
      if (!actionType) errors.push('Action Type is required');
      if (actionType === 'OTHER' && !actionOther) errors.push('Please describe the action');
      if (!because) errors.push('Comment (plain English) is required');
      if (because.length > 500) errors.push('Comment must be 500 characters or less');
      
      return errors;
    }
    
    document.getElementById('ps-submit-to-queue')?.addEventListener('click', function() {
      var errors = validatePatchStudioForm();
      if (errors.length > 0) {
        showToast(errors[0], 'warning');
        return;
      }
      
      const draft = getPatchStudioDraft();
      const identity = currentSelection.joinIdentity || {};
      const author = getCurrentUserName();
      
      var request = createPatchRequest({
        author: author,
        author_role: currentMode || 'Analyst',
        status: 'Draft',
        contract_key: identity.contract_key || null,
        file_url: identity.file_url || null,
        file_name: identity.file_name || null,
        target: draft.target,
        target_field: draft.intent_structured.target_field,
        condition_type: draft.intent_structured.condition_type,
        condition_params: draft.intent_structured.condition_params,
        action_type: draft.intent_structured.action_type,
        action_params: draft.intent_structured.action_params,
        because: draft.intent_structured.because,
        rationale: draft.rationale,
        risk: draft.risk,
        evidence_observation: draft.evidence.observation,
        evidence_expected: draft.evidence.expected_behavior,
        evidence_justification: draft.evidence.rule_justification,
        evidence_repro: draft.evidence.repro_steps
      });
      
      var submittedRequest = submitPatchRequest(request.request_id, author, currentMode || 'Analyst');
      
      if (submittedRequest) {
        showToast('Patch request submitted to queue: ' + request.request_id, 'success');
        clearPatchStudioForm();
        updatePatchQueueCounts();
        
        document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
        document.querySelector('.drawer-tab[data-tab="contract"]')?.classList.add('active');
        document.getElementById('patch-studio-panel').style.display = 'none';
        document.getElementById('drawer-body').style.display = 'block';
        document.getElementById('drawer-actions-default').style.display = 'block';
        document.getElementById('drawer-actions-patch-studio').style.display = 'none';
        renderDrawerTab('contract');
      } else {
        showToast('Failed to submit patch request', 'error');
      }
    });
    
    document.getElementById('ps-copy-draft')?.addEventListener('click', async function() {
      const draft = getPatchStudioDraft();
      const json = JSON.stringify(draft, null, 2);
      const success = await copyToClipboard(json);
      showToast(success ? 'Draft copied to clipboard' : 'Failed to copy', success ? 'success' : 'error');
    });
    
    document.getElementById('ps-save-local')?.addEventListener('click', function() {
      const draft = getPatchStudioDraft();
      localStorage.setItem('orchestrate.patch_studio.draft', JSON.stringify(draft));
      showToast('Draft saved locally', 'success');
    });
    
    document.getElementById('ps-run-preflight')?.addEventListener('click', function() {
      runPreflightChecks();
    });
    
    document.getElementById('ps-copy-preflight')?.addEventListener('click', async function() {
      const report = generatePreflightReport();
      const success = await copyToClipboard(JSON.stringify(report, null, 2));
      showToast(success ? 'Preflight report copied' : 'Failed to copy', success ? 'success' : 'error');
    });
    
    function runPreflightChecks() {
      const draft = getPatchStudioDraft();
      const checks = [];
      
      if (draft.intent.when && draft.intent.then) {
        checks.push({ status: 'PASS', message: 'Intent fields populated' });
      } else {
        checks.push({ status: 'FAIL', message: 'Intent fields incomplete (WHEN and THEN required)' });
      }
      
      if (draft.evidence.observation || draft.evidence.expected_behavior) {
        checks.push({ status: 'PASS', message: 'Evidence pack has content' });
      } else {
        checks.push({ status: 'WARN', message: 'Evidence pack incomplete' });
      }
      
      checks.push({ status: 'INFO', message: 'Target: ' + humanLabel(draft.target) });
      checks.push({ status: 'INFO', message: 'Risk level: ' + draft.risk });
      
      const container = document.getElementById('ps-preflight-checks');
      container.innerHTML = checks.map(function(check) {
        var badgeClass = check.status === 'PASS' ? 'background: #e8f5e9; color: #2e7d32;' :
                         check.status === 'FAIL' ? 'background: #ffebee; color: #c62828;' :
                         check.status === 'WARN' ? 'background: #fff3e0; color: #e65100;' :
                         'background: #e3f2fd; color: #1565c0;';
        return '<div class="preflight-check" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 6px;">' +
          '<span class="preflight-badge" style="padding: 3px 8px; border-radius: 4px; font-size: 0.75em; font-weight: 600; ' + badgeClass + '">' + check.status + '</span>' +
          '<span style="font-size: 0.9em;">' + escapeHtml(check.message) + '</span>' +
          '</div>';
      }).join('');
    }
    
    function generatePreflightReport() {
      const draft = getPatchStudioDraft();
      return {
        generated_at: new Date().toISOString(),
        intent_complete: !!(draft.intent.when && draft.intent.then),
        evidence_complete: !!(draft.evidence.observation && draft.evidence.expected_behavior),
        target: draft.target,
        risk: draft.risk,
        draft_snapshot: draft
      };
    }
    
    function copyEvidenceBlock(block) {
      var value = '';
      switch(block) {
        case 'observation': value = document.getElementById('ps-evidence-observation')?.value || ''; break;
        case 'expected': value = document.getElementById('ps-evidence-expected')?.value || ''; break;
        case 'justification': value = document.getElementById('ps-evidence-justification')?.value || ''; break;
        case 'repro': value = document.getElementById('ps-evidence-repro')?.value || ''; break;
      }
      copyToClipboard(value).then(function(success) {
        showToast(success ? 'Evidence block copied' : 'Failed to copy', success ? 'success' : 'error');
      });
    }

    document.getElementById('drawer-copy')?.addEventListener('click', async () => {
      const rawJson = document.getElementById('drawer-body').dataset.json || '{}';
      const parsed = JSON.parse(rawJson);
      const sorted = sortObjectKeys(parsed);
      const json = JSON.stringify(sorted, null, 2);
      const success = await copyToClipboard(json);
      const btn = document.getElementById('drawer-copy');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('identity-copy')?.addEventListener('click', async () => {
      const identity = currentSelection.joinIdentity;
      if (!identity) return;
      const text = formatJoinIdentityText(identity);
      const success = await copyToClipboard(text);
      const btn = document.getElementById('identity-copy');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    function sortObjectKeys(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (Array.isArray(obj)) return obj.map(sortObjectKeys);
      return Object.keys(obj).sort().reduce((acc, key) => {
        acc[key] = sortObjectKeys(obj[key]);
        return acc;
      }, {});
    }

    function generatePRSummary() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return '';
      const contract = currentSelection.contractIdx !== null 
        ? allData.contractResults[currentSelection.contractIdx] : null;
      const issues = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
      const actions = sortBySeverityFirst(getRelatedRecords(identity, allData.fieldActions), ['sheet', 'field', 'action']);
      const primary = getPrimaryKey(identity);
      const primaryVal = identity[primary] || 'unknown';

      let md = `# PR: Fix issues for ${primary}=${primaryVal}\n\n`;
      md += `## WHY\n`;
      md += `This record has ${issues.length} issue(s) and ${actions.length} pending action(s) that need resolution.\n\n`;
      md += `## Affected Artifacts\n`;
      md += `- **Join Identity**: ${formatJoinIdentityText(identity)}\n`;
      md += `- **Contract Status**: ${contract?.sf_contract_status || 'unknown'}\n`;
      md += `- **Detected Subtype**: ${contract?.detected_subtype || 'unknown'}\n`;
      if (issues.length > 0) {
        md += `- **Issues**: ${issues.map(i => i.issue_type).join(', ')}\n`;
      }
      md += `\n## Smoke Status\nunknown (run \`bash scripts/replit_smoke.sh\` to verify)\n`;
      return md;
    }

    function generatePatchSkeleton() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return '{}';
      const issues = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
      const primary = getPrimaryKey(identity);
      const primaryVal = (identity[primary] || 'unknown').replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20);
      const patch = {
        base_version: "0.1.0",
        changes: issues.map((issue, idx) => ({
          op: "add_rule",
          rule_id: `NEW_RULE_${primaryVal}_${idx + 1}`,
          description: `Fix: ${issue.issue_type} on ${issue.field || 'unknown'}`,
          when: { sheet: issue.sheet || "", field: issue.field || "", operator: "EXISTS", value: null },
          then: { action: "REQUIRE_PRESENT", sheet: issue.sheet || "", field: issue.field || "", severity: issue.severity || "warning" }
        }))
      };
      return JSON.stringify(sortObjectKeys(patch), null, 2);
    }

    function generateRuleDraft() {
      const identity = currentSelection.joinIdentity;
      if (!identity) return '';
      const issues = sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']);
      const primary = getPrimaryKey(identity);
      
      let draft = `# Rule Draft\n\n`;
      if (issues.length === 0) {
        draft += `No issues found for this join identity.\n`;
      } else {
        issues.forEach((issue, idx) => {
          draft += `## Rule ${idx + 1}\n\n`;
          draft += `**WHEN**\n`;
          draft += `- Sheet: ${issue.sheet || 'any'}\n`;
          draft += `- Field: ${issue.field || 'any'}\n`;
          draft += `- Condition: ${issue.issue_type || 'unknown'}\n\n`;
          draft += `**THEN**\n`;
          draft += `- Action: REQUIRE_PRESENT\n`;
          draft += `- Severity: ${issue.severity || 'warning'}\n\n`;
          draft += `**BECAUSE**\n`;
          draft += `- ${issue.details || 'Issue detected during validation'}\n`;
          draft += `- Primary key: ${primary}=${identity[primary]}\n\n`;
        });
      }
      return draft;
    }

    document.getElementById('copy-pr-summary')?.addEventListener('click', async () => {
      const text = generatePRSummaryWithEvidence();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-pr-summary');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-rule-draft')?.addEventListener('click', async () => {
      const text = generateRuleDraft();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-rule-draft');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('filter-search')?.addEventListener('input', e => {
      activeFilters.search = e.target.value;
      renderAllTables();
    });

    document.getElementById('severity-chips')?.addEventListener('click', e => {
      const chip = e.target.closest('.filter-chip');
      if (!chip) return;
      const sev = chip.dataset.severity;
      const idx = activeFilters.severities.indexOf(sev);
      if (idx >= 0) {
        activeFilters.severities.splice(idx, 1);
        chip.classList.add('inactive');
      } else {
        activeFilters.severities.push(sev);
        chip.classList.remove('inactive');
      }
      renderAllTables();
    });

    document.getElementById('status-chips')?.addEventListener('click', e => {
      const chip = e.target.closest('.filter-chip');
      if (!chip) return;
      const status = chip.dataset.status;
      const idx = activeFilters.statuses.indexOf(status);
      if (idx >= 0) {
        activeFilters.statuses.splice(idx, 1);
        chip.classList.add('inactive');
      } else {
        activeFilters.statuses.push(status);
        chip.classList.remove('inactive');
      }
      renderAllTables();
    });

    document.getElementById('filter-subtype')?.addEventListener('change', e => {
      activeFilters.subtype = e.target.value;
      renderAllTables();
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        closeModal();
        closeDrawer();
      }
    });

    document.getElementById('drawer-body')?.addEventListener('change', e => {
      if (e.target.type !== 'checkbox') return;
      const key = e.target.dataset.key;
      const tabType = document.getElementById('drawer-body').dataset.tabType;
      if (!tabType || tabType === 'contract') return;
      
      const selectionSet = selectedRecords[tabType];
      if (!selectionSet) return;
      
      if (e.target.checked) {
        selectionSet.add(key);
      } else {
        selectionSet.delete(key);
      }
      updateSelectionCount(tabType);
    });

    document.getElementById('drawer-body')?.addEventListener('click', e => {
      const btn = e.target.closest('.selection-btn');
      if (!btn) return;
      
      const action = btn.dataset.action;
      const tabType = btn.dataset.tab;
      const records = JSON.parse(document.getElementById('drawer-body').dataset.records || '[]');
      
      if (action === 'select-all') {
        records.forEach(r => selectedRecords[tabType].add(getRecordKey(r)));
        renderDrawerTab(currentSelection.activeTab);
      } else if (action === 'clear') {
        selectedRecords[tabType].clear();
        renderDrawerTab(currentSelection.activeTab);
      } else if (action === 'add-to-patch') {
        addSelectedToPatch(tabType);
      }
    });

    function updateSelectionCount(tabType) {
      const countEl = document.querySelector(`.selection-count`);
      if (countEl) {
        const records = JSON.parse(document.getElementById('drawer-body').dataset.records || '[]');
        countEl.textContent = `${selectedRecords[tabType]?.size || 0} of ${records.length} selected`;
      }
    }

    function addSelectedToPatch(tabType) {
      const records = JSON.parse(document.getElementById('drawer-body').dataset.records || '[]');
      const selectionSet = selectedRecords[tabType];
      const selected = records.filter(r => selectionSet.has(getRecordKey(r)));
      
      selected.forEach(record => {
        const key = getRecordKey(record);
        const exists = patchDraft.changes.some(c => c._key === key);
        if (!exists) {
          patchDraft.changes.push({
            _key: key,
            _source: tabType,
            record: record
          });
        }
      });
      
      renderPatchChanges();
      savePatchDraft();
      document.getElementById('patch-studio').classList.add('active');
    }

    function renderPatchChanges() {
      const list = document.getElementById('patch-changes-list');
      const count = document.getElementById('patch-changes-count');
      count.textContent = patchDraft.changes.length;
      
      if (patchDraft.changes.length === 0) {
        list.innerHTML = '<div class="patch-empty">No changes added. Select issues/actions in the Workbench tabs and add them here.</div>';
        return;
      }
      
      const sorted = sortBySeverityFirst([...patchDraft.changes].map(c => c.record), ['sheet', 'field']);
      const sortedChanges = sorted.map(r => patchDraft.changes.find(c => c._key === getRecordKey(r)));
      
      list.innerHTML = sortedChanges.map((change, idx) => {
        const r = change.record;
        const typeLabel = change._source === 'issues' ? 'Issue' : change._source === 'actions' ? 'Action' : 'Log';
        const desc = r.issue_type || r.action || r.notes || 'unknown';
        return `
          <div class="patch-change-item" data-idx="${idx}">
            <div class="patch-change-info">
              <strong>${typeLabel}:</strong> ${desc}<br>
              <small>${r.sheet || '-'} / ${r.field || '-'} (${r.severity || 'info'})</small>
            </div>
            <button class="patch-change-remove" data-key="${change._key}">&times;</button>
          </div>
        `;
      }).join('');
    }

    document.getElementById('patch-changes-list')?.addEventListener('click', e => {
      const btn = e.target.closest('.patch-change-remove');
      if (!btn) return;
      const key = btn.dataset.key;
      patchDraft.changes = patchDraft.changes.filter(c => c._key !== key);
      renderPatchChanges();
      savePatchDraft();
    });

    document.getElementById('clear-patch-changes')?.addEventListener('click', () => {
      patchDraft.changes = [];
      renderPatchChanges();
      savePatchDraft();
    });

    document.getElementById('switch-to-patch-studio-tab')?.addEventListener('click', () => {
      var patchStudioTab = document.querySelector('.drawer-tab[data-tab="patch-studio"]');
      if (patchStudioTab) {
        patchStudioTab.click();
      }
    });

    document.getElementById('patch-base-version')?.addEventListener('input', e => {
      patchDraft.baseVersion = e.target.value;
      savePatchDraft();
    });

    document.getElementById('patch-author')?.addEventListener('input', e => {
      patchDraft.author = e.target.value;
      savePatchDraft();
    });

    document.getElementById('patch-rationale')?.addEventListener('input', e => {
      patchDraft.rationale = e.target.value;
      savePatchDraft();
    });

    function generateGroupedRules() {
      const changes = patchDraft.changes;
      if (changes.length === 0) return '';
      
      const sorted = sortBySeverityFirst(changes.map(c => c.record), ['sheet', 'field']);
      const groups = new Map();
      
      sorted.forEach(record => {
        const whenKey = `${record.sheet || ''}|${record.field || ''}`;
        if (!groups.has(whenKey)) {
          groups.set(whenKey, []);
        }
        groups.get(whenKey).push(record);
      });
      
      let draft = `# Grouped Rule Draft\n\n`;
      let ruleNum = 1;
      
      groups.forEach((records, whenKey) => {
        const [sheet, field] = whenKey.split('|');
        draft += `## Rule ${ruleNum}\n\n`;
        draft += `**WHEN**\n`;
        draft += `- Sheet: ${sheet || 'any'}\n`;
        draft += `- Field: ${field || 'any'}\n\n`;
        draft += `**THEN**\n`;
        records.forEach(r => {
          const actionType = r.issue_type || r.action || 'REQUIRE_PRESENT';
          draft += `- ${actionType} (${r.severity || 'warning'})\n`;
        });
        draft += `\n**BECAUSE**\n`;
        records.forEach(r => {
          draft += `- ${r.details || r.reason_text || r.notes || 'Issue detected'}\n`;
        });
        draft += `\n`;
        ruleNum++;
      });
      
      return draft;
    }

    function getRuleIdPrefix(record) {
      const identity = getJoinIdentity(record);
      const primary = getPrimaryKey(identity);
      const primaryVal = identity[primary] || 'unknown';
      return String(primaryVal).replace(/[^a-zA-Z0-9]/g, '_').substring(0, 15);
    }

    function generateRuleMapping() {
      const changes = patchDraft.changes;
      if (changes.length === 0) return '[]';
      
      const sorted = sortBySeverityFirst(changes.map(c => c.record), ['sheet', 'field']);
      
      const rules = sorted.map((record, idx) => ({
        op: 'add_rule',
        rule_id: `RULE_${getRuleIdPrefix(record)}_${idx + 1}`,
        description: `Fix: ${record.issue_type || record.action || 'unknown'} on ${record.field || 'unknown'}`,
        when: {
          sheet: record.sheet || '',
          field: record.field || '',
          operator: 'EXISTS',
          value: null
        },
        then: {
          action: record.action || 'REQUIRE_PRESENT',
          sheet: record.sheet || '',
          field: record.field || '',
          severity: record.severity || 'warning'
        }
      }));
      
      return JSON.stringify(sortObjectKeys(rules), null, 2);
    }

    function generateFullPatchDraft() {
      const baseVersion = document.getElementById('patch-base-version').value || null;
      const author = document.getElementById('patch-author').value || null;
      const rationale = document.getElementById('patch-rationale').value || null;
      
      const changes = patchDraft.changes;
      const sorted = sortBySeverityFirst(changes.map(c => c.record), ['sheet', 'field']);
      
      const changesArray = sorted.map((record, idx) => ({
        op: 'add_rule',
        rule_id: `RULE_${getRuleIdPrefix(record)}_${idx + 1}`,
        description: `Fix: ${record.issue_type || record.action || 'unknown'} on ${record.field || 'unknown'}`,
        when: {
          sheet: record.sheet || '',
          field: record.field || '',
          operator: 'EXISTS',
          value: null
        },
        then: {
          action: record.action || 'REQUIRE_PRESENT',
          sheet: record.sheet || '',
          field: record.field || '',
          severity: record.severity || 'warning'
        }
      }));
      
      const patch = {
        base_version: baseVersion,
        author: author,
        rationale: rationale,
        changes: changesArray
      };
      
      return JSON.stringify(sortObjectKeys(patch), null, 2);
    }

    document.getElementById('copy-full-patch')?.addEventListener('click', async () => {
      const text = generateFullPatchDraft();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-full-patch');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-rule-mapping')?.addEventListener('click', async () => {
      const text = generateRuleMapping();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-rule-mapping');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-grouped-rules')?.addEventListener('click', async () => {
      const text = generateGroupedRules();
      const success = await copyToClipboard(text);
      const btn = document.getElementById('copy-grouped-rules');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-smoke-baseline')?.addEventListener('click', async () => {
      const cmd = commands.commands?.smoke_baseline || 'bash scripts/replit_smoke.sh';
      const success = await copyToClipboard(cmd);
      const btn = document.getElementById('copy-smoke-baseline');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-smoke-edge')?.addEventListener('click', async () => {
      const cmd = commands.commands?.smoke_edge || 'bash scripts/replit_smoke.sh edge';
      const success = await copyToClipboard(cmd);
      const btn = document.getElementById('copy-smoke-edge');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('copy-evidence-template')?.addEventListener('click', async () => {
      const identity = currentSelection.joinIdentity;
      const primary = identity ? getPrimaryKey(identity) : null;
      const primaryVal = identity?.[primary] || 'unknown';
      
      const template = `# Evidence for Patch

## Commit
- **SHA**: <COMMIT_SHA>
- **Branch**: main

## Verification
- [ ] Smoke baseline passed
- [ ] Smoke edge passed
- [ ] Manual review completed

## Artifacts
- **Join Identity**: ${identity ? formatJoinIdentityText(identity) : 'N/A'}
- **Primary Key**: ${primary || 'N/A'}=${primaryVal}
- **Patch File SHA256**: <SHA256_HASH>

## Notes
Add any additional notes here.
`;
      const success = await copyToClipboard(template);
      const btn = document.getElementById('copy-evidence-template');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    var patchStudioTabs = document.querySelector('.patch-studio-tabs');
    if (patchStudioTabs) {
      patchStudioTabs.addEventListener('click', function(e) {
        var tab = e.target.closest('.patch-studio-tab');
        if (!tab) return;
        var panelName = tab.dataset.panel;
        document.querySelectorAll('.patch-studio-tab').forEach(function(t) { t.classList.remove('active'); });
        tab.classList.add('active');
        document.querySelectorAll('.patch-studio-panel').forEach(function(p) { p.classList.remove('active'); });
        var panelEl = document.getElementById('panel-' + panelName);
        if (panelEl) panelEl.classList.add('active');
        if (panelName === 'preflight') renderPreflightChecklist();
      });
    }

    function parseBaseVersion(input) {
      const trimmed = input.trim();
      if (!trimmed) return { parsed: null, status: 'pending' };
      if (trimmed.startsWith('{')) {
        try {
          const json = JSON.parse(trimmed);
          if (json.version) return { parsed: { version: json.version }, status: 'pass' };
          return { parsed: null, status: 'warn', message: 'No version field found in JSON' };
        } catch (e) {
          return { parsed: null, status: 'warn', message: 'Invalid JSON, storing as raw text' };
        }
      }
      const versionMatch = trimmed.match(/^(\d+\.\d+\.\d+)$/);
      if (versionMatch) return { parsed: { version: versionMatch[1] }, status: 'pass' };
      return { parsed: { version: trimmed }, status: 'warn', message: 'Non-standard version format' };
    }

    function parseValidation(input) {
      const trimmed = input.trim();
      if (!trimmed) return { parsed: null, status: 'pending' };
      const result = { status: 'unknown', baseVersion: null, patchBaseVersion: null, changesCount: null, conflicts: [] };
      if (trimmed.toLowerCase().includes('ok:') || trimmed.toLowerCase().includes('valid')) {
        result.status = 'ok';
      } else if (trimmed.toLowerCase().includes('error') || trimmed.toLowerCase().includes('fail')) {
        result.status = 'error';
      }
      const bvMatch = trimmed.match(/base\.version[:\s]+([0-9.]+)/i);
      if (bvMatch) result.baseVersion = bvMatch[1];
      const pbvMatch = trimmed.match(/patch\.base_version[:\s]+([0-9.]+)/i);
      if (pbvMatch) result.patchBaseVersion = pbvMatch[1];
      const ccMatch = trimmed.match(/changes_count[:\s]+(\d+)/i);
      if (ccMatch) result.changesCount = parseInt(ccMatch[1]);
      const conflictMatches = [...trimmed.matchAll(/conflict[:\s]*(.*?)(?:\n|$)/gi)];
      result.conflicts = conflictMatches.map(m => m[1].trim()).filter(Boolean);
      if (result.status === 'ok') return { parsed: result, status: 'pass' };
      if (result.status === 'error') return { parsed: result, status: 'fail' };
      return { parsed: result, status: 'warn', message: 'Could not determine validation status' };
    }

    function parseConflict(input) {
      const trimmed = input.trim().toLowerCase();
      if (!trimmed) return { parsed: null, status: 'pending' };
      if (trimmed === 'reviewed') return { parsed: { reviewed: true }, status: 'warn', message: 'Manual review confirmed' };
      if (trimmed.includes('no conflict') || trimmed.includes('0 conflicts')) {
        return { parsed: { conflicts: [], count: 0 }, status: 'pass' };
      }
      const conflictLines = input.trim().split('\n').filter(l => l.trim() && !l.toLowerCase().includes('no conflict'));
      if (conflictLines.length > 0) {
        return { parsed: { conflicts: conflictLines, count: conflictLines.length }, status: 'fail', message: `${conflictLines.length} conflict(s) found` };
      }
      return { parsed: { reviewed: true }, status: 'warn', message: 'Content stored for manual review' };
    }

    function parseSmoke(input) {
      const trimmed = input.trim();
      if (!trimmed) return { parsed: null, status: 'pending' };
      if (trimmed.toLowerCase().includes('ok:') || trimmed.toLowerCase().includes('matches expected')) {
        return { parsed: { pass: true }, status: 'pass' };
      }
      if (trimmed.toLowerCase().includes('fail') || trimmed.toLowerCase().includes('error') || trimmed.toLowerCase().includes('mismatch')) {
        return { parsed: { pass: false }, status: 'fail' };
      }
      return { parsed: { raw: trimmed }, status: 'warn', message: 'Could not determine pass/fail' };
    }

    function renderPreflightChecklist() {
      const steps = [
        { id: 1, title: 'Base Version Check', key: 'baseVersion', desc: getStepDescription('baseVersion') },
        { id: 2, title: 'Validation Report', key: 'validation', desc: getStepDescription('validation') },
        { id: 3, title: 'Conflict Check', key: 'conflict', desc: getStepDescription('conflict') },
        { id: 4, title: 'Smoke Evidence', key: 'smoke', desc: getStepDescription('smoke') }
      ];
      const html = steps.map(step => {
        const status = getStepStatus(step.key);
        return `
          <div class="preflight-step">
            <div class="preflight-step-num ${status}">${step.id}</div>
            <div class="preflight-step-info">
              <div class="preflight-step-title">${step.title}</div>
              <div class="preflight-step-status">${step.desc}</div>
            </div>
            <span class="preflight-step-chip ${status}">${status}</span>
          </div>
        `;
      }).join('');
      document.getElementById('preflight-checklist').innerHTML = html;
    }

    function getStepStatus(key) {
      if (key === 'smoke') {
        const baseline = preflightEvidence.smokeBaseline.status;
        if (baseline === 'pass') return 'pass';
        if (baseline === 'fail') return 'fail';
        if (baseline === 'warn') return 'warn';
        return 'pending';
      }
      return preflightEvidence[key]?.status || 'pending';
    }

    function getStepDescription(key) {
      const ev = preflightEvidence;
      if (key === 'baseVersion') {
        if (ev.baseVersion.parsed?.version) return `Version: ${ev.baseVersion.parsed.version}`;
        if (ev.baseVersion.status === 'warn') return ev.baseVersion.message || 'Needs review';
        return 'Not provided';
      }
      if (key === 'validation') {
        if (ev.validation.parsed) {
          const p = ev.validation.parsed;
          if (p.status === 'ok') return `Valid (base: ${p.baseVersion || '?'}, changes: ${p.changesCount || '?'})`;
          if (p.status === 'error') return 'Validation failed';
        }
        if (ev.validation.status === 'warn') return ev.validation.message || 'Needs review';
        return 'Not provided';
      }
      if (key === 'conflict') {
        if (ev.conflict.parsed?.count === 0) return 'No conflicts';
        if (ev.conflict.parsed?.count > 0) return `${ev.conflict.parsed.count} conflict(s)`;
        if (ev.conflict.parsed?.reviewed) return 'Manual review confirmed';
        return 'Not provided';
      }
      if (key === 'smoke') {
        const parts = [];
        if (ev.smokeBaseline.parsed?.pass === true) parts.push('Baseline: PASS');
        else if (ev.smokeBaseline.parsed?.pass === false) parts.push('Baseline: FAIL');
        else if (ev.smokeBaseline.status === 'warn') parts.push('Baseline: Review');
        if (ev.smokeEdge.parsed?.pass === true) parts.push('Edge: PASS');
        else if (ev.smokeEdge.parsed?.pass === false) parts.push('Edge: FAIL');
        else if (ev.smokeEdge.status === 'warn') parts.push('Edge: Review');
        return parts.length > 0 ? parts.join(', ') : 'Not provided';
      }
      return 'Unknown';
    }

    function renderPreflightResult(containerId, evidence) {
      const container = document.getElementById(containerId);
      if (!evidence.parsed && evidence.status === 'pending') {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      container.className = `preflight-result ${evidence.status}`;
      let html = '';
      if (evidence.message) {
        html += `<div style="margin-bottom:6px;"><em>${evidence.message}</em></div>`;
      }
      if (evidence.parsed) {
        const entries = Object.entries(evidence.parsed).filter(([k, v]) => v !== null && k !== 'conflicts');
        entries.sort((a, b) => a[0].localeCompare(b[0]));
        entries.forEach(([key, val]) => {
          html += `<div class="preflight-result-row"><span class="preflight-result-key">${key}:</span><span class="preflight-result-val">${val}</span></div>`;
        });
        if (evidence.parsed.conflicts && evidence.parsed.conflicts.length > 0) {
          html += `<table class="preflight-conflicts-table"><thead><tr><th>#</th><th>Conflict</th></tr></thead><tbody>`;
          evidence.parsed.conflicts.forEach((c, i) => {
            html += `<tr><td>${i + 1}</td><td>${c}</td></tr>`;
          });
          html += `</tbody></table>`;
        }
      }
      container.innerHTML = html || '<em>Parsed successfully</em>';
    }

    function handlePreflightParse(type) {
      if (type === 'base-version') {
        const input = document.getElementById('preflight-base-version').value;
        const result = parseBaseVersion(input);
        preflightEvidence.baseVersion = { raw: input, ...result };
        renderPreflightResult('preflight-base-result', preflightEvidence.baseVersion);
      } else if (type === 'validation') {
        const input = document.getElementById('preflight-validation-input').value;
        const result = parseValidation(input);
        preflightEvidence.validation = { raw: input, ...result };
        renderPreflightResult('preflight-validation-result', preflightEvidence.validation);
      } else if (type === 'conflict') {
        const input = document.getElementById('preflight-conflict-input').value;
        const result = parseConflict(input);
        preflightEvidence.conflict = { raw: input, ...result };
        renderPreflightResult('preflight-conflict-result', preflightEvidence.conflict);
      } else if (type === 'smoke-baseline') {
        const input = document.getElementById('preflight-smoke-baseline-input').value;
        const result = parseSmoke(input);
        preflightEvidence.smokeBaseline = { raw: input, ...result };
        updateSmokeResult();
      } else if (type === 'smoke-edge') {
        const input = document.getElementById('preflight-smoke-edge-input').value;
        const result = parseSmoke(input);
        preflightEvidence.smokeEdge = { raw: input, ...result };
        updateSmokeResult();
      }
      renderPreflightChecklist();
      savePreflightEvidence();
    }

    function updateSmokeResult() {
      const container = document.getElementById('preflight-smoke-result');
      const baseline = preflightEvidence.smokeBaseline;
      const edge = preflightEvidence.smokeEdge;
      const sha = document.getElementById('preflight-sha256').value;
      preflightEvidence.sha256 = sha;
      if (baseline.status === 'pending' && edge.status === 'pending') {
        container.style.display = 'none';
        return;
      }
      container.style.display = 'block';
      const overallStatus = (baseline.status === 'fail' || edge.status === 'fail') ? 'fail' :
        (baseline.status === 'pass' && (edge.status === 'pass' || edge.status === 'pending')) ? 'pass' : 'warn';
      container.className = `preflight-result ${overallStatus}`;
      let html = '';
      html += `<div class="preflight-result-row"><span class="preflight-result-key">Baseline:</span><span class="preflight-result-val">${baseline.parsed?.pass === true ? 'PASS' : baseline.parsed?.pass === false ? 'FAIL' : baseline.status}</span></div>`;
      if (edge.status !== 'pending') {
        html += `<div class="preflight-result-row"><span class="preflight-result-key">Edge:</span><span class="preflight-result-val">${edge.parsed?.pass === true ? 'PASS' : edge.parsed?.pass === false ? 'FAIL' : edge.status}</span></div>`;
      }
      if (sha) {
        html += `<div class="preflight-result-row"><span class="preflight-result-key">SHA256:</span><span class="preflight-result-val" style="word-break:break-all;">${sha}</span></div>`;
      }
      container.innerHTML = html;
    }

    function handlePreflightClear(type) {
      if (type === 'base-version') {
        document.getElementById('preflight-base-version').value = '';
        preflightEvidence.baseVersion = { raw: '', parsed: null, status: 'pending' };
        document.getElementById('preflight-base-result').style.display = 'none';
      } else if (type === 'validation') {
        document.getElementById('preflight-validation-input').value = '';
        preflightEvidence.validation = { raw: '', parsed: null, status: 'pending' };
        document.getElementById('preflight-validation-result').style.display = 'none';
      } else if (type === 'conflict') {
        document.getElementById('preflight-conflict-input').value = '';
        preflightEvidence.conflict = { raw: '', parsed: null, status: 'pending' };
        document.getElementById('preflight-conflict-result').style.display = 'none';
      } else if (type === 'smoke-baseline') {
        document.getElementById('preflight-smoke-baseline-input').value = '';
        preflightEvidence.smokeBaseline = { raw: '', parsed: null, status: 'pending' };
        updateSmokeResult();
      } else if (type === 'smoke-edge') {
        document.getElementById('preflight-smoke-edge-input').value = '';
        preflightEvidence.smokeEdge = { raw: '', parsed: null, status: 'pending' };
        updateSmokeResult();
      }
      renderPreflightChecklist();
      savePreflightEvidence();
    }

    document.getElementById('panel-preflight')?.addEventListener('click', e => {
      const parseBtn = e.target.closest('.preflight-parse-btn');
      if (parseBtn) {
        handlePreflightParse(parseBtn.dataset.parse);
        return;
      }
      const clearBtn = e.target.closest('.preflight-clear-btn');
      if (clearBtn) {
        handlePreflightClear(clearBtn.dataset.clear);
        return;
      }
    });

    document.getElementById('preflight-sha256')?.addEventListener('input', () => {
      preflightEvidence.sha256 = document.getElementById('preflight-sha256').value;
      updateSmokeResult();
      savePreflightEvidence();
    });

    document.getElementById('preflight-reset')?.addEventListener('click', () => {
      preflightEvidence = {
        baseVersion: { raw: '', parsed: null, status: 'pending' },
        validation: { raw: '', parsed: null, status: 'pending' },
        conflict: { raw: '', parsed: null, status: 'pending' },
        smokeBaseline: { raw: '', parsed: null, status: 'pending' },
        smokeEdge: { raw: '', parsed: null, status: 'pending' },
        sha256: ''
      };
      document.getElementById('preflight-base-version').value = '';
      document.getElementById('preflight-validation-input').value = '';
      document.getElementById('preflight-conflict-input').value = '';
      document.getElementById('preflight-smoke-baseline-input').value = '';
      document.getElementById('preflight-smoke-edge-input').value = '';
      document.getElementById('preflight-sha256').value = '';
      document.getElementById('preflight-base-result').style.display = 'none';
      document.getElementById('preflight-validation-result').style.display = 'none';
      document.getElementById('preflight-conflict-result').style.display = 'none';
      document.getElementById('preflight-smoke-result').style.display = 'none';
      renderPreflightChecklist();
      savePreflightEvidence();
    });

    function savePreflightEvidence() {
      try {
        localStorage.setItem(PREFLIGHT_STORAGE_KEY, JSON.stringify(preflightEvidence));
      } catch (e) {}
    }

    function restorePreflightEvidence() {
      try {
        const stored = localStorage.getItem(PREFLIGHT_STORAGE_KEY);
        if (!stored) return;
        preflightEvidence = JSON.parse(stored);
        document.getElementById('preflight-base-version').value = preflightEvidence.baseVersion?.raw || '';
        document.getElementById('preflight-validation-input').value = preflightEvidence.validation?.raw || '';
        document.getElementById('preflight-conflict-input').value = preflightEvidence.conflict?.raw || '';
        document.getElementById('preflight-smoke-baseline-input').value = preflightEvidence.smokeBaseline?.raw || '';
        document.getElementById('preflight-smoke-edge-input').value = preflightEvidence.smokeEdge?.raw || '';
        document.getElementById('preflight-sha256').value = preflightEvidence.sha256 || '';
        if (preflightEvidence.baseVersion?.status !== 'pending') renderPreflightResult('preflight-base-result', preflightEvidence.baseVersion);
        if (preflightEvidence.validation?.status !== 'pending') renderPreflightResult('preflight-validation-result', preflightEvidence.validation);
        if (preflightEvidence.conflict?.status !== 'pending') renderPreflightResult('preflight-conflict-result', preflightEvidence.conflict);
        if (preflightEvidence.smokeBaseline?.status !== 'pending' || preflightEvidence.smokeEdge?.status !== 'pending') updateSmokeResult();
      } catch (e) {}
    }

    function savePatchDraft() {
      try {
        const toSave = { ...patchDraft, changes: patchDraft.changes.map(c => ({ _key: c._key, _source: c._source, record: c.record })) };
        localStorage.setItem(PATCH_STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {}
    }

    function restorePatchDraft() {
      try {
        const stored = localStorage.getItem(PATCH_STORAGE_KEY);
        if (!stored) return;
        const data = JSON.parse(stored);
        patchDraft.baseVersion = data.baseVersion || '0.1.0';
        patchDraft.author = data.author || '';
        patchDraft.rationale = data.rationale || '';
        patchDraft.changes = data.changes || [];
        document.getElementById('patch-base-version').value = patchDraft.baseVersion;
        document.getElementById('patch-author').value = patchDraft.author;
        document.getElementById('patch-rationale').value = patchDraft.rationale;
        renderPatchChanges();
      } catch (e) {}
    }

    function generatePRSummaryWithEvidence() {
      const identity = currentSelection.joinIdentity;
      const contract = currentSelection.contractIdx !== null 
        ? allData.contractResults[currentSelection.contractIdx] : null;
      const issues = identity ? sortBySeverityFirst(getRelatedRecords(identity, allData.issues), ['sheet', 'field', 'issue_type']) : [];
      const actions = identity ? sortBySeverityFirst(getRelatedRecords(identity, allData.fieldActions), ['sheet', 'field', 'action']) : [];
      const primary = identity ? getPrimaryKey(identity) : null;
      const primaryVal = identity?.[primary] || 'unknown';

      const ev = preflightEvidence;
      const baseVer = ev.baseVersion.parsed?.version || document.getElementById('patch-base-version').value || 'unknown';
      const patchBaseVer = ev.validation.parsed?.patchBaseVersion || document.getElementById('patch-base-version').value || 'unknown';
      const smokeBaselineStatus = ev.smokeBaseline.parsed?.pass === true ? 'PASS' : ev.smokeBaseline.parsed?.pass === false ? 'FAIL' : 'unknown';
      const smokeEdgeStatus = ev.smokeEdge.parsed?.pass === true ? 'PASS' : ev.smokeEdge.parsed?.pass === false ? 'FAIL' : ev.smokeEdge.status === 'pending' ? 'N/A' : 'unknown';
      const sha256 = ev.sha256 || '<SHA256_HASH>';

      let md = `# PR: Fix issues for ${primary || 'unknown'}=${primaryVal}\n\n`;
      md += `## WHY\n`;
      if (identity) {
        md += `This record has ${issues.length} issue(s) and ${actions.length} pending action(s) that need resolution.\n\n`;
      } else {
        md += `Patch draft with ${patchDraft.changes.length} change(s).\n\n`;
      }
      md += `## Affected Artifacts\n`;
      if (identity) {
        md += `- **Join Identity**: ${formatJoinIdentityText(identity)}\n`;
        md += `- **Contract Status**: ${contract?.sf_contract_status || 'unknown'}\n`;
        md += `- **Detected Subtype**: ${contract?.detected_subtype || 'unknown'}\n`;
        if (issues.length > 0) {
          md += `- **Issues**: ${issues.map(i => i.issue_type).join(', ')}\n`;
        }
      }
      md += `\n## Evidence\n`;
      md += `- **base.version**: ${baseVer}\n`;
      md += `- **patch.base_version**: ${patchBaseVer}\n`;
      md += `- **Smoke Baseline**: ${smokeBaselineStatus}\n`;
      md += `- **Smoke Edge**: ${smokeEdgeStatus}\n`;
      md += `- **SHA256**: ${sha256}\n`;
      return md;
    }

    document.getElementById('stream-panel-toggle')?.addEventListener('click', () => {
      const body = document.getElementById('stream-panel-body');
      const btn = document.getElementById('stream-panel-toggle');
      if (body && btn) {
        body.classList.toggle('active');
        btn.textContent = body.classList.contains('active') ? 'Hide' : 'Show';
        if (body.classList.contains('active')) {
          renderRecordStateSummary();
          renderSessionTimeline();
        }
      }
    });

    function deriveRecordState(record) {
      const joinKey = getJoinKey(record);
      const recordIssues = allData.issues.filter(i => getJoinKey(i) === joinKey);
      
      const hasBlocking = recordIssues.some(i => i.severity === 'blocking');
      const hasWarning = recordIssues.some(i => i.severity === 'warning');
      const hasInfo = recordIssues.some(i => i.severity === 'info');
      const hasMissingData = recordIssues.some(i => 
        i.issue_type === 'missing_data' || 
        i.issue_type === 'join_failure' ||
        i.issue_type === 'missing_required'
      );
      
      if (hasBlocking) return 'BLOCKED';
      if (hasMissingData && hasWarning) return 'WAITING';
      if (hasWarning) return 'PARTIAL';
      return 'CONSOLIDATED';
    }

    function computeRecordStates() {
      const states = { CONSOLIDATED: 0, PARTIAL: 0, WAITING: 0, BLOCKED: 0 };
      allData.contractResults.forEach(record => {
        const state = deriveRecordState(record);
        states[state]++;
      });
      return states;
    }

    function renderRecordStateSummary() {
      const container = document.getElementById('record-state-summary');
      const states = computeRecordStates();
      
      container.innerHTML = `
        <div class="record-state-card consolidated">
          <div class="count">${states.CONSOLIDATED}</div>
          <div class="label">Consolidated</div>
        </div>
        <div class="record-state-card partial">
          <div class="count">${states.PARTIAL}</div>
          <div class="label">Partial</div>
        </div>
        <div class="record-state-card waiting">
          <div class="count">${states.WAITING}</div>
          <div class="label">Waiting</div>
        </div>
        <div class="record-state-card blocked">
          <div class="count">${states.BLOCKED}</div>
          <div class="label">Blocked</div>
        </div>
      `;
    }

    function simulateSessions() {
      const total = allData.contractResults.length;
      if (total === 0) return [];
      
      const sessionCount = Math.min(3, Math.ceil(total / 2));
      const sessions = [];
      
      for (let i = 0; i < sessionCount; i++) {
        const isLast = i === sessionCount - 1;
        const consolidatedPct = 0.3 + (i * 0.25);
        const partialPct = 0.3 - (i * 0.1);
        const waitingPct = 0.2 - (i * 0.08);
        const blockedPct = 1 - consolidatedPct - partialPct - waitingPct;
        
        const sessionRecords = Math.ceil(total / sessionCount);
        
        sessions.push({
          index: i + 1,
          name: `Session ${i + 1}`,
          timestamp: `T+${i * 30}min`,
          records: sessionRecords,
          states: {
            CONSOLIDATED: Math.round(sessionRecords * consolidatedPct),
            PARTIAL: Math.round(sessionRecords * partialPct),
            WAITING: Math.round(sessionRecords * waitingPct),
            BLOCKED: Math.max(0, sessionRecords - Math.round(sessionRecords * consolidatedPct) - Math.round(sessionRecords * partialPct) - Math.round(sessionRecords * waitingPct))
          },
          reconsolidated: i > 0 ? Math.round(sessionRecords * 0.1) : 0
        });
      }
      
      return sessions;
    }

    function renderSessionTimeline() {
      const container = document.getElementById('session-timeline');
      const sessions = simulateSessions();
      
      if (sessions.length === 0) {
        container.innerHTML = '<div class="stream-concept"><p>No data loaded. Load an artifact to see simulated sessions.</p></div>';
        return;
      }
      
      container.innerHTML = sessions.map(s => `
        <div class="session-card">
          <div class="session-card-header">
            <span class="session-card-title">${s.name}</span>
            <span class="session-card-idx">${s.timestamp}</span>
          </div>
          <div class="session-card-stats">
            <div><span>Records:</span><span>${s.records}</span></div>
            <div><span class="state-chip consolidated">CONS</span><span>${s.states.CONSOLIDATED}</span></div>
            <div><span class="state-chip partial">PART</span><span>${s.states.PARTIAL}</span></div>
            <div><span class="state-chip waiting">WAIT</span><span>${s.states.WAITING}</span></div>
            <div><span class="state-chip blocked">BLCK</span><span>${s.states.BLOCKED}</span></div>
            ${s.reconsolidated > 0 ? `<div style="color: #2e7d32; font-weight: 500;"><span>Reconsolidated:</span><span>+${s.reconsolidated}</span></div>` : ''}
          </div>
        </div>
      `).join('');
    }

    function generateStreamSemanticsMarkdown() {
      const states = computeRecordStates();
      const sessions = simulateSessions();
      const total = Object.values(states).reduce((a, b) => a + b, 0);
      
      let md = `# Stream Semantics Model\n\n`;
      md += `## Overview\n\n`;
      md += `This document describes the conceptual streaming model for continuous data processing.\n\n`;
      
      md += `## Never-Stop Flow (Open Faucet Model)\n\n`;
      md += `Records flow continuously through the pipeline:\n`;
      md += `- **CONSOLIDATED** records pass through immediately\n`;
      md += `- **PARTIAL** records are usable but flagged for completion\n`;
      md += `- **WAITING** records are held until missing data arrives\n`;
      md += `- **BLOCKED** records require manual intervention\n\n`;
      md += `This prevents backlogs by isolating issues rather than stopping the entire pipeline.\n\n`;
      
      md += `## Current State Distribution\n\n`;
      md += `| State | Count | Percentage |\n`;
      md += `|-------|-------|------------|\n`;
      md += `| CONSOLIDATED | ${states.CONSOLIDATED} | ${total > 0 ? Math.round(states.CONSOLIDATED / total * 100) : 0}% |\n`;
      md += `| PARTIAL | ${states.PARTIAL} | ${total > 0 ? Math.round(states.PARTIAL / total * 100) : 0}% |\n`;
      md += `| WAITING | ${states.WAITING} | ${total > 0 ? Math.round(states.WAITING / total * 100) : 0}% |\n`;
      md += `| BLOCKED | ${states.BLOCKED} | ${total > 0 ? Math.round(states.BLOCKED / total * 100) : 0}% |\n`;
      md += `| **Total** | ${total} | 100% |\n\n`;
      
      md += `## Reconsolidation Rules\n\n`;
      md += `| From State | Condition | To State |\n`;
      md += `|------------|-----------|----------|\n`;
      md += `| PARTIAL | Warnings resolved | CONSOLIDATED |\n`;
      md += `| WAITING | Missing data arrives | PARTIAL or CONSOLIDATED |\n`;
      md += `| BLOCKED | Manual fix + re-submit | CONSOLIDATED |\n`;
      md += `| CONSOLIDATED | New blocking issue | BLOCKED |\n\n`;
      
      if (sessions.length > 0) {
        md += `## Simulated Session Timeline\n\n`;
        md += `| Session | Timestamp | Records | Consolidated | Partial | Waiting | Blocked | Reconsolidated |\n`;
        md += `|---------|-----------|---------|--------------|---------|---------|---------|----------------|\n`;
        sessions.forEach(s => {
          md += `| ${s.name} | ${s.timestamp} | ${s.records} | ${s.states.CONSOLIDATED} | ${s.states.PARTIAL} | ${s.states.WAITING} | ${s.states.BLOCKED} | ${s.reconsolidated > 0 ? '+' + s.reconsolidated : '-'} |\n`;
        });
        md += `\n`;
      }
      
      md += `## Key Benefits\n\n`;
      md += `1. **No Backlogs**: Problems don't stop the entire pipeline\n`;
      md += `2. **Async Resolution**: Issues are resolved in parallel\n`;
      md += `3. **Deterministic States**: State transitions are rule-based and auditable\n`;
      md += `4. **Visibility**: Operators can see exactly where records are in the flow\n`;
      
      return md;
    }

    document.getElementById('copy-stream-semantics')?.addEventListener('click', async () => {
      const md = generateStreamSemanticsMarkdown();
      const success = await copyToClipboard(md);
      const btn = document.getElementById('copy-stream-semantics');
      if (btn) {
        const orig = btn.textContent;
        btn.textContent = success ? 'Copied!' : 'Failed';
        setTimeout(() => btn.textContent = orig, 1500);
      }
    });

    document.getElementById('simulate-sessions')?.addEventListener('click', () => {
      renderRecordStateSummary();
      renderSessionTimeline();
    });

    document.getElementById('config-inspector-toggle')?.addEventListener('click', () => {
      const body = document.getElementById('config-inspector-body');
      const btn = document.getElementById('config-inspector-toggle');
      if (body && btn) {
        body.classList.toggle('active');
        btn.textContent = body.classList.contains('active') ? 'Hide' : 'Show';
      }
    });

    async function loadConfigFile(path) {
      const relativePath = path.startsWith('../../') ? path : `../../${path}`;
      const resp = await fetch(relativePath);
      if (!resp.ok) throw new Error(`Failed to load ${path}`);
      return await resp.json();
    }

    function sortChangesArray(changes) {
      const sevOrder = { blocking: 0, warning: 1, info: 2 };
      return [...changes].sort((a, b) => {
        const targetCmp = (a.target || '').localeCompare(b.target || '');
        if (targetCmp !== 0) return targetCmp;
        const actionCmp = (a.action || '').localeCompare(b.action || '');
        if (actionCmp !== 0) return actionCmp;
        const ruleIdA = a.rule?.rule_id || a.rule_id || null;
        const ruleIdB = b.rule?.rule_id || b.rule_id || null;
        if (ruleIdA === null && ruleIdB !== null) return 1;
        if (ruleIdA !== null && ruleIdB === null) return -1;
        if (ruleIdA !== null && ruleIdB !== null) {
          const ruleIdCmp = ruleIdA.localeCompare(ruleIdB);
          if (ruleIdCmp !== 0) return ruleIdCmp;
        }
        const whenSheetA = a.rule?.when?.sheet || '';
        const whenSheetB = b.rule?.when?.sheet || '';
        const whenSheetCmp = whenSheetA.localeCompare(whenSheetB);
        if (whenSheetCmp !== 0) return whenSheetCmp;
        const whenFieldA = a.rule?.when?.field || '';
        const whenFieldB = b.rule?.when?.field || '';
        const whenFieldCmp = whenFieldA.localeCompare(whenFieldB);
        if (whenFieldCmp !== 0) return whenFieldCmp;
        const thenArrA = a.rule?.then || [];
        const thenArrB = b.rule?.then || [];
        const minLen = Math.min(thenArrA.length, thenArrB.length);
        for (let i = 0; i < minLen; i++) {
          const thenA = thenArrA[i] || {};
          const thenB = thenArrB[i] || {};
          const sevA = sevOrder[thenA.severity] ?? 3;
          const sevB = sevOrder[thenB.severity] ?? 3;
          if (sevA !== sevB) return sevA - sevB;
          const thenSheetCmp = (thenA.sheet || '').localeCompare(thenB.sheet || '');
          if (thenSheetCmp !== 0) return thenSheetCmp;
          const thenFieldCmp = (thenA.field || '').localeCompare(thenB.field || '');
          if (thenFieldCmp !== 0) return thenFieldCmp;
        }
        return thenArrA.length - thenArrB.length;
      });
    }

    function computeRulesetDelta(baseConfig, patch) {
      const delta = {
        salesforce_rules: { added: 0, deprecated: 0 },
        qa_rules: { added: 0, deprecated: 0 },
        resolver_rules: { added: 0, deprecated: 0 }
      };
      
      (patch.changes || []).forEach(change => {
        const target = change.target;
        if (!delta[target]) return;
        if (change.action === 'add_rule') delta[target].added++;
        if (change.action === 'deprecate_rule') delta[target].deprecated++;
      });
      
      return delta;
    }

    function renderPatchSummary(baseConfig, patch) {
      const container = document.getElementById('patch-summary');
      const baseVersion = baseConfig.version || '(unknown)';
      const patchBaseVersion = patch.base_version || '(unknown)';
      configVersionMatch = baseVersion === patchBaseVersion;
      const chipClass = configVersionMatch ? 'match' : 'mismatch';
      const chipText = configVersionMatch ? 'MATCH' : 'MISMATCH';
      
      container.innerHTML = `
        <div class="patch-summary-header">
          <h4>Patch Summary</h4>
          <span class="version-chip ${chipClass}">${chipText}</span>
        </div>
        <div class="patch-summary-grid">
          <div class="patch-summary-item">
            <label>base.version</label>
            <div class="value">${baseVersion}</div>
          </div>
          <div class="patch-summary-item">
            <label>patch.base_version</label>
            <div class="value">${patchBaseVersion}</div>
          </div>
          <div class="patch-summary-item">
            <label>Author</label>
            <div class="value">${patch.author || '(not set)'}</div>
          </div>
          <div class="patch-summary-item">
            <label>Rationale</label>
            <div class="value">${patch.rationale || '(not set)'}</div>
          </div>
          <div class="patch-summary-item">
            <label>Changes Count</label>
            <div class="value">${(patch.changes || []).length}</div>
          </div>
        </div>
      `;
      
      updatePreflightFromLoadedConfig(baseVersion, patchBaseVersion, configVersionMatch);
    }

    function updatePreflightFromLoadedConfig(baseVersion, patchBaseVersion, isMatch) {
      preflightEvidence.baseVersion.raw = `base.version: ${baseVersion}, patch.base_version: ${patchBaseVersion}`;
      preflightEvidence.baseVersion.parsed = {
        version: baseVersion,
        patchBaseVersion: patchBaseVersion,
        match: isMatch
      };
      preflightEvidence.baseVersion.status = isMatch ? 'pass' : 'fail';
      
      preflightEvidence.validation.parsed = preflightEvidence.validation.parsed || {};
      preflightEvidence.validation.parsed.baseVersion = baseVersion;
      preflightEvidence.validation.parsed.patchBaseVersion = patchBaseVersion;
      
      savePreflightEvidence();
    }

    function renderRulesetDelta(delta) {
      const container = document.getElementById('ruleset-delta');
      const targets = ['salesforce_rules', 'qa_rules', 'resolver_rules'];
      
      let cardsHtml = '';
      targets.forEach(t => {
        const d = delta[t] || { added: 0, deprecated: 0 };
        cardsHtml += `
          <div class="ruleset-count-card">
            <div class="count added">+${d.added}</div>
            <div class="label">${t.replace('_rules', '')} Added</div>
          </div>
          <div class="ruleset-count-card">
            <div class="count deprecated">-${d.deprecated}</div>
            <div class="label">${t.replace('_rules', '')} Deprecated</div>
          </div>
        `;
      });
      
      container.innerHTML = `
        <h4>Ruleset Delta</h4>
        <div class="ruleset-delta-counts">${cardsHtml}</div>
      `;
    }

    function renderChangesTable(changes) {
      const container = document.getElementById('changes-table');
      const sorted = sortChangesArray(changes);
      
      let rowsHtml = sorted.map(change => {
        const action = change.action || '';
        const target = change.target || '';
        const ruleId = change.rule?.rule_id || change.rule_id || '';
        const when = change.rule?.when || {};
        const whenStr = when.sheet && when.field ? `${when.sheet}.${when.field} ${when.operator || ''} ${JSON.stringify(when.value || '')}` : (change.reason || '');
        const then = change.rule?.then || [];
        const thenStr = then.map(t => `${t.action || ''} ${t.sheet || ''}.${t.field || ''}`).join('; ') || '';
        const severity = then[0]?.severity || '';
        
        return `
          <tr>
            <td><span class="action-chip ${action}">${action}</span></td>
            <td>${target}</td>
            <td>${ruleId || '<span class="null-value">null</span>'}</td>
            <td style="font-size: 0.8em; font-family: monospace;">${whenStr}</td>
            <td style="font-size: 0.8em; font-family: monospace;">${thenStr}</td>
            <td><span class="severity-${severity}">${severity}</span></td>
          </tr>
        `;
      }).join('');
      
      container.innerHTML = `
        <thead><tr>
          <th>Action</th>
          <th>Target</th>
          <th>Rule ID</th>
          <th>When</th>
          <th>Then</th>
          <th>Severity</th>
        </tr></thead>
        <tbody>${rowsHtml}</tbody>
      `;
    }

    function generateRulesetDeltaMarkdown() {
      if (!loadedBaseConfig || !loadedPatch) return '# No config loaded\n';
      
      const baseVersion = loadedBaseConfig.version || '(unknown)';
      const patchBaseVersion = loadedPatch.base_version || '(unknown)';
      const delta = computeRulesetDelta(loadedBaseConfig, loadedPatch);
      const sorted = sortChangesArray(loadedPatch.changes || []);
      
      let md = `# Ruleset Delta\n\n`;
      md += `## Summary\n\n`;
      md += `| Field | Value |\n`;
      md += `|-------|-------|\n`;
      md += `| base.version | ${baseVersion} |\n`;
      md += `| patch.base_version | ${patchBaseVersion} |\n`;
      md += `| Version Match | ${configVersionMatch ? 'YES' : 'NO'} |\n`;
      md += `| Author | ${loadedPatch.author || '(not set)'} |\n`;
      md += `| Changes Count | ${(loadedPatch.changes || []).length} |\n`;
      md += `\n## Rule Counts by Target\n\n`;
      md += `| Target | Added | Deprecated |\n`;
      md += `|--------|-------|------------|\n`;
      ['salesforce_rules', 'qa_rules', 'resolver_rules'].forEach(t => {
        const d = delta[t] || { added: 0, deprecated: 0 };
        md += `| ${t} | +${d.added} | -${d.deprecated} |\n`;
      });
      md += `\n## Changes Detail\n\n`;
      md += `| Action | Target | Rule ID | Severity |\n`;
      md += `|--------|--------|---------|----------|\n`;
      sorted.forEach(change => {
        const action = change.action || '';
        const target = change.target || '';
        const ruleId = change.rule?.rule_id || change.rule_id || '(null)';
        const severity = change.rule?.then?.[0]?.severity || '';
        md += `| ${action} | ${target} | ${ruleId} | ${severity} |\n`;
      });
      md += `\n## Rationale\n\n${loadedPatch.rationale || '(not set)'}\n`;
      
      return md;
    }

    async function loadConfigWithPatch() {
      const basePath = document.getElementById('base-config-path').value.trim();
      const patchPath = document.getElementById('patch-path').value.trim();
      const statusEl = document.getElementById('config-status');
      const resultsEl = document.getElementById('config-results');
      
      if (!basePath) {
        statusEl.style.display = 'block';
        statusEl.className = 'config-inspector-status error';
        statusEl.textContent = 'Base config path is required.';
        return;
      }
      
      try {
        statusEl.style.display = 'block';
        statusEl.className = 'config-inspector-status info';
        statusEl.textContent = 'Loading base config...';
        
        loadedBaseConfig = await loadConfigFile(basePath);
        
        if (patchPath) {
          statusEl.textContent = 'Loading patch...';
          loadedPatch = await loadConfigFile(patchPath);
        } else {
          loadedPatch = { base_version: loadedBaseConfig.version, changes: [], author: '', rationale: '' };
        }
        
        renderPatchSummary(loadedBaseConfig, loadedPatch);
        const delta = computeRulesetDelta(loadedBaseConfig, loadedPatch);
        renderRulesetDelta(delta);
        renderChangesTable(loadedPatch.changes || []);
        
        resultsEl.style.display = 'block';
        statusEl.className = 'config-inspector-status success';
        statusEl.textContent = `Loaded: ${basePath} + ${patchPath || '(no patch)'}`;
        
      } catch (e) {
        statusEl.className = 'config-inspector-status error';
        statusEl.textContent = `Error: ${e.message}`;
        resultsEl.style.display = 'none';
      }
    }

    document.getElementById('load-config')?.addEventListener('click', loadConfigWithPatch);
    
    document.getElementById('clear-config')?.addEventListener('click', () => {
      loadedBaseConfig = null;
      loadedPatch = null;
      configVersionMatch = null;
      document.getElementById('config-results').style.display = 'none';
      document.getElementById('config-status').style.display = 'none';
    });

    document.getElementById('copy-ruleset-delta')?.addEventListener('click', async () => {
      const md = generateRulesetDeltaMarkdown();
      const success = await copyToClipboard(md);
      const btn = document.getElementById('copy-ruleset-delta');
      const orig = btn.textContent;
      btn.textContent = success ? 'Copied!' : 'Failed';
      setTimeout(() => btn.textContent = orig, 1500);
    });

    document.getElementById('session-loader-toggle')?.addEventListener('click', () => {
      const body = document.getElementById('session-loader-body');
      const btn = document.getElementById('session-loader-toggle');
      body.classList.toggle('active');
      btn.textContent = body.classList.contains('active') ? 'Hide' : 'Show';
    });

    async function loadArtifact(path) {
      const relativePath = path.startsWith('../../') ? path : `../../${path}`;
      const resp = await fetch(relativePath);
      if (!resp.ok) throw new Error(`Failed to load ${path}`);
      return await resp.json();
    }

    async function loadDataWithComparison(primaryPath, comparePath) {
      const statusEl = document.getElementById('session-status');
      const errorContainer = document.getElementById('error-container');
      const sourceInfo = document.getElementById('source-info');
      
      try {
        statusEl.style.display = 'block';
        statusEl.className = 'session-loader-status info';
        statusEl.textContent = 'Loading primary artifact...';
        
        const primaryData = await loadArtifact(primaryPath);
        
        renderSummary(primaryData.sf_summary || {});
        allData.contractResults = sortByJoinTriplet(primaryData.sf_contract_results || []);
        // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
        allData.issues = filterOutReferenceData(sortBySeverityFirst(primaryData.sf_issues || [], ['sheet', 'field', 'issue_type']));
        allData.fieldActions = filterOutReferenceData(sortBySeverityFirst(primaryData.sf_field_actions || [], ['sheet', 'field', 'action']));
        allData.changeLog = sortBySeverityFirst(primaryData.sf_change_log || [], ['sheet', 'field', 'notes']);
        
        sourceInfo.textContent = `Primary: ${primaryPath}`;
        
        if (comparePath && comparePath.trim()) {
          statusEl.textContent = 'Loading comparison artifact...';
          try {
            compareData = await loadArtifact(comparePath);
            
            const compareContractResults = sortByJoinTriplet(compareData.sf_contract_results || []);
            const compareIssues = sortBySeverityFirst(compareData.sf_issues || [], ['sheet', 'field', 'issue_type']);
            const compareFieldActions = sortBySeverityFirst(compareData.sf_field_actions || [], ['sheet', 'field', 'action']);
            
            rowChanges.contractResults = computeRowChanges(allData.contractResults, compareContractResults, 'contractResults');
            rowChanges.issues = computeRowChanges(allData.issues, compareIssues, 'issues');
            rowChanges.fieldActions = computeRowChanges(allData.fieldActions, compareFieldActions, 'fieldActions');
            
            deltaStats = computeDeltaStats(primaryData, compareData);
            
            sourceInfo.textContent = `Primary: ${primaryPath} | Compare: ${comparePath}`;
            statusEl.className = 'session-loader-status success';
            statusEl.textContent = `Loaded with comparison. Found ${Object.keys(rowChanges.issues).length + Object.keys(rowChanges.fieldActions).length} row-level changes.`;
          } catch (e) {
            statusEl.className = 'session-loader-status error';
            statusEl.textContent = `Comparison file not found: ${comparePath}. Showing primary only.`;
            compareData = null;
            rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
            deltaStats = null;
          }
        } else {
          compareData = null;
          rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
          deltaStats = null;
          statusEl.className = 'session-loader-status success';
          statusEl.textContent = 'Loaded primary artifact (no comparison).';
        }
        
        populateSubtypeDropdown();
        renderDeltaSummary();
        renderAllTables();
        restoreSelection();
        
        errorContainer.innerHTML = '';
      } catch (e) {
        statusEl.className = 'session-loader-status error';
        statusEl.textContent = `Error: ${e.message}`;
        errorContainer.innerHTML = `<div class="error">Could not load artifact: ${e.message}</div>`;
      }
    }

    document.getElementById('load-session')?.addEventListener('click', () => {
      const primaryPath = document.getElementById('primary-path').value.trim() || 'out/sf_packet.preview.json';
      const comparePath = document.getElementById('compare-path').value.trim();
      loadDataWithComparison(primaryPath, comparePath);
    });

    document.getElementById('clear-compare')?.addEventListener('click', () => {
      document.getElementById('compare-path').value = '';
      compareData = null;
      rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
      deltaStats = null;
      renderDeltaSummary();
      renderAllTables();
      document.getElementById('session-status').style.display = 'none';
      document.getElementById('source-info').textContent = `Data source: ${document.getElementById('primary-path').value || 'out/sf_packet.preview.json'}`;
    });

    // ========== DATASET BUNDLE (V1.2.6) ==========
    // DatasetBundleDraft: internal model for multi-sheet dataset with computed field_index
    // TODO: Align exact schema keys once Kiwi returns
    
    function createDatasetBundle(dataset, source) {
      var sheets = dataset.sheets || {};
      var sheetNames = Object.keys(sheets);
      
      var bundle = {
        dataset_id: dataset.dataset_id || ('ds_' + Date.now()),
        dataset_revision: 1,
        created_at_utc: new Date().toISOString(),
        source: {
          dataset_type: source?.type || 'unknown',
          source_file_name: source?.filename || 'unknown'
        },
        sheet_packets: sheetNames.map(function(name) {
          var sheet = sheets[name];
          return {
            packet_version: 'DatasetPacketV1',
            sheet_name: name,
            header_map: (sheet.headers || []).reduce(function(acc, h, i) { acc[h] = i; return acc; }, {}),
            rows: sheet.rows || []
          };
        }),
        field_index: [],
        audit_log: [
          { event: 'bundle_created', timestamp: new Date().toISOString(), source: source?.type || 'unknown' }
        ]
      };
      
      // Compute field_index from sheet_packets
      bundle.field_index = computeFieldIndex(bundle.sheet_packets);
      
      return bundle;
    }
    
    function computeFieldIndex(sheetPackets) {
      var index = [];
      (sheetPackets || []).forEach(function(packet) {
        var headers = Object.keys(packet.header_map || {});
        headers.forEach(function(field) {
          index.push({
            sheet: packet.sheet_name,
            field: field,
            full_path: packet.sheet_name + '.' + field
          });
        });
      });
      return index;
    }
    
    function getCurrentBundle() {
      if (!dataLoaded || !allData) return null;
      
      var source = { type: 'loaded', filename: currentArtifactPath || 'unknown' };
      var dataset = {
        dataset_id: localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET) || 'current',
        sheets: allData.sheets || {}
      };
      
      return createDatasetBundle(dataset, source);
    }
    
    function copyBundleJSON() {
      var bundle = getCurrentBundle();
      if (!bundle) {
        showToast('No dataset loaded', 'error');
        return;
      }
      
      var json = JSON.stringify(bundle, null, 2);
      navigator.clipboard.writeText(json).then(function() {
        showToast('Bundle JSON copied to clipboard', 'success');
      }).catch(function(err) {
        console.error('Failed to copy:', err);
        showToast('Failed to copy to clipboard', 'error');
      });
    }
    
    // ========== PACKAGER (V1.2.6) ==========
    // Consumes DatasetBundle and generates stable record_id index
    
    function generateRecordId(datasetId, sheetName, rowNumber, stableColumns) {
      // Generate stable record_id: dataset_id + sheet_name + row_number + optional stable columns
      var base = datasetId + '|' + sheetName + '|' + rowNumber;
      if (stableColumns && stableColumns.contract_key) {
        base += '|' + stableColumns.contract_key;
      }
      return base;
    }
    
    function packageBundle(bundle) {
      if (!bundle || !bundle.sheet_packets) return null;
      
      var recordIndex = [];
      var queueRecords = { todo: [], needs_review: [] };
      
      bundle.sheet_packets.forEach(function(packet) {
        (packet.rows || []).forEach(function(row, idx) {
          var recordId = generateRecordId(
            bundle.dataset_id,
            packet.sheet_name,
            idx,
            { contract_key: row.contract_key }
          );
          
          var record = {
            record_id: recordId,
            dataset_id: bundle.dataset_id,
            sheet_name: packet.sheet_name,
            row_number: idx,
            contract_key: row.contract_key || '',
            file_url: row.file_url || '',
            file_name: row.file_name || '',
            status: 'needs_review',
            data: row
          };
          
          recordIndex.push(record);
          
          // Route to queue: if has issues -> Needs Review, else -> To Do
          if (row._has_issue) {
            queueRecords.needs_review.push(record);
          } else {
            queueRecords.todo.push(record);
          }
        });
      });
      
      return {
        dataset_id: bundle.dataset_id,
        dataset_revision: bundle.dataset_revision,
        record_count: recordIndex.length,
        record_index: recordIndex,
        queue_distribution: {
          todo: queueRecords.todo.length,
          needs_review: queueRecords.needs_review.length
        },
        packaged_at: new Date().toISOString()
      };
    }
    
    function repackageCurrentDataset() {
      var bundle = getCurrentBundle();
      if (!bundle) {
        showToast('No dataset to package', 'error');
        return null;
      }
      
      var packageResult = packageBundle(bundle);
      
      // Update allData.contractResults with stable record_ids
      allData.contractResults = packageResult.record_index.map(function(rec) {
        return {
          record_id: rec.record_id,
          contract_key: rec.contract_key,
          file_url: rec.file_url,
          file_name: rec.file_name,
          status: rec.status,
          sheet_name: rec.sheet_name,
          row_number: rec.row_number
        };
      });
      
      // Re-render tables
      renderAllTables();
      updateQueueCounts();
      
      showToast('Dataset packaged with ' + packageResult.record_count + ' records', 'success');
      return packageResult;
    }
    
    // ========== UPLOAD LIBRARY (V1.2.6) ==========
    function getUploadLibrary() {
      try {
        var stored = localStorage.getItem(STORAGE_KEY_LIBRARY);
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        return [];
      }
    }
    
    function saveUploadLibrary(library) {
      try {
        localStorage.setItem(STORAGE_KEY_LIBRARY, JSON.stringify(library));
      } catch (e) {
        console.error('Failed to save upload library:', e);
      }
    }
    
    function saveToUploadLibrary(dataset, filename, source) {
      var library = getUploadLibrary();
      var existingIndex = library.findIndex(function(d) { return d.dataset_id === dataset.dataset_id; });
      
      var entry = {
        dataset_id: dataset.dataset_id || ('ds_' + Date.now()),
        filename: filename || 'Untitled',
        source: source || 'unknown',
        revision: existingIndex >= 0 ? (library[existingIndex].revision + 1) : 1,
        created_at: new Date().toISOString(),
        sheet_count: Object.keys(dataset.sheets || {}).length,
        row_count: Object.values(dataset.sheets || {}).reduce(function(acc, s) { return acc + (s.rows?.length || 0); }, 0)
      };
      
      if (existingIndex >= 0) {
        library[existingIndex] = entry;
      } else {
        library.unshift(entry);
      }
      
      saveUploadLibrary(library);
      localStorage.setItem(STORAGE_KEY_ACTIVE_DATASET, entry.dataset_id);
      return entry;
    }
    
    // v1.4.24: Render mocked Drive files list (read-only stub)
    function renderUploadLibrary() {
      var listEl = document.getElementById('upload-library-list');
      if (!listEl) return;
      
      // Get folder name to generate contextual mock files
      var folderName = localStorage.getItem('ingestion_folder_name') || 'Analyst';
      var firstName = folderName.split(' ')[0] || 'Analyst';
      
      // Mocked drive files derived from user's folder
      var mockFiles = [
        { name: 'Q4_2025_Contracts_' + firstName + '.xlsx', size: '2.4 MB', modified: 'Jan 28, 2026' },
        { name: 'Vendor_Agreements_' + firstName + '.csv', size: '856 KB', modified: 'Jan 25, 2026' },
        { name: 'License_Review_Batch_12.xlsx', size: '1.1 MB', modified: 'Jan 22, 2026' },
        { name: 'Distribution_Terms_2026.csv', size: '445 KB', modified: 'Jan 18, 2026' }
      ];
      
      var html = mockFiles.map(function(file) {
        var ext = file.name.split('.').pop().toUpperCase();
        var icon = ext === 'XLSX' ? 'ðŸ“Š' : 'ðŸ“„';
        return '<div class="drive-file-item" style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px 15px; opacity: 0.7;">' +
          '<div style="display: flex; align-items: center; gap: 12px;">' +
            '<span style="font-size: 1.3em;">' + icon + '</span>' +
            '<div style="flex: 1; min-width: 0;">' +
              '<div style="font-weight: 500; font-size: 0.9em; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + file.name + '</div>' +
              '<div style="font-size: 0.8em; color: #888;">' + file.size + ' Â· Modified ' + file.modified + '</div>' +
            '</div>' +
            '<span style="font-size: 0.7em; background: #e0e0e0; padding: 2px 6px; border-radius: 3px; color: #666;">Read Only</span>' +
          '</div>' +
        '</div>';
      }).join('');
      
      listEl.innerHTML = html;
    }
    
    function activateDataset(datasetId) {
      try {
        var stored = localStorage.getItem(STORAGE_KEY_DATASET);
        var dataset = stored ? JSON.parse(stored) : null;
        
        if (!dataset || dataset.dataset_id !== datasetId) {
          showToast('Dataset not found in cache. Please reload from Loader.', 'error');
          return;
        }
        
        allData = {
          contractResults: dataset.contract_results || [],
          issues: dataset.issues || [],
          fieldActions: dataset.field_actions || [],
          changeLog: [],
          summary: dataset.summary || {},
          sheets: dataset.sheets || {}
        };
        
        localStorage.setItem(STORAGE_KEY_ACTIVE_DATASET, datasetId);
        dataLoaded = true;
        datasetRevision++; // v1.6.18: Bump revision for cache invalidation
        currentArtifactPath = datasetId;
        updateUIForDataState();
        updateSessionChip();
        populateSubtypeDropdown();
        renderAllTables();
        populateTargetFieldDropdown();
        renderUploadLibrary();
        
        // v1.5.3: Persist all records to canonical store
        persistAllRecordsToStore();
        
        // v1.6.0: Generate signals for dataset
        generateSignalsForDataset();
        
        showToast('Dataset activated: ' + datasetId, 'success');
      } catch (e) {
        console.error('Failed to activate dataset:', e);
        showToast('Failed to activate dataset', 'error');
      }
    }
    
    function duplicateDataset(datasetId) {
      var library = getUploadLibrary();
      var entry = library.find(function(d) { return d.dataset_id === datasetId; });
      if (!entry) return;
      
      var newEntry = Object.assign({}, entry, {
        dataset_id: 'ds_' + Date.now(),
        revision: 1,
        created_at: new Date().toISOString(),
        filename: entry.filename + ' (copy)'
      });
      
      library.unshift(newEntry);
      saveUploadLibrary(library);
      renderUploadLibrary();
      showToast('Duplicated as new dataset', 'success');
    }
    
    function deleteDataset(datasetId) {
      if (!confirm('Delete this dataset from the library?')) return;
      
      var library = getUploadLibrary();
      library = library.filter(function(d) { return d.dataset_id !== datasetId; });
      saveUploadLibrary(library);
      
      var activeId = localStorage.getItem(STORAGE_KEY_ACTIVE_DATASET);
      if (activeId === datasetId) {
        localStorage.removeItem(STORAGE_KEY_ACTIVE_DATASET);
      }
      
      renderUploadLibrary();
      showToast('Dataset deleted', 'success');
    }
    
    // ========== LOADER HANDLERS (v1.4.3) ==========
    // v1.6.8: Load demo dataset (original or modified based on variant parameter)
    var cachedOriginalDataset = null;
    var cachedModifiedDataset = null;
    var activeDatasetVariant = 'original';  // Track which dataset is currently active
    
    // v1.6.8: Update saved datasets UI to show active indicator
    function updateSavedDatasetsUI(activeVariant) {
      var originalCard = document.getElementById('demo-dataset-card-original');
      var modifiedCard = document.getElementById('demo-dataset-card-modified');
      var modifiedBanner = document.getElementById('demo-modified-banner');
      
      if (originalCard && modifiedCard) {
        if (activeVariant === 'modified') {
          // Modified is active
          originalCard.style.background = '#fafafa';
          originalCard.style.border = '1px solid #e0e0e0';
          originalCard.classList.remove('active');
          
          modifiedCard.style.background = '#fff3e0';
          modifiedCard.style.border = '2px solid #ff9800';
          modifiedCard.classList.add('active');
          
          // Show in-progress banner
          if (modifiedBanner) modifiedBanner.style.display = 'block';
        } else {
          // Original is active (default)
          originalCard.style.background = '#e3f2fd';
          originalCard.style.border = '2px solid #1976d2';
          originalCard.classList.add('active');
          
          modifiedCard.style.background = '#fafafa';
          modifiedCard.style.border = '1px solid #e0e0e0';
          modifiedCard.classList.remove('active');
          
          // Hide in-progress banner
          if (modifiedBanner) modifiedBanner.style.display = 'none';
        }
      }
    }
    
    async function loadSampleDataset(options) {
      options = options || {};
      try {
        // Start staged loader
        stagedLoader.start();
        stagedLoader.setStage('loading');
        
        // v1.6.8: Select dataset URL based on explicit variant parameter (default: original)
        var variant = options.variant || 'original';
        var isModified = (variant === 'modified');
        var datasetUrl = isModified ? MODIFIED_DATASET_URL : DEFAULT_DATASET_URL;
        var datasetName = isModified ? 'ostereo_demo_v1.json' : 'ostereo_demo_original.json';
        
        // Update active variant tracker
        activeDatasetVariant = variant;
        
        // Fetch the dataset if not cached
        var cached = isModified ? cachedModifiedDataset : cachedOriginalDataset;
        if (!cached) {
          console.log('[Loader] Fetching demo dataset from:', datasetUrl);
          var resp = await fetch(datasetUrl);
          if (!resp.ok) {
            throw new Error('Failed to fetch demo dataset: ' + resp.status);
          }
          cached = await resp.json();
          if (isModified) {
            cachedModifiedDataset = cached;
          } else {
            cachedOriginalDataset = cached;
          }
          console.log('[Loader] Demo dataset fetched:', cached.dataset_id || datasetName);
        }
        
        // Standardizing fields stage
        stagedLoader.setStage('standardizing');
        
        var dataset = cached;
        
        // Reset workbook and populate from dataset sheets
        resetWorkbook();
        
        if (dataset.sheets) {
          Object.keys(dataset.sheets).forEach(function(sheetName) {
            var sheet = dataset.sheets[sheetName];
            addSheet(sheetName, sheet.headers || [], sheet.rows || [], {});
          });
        }
        
        // Transform dataset to match expected format
        allData = {
          contractResults: dataset.contract_results || [],
          issues: dataset.issues || [],
          fieldActions: dataset.field_actions || [],
          changeLog: [],
          summary: dataset.summary || {},
          sheets: dataset.sheets || {}
        };
        
        // Save to localStorage
        localStorage.setItem(STORAGE_KEY_DATASET, JSON.stringify(dataset));
        
        // Save to upload library
        saveToUploadLibrary(dataset, 'Ostereo Demo Dataset', 'ostereo_demo');
        
        dataLoaded = true;
        currentArtifactPath = datasetName;
        currentDataset = null; // Reset cache
        updateUIForDataState();
        updateSessionChip();
        populateSubtypeDropdown();
        populateGridSheetSelector();
        renderAllTables();
        renderGrid();
        populateTargetFieldDropdown();
        updateLoaderPageUI();
        
        // v1.6.5: Clear old records before persisting new ones to prevent quota issues
        clearOldRecordsFromStore();
        
        // v1.5.3: Persist all records to canonical store for SRR rehydration
        try {
          persistAllRecordsToStore();
        } catch (e) {
          console.warn('[RecordStore] Non-critical: Failed to persist records:', e.message);
          // Non-critical - dataset still loaded successfully in memory
        }
        
        // v1.6.0: Generate signals for dataset
        generateSignalsForDataset();
        
        // v1.6.8 fix: Re-render grid after change map is built for cell highlighting
        renderGrid();
        
        console.log('[Loader] Ostereo demo dataset loaded:', workbook.order.length, 'sheets');
        showToast('Ostereo demo dataset loaded successfully', 'success');
        updateSidebarSheetSelector();
        updateActiveDataSourceBar(datasetName);
        
        // v1.6.8: Update saved datasets UI to show active indicator
        updateSavedDatasetsUI(variant);
        
        // Rendering stage then finish staged loader
        stagedLoader.setStage('rendering');
        stagedLoader.finish();
        
        // Auto-redirect after loading (v1.4.4) - always go to grid after load
        if (options.autoRedirect !== false) {
          setTimeout(function() {
            navigateTo('grid');
          }, 300);
        }
      } catch (e) {
        // Finish loader on error too
        stagedLoader.finish();
        console.error('[Loader] Failed to load default dataset:', e.message || e, e.stack);
        showToast('Failed to load default dataset: ' + (e.message || 'Unknown error'), 'error');
      }
    }
    
    // Handle CSV import with standardization (v1.4.3 INGEST-02: preserve ALL columns)
    function handleCSVImport(file, callback) {
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var csvText = e.target.result;
          var parsed = parseCSV(csvText);
          
          if (!parsed.rows || parsed.rows.length === 0) {
            showToast('No data rows found in CSV', 'error');
            return;
          }
          
          // Sheet name from file (single sheet for CSV)
          var sheetName = file.name.replace(/\.[^.]+$/, '') || 'Sheet1';
          
          // Reset and populate workbook (v1.4.3 INGEST-01)
          resetWorkbook();
          
          // Normalize headers while preserving originals
          var normalizedHeaders = parsed.headers.map(normalizeHeader);
          var headerMap = {};
          parsed.headers.forEach(function(h, i) { headerMap[h] = normalizedHeaders[i]; });
          
          // Detect unknown columns
          var unknownColumns = [];
          normalizedHeaders.forEach(function(nh, i) {
            if (!CANONICAL_HEADERS.includes(nh)) {
              unknownColumns.push({
                original: parsed.headers[i],
                normalized: nh,
                samples: parsed.rows.slice(0, 3).map(function(r) { return r[parsed.headers[i]]; }).filter(Boolean)
              });
            }
          });
          
          // Build rows with ALL columns preserved
          var normalizedRows = parsed.rows.map(function(row, idx) {
            var newRow = { _row_index: idx };
            parsed.headers.forEach(function(original) {
              var normalized = headerMap[original];
              newRow[normalized] = row[original] !== '' ? row[original] : null;
            });
            // Ensure required fields have defaults
            if (!newRow.contract_key) newRow.contract_key = 'ROW_' + (idx + 1);
            if (!newRow.status) newRow.status = 'needs_review';
            return newRow;
          });
          
          // Add sheet to workbook
          addSheet(sheetName, normalizedHeaders, normalizedRows, {
            originalHeaders: parsed.headers,
            headerMap: headerMap,
            unknownColumns: unknownColumns,
            delimiter: parsed.delimiter
          });
          
          // Also populate allData for legacy compatibility
          allData = {
            contractResults: normalizedRows.map(function(r) {
              var row = Object.assign({}, r);
              row.sheet = sheetName;
              return row;
            }),
            issues: [],
            fieldActions: [],
            changeLog: [],
            summary: {
              total_contracts: normalizedRows.length,
              ready: 0,
              needs_review: normalizedRows.length,
              blocked: 0
            }
          };
          
          // Detect unknown columns for Admin UI
          if (unknownColumns.length > 0) {
            var unknownColsStorage = JSON.parse(localStorage.getItem('unknown_columns') || '{}');
            unknownColsStorage[sheetName] = unknownColumns.map(function(uc) {
              return {
                original: uc.original,
                normalized: uc.normalized,
                samples: uc.samples,
                nonEmptyCount: normalizedRows.filter(function(r) { return r[uc.normalized]; }).length
              };
            });
            localStorage.setItem('unknown_columns', JSON.stringify(unknownColsStorage));
          }
          
          // Save to localStorage
          localStorage.setItem(STORAGE_KEY_DATASET, JSON.stringify({
            workbook: workbook,
            allData: allData
          }));
          saveToUploadLibrary({ workbook: workbook }, file.name, 'csv');
          
          dataLoaded = true;
          currentArtifactPath = file.name;
          currentDataset = null; // Reset cache
          updateUIForDataState();
          updateSessionChip();
          populateSubtypeDropdown();
          populateGridSheetSelector();
          renderAllTables();
          renderGrid();
          
          // v1.5.3: Persist all records to canonical store
          persistAllRecordsToStore();
          
          // v1.6.0: Generate signals for dataset
          generateSignalsForDataset();
          
          console.log('[Loader] CSV imported:', sheetName, 'headers:', normalizedHeaders.length, 'rows:', normalizedRows.length, 'unknown:', unknownColumns.length);
          showToast('CSV imported: ' + parsed.rows.length + ' rows, ' + unknownColumns.length + ' unknown columns', 'success');
          
          if (callback) callback();
        } catch (err) {
          console.error('CSV import error:', err);
          showToast('Failed to import CSV: ' + err.message, 'error');
        }
      };
      reader.readAsText(file);
    }
    
    // ========== LOADER PAGE UI (V1.2.7) ==========
    
    function updateLoaderPageUI() {
      var continuePanel = document.getElementById('loader-continue-panel');
      var importPanel = document.getElementById('loader-import-panel');
      var samplePanel = document.getElementById('loader-sample-panel');
      var activeDatasetInfo = document.getElementById('loader-active-dataset-info');
      
      console.log('[LoaderUI] Updating, dataLoaded: ' + dataLoaded);
      
      if (dataLoaded) {
        // Show Continue panel, hide Import/Sample panels
        if (continuePanel) {
          continuePanel.style.display = 'block';
          if (activeDatasetInfo) {
            var contractCount = (allData.contractResults || []).length;
            var sheetCount = Object.keys(allData.sheets || {}).length;
            activeDatasetInfo.innerHTML = '<strong>' + (currentArtifactPath || 'Dataset') + '</strong> | ' + 
              sheetCount + ' sheets, ' + contractCount + ' records';
          }
        }
        if (importPanel) importPanel.style.display = 'none';
        if (samplePanel) samplePanel.style.display = 'none';
      } else {
        // Show Import (primary) + Sample (secondary), hide Continue
        if (continuePanel) continuePanel.style.display = 'none';
        if (importPanel) importPanel.style.display = 'block';
        if (samplePanel) samplePanel.style.display = 'block';
      }
    }
    
    function initLoaderPage() {
      // Toggle collapsible actions
      var toggleBtn = document.getElementById('loader-toggle-actions');
      var actionsContent = document.getElementById('loader-actions-content');
      var toggleIcon = document.getElementById('loader-toggle-icon');
      
      if (toggleBtn) {
        toggleBtn.addEventListener('click', function() {
          var isOpen = actionsContent.style.display !== 'none';
          actionsContent.style.display = isOpen ? 'none' : 'block';
          toggleIcon.innerHTML = isOpen ? '&#9660;' : '&#9650;';
        });
      }
      
      // Continue to Triage button
      var continueBtn = document.getElementById('btn-continue-triage');
      if (continueBtn) {
        continueBtn.addEventListener('click', function() {
          navigateTo('triage');
        });
      }
      
      // Primary Import CSV button
      var importBtnPrimary = document.getElementById('btn-import-csv-primary');
      var fileInputPrimary = document.getElementById('file-import-csv-primary');
      if (importBtnPrimary && fileInputPrimary) {
        importBtnPrimary.addEventListener('click', function() {
          fileInputPrimary.click();
        });
        fileInputPrimary.addEventListener('change', function(e) {
          if (e.target.files && e.target.files[0]) {
            importCSVFile(e.target.files[0]);
          }
        });
      }
      
      // Secondary Sample Dataset button
      var sampleBtn = document.getElementById('btn-load-sample-secondary');
      if (sampleBtn) {
        sampleBtn.addEventListener('click', function() {
          loadSampleDataset({ autoRedirect: true });
        });
      }
    }
    
    function seedSampleDatasetOnFirstRun() {
      // v1.4.24: Clean up sample datasets and auto-map folder from email
      try {
        var library = JSON.parse(localStorage.getItem(STORAGE_KEY_LIBRARY) || '[]');
        var filtered = library.filter(function(e) { 
          return e.dataset_id !== 'ds-sample' && e.source !== 'sample'; 
        });
        if (filtered.length !== library.length) {
          console.log('[FirstRun] Removing demo dataset from library');
          localStorage.setItem(STORAGE_KEY_LIBRARY, JSON.stringify(filtered));
        }
      } catch (e) { console.warn('[FirstRun] Error cleaning demo data:', e); }
      
      // v1.4.24: Clear stale reviewer queue data if no actual data is loaded
      if (!dataLoaded) {
        clearStaleReviewerData();
      }
      
      // v1.4.24: Auto-map folder from demoUser email/folder (no manual selection)
      var mappedFolder = localStorage.getItem('ingestion_folder_name');
      if (!mappedFolder) {
        var folderName = deriveFolderFromUser();
        if (folderName) {
          localStorage.setItem('ingestion_folder_name', folderName);
          localStorage.setItem('ingestion_folder_sync_time', new Date().toISOString());
          console.log('[FirstRun] Auto-mapped folder from user:', folderName);
        } else {
          console.log('[FirstRun] Could not derive folder, using placeholder');
          localStorage.setItem('ingestion_folder_name', 'Assigned Analyst Folder');
          localStorage.setItem('ingestion_folder_sync_time', new Date().toISOString());
        }
        updateDataSourceDrawerState();
        updateActiveDataSourceBar();
      }
    }
    
    // v1.4.24: Clear stale reviewer queue and patch request data
    // v1.6.26: Also clears artifact store to prevent stale queue counts
    function clearStaleReviewerData() {
      console.log('[FirstRun] Clearing stale reviewer queue data');
      
      // Clear verifier queue
      localStorage.removeItem('srr_verifier_queue_v1');
      
      // v1.6.26: Clear artifact store (clears stale art_* files that cause phantom queue counts)
      var artifactCleared = ARTIFACT_STORE.resetPlayground();
      console.log('[FirstRun] Cleared', artifactCleared, 'stale artifacts');
      
      // Clear all patch requests from PATCH_REQUEST_STORE
      var keysToRemove = [];
      var prefix = 'pr:' + ARTIFACT_STORE.environment + ':';
      for (var i = 0; i < localStorage.length; i++) {
        var key = localStorage.key(i);
        if (key && key.startsWith(prefix)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(function(key) {
        localStorage.removeItem(key);
      });
      console.log('[FirstRun] Cleared', keysToRemove.length, 'stale patch requests');
      
      // Reset in-memory verifier queue state
      if (typeof verifierQueueState !== 'undefined') {
        verifierQueueState.payloads = [];
      }
      
      // Reset in-memory reviewer queue state
      if (typeof reviewerQueueState !== 'undefined') {
        reviewerQueueState.items = [];
      }
    }
    
    // v1.4.24: Derive folder name from demoUser stored in localStorage
    function deriveFolderFromUser() {
      try {
        var demoUser = JSON.parse(localStorage.getItem('demoUser') || '{}');
        // If folder is explicitly set in demoUser, use it
        if (demoUser.folder) return demoUser.folder;
        // Otherwise derive from name or email
        if (demoUser.name) return demoUser.name;
        if (demoUser.email) {
          // sarah.chen@company.com â†’ "Sarah Chen"
          var local = demoUser.email.split('@')[0];
          return local.split('.').map(function(p) {
            return p.charAt(0).toUpperCase() + p.slice(1);
          }).join(' ');
        }
        return null;
      } catch (e) { return null; }
    }
    
    function updateLoaderSummary() {
      // Legacy function - now handled by updateLoaderPageUI
      updateLoaderPageUI();
    }
    
    function importCSVFile(file) {
      var reader = new FileReader();
      reader.onload = function(e) {
        try {
          var text = e.target.result;
          var parsed = parseCSV(text);
          var sheetName = file.name.replace(/\.[^/.]+$/, '').toLowerCase().replace(/[^a-z0-9_]/g, '_');
          
          var dataset = {
            dataset_id: 'import_' + Date.now(),
            version: '1.0.0',
            created_at: new Date().toISOString(),
            description: 'Imported from ' + file.name,
            sheets: {},
            issues: [],
            field_actions: [],
            contract_results: [],
            summary: {}
          };
          dataset.sheets[sheetName] = parsed;
          
          // Generate contract_results from rows if contract_key exists
          if (parsed.headers.includes('contract_key')) {
            parsed.rows.forEach(function(row, idx) {
              dataset.contract_results.push({
                contract_key: row.contract_key || '',
                file_url: row.file_url || '',
                file_name: row.file_name || '',
                status: 'needs_review',
                subtype: row.subtype || 'unknown',
                issue_count: 0
              });
            });
          }
          
          allData = {
            contractResults: dataset.contract_results,
            issues: dataset.issues,
            fieldActions: dataset.field_actions,
            changeLog: [],
            summary: dataset.summary,
            sheets: dataset.sheets
          };
          
          localStorage.setItem(STORAGE_KEY_DATASET, JSON.stringify(dataset));
          
          // Save to upload library
          saveToUploadLibrary(dataset, file.name, 'csv');
          
          dataLoaded = true;
          currentArtifactPath = file.name;
          updateUIForDataState();
          updateSessionChip();
          populateSubtypeDropdown();
          renderAllTables();
          populateTargetFieldDropdown();
          updateLoaderPageUI();
          
          // v1.5.3: Persist all records to canonical store
          persistAllRecordsToStore();
          
          // v1.6.0: Generate signals for dataset
          generateSignalsForDataset();
          
          showToast('Imported ' + parsed.rows.length + ' rows from ' + file.name, 'success');
          
          // Auto-redirect after CSV import (v1.2.7) - use intended route if stored
          setTimeout(function() {
            var nextRoute = sessionStorage.getItem('kiwi_next_route') || 'triage';
            sessionStorage.removeItem('kiwi_next_route');
            navigateTo(nextRoute);
          }, 300);
        } catch (err) {
          console.error('CSV import error:', err);
          showToast('Failed to import CSV: ' + err.message, 'error');
        }
      };
      reader.readAsText(file);
    }
    
    function attachPDFFile(file) {
      try {
        var attachments = JSON.parse(localStorage.getItem(STORAGE_KEY_PDF_ATTACHMENTS) || '[]');
        
        var attachment = {
          pdf_artifact_id: 'pdf_' + Date.now(),
          file_name: file.name,
          file_size_bytes: file.size,
          added_at_utc: new Date().toISOString(),
          local_object_url: URL.createObjectURL(file)
        };
        
        attachments.push(attachment);
        localStorage.setItem(STORAGE_KEY_PDF_ATTACHMENTS, JSON.stringify(attachments));
        
        renderPDFAttachmentsList();
        showToast('PDF attached: ' + file.name, 'success');
      } catch (err) {
        console.error('PDF attach error:', err);
        showToast('Failed to attach PDF: ' + err.message, 'error');
      }
    }
    
    function renderPDFAttachmentsList() {
      var listEl = document.getElementById('pdf-attachments-list');
      if (!listEl) return;
      
      var attachments = JSON.parse(localStorage.getItem(STORAGE_KEY_PDF_ATTACHMENTS) || '[]');
      
      if (attachments.length === 0) {
        listEl.innerHTML = '';
        return;
      }
      
      listEl.innerHTML = '<div style="margin-top: 8px;"><strong>Attached:</strong></div>' +
        attachments.map(function(a) {
          return '<div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">' +
            '<span>ðŸ“„ ' + escapeHtml(a.file_name) + '</span>' +
            '<span style="color: #999; font-size: 0.8em;">(' + Math.round(a.file_size_bytes / 1024) + ' KB)</span>' +
            '</div>';
        }).join('');
    }
    
    function resetDemoState() {
      var keysToRemove = [
        STORAGE_KEY_DATASET,
        STORAGE_KEY_PDF_ATTACHMENTS,
        STORAGE_KEY_SESSION,
        STORAGE_KEY_LIBRARY,
        STORAGE_KEY_ACTIVE_DATASET,
        'orchestrate.comments.v1',
        'orchestrate.patch_requests.v1'
      ];
      
      keysToRemove.forEach(function(key) {
        localStorage.removeItem(key);
      });
      
      allData = { contractResults: [], issues: [], fieldActions: [], changeLog: [], summary: {}, sheets: {} };
      dataLoaded = false;
      currentArtifactPath = null;
      
      updateUIForDataState();
      updateSessionChip();
      renderAllTables();
      populateTargetFieldDropdown();
      updateLoaderSummary();
      renderPDFAttachmentsList();
      updatePatchQueueCounts();
      
      // Navigate to loader after reset
      navigateTo('loader');
      showToast('Demo state reset', 'success');
    }
    
    function rebuildFieldIndex() {
      populateTargetFieldDropdown();
      showToast('Field index rebuilt', 'success');
    }
    
    // Loader button event listeners
    document.getElementById('btn-load-sample')?.addEventListener('click', loadSampleDataset);
    document.getElementById('btn-import-csv')?.addEventListener('click', function() {
      document.getElementById('file-import-csv')?.click();
    });
    document.getElementById('file-import-csv')?.addEventListener('change', function(e) {
      var file = e.target.files?.[0];
      if (file) importCSVFile(file);
      e.target.value = '';
    });
    document.getElementById('btn-attach-pdf')?.addEventListener('click', function() {
      document.getElementById('file-attach-pdf')?.click();
    });
    document.getElementById('file-attach-pdf')?.addEventListener('change', function(e) {
      var file = e.target.files?.[0];
      if (file) attachPDFFile(file);
      e.target.value = '';
    });
    document.getElementById('btn-open-spreadsheet')?.addEventListener('click', function() {
      navigateTo('grid');
    });
    document.getElementById('btn-reset-demo-state')?.addEventListener('click', resetDemoState);
    document.getElementById('btn-rebuild-field-index')?.addEventListener('click', rebuildFieldIndex);
    
    // Initialize loader state on page load (v1.2.7)
    seedSampleDatasetOnFirstRun();
    initLoaderPage();
    renderPDFAttachmentsList();
    updateLoaderPageUI();
    
    // v1.4.13: Initialize PDF cache (IndexedDB)
    initPdfCache().then(function() {
      console.log('[PDF_CACHE] Initialized, cached:', cacheState.pdfCount, 'files,', formatCacheSize(cacheState.totalBytes));
    });
    
    // Welcome hero and top toolbar event listeners
    document.getElementById('welcome-load-data')?.addEventListener('click', openDataSourcePanel);
    document.getElementById('btn-data-source')?.addEventListener('click', openDataSourcePanel);
    document.getElementById('btn-configure')?.addEventListener('click', openConfigureWizard);
    document.getElementById('btn-ruleset')?.addEventListener('click', openRulesetModal);
    document.getElementById('btn-compare')?.addEventListener('click', openCompareModal);
    document.getElementById('btn-run')?.addEventListener('click', openRunModal);
    
    // Configure wizard modal events
    document.getElementById('configure-wizard-modal')?.addEventListener('click', e => {
      if (e.target.id === 'configure-wizard-modal') closeConfigureWizard();
    });

    // Data source drawer events
    document.getElementById('data-source-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'data-source-drawer') closeDataSourceDrawer();
    });
    
    // v1.4.23: Folder selection modal events
    document.getElementById('folder-modal-overlay')?.addEventListener('click', e => {
      if (e.target.id === 'folder-modal-overlay') closeFolderSelectionModal();
    });
    document.getElementById('folder-select')?.addEventListener('change', function(e) {
      var confirmBtn = document.getElementById('folder-confirm-btn');
      if (confirmBtn) confirmBtn.disabled = !e.target.value;
    });
    
    // v1.4.23: Initialize folder state on load
    updateActiveDataSourceBar();
    updateLoaderFolderState();
    
    // Record drawer events
    document.getElementById('record-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'record-drawer') closeRecordDrawer();
    });
    
    // Patch detail drawer events
    document.getElementById('patch-detail-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'patch-detail-drawer') closePatchDetailDrawer();
    });
    
    // Config Flows drawer events
    document.getElementById('config-flows-drawer')?.addEventListener('click', e => {
      if (e.target.id === 'config-flows-drawer') closeConfigFlows();
    });
    document.querySelectorAll('#data-source-drawer .wizard-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#data-source-drawer .wizard-preset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('wizard-artifact-path').value = btn.dataset.path;
      });
    });
    document.getElementById('wizard-load-artifact')?.addEventListener('click', async () => {
      const path = document.getElementById('wizard-artifact-path').value.trim();
      if (!path) {
        showWizardStatus('data-source-status', 'Please enter an artifact path', 'error');
        return;
      }
      const relativePath = '../../' + path;
      try {
        const response = await fetch(relativePath);
        if (!response.ok) throw new Error('File not found');
        const data = await response.json();
        if (data.sf_summary || data.sf_contract_results || data.sf_issues || data.sf_field_actions) {
          allData.contractResults = data.sf_contract_results || [];
          // v1.6.20: Filter out reference/glossary sheets from issues and fieldActions
          allData.issues = filterOutReferenceData(data.sf_issues || []);
          allData.fieldActions = filterOutReferenceData(data.sf_field_actions || []);
          allData.summary = data.sf_summary || {};
          allData.changeLog = data.sf_changelog || [];
          dataLoaded = true;
          currentArtifactPath = path;
          updateUIForDataState();
          renderAllTables();
          closeDataSourceDrawer();
          navigateTo('grid');
          showWizardStatus('data-source-status', 'Data loaded successfully!', 'success');
        } else {
          throw new Error('Invalid data format - expected Preview Packet structure');
        }
      } catch (e) {
        showWizardStatus('data-source-status', 'Failed to load: ' + e.message, 'error');
      }
    });

    // Ruleset modal events
    document.getElementById('ruleset-modal')?.addEventListener('click', e => {
      if (e.target.id === 'ruleset-modal') closeRulesetModal();
    });
    document.getElementById('wizard-load-ruleset')?.addEventListener('click', async () => {
      const basePath = document.getElementById('wizard-base-config').value.trim();
      const patchPath = document.getElementById('wizard-patch-config').value.trim();
      if (!basePath) {
        showWizardStatus('ruleset-status', 'Please enter a base config path', 'error');
        return;
      }
      try {
        // Use existing config loading logic
        document.getElementById('base-config-path').value = basePath;
        document.getElementById('patch-path').value = patchPath;
        await loadConfigAndPatch();
        closeRulesetModal();
        showWizardStatus('ruleset-status', 'Ruleset loaded!', 'success');
      } catch (e) {
        showWizardStatus('ruleset-status', 'Failed to load ruleset: ' + e.message, 'error');
      }
    });

    // Compare modal events
    document.getElementById('compare-modal')?.addEventListener('click', e => {
      if (e.target.id === 'compare-modal') closeCompareModal();
    });
    document.querySelectorAll('#compare-modal .wizard-preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#compare-modal .wizard-preset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('wizard-compare-path').value = btn.dataset.compare || '';
      });
    });
    document.getElementById('wizard-load-compare')?.addEventListener('click', async () => {
      const comparePath = document.getElementById('wizard-compare-path').value.trim();
      if (!comparePath) {
        compareData = null;
        rowChanges = { contractResults: {}, issues: {}, fieldActions: {} };
        deltaStats = null;
        renderDeltaSummary();
        renderAllTables();
        closeCompareModal();
        return;
      }
      const relativePath = '../../' + comparePath;
      try {
        const response = await fetch(relativePath);
        if (!response.ok) throw new Error('File not found');
        compareData = await response.json();
        rowChanges.contractResults = computeRowChanges(allData.contractResults, compareData.sf_contract_results || [], 'contractResults');
        rowChanges.issues = computeRowChanges(allData.issues, compareData.sf_issues || [], 'issues');
        rowChanges.fieldActions = computeRowChanges(allData.fieldActions, compareData.sf_field_actions || [], 'fieldActions');
        deltaStats = computeDeltaStats({ sf_summary: allData.summary }, compareData);
        renderDeltaSummary();
        renderAllTables();
        closeCompareModal();
      } catch (e) {
        showWizardStatus('compare-status', 'Failed to load comparison: ' + e.message, 'error');
      }
    });

    // Run modal events
    document.getElementById('run-modal')?.addEventListener('click', e => {
      if (e.target.id === 'run-modal') closeRunModal();
    });
    document.querySelectorAll('#run-modal .toolbar-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const cmdKey = btn.dataset.cmd;
        if (commands[cmdKey]) {
          const cmd = commands[cmdKey];
          document.getElementById('modal-title').textContent = cmd.label || cmdKey;
          document.getElementById('modal-description').textContent = cmd.description || '';
          document.getElementById('modal-command').textContent = cmd.command;
          document.getElementById('command-modal').classList.add('active');
        }
      });
    });

    function showWizardStatus(id, message, type) {
      const status = document.getElementById(id);
      if (status) {
        status.textContent = message;
        status.className = 'modal-status ' + type;
        status.style.display = 'block';
        setTimeout(() => { status.style.display = 'none'; }, 3000);
      }
    }

    initRouter();
    loadCommands();
    setupLoaderHandlers();
    
    // Initialize Masterline Artifact Registry
    loadArtifactRegistry();
    updateDevMasterlineUI();
    updateDemoToggleUI(); // v1.6.4: Initialize demo toggle UI state
    renderArtifactRegistryTable();
    renderWorkflowMap();
    setupStandardizerDropZone();
    initPatchConsole();
    
    // If Dev Masterline is enabled, auto-load artifacts instead of default loadData
    if (artifactRegistry.devMasterlineEnabled) {
      masterlineAutoload();
    } else {
      loadData();
    }
    
    restorePreflightEvidence();
    restorePatchDraft();
    updateUIForDataState();
    updateSessionChip();
  </script>
</body>
</html>
